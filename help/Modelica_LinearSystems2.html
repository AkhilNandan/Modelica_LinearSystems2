<HTML>
<HEAD>
<TITLE>Modelica_LinearSystems2</TITLE>
<META name="HTML-Generator" content="Dymola">
<META name="description" content="&quot;Modelica_LinearSystems2 - Analysis, Synthesis and Modeling of Continuous and Discrete Linear Systems&quot;">
<style type="text/css">
*       { font-size: 10pt; font-family: Arial,sans-serif; }
pre     { font-size:  9pt; font-family: Courier,monospace;}
h4      { font-size: 10pt; font-weight: bold; color: green; }
h3      { font-size: 11pt; font-weight: bold; color: green; }
h2      { font-size: 13pt; font-weight: bold; color: green; }
address {                  font-weight: normal} 
td      { solid #000; vertical-align:top; }
th      { solid #000; vertical-align:top; font-weight: bold; }
table   { solid #000; border-collapse: collapse;}
</style>
</HEAD>
<BODY><P>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Modelica_LinearSystems2<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2"></A>Modelica_LinearSystems2</H2>
<B>Modelica_LinearSystems2 - Analysis, Synthesis and Modeling of Continuous and Discrete Linear Systems</B>
<P>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
Library <b>Modelica_LinearSystems2</b> is a Modelica package
providing different representations of linear, time invariant differential and
difference equation systems. For example, record
<A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</a>
defines a linear time invariant differential
equation system in state space form:
</p>
<pre>    <b>der</b>(x) = A * x + B * u
        y  = C * x + D * u
</pre>
<p>
Operators are overloaded to work conveniently with these system descriptions in an
interactive environment, e.g., to multiply transfer functions or to operate on complex numbers.
About 180 functions are provided to operate
on these data structures, e.g., to compute eigen values, zeros, step responses,
to design pole-placement and LQG controllers, to plot step responses, frequency responses,
eigen values, to convert between different description forms, or to
generate a linear system description by linearization of a Modelica model.
</p>

<p>
Furthermore, in sublibrary
<A HREF="Modelica_LinearSystems2_Controller.html#Modelica_LinearSystems2.Controller"
>Controller</a>
about 20 input/output blocks of linear systems are provided that are
based on the different representation forms, e.g., PID, StateSpace, Filter blocks.
A unique feature of these blocks is that it is very convenient to quickly switch
between a continuous and a discrete block representation. Also, templates are provide
to quickly built-up standard controller structures.
</p>

<p>
For an introduction, have especially a look at:
</p>
<ul>
<li> <A HREF="Modelica_LinearSystems2_UsersGuide.html#Modelica_LinearSystems2.UsersGuide.GettingStarted"
>Getting started</a>
     provides an overview of the Library
     inside the <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_UsersGuide.html#Modelica.UsersGuide"
>Users Guide</a>.</li>
<li><A HREF="Modelica_LinearSystems2_UsersGuide_ReleaseNotes.html#Modelica_LinearSystems2.UsersGuide.ReleaseNotes"
>Release Notes</a>
    summarizes the changes of new versions of this package.</li>
<li> <A HREF="Modelica_LinearSystems2_UsersGuide.html#Modelica_LinearSystems2.UsersGuide.Contact"
>Contact</a>
     gives the contact information for this library.</li>
<li> In an interactive environment, it is useful to run first the script
     &quot;_abbreviations.mos&quot; in directory
     &quot;Modelica_LinearSystems2\Extras\Scripts&quot;
     in order to set useful abbreviations: ss, tf, zp, poly, Complex, Plot, s, p, j.</li>
</ul>

<p>
It is planned to include this library in a future version of the
Modelica Standard Library. Note, the library is <u>not</u> backwards compatible
to the previous beta version 0.95, called "Modelica_LinearSystems", which was shipped
with previous versions of Dymola. Since the differences are too large, no conversion
scripts are provided, but different library names are used.
</p>


<p>
<b>Licensed by DLR under the Modelica License 2</b><br>
<img src="H:/mb/Eurosyslib/WP6/Modelica_LinearSystems2/Extras/Images/dlr_logo.png"  width=60 >
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 <b>      Copyright &copy; 2005-2009, DLR Institute of Robotics and Mechatronics</b>
</p>


<p>
<i>This Modelica package is <u>free</u> software and
the use is completely at <u>your own risk</u>;
it can be redistributed and/or modified under the terms of the
Modelica license 2, see the license conditions (including the
disclaimer of warranty)
<A HREF="Modelica_LinearSystems2_UsersGuide.html#Modelica_LinearSystems2.UsersGuide.ModelicaLicense2"
>here</a></u>
or at
<a href="http://www.Modelica.org/licenses/ModelicaLicense2">
http://www.Modelica.org/licenses/ModelicaLicense2</a>.</i>
</p>
<pre></PRE><P>

<P><H3>Package Content</H3><p>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 >
<TR><TH >Name</TH><TH>Description</TH></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.UsersGuideS.png" ALT="Modelica_LinearSystems2.UsersGuide" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_UsersGuide.html#Modelica_LinearSystems2.UsersGuide"
>UsersGuide</A>
</TD><TD>Users Guide</TD></TR>
<TR><TD>DataDir=classDirectory() + &quot;Extras/Data/&quot;</TD><TD>Absolute path to directory containing utilitiy files for this package</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.ExamplesS.png" ALT="Modelica_LinearSystems2.Examples" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Examples.html#Modelica_LinearSystems2.Examples"
>Examples</A>
</TD><TD>Examples demonstrating the usage of this package</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpaceS.png" ALT="Modelica_LinearSystems2.StateSpace" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A>
</TD><TD>Continuous state space description of a linear, time invariant differential equation system (data + operations)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpaceS.png" ALT="Modelica_LinearSystems2.TransferFunction" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A>
</TD><TD>Continuous transfer function description of a single input, single output system (data + operations)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpaceS.png" ALT="Modelica_LinearSystems2.ZerosAndPoles" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A>
</TD><TD>Continuous zeros and poles description of a single input, single output system (data + operations)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpaceS.png" ALT="Modelica_LinearSystems2.DiscreteStateSpace" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.DiscreteStateSpace"
>DiscreteStateSpace</A>
</TD><TD>Discrete state space description of a linear, time invariant difference equation system (data + operations)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.ControllerS.png" ALT="Modelica_LinearSystems2.Controller" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Controller.html#Modelica_LinearSystems2.Controller"
>Controller</A>
</TD><TD>Continuous and discrete input/output blocks. Easy to switch from continuous to discrete representation.</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.ControllerS.png" ALT="Modelica_LinearSystems2.Math" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math"
>Math</A>
</TD><TD>Additional functions for Modelica.Math</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.UtilitiesS.png" ALT="Modelica_LinearSystems2.Utilities" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Utilities.html#Modelica_LinearSystems2.Utilities"
>Utilities</A>
</TD><TD>Functions that shall be included in Modelica.Utilities</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.TypesS.png" ALT="Modelica_LinearSystems2.Types" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types"
>Types</A>
</TD><TD>Constants and types with choices, especially to build menus</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.TypesS.png" ALT="Modelica_LinearSystems2.Internal" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Internal</A>
</TD><TD>Internal library of library LinearSystems (should not be directly used by user)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.WorkInProgressS.png" ALT="Modelica_LinearSystems2.WorkInProgress" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_WorkInProgress.html#Modelica_LinearSystems2.WorkInProgress"
>WorkInProgress</A>
</TD><TD>Package for developments and internal models</TD></TR>
</TABLE>
<P><H3>Types and constants</H3>
<PRE><font color="blue">constant </font>String DataDir=<font color="red">classDirectory</font>() + &quot;Extras/Data/&quot; <font color="darkgreen">
  &quot;Absolute path to directory containing utilitiy files for this package&quot;</font>;</PRE><p>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE StateSpace<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.StateSpaceI.png" ALT="Modelica_LinearSystems2.StateSpace" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.StateSpace"></A><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>.StateSpace</H2>
<B>Continuous state space description of a linear, time invariant differential equation system (data + operations)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This record defines a linear time invariant differential
equation system in state space form:
</p>
<pre>    <b>der</b>(x) = A * x + B * u
        y  = C * x + D * u
</pre>
<p>
with
</p>
<ul>
<li> u - the input vector</li>
<li> y - the output vector</li>
<li> x - the state vector</li>
<li> A,B,C,D - matrices of appropriate dimensions</li>
</ul>
<pre></PRE><P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Record"
>Modelica.Icons.Record</A> (Icon for a record).
<P><H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>der(x) = A*x + B*u;  y = C*x + D*u</TD></TR>
<TR><TD>Real</TD><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>B[size(A, 1), :]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>C[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>D[size(C, 1), size(B, 2)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>Signal names</TD></TR>
<TR><TD>String</TD><TD>yNames[size(C, 1)]</TD><TD>fill(&quot;&quot;, size(C, 1))</TD><TD>Names of the output signals</TD></TR>
<TR><TD>String</TD><TD>xNames[size(A, 1)]</TD><TD>fill(&quot;&quot;, size(A, 1))</TD><TD>Names of the states</TD></TR>
<TR><TD>String</TD><TD>uNames[size(B, 2)]</TD><TD>fill(&quot;&quot;, size(B, 2))</TD><TD>Names of the input signals</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">record</font> StateSpace <font color="darkgreen">
  &quot;Continuous state space description of a linear, time invariant differential equation system (data + operations)&quot;</font>

  <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Record"
>Modelica.Icons.Record</A>;

  Real A[:,<font color="red">size</font>(A, 1)];
  Real B[<font color="red">size</font>(A, 1),:];
  Real C[:,<font color="red">size</font>(A, 1)];
  Real D[<font color="red">size</font>(C, 1),<font color="red">size</font>(B, 2)];

   String yNames[<font color="red">size</font>(C, 1)]=<font color="red">fill</font>(&quot;&quot;,<font color="red"> size</font>(C, 1)) <font color="darkgreen">&quot;Names of the output signals&quot;</font>;
   String xNames[<font color="red">size</font>(A, 1)]=<font color="red">fill</font>(&quot;&quot;,<font color="red"> size</font>(A, 1)) <font color="darkgreen">&quot;Names of the states&quot;</font>;
   String uNames[<font color="red">size</font>(B, 2)]=<font color="red">fill</font>(&quot;&quot;,<font color="red"> size</font>(B, 2)) <font color="darkgreen">&quot;Names of the input signals&quot;</font>;

<textblock type="packagesmall" expanded="false" path="Modelica_LinearSystems2.StateSpace.'constructor'"><font color="blue">encapsulated </font><font color="blue">operator</font> &#39;constructor&#39; <font color="darkgreen">
    &quot;Default constructors for a StateSpace record&quot;</font>
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.'constructor'.fromABCDMatrices"><font color="blue">function</font> fromABCDMatrices <font color="darkgreen">
      &quot;Default constructor for a StateSpace record&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

    <font color="blue">input </font>Real A[:,<font color="red">size</font>(A, 1)];
    <font color="blue">input </font>Real B[<font color="red">size</font>(A, 1),:];
    <font color="blue">input </font>Real C[:,<font color="red">size</font>(A, 1)];
    <font color="blue">input </font>Real D[<font color="red">size</font>(C, 1),<font color="red">size</font>(B, 2)];

    <font color="blue">input </font>String uNames[<font color="red">size</font>(B, 2)]=<font color="red">fill</font>(&quot;&quot;, <font color="red">size</font>(B, 2));
    <font color="blue">input </font>String yNames[<font color="red">size</font>(C, 1)]=<font color="red">fill</font>(&quot;&quot;, <font color="red">size</font>(C, 1));
    <font color="blue">input </font>String xNames[<font color="red">size</font>(A, 2)]=<font color="red">fill</font>(&quot;&quot;, <font color="red">size</font>(A, 2));

     <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> result(
      <font color="blue">redeclare </font>Real A[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)],
      <font color="blue">redeclare </font>Real B[<font color="red">size</font>(B, 1),<font color="red">size</font>(B, 2)],
      <font color="blue">redeclare </font>Real C[<font color="red">size</font>(C, 1),<font color="red">size</font>(C, 2)],
      <font color="blue">redeclare </font>Real D[<font color="red">size</font>(D, 1),<font color="red">size</font>(D, 2)],
      <font color="blue">redeclare </font>String uNames[<font color="red">size</font>(B, 2)],
      <font color="blue">redeclare </font>String yNames[<font color="red">size</font>(C, 1)],
      <font color="blue">redeclare </font>String xNames[<font color="red">size</font>(A, 2)]);

  <font color="blue">algorithm </font>
    result.A := A;
    result.B := B;
    result.C := C;
    result.D := D;
     result.uNames := uNames;
     result.yNames := yNames;
     result.xNames := xNames;

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>fromABCDMatrices</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.'constructor'.fromReal"><font color="blue">function</font> fromReal <font color="darkgreen">
      &quot;Generate a StateSpace data record from a Real value&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

    <font color="blue">input </font>Real r <font color="darkgreen">&quot;Value of Real variable&quot;</font>;
    <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss(
      <font color="blue">redeclare </font>Real A[0,0],
      <font color="blue">redeclare </font>Real B[0,1],
      <font color="blue">redeclare </font>Real C[1,0],
      <font color="blue">redeclare </font>Real D[1,1]) <font color="darkgreen">&quot;= r&quot;</font>;

  <font color="blue">algorithm </font>
    ss.D[1, 1] := r;
<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>fromReal</textblock>;

  <font color="blue">function</font> fromTransferFunction = 
      <A HREF="Modelica_LinearSystems2_Conversion.html#Modelica_LinearSystems2.TransferFunction.Conversion.toStateSpace"
>Modelica_LinearSystems2.TransferFunction.Conversion.toStateSpace</A>;
  <font color="blue">function</font> fromZerosAndPoles = 
      <A HREF="Modelica_LinearSystems2_Conversion.html#Modelica_LinearSystems2.ZerosAndPoles.Conversion.toStateSpace"
>Modelica_LinearSystems2.ZerosAndPoles.Conversion.toStateSpace</A>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>&#39;constructor&#39;</textblock>;

<textblock type="packagesmall" expanded="false" path="Modelica_LinearSystems2.StateSpace.'-'"><font color="blue">encapsulated </font><font color="blue">operator</font> &#39;-&#39; <font color="darkgreen">
    &quot;Contains operators for subtraction of state space systems&quot;</font>

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.'-'.subtract"><font color="blue">function</font> subtract <font color="darkgreen">
      &quot;Subtraction of two state space systems connected in parallel (= inputs are the same, outputs of the two systems are subtracted)&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss1 <font color="darkgreen">&quot;State space system 1&quot;</font>;
    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss2 <font color="darkgreen">&quot;State Space system 2 is subtracted from system 1&quot;</font>;
    <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> result(
      <font color="blue">redeclare </font>Real A[<font color="red">size</font>(ss1.A, 1) + <font color="red">size</font>(ss2.A, 1),<font color="red">size</font>(ss1.A, 2) + <font color="red">size</font>(
        ss2.A, 2)],
      <font color="blue">redeclare </font>Real B[<font color="red">size</font>(ss1.B, 1) + <font color="red">size</font>(ss2.B, 1),<font color="red">size</font>(ss1.B, 2)],
      <font color="blue">redeclare </font>Real C[<font color="red">size</font>(ss1.C, 1),<font color="red">size</font>(ss1.C, 2) + <font color="red">size</font>(ss2.C, 2)],
      <font color="blue">redeclare </font>Real D[<font color="red">size</font>(ss1.D, 1),<font color="red">size</font>(ss1.D, 2)]) <font color="darkgreen">&quot;= ss1 - ss2&quot;</font>;
    <font color="blue">protected </font>
    Integer nx1=<font color="red">size</font>(ss1.A, 1);
    Integer nx2=<font color="red">size</font>(ss2.A, 1);
  <font color="blue">algorithm </font>
    result.A := [ss1.A,<font color="red">zeros</font>(nx1, nx2); <font color="red">zeros</font>(nx2, nx1),ss2.A];
    result.B := [ss1.B; ss2.B];
    result.C := [ss1.C,-ss2.C];
    result.D := ss1.D - ss2.D;
<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>subtract</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.'-'.negate"><font color="blue">function</font> negate <font color="darkgreen">
      &quot;Unary minus (state space system where the output is multiplied by a gain of -1)&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;
    <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> result(
      <font color="blue">redeclare </font>Real A[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)],
      <font color="blue">redeclare </font>Real B[<font color="red">size</font>(ss.B, 1),<font color="red">size</font>(ss.B, 2)],
      <font color="blue">redeclare </font>Real C[<font color="red">size</font>(ss.C, 1),<font color="red">size</font>(ss.C, 2)],
      <font color="blue">redeclare </font>Real D[<font color="red">size</font>(ss.D, 1),<font color="red">size</font>(ss.D, 2)]) <font color="darkgreen">&quot;= -ss&quot;</font>;
  <font color="blue">algorithm </font>
    result.A := ss.A;
    result.B := ss.B;
    result.C := -ss.C;
    result.D := -ss.D;
  <font color="blue">end </font>negate</textblock>;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>&#39;-&#39;</textblock>;

<textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.'+'"><font color="blue">encapsulated </font><font color="blue">operator function</font> &#39;+&#39; <font color="darkgreen">
    &quot;Parallel connection of two state space systems (= inputs are the same, outputs of the two systems are added)&quot;</font>
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss1 <font color="darkgreen">&quot;System 1&quot;</font>;
    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss2 <font color="darkgreen">&quot;System 2 is added in parallel to system 1&quot;</font>;
    <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> result(
      <font color="blue">redeclare </font>Real A[<font color="red">size</font>(ss1.A, 1) +<font color="red"> size</font>(ss2.A, 1),<font color="red">size</font>(ss1.A, 2) +<font color="red"> size</font>(
        ss2.A, 2)],
      <font color="blue">redeclare </font>Real B[<font color="red">size</font>(ss1.B, 1) +<font color="red"> size</font>(ss2.B, 1),<font color="red">size</font>(ss1.B, 2)],
      <font color="blue">redeclare </font>Real C[<font color="red">size</font>(ss1.C, 1),<font color="red">size</font>(ss1.C, 2) +<font color="red"> size</font>(ss2.C, 2)],
      <font color="blue">redeclare </font>Real D[<font color="red">size</font>(ss1.D, 1),<font color="red">size</font>(ss1.D, 2)]) <font color="darkgreen">&quot;= ss1 + ss2&quot;</font>;
  <font color="blue">protected </font>
    Integer nx1=<font color="red">size</font>(ss1.A, 1);
    Integer nx2=<font color="red">size</font>(ss2.A, 1);
<font color="blue">algorithm </font>
    result.A := [ss1.A,<font color="red">zeros</font>(nx1, nx2);<font color="red"> zeros</font>(nx2, nx1),ss2.A];
    result.B := [ss1.B; ss2.B];
    result.C := [ss1.C,ss2.C];
    result.D := ss1.D + ss2.D;

<font color="blue">end </font>&#39;+&#39;</textblock>;

<textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.'*'"><font color="blue">encapsulated </font><font color="blue">operator function</font> &#39;*&#39; <font color="darkgreen">
    &quot;Series connection of two state space systems&quot;</font>
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss1 <font color="darkgreen">&quot;System 1&quot;</font>;
    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss2 <font color="darkgreen">&quot;System 2&quot;</font>;
    <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> result(
      <font color="blue">redeclare </font>Real A[<font color="red">size</font>(ss1.A, 1) +<font color="red"> size</font>(ss2.A, 1),<font color="red">size</font>(ss1.A, 2) +<font color="red"> size</font>(
        ss2.A, 2)],
      <font color="blue">redeclare </font>Real B[<font color="red">size</font>(ss1.B, 1) +<font color="red"> size</font>(ss2.B, 1),<font color="red">size</font>(ss2.B, 2)],
      <font color="blue">redeclare </font>Real C[<font color="red">size</font>(ss1.C, 1),<font color="red">size</font>(ss1.C, 2) +<font color="red"> size</font>(ss2.C, 2)],
      <font color="blue">redeclare </font>Real D[<font color="red">size</font>(ss1.D, 1),<font color="red">size</font>(ss2.D, 2)]) <font color="darkgreen">
      &quot;y = G(s)*u = G(ss1)*G(ss2)*u&quot;</font>;
  <font color="blue">protected </font>
    Integer nx1=<font color="red">size</font>(ss1.A, 1);
    Integer nx2=<font color="red">size</font>(ss2.A, 1);
<font color="blue">algorithm </font>
    result.A := [ss1.A,ss1.B*ss2.C;<font color="red"> zeros</font>(nx2, nx1),ss2.A];
    result.B := [ss1.B*ss2.D; ss2.B];
    result.C := [ss1.C,ss1.D*ss2.C];
    result.D := ss1.D*ss2.D;

<font color="blue">end </font>&#39;*&#39;</textblock>;

<textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.'=='"><font color="blue">encapsulated </font><font color="blue">operator function</font> &#39;==&#39; <font color="darkgreen">
    &quot;Check whether two linear systems have identical matrices&quot;</font>
    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Math_Matrices.html#Modelica.Math.Matrices.isEqual"
>Modelica.Math.Matrices.isEqual</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss1 <font color="darkgreen">&quot;System 1&quot;</font>;
    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss2 <font color="darkgreen">&quot;System 2&quot;</font>;
    <font color="blue">input </font>Real eps(min=0) = 0 <font color="darkgreen">
      &quot;Two elements e1 and e2 of the two systems are identical if abs(e1-e2) &lt;= eps&quot;</font>;
    <font color="blue">output </font>Boolean same <font color="darkgreen">&quot;=true, if the two systems are identical&quot;</font>;
<font color="blue">algorithm </font>
    same :=<font color="red"> isEqual</font>(
          ss1.A,
          ss2.A,
          eps)<font color="blue"> and </font><font color="red">isEqual</font>(
          ss1.B,
          ss2.B,
          eps)<font color="blue"> and </font><font color="red">isEqual</font>(
          ss1.C,
          ss2.C,
          eps)<font color="blue"> and </font><font color="red">isEqual</font>(
          ss1.D,
          ss2.D,
          eps);
<font color="blue">end </font>&#39;==&#39;</textblock>;

<textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.'String'"><font color="blue">encapsulated </font><font color="blue">operator function</font> &#39;String&#39; <font color="darkgreen">
    &quot;Transform state space into a String representation&quot;</font>
   <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
   <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
   <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Strings.html#Modelica.Utilities.Strings"
>Modelica.Utilities.Strings</A>;

   <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">
      &quot;State space system to be transformed in a String representation&quot;</font>;
   <font color="blue">input </font>Integer significantDigits=12 <font color="darkgreen">
      &quot;Number of significant digits that are shown&quot;</font>;
   <font color="blue">input </font>String name=&quot;ss&quot; <font color="darkgreen">&quot;Independent variable name used for printing&quot;</font>;
   <font color="blue">output </font>String s=&quot;&quot;;

  <font color="blue">protected </font>
    String space=<font color="red">Strings.repeat</font>(5);
    String space2=<font color="red">Strings.repeat</font>(3);
    String space3=<font color="red">Strings.repeat</font>(8);
    Integer nx=<font color="red">size</font>(ss.A, 1);
    Integer nu=<font color="red">size</font>(ss.B, 2);
    Integer ny=<font color="red">size</font>(ss.C, 1);
    Integer sizeD=<font color="red">size</font>(ss.D, 2);
    Integer stringMaxLength;
    Boolean xNamesExist=false;
    Boolean uNamesExist=false;
    Boolean yNamesExist=false;

<font color="blue">algorithm </font>
  <font color="darkgreen">//Checking if name arrays are empty</font>
    <font color="blue">for </font>i<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
      xNamesExist := xNamesExist<font color="blue"> or </font>(ss.xNames[i] &lt;&gt; &quot;&quot;);
    <font color="blue">end for</font>;

    <font color="blue">for </font>i<font color="blue"> in </font>1:ny<font color="blue"> loop</font>
      yNamesExist := yNamesExist<font color="blue"> or </font>(ss.yNames[i] &lt;&gt; &quot;&quot;);
    <font color="blue">end for</font>;

    <font color="blue">for </font>i<font color="blue"> in </font>1:nu<font color="blue"> loop</font>
      uNamesExist := uNamesExist<font color="blue"> or </font>(ss.uNames[i] &lt;&gt; &quot;&quot;);
    <font color="blue">end for</font>;

    <font color="blue">if </font>xNamesExist<font color="blue"> then</font>
      <font color="red">Modelica.Utilities.Streams.print</font>(&quot;xNamesExist == true&quot;);
    <font color="blue">else</font>
      <font color="red">Modelica.Utilities.Streams.print</font>(&quot;xNamesExist == false&quot;);
    <font color="blue">end if</font>;

    stringMaxLength :=<font color="red"> max</font>(<font color="red">size</font>(ss.xNames, 1),<font color="red"> min</font>(<font color="red">size</font>(ss.yNames, 1),
      11));

    <font color="blue">if </font>nx == 0<font color="blue"> and </font>sizeD == 0<font color="blue"> then</font>
      s := name + &quot;.A = []\n  &quot; + name + &quot;.B = []\n   &quot; + name + &quot;.C = [] \n   &quot; + name + &quot;.D = []&quot;;
    <font color="blue">else</font>
      s := &quot;\n&quot; + name + &quot;.A = \n&quot;;

  <font color="darkgreen">//Horizontal</font>
  <font color="darkgreen">// Two alternatives when printing state names</font>
      <font color="blue">if </font>xNamesExist == false<font color="blue"> then</font>
        s := s +<font color="red"> Strings.repeat</font>(stringMaxLength + significantDigits - 1) +
          &quot;x1 &quot;;
      <font color="blue">else</font>
        s := s +<font color="red"> Strings.repeat</font>(11 + significantDigits -<font color="red"> min</font>(<font color="red">Strings.length</font>(
          ss.xNames[1]), 11)) +<font color="red"> Strings.repeat</font>(<font color="red">min</font>(<font color="red">Strings.length</font>(ss.xNames[
          1]), 11)) + &quot; &quot; +<font color="red"> Strings.substring</font>(
              ss.xNames[1],
              1,
              <font color="red">min</font>(<font color="red">Strings.length</font>(ss.xNames[1]), 11));
      <font color="blue">end if</font>;

      <font color="blue">for </font>i<font color="blue"> in </font>2:nx<font color="blue"> loop</font>

  <font color="darkgreen">//Two alternatives when printing state names</font>

        <font color="blue">if </font>xNamesExist == false<font color="blue"> then</font>
          s := s +<font color="red"> Strings.repeat</font>(significantDigits + 11 -<font color="red"> Strings.length</font>(&quot;x&quot;
             +<font color="red"> String</font>(i - 1))) + &quot;x&quot; +<font color="red"> String</font>(i) + &quot; &quot;;
        <font color="blue">else</font>
          s := s + &quot; &quot; +<font color="red"> Strings.repeat</font>(significantDigits + 11 -<font color="red"> min</font>(
            <font color="red">Strings.length</font>(ss.xNames[i - 1]), 11)) +<font color="red"> Strings.substring</font>(
                ss.xNames[i],
                1,
                <font color="red">min</font>(<font color="red">Strings.length</font>(ss.xNames[i]), 11));

        <font color="blue">end if</font>;

  <font color="darkgreen">//s := s + Strings.repeat(6) + &quot;x&quot; + String(i);</font>
      <font color="blue">end for</font>;
      s := s + &quot;\n&quot;;

      <font color="blue">for </font>i<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
  <font color="darkgreen">//Vertical</font>
  <font color="darkgreen">//Two alternatives when printing state names</font>
        <font color="blue">if </font>xNamesExist == false<font color="blue"> then</font>
          s := s + space + &quot;x&quot; +<font color="red"> String</font>(i) + &quot; &quot;;
        <font color="blue">else</font>
          s := s +<font color="red"> Strings.repeat</font>(significantDigits + 11 -<font color="red"> min</font>(<font color="red">Strings.length</font>(
            ss.xNames[i]), 11)) +<font color="red"> Strings.substring</font>(
                ss.xNames[i],
                1,
                <font color="red">min</font>(<font color="red">Strings.length</font>(ss.xNames[i]), 11)) + &quot; &quot;;
        <font color="blue">end if</font>;

        <font color="blue">for </font>j<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
          <font color="blue">if </font>ss.A[i, j] &gt;= 0<font color="blue"> then</font>
            s := s + &quot; &quot;;
          <font color="blue">end if</font>;
          s := s +<font color="red"> String</font>(ss.A[i, j], significantDigits=significantDigits) +
            <font color="red">Strings.repeat</font>(significantDigits + 11 -<font color="red"> Strings.length</font>(<font color="red">String</font>(<font color="red">abs</font>(
            ss.A[i, j]), significantDigits=significantDigits)));
       <font color="blue">end for</font>;
        s := s + &quot;\n&quot;;
      <font color="blue">end for</font>;
  <font color="darkgreen">//--------------------------------------------------------------------------------------------------------------------------------------------------</font>
      s := s + &quot;\n&quot; + name + &quot;.B = \n&quot;;
   <font color="darkgreen">//Horizontal</font>
  <font color="darkgreen">// Two alternatives when printing state names</font>
      <font color="blue">if </font>uNamesExist == false<font color="blue"> then</font>
        s := s +<font color="red"> Strings.repeat</font>(stringMaxLength + significantDigits - 1) +
          &quot;u1 &quot;;
      <font color="blue">else</font>
        s := s +<font color="red"> Strings.repeat</font>(11 + significantDigits -<font color="red"> min</font>(<font color="red">Strings.length</font>(
          ss.uNames[1]), 11)) +<font color="red"> Strings.repeat</font>(<font color="red">min</font>(<font color="red">Strings.length</font>(ss.uNames[
          1]), 11)) + &quot; &quot; +<font color="red"> Strings.substring</font>(
              ss.uNames[1],
              1,
              <font color="red">min</font>(<font color="red">Strings.length</font>(ss.uNames[1]), 11));
      <font color="blue">end if</font>;

      <font color="blue">for </font>i<font color="blue"> in </font>2:nu<font color="blue"> loop</font>
  <font color="darkgreen">//Two alternatives when printing state names</font>
        <font color="blue">if </font>uNamesExist == false<font color="blue"> then</font>
          s := s +<font color="red"> Strings.repeat</font>(significantDigits + 11 -<font color="red"> Strings.length</font>(&quot;u&quot;
             +<font color="red"> String</font>(i - 1))) + &quot;u&quot; +<font color="red"> String</font>(i) + &quot; &quot;;
        <font color="blue">else</font>
          s := s + &quot; &quot; +<font color="red"> Strings.repeat</font>(significantDigits + 11 -<font color="red"> min</font>(
            <font color="red">Strings.length</font>(ss.uNames[i - 1]), 11)) +<font color="red"> Strings.substring</font>(
                ss.uNames[i],
                1,
                <font color="red">min</font>(<font color="red">Strings.length</font>(ss.uNames[i]), 11));
        <font color="blue">end if</font>;
      <font color="blue">end for</font>;
      s := s + &quot;\n&quot;;
  <font color="darkgreen">//s := s + Strings.repeat(6) + &quot;x&quot; + String(i);</font>
      <font color="blue">for </font>i<font color="blue"> in </font>1:nx<font color="blue"> loop</font>

  <font color="darkgreen">//Vertical</font>
  <font color="darkgreen">//Two alternatives when printing state names</font>
        <font color="blue">if </font>xNamesExist == false<font color="blue"> then</font>
          s := s + space + &quot;x&quot; +<font color="red"> String</font>(i) + &quot; &quot;;
        <font color="blue">else</font>

          s := s +<font color="red"> Strings.repeat</font>(significantDigits + 11 -<font color="red"> min</font>(<font color="red">Strings.length</font>(
            ss.xNames[i]), 11)) +<font color="red"> Strings.substring</font>(
                ss.xNames[i],
                1,
                <font color="red">min</font>(<font color="red">Strings.length</font>(ss.xNames[i]), 11)) + &quot; &quot;;
        <font color="blue">end if</font>;

        <font color="blue">for </font>j<font color="blue"> in </font>1:nu<font color="blue"> loop</font>
          <font color="blue">if </font>ss.B[i, j] &gt;= 0<font color="blue"> then</font>
            s := s + &quot; &quot;;
          <font color="blue">end if</font>;
          s := s +<font color="red"> String</font>(ss.B[i, j], significantDigits=significantDigits) +
            <font color="red">Strings.repeat</font>(significantDigits + 11 -<font color="red"> Strings.length</font>(<font color="red">String</font>(<font color="red">abs</font>(
            ss.B[i, j]), significantDigits=significantDigits)));
        <font color="blue">end for</font>;
        s := s + &quot;\n&quot;;
      <font color="blue">end for</font>;

  <font color="darkgreen">//--------------------------------------------------------------------------------------------------------------------------------------------------</font>
      s := s + &quot;\n&quot; + name + &quot;.C = \n&quot;;
   <font color="darkgreen">//Horizontal</font>
  <font color="darkgreen">// Two alternatives when printing state names</font>
      <font color="blue">if </font>xNamesExist == false<font color="blue"> then</font>
        s := s +<font color="red"> Strings.repeat</font>(stringMaxLength + significantDigits - 1) +
          &quot;x1 &quot;;
      <font color="blue">else</font>
        s := s +<font color="red"> Strings.repeat</font>(11 + significantDigits -<font color="red"> min</font>(<font color="red">Strings.length</font>(
          ss.xNames[1]), 11)) +<font color="red"> Strings.repeat</font>(<font color="red">min</font>(<font color="red">Strings.length</font>(ss.xNames[
          1]), 11)) + &quot; &quot; +<font color="red"> Strings.substring</font>(
              ss.xNames[1],
              1,
              <font color="red">min</font>(<font color="red">Strings.length</font>(ss.xNames[1]), 11));
      <font color="blue">end if</font>;

      <font color="blue">for </font>i<font color="blue"> in </font>2:nx<font color="blue"> loop</font>
  <font color="darkgreen">//Two alternatives when printing state names</font>
        <font color="blue">if </font>xNamesExist == false<font color="blue"> then</font>
          s := s +<font color="red"> Strings.repeat</font>(significantDigits + 11 -<font color="red"> Strings.length</font>(&quot;x&quot;
             +<font color="red"> String</font>(i - 1))) + &quot;x&quot; +<font color="red"> String</font>(i) + &quot; &quot;;
        <font color="blue">else</font>
          s := s + &quot; &quot; +<font color="red"> Strings.repeat</font>(significantDigits + 11 -<font color="red"> min</font>(
            <font color="red">Strings.length</font>(ss.xNames[i - 1]), 11)) +<font color="red"> Strings.substring</font>(
                ss.xNames[i],
                1,
                <font color="red">min</font>(<font color="red">Strings.length</font>(ss.xNames[i]), 11));
        <font color="blue">end if</font>;
      <font color="blue">end for</font>;
      s := s + &quot;\n&quot;;
  <font color="darkgreen">//s := s + Strings.repeat(6) + &quot;x&quot; + String(i);</font>

      <font color="blue">for </font>i<font color="blue"> in </font>1:ny<font color="blue"> loop</font>
  <font color="darkgreen">//Vertical</font>
  <font color="darkgreen">//Two alternatives when printing state names</font>
        <font color="blue">if </font>yNamesExist == false<font color="blue"> then</font>
          s := s + space + &quot;y&quot; +<font color="red"> String</font>(i) + &quot; &quot;;
        <font color="blue">else</font>
          s := s +<font color="red"> Strings.repeat</font>(significantDigits + 11 -<font color="red"> min</font>(<font color="red">Strings.length</font>(
            ss.yNames[i]), 11)) +<font color="red"> Strings.substring</font>(
                ss.yNames[i],
                1,
                <font color="red">min</font>(<font color="red">Strings.length</font>(ss.yNames[i]), 11)) + &quot; &quot;;

        <font color="blue">end if</font>;

        <font color="blue">for </font>j<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
          <font color="blue">if </font>ss.C[i, j] &gt;= 0<font color="blue"> then</font>
            s := s + &quot; &quot;;
          <font color="blue">end if</font>;
          s := s +<font color="red"> String</font>(ss.C[i, j], significantDigits=significantDigits) +
            <font color="red">Strings.repeat</font>(significantDigits + 11 -<font color="red"> Strings.length</font>(<font color="red">String</font>(<font color="red">abs</font>(
            ss.C[i, j]), significantDigits=significantDigits)));
        <font color="blue">end for</font>;
        s := s + &quot;\n&quot;;
      <font color="blue">end for</font>;
  <font color="darkgreen">//--------------------------------------------------------------------------------------------------------------------------------------------------</font>
      s := s + &quot;\n&quot; + name + &quot;.D = \n&quot;;
   <font color="darkgreen">//Horizontal</font>
  <font color="darkgreen">// Two alternatives when printing state names</font>
      <font color="blue">if </font>uNamesExist == false<font color="blue"> then</font>
        s := s +<font color="red"> Strings.repeat</font>(stringMaxLength + significantDigits - 1) +
          &quot;u1 &quot;;
      <font color="blue">else</font>
        s := s +<font color="red"> Strings.repeat</font>(11 + significantDigits -<font color="red"> min</font>(<font color="red">Strings.length</font>(
          ss.uNames[1]), 11)) +<font color="red"> Strings.repeat</font>(<font color="red">min</font>(<font color="red">Strings.length</font>(ss.uNames[
          1]), 11)) + &quot; &quot; +<font color="red"> Strings.substring</font>(
              ss.uNames[1],
              1,
              <font color="red">min</font>(<font color="red">Strings.length</font>(ss.uNames[1]), 11));
      <font color="blue">end if</font>;

      <font color="blue">for </font>i<font color="blue"> in </font>2:nu<font color="blue"> loop</font>
  <font color="darkgreen">//Two alternatives when printing state names</font>
        <font color="blue">if </font>uNamesExist == false<font color="blue"> then</font>
          s := s +<font color="red"> Strings.repeat</font>(significantDigits + 11 -<font color="red"> Strings.length</font>(&quot;u&quot;
             +<font color="red"> String</font>(i - 1))) + &quot;u&quot; +<font color="red"> String</font>(i) + &quot; &quot;;
        <font color="blue">else</font>
          s := s + &quot; &quot; +<font color="red"> Strings.repeat</font>(significantDigits + 11 -<font color="red"> min</font>(
            <font color="red">Strings.length</font>(ss.uNames[i - 1]), 11)) +<font color="red"> Strings.substring</font>(
                ss.uNames[i],
                1,
                <font color="red">min</font>(<font color="red">Strings.length</font>(ss.uNames[i]), 11));
        <font color="blue">end if</font>;
      <font color="blue">end for</font>;
      s := s + &quot;\n&quot;;
      <font color="blue">for </font>i<font color="blue"> in </font>1:ny<font color="blue"> loop</font>
  <font color="darkgreen">//Vertical</font>
  <font color="darkgreen">//Two alternatives when printing state names</font>
        <font color="blue">if </font>yNamesExist == false<font color="blue"> then</font>
          s := s + space + &quot;y&quot; +<font color="red"> String</font>(i) + &quot; &quot;;
        <font color="blue">else</font>
          s := s +<font color="red"> Strings.repeat</font>(significantDigits + 11 -<font color="red"> min</font>(<font color="red">Strings.length</font>(
            ss.yNames[i]), 11)) +<font color="red"> Strings.substring</font>(
                ss.yNames[i],
                1,
                <font color="red">min</font>(<font color="red">Strings.length</font>(ss.yNames[i]), 11)) + &quot; &quot;;
        <font color="blue">end if</font>;

        <font color="blue">for </font>j<font color="blue"> in </font>1:nu<font color="blue"> loop</font>
          <font color="blue">if </font>ss.D[i, j] &gt;= 0<font color="blue"> then</font>
            s := s + &quot; &quot;;
          <font color="blue">end if</font>;
          s := s +<font color="red"> String</font>(ss.D[i, j], significantDigits=significantDigits) +
            <font color="red">Strings.repeat</font>(significantDigits + 11 -<font color="red"> Strings.length</font>(<font color="red">String</font>(<font color="red">abs</font>(
            ss.D[i, j]), significantDigits=significantDigits)));
        <font color="blue">end for</font>;
        s := s + &quot;\n&quot;;
      <font color="blue">end for</font>;

    <font color="blue">end if</font>;

<font color="blue">end </font>&#39;String&#39;</textblock>;

<textblock type="packagesmall" expanded="false" path="Modelica_LinearSystems2.StateSpace.Analysis"><font color="blue">encapsulated </font><font color="blue">package</font> Analysis <font color="darkgreen">
    &quot;Functions to analyse state space systems represented by a StateSpace record&quot;</font>

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Analysis.analysis"><font color="blue">function</font> analysis <font color="darkgreen">
      &quot;Perform a system analysis based on the poles and zeros of the system&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Strings.html#Modelica.Utilities.Strings"
>Modelica.Utilities.Strings</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Modelica_LinearSystems2.Internal.Eigenvalue</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>;
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams.print"
>Modelica.Utilities.Streams.print</A>;

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Utilities_Plot.html#Modelica_LinearSystems2.Utilities.Plot"
>Modelica_LinearSystems2.Utilities.Plot</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.AnalyseOptions"
>Internal.AnalyseOptions</A> analyseOptions=
        <font color="red">Modelica_LinearSystems2.Internal.AnalyseOptions</font>(
        plotEigenValues=true,
        plotInvariantZeros=true,
        plotStepResponse=true,
        plotFrequencyResponse=true,
        printEigenValues=true,
        printEigenValueProperties=true,
        printInvariantZeros=true,
        printControllability=true,
        printObservability=true,
        headingEigenValues=&quot;Eigenvalues&quot;,
        headingInvariantzeros=&quot;Invariant zeros&quot;,
        headingStepResponse=&quot;Step response&quot;,
        headingFrequencyResponse=&quot;Frequency response&quot;);
    <font color="blue">input </font>String fileName=&quot;eigenvalues.html&quot; <font color="darkgreen">
        &quot;Name of html-file that contains eigenvalue table&quot;</font>;
    <font color="blue">input </font>String systemName=&quot;&quot; <font color="darkgreen">&quot;Name of system (used as heading in html file)&quot;</font>;
    <font color="blue">input </font>String description=&quot;&quot; <font color="darkgreen">&quot;Description of system (used in html file)&quot;</font>;
    <font color="blue">protected </font>
    <font color="blue">input </font>Boolean printStateSpaceSystem=true;
    String dummyFileName=&quot;dummy&quot; + fileName;
    <font color="blue">public </font>
    <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.PartialPlotFunction"
>Modelica_LinearSystems2.Internal.PartialPlotFunction</A>(defaultDiagram=
          <font color="red">Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros</font>());

    <font color="blue">protected </font>
    <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> j=<font color="red">Modelica_LinearSystems2.Math.Complex.j</font>();
    <A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Eigenvalue</A> ev[<font color="red">size</font>(ss.A, 1)];
    Integer nx=<font color="red">size</font>(ss.A, 1);
    Integer window=0;
    Real eval[nx,2];
    Real revec[nx,nx];
    Real levec[nx,nx];
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> cev[<font color="red">size</font>(ss.A, 1)];
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> systemZeros[:]=
    <font color="red">Modelica_LinearSystems2.StateSpace.Analysis.invariantZeros</font>(ss);
    Boolean isStable;
    Boolean isControllable;
    Boolean isStabilizable;
    Boolean isObservable;
    Boolean isDetectable;

    Real abs_evec[nx];
    String xNames2[nx];
    String heading=&quot;Eigenvalues&quot; <font color="darkgreen">&quot;Eigen values of system&quot;</font>;
    <A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Eigenvalue</A> evSorted[<font color="red">size</font>(ss.A, 1)];
    Integer evIndex[<font color="red">size</font>(ss.A, 1)];
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> zerosSorted[:];
    Integer zerosIndex[<font color="red">size</font>(systemZeros, 1)];
    Integer nReal;

    Integer i;
    Integer k;
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> evecComplex[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 1)];
    <A HREF="Modelica_LinearSystems2_Utilities_Plot_Records.html#Modelica_LinearSystems2.Utilities.Plot.Records.Curve"
>Plot.Records.Curve</A> curves[2];
    <A HREF="Modelica_LinearSystems2_Utilities_Plot_Records.html#Modelica_LinearSystems2.Utilities.Plot.Records.Diagram"
>Plot.Records.Diagram</A> diagram2;
    Boolean instableZeros=false;

  <font color="blue">algorithm </font>
    (eval,levec,revec) := <font color="red">Modelica_LinearSystems2.Math.Matrices.eigenValues</font>(ss.A);

    <font color="blue">for </font>i<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
      cev[i].re := eval[i, 1];
      cev[i].im := eval[i, 2];
      ev[i].ev := cev[i];
    <font color="blue">end for</font>;

    (evSorted,evIndex) := <font color="red">Modelica_LinearSystems2.Internal.sortEigenvalue</font>(ev);

   <font color="darkgreen">// Build x names</font>
    <font color="blue">if </font><font color="red">size</font>(ss.xNames, 1) &lt;&gt; nx<font color="blue"> then</font>
      <font color="blue">for </font>i<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
        xNames2[i] := &quot;x[&quot; + <font color="red">String</font>(i) + &quot;]&quot;;
      <font color="blue">end for</font>;
    <font color="blue">else</font>
      xNames2 := ss.xNames;
    <font color="blue">end if</font>;

  <font color="darkgreen">// ###### whole system checks ######</font>
  <font color="darkgreen">// stability check</font>
    isStable := true;
    <font color="blue">for </font>i<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
      isStable := isStable<font color="blue"> and </font>ev[i].ev.re &lt; 0;
    <font color="blue">end for</font>;

  <font color="darkgreen">//controllability check, stabilizability check</font>
    isControllable := <font color="red">StateSpace.Analysis.isControllable</font>(ss);
    isStabilizable := <font color="red">StateSpace.Analysis.isStabilizable</font>(ss);

  <font color="darkgreen">// observability check, detectability check</font>
    isObservable := <font color="red">StateSpace.Analysis.isObservable</font>(ss);
    isDetectable := <font color="red">StateSpace.Analysis.isDetectable</font>(ss);

  <font color="darkgreen">// analysis of single eingenvalues</font>
    ev := <font color="red">StateSpace.Internal.characterizeEigenvalue</font>(ss, ev);

  <font color="darkgreen">// Sort eigen values according to smallest imaginary value and restore the original order</font>
    evSorted := <font color="red">Modelica_LinearSystems2.Internal.sortEigenvalue</font>(ev);

  <font color="darkgreen">// analysis file</font>

    <font color="red">Modelica.Utilities.Files.removeFile</font>(fileName);
    <font color="red">Modelica.Utilities.Files.removeFile</font>(dummyFileName);
    <font color="blue">if </font>printStateSpaceSystem<font color="blue"> then</font>
      <font color="red">printSystem</font>(
        ss,
        fileName,
        systemName,
        description);
      <font color="red">printSystem</font>(
        ss,
        dummyFileName,
        systemName,
        description);
    <font color="blue">end if</font>;

    <font color="red">printHead1</font>(
      ss,
      isStable,
      isControllable,
      isStabilizable,
      isObservable,
      isDetectable,
      fileName,
      analyseOptions=analyseOptions);
    <font color="red">printHead1</font>(
      ss,
      isStable,
      isControllable,
      isStabilizable,
      isObservable,
      isDetectable,
      dummyFileName,
      analyseOptions=analyseOptions);

    <font color="red">Modelica.Utilities.Streams.readFile</font>(dummyFileName);

  <font color="darkgreen">// Plot step response</font>
    <font color="blue">if </font>analyseOptions.plotStepResponse<font color="blue"> then</font>
      <font color="red">Modelica.Utilities.Files.removeFile</font>(dummyFileName);
      <font color="red">print</font>(&quot;</pre>\n<body>\n<p>\n<b>Step responses</b>\n</p></body><pre>&quot;,
        dummyFileName);
      <font color="red">Modelica.Utilities.Streams.readFile</font>(dummyFileName);
      <font color="red">StateSpace.Plot.step</font>(ss=ss);
    <font color="blue">end if</font>;

  <font color="darkgreen">// Plot Bode plots</font>
    <font color="blue">if </font>analyseOptions.plotFrequencyResponse<font color="blue"> then</font>
      <font color="red">Modelica.Utilities.Files.removeFile</font>(dummyFileName);
      <font color="red">print</font>(&quot;</pre>\n<body>\n<p>\n<b>Bode plots</b>\n</p><pre>&quot;, dummyFileName);
      <font color="red">Modelica.Utilities.Streams.readFile</font>(dummyFileName);
      <font color="red">StateSpace.Plot.bodeMIMO</font>(ss=ss);
    <font color="blue">end if</font>;

   <font color="darkgreen">// calculate the number of real eigenvalues</font>
    nReal := <font color="red">Modelica_LinearSystems2.Internal.numberOfRealZeros</font>(cev);

    <font color="darkgreen">// Construct complex eigenvector matrix</font>
    i := 1;
    <font color="blue">while </font>i &lt;= nx<font color="blue"> loop</font>
      <font color="blue">if </font>eval[i, 2] == 0.0<font color="blue"> then</font>

        <font color="blue">for </font>jj<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
          evecComplex[jj, i] := revec[jj, i] + 0*j;
        <font color="blue">end for</font>;
        i := i + 1;
      <font color="blue">else</font>
        <font color="blue">for </font>jj<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
          evecComplex[jj, i] := revec[jj, i] + revec[jj, i + 1]*j;
          evecComplex[jj, i + 1] := revec[jj, i] - revec[jj, i + 1]*j;
        <font color="blue">end for</font>;
        i := i + 2;
      <font color="blue">end if</font>;
    <font color="blue">end while</font>;

    <font color="blue">if </font>analyseOptions.printEigenValues<font color="blue"> then</font>
      <font color="blue">if </font>nReal &gt; 0<font color="blue"> then</font>
        <font color="red">printHead2a</font>(fileName, analyseOptions=analyseOptions);
        <font color="red">printTab1</font>(
          evSorted,
          evIndex,
          revec,
          levec,
          nReal,
          xNames2,
          fileName,
          analyseOptions=analyseOptions);

        <font color="red">Modelica.Utilities.Files.removeFile</font>(dummyFileName);
        <font color="red">printHead2a</font>(dummyFileName, analyseOptions=analyseOptions);
        <font color="red">printTab1</font>(
          evSorted,
          evIndex,
          revec,
          levec,
          nReal,
          xNames2,
          dummyFileName,
          analyseOptions=analyseOptions);
        <font color="red">Modelica.Utilities.Streams.readFile</font>(dummyFileName);
      <font color="blue">else</font>
        <font color="red">print</font>(&quot;&lt;b&gt;The system has no real eigenvalues&lt;/b&gt;&lt;br&gt;&lt;br&gt;&quot;, fileName);
        <font color="red">Modelica.Utilities.Files.removeFile</font>(dummyFileName);
        <font color="red">print</font>(&quot;</pre><body><b>The system has no real eigenvalues</b><br><br></body><pre>&quot;,
          dummyFileName);
        <font color="red">Modelica.Utilities.Streams.readFile</font>(dummyFileName);

      <font color="blue">end if</font>;

      <font color="blue">if </font>nReal &lt; nx<font color="blue"> then</font>
        <font color="red">printHead2b</font>(fileName, analyseOptions=analyseOptions);
        <font color="red">printTab2</font>(
          evSorted,
          evIndex,
          revec,
          levec,
          nReal,
          xNames2,
          fileName,
          analyseOptions=analyseOptions);

        <font color="red">Modelica.Utilities.Files.removeFile</font>(dummyFileName);
        <font color="red">printHead2b</font>(dummyFileName, analyseOptions=analyseOptions);
        <font color="red">printTab2</font>(
          evSorted,
          evIndex,
          revec,
          levec,
          nReal,
          xNames2,
          dummyFileName,
          analyseOptions=analyseOptions);
        <font color="red">Modelica.Utilities.Streams.readFile</font>(dummyFileName);

    <font color="darkgreen">// Plot eigen values</font>
        i := 0;
        <font color="blue">if </font>analyseOptions.plotEigenValues<font color="blue"> then</font>
          i := i + 1;
          curves[i] := <font color="red">Plot.Records.Curve</font>(
            x=eval[:, 1],
            y=eval[:, 2],
            legend=&quot;poles&quot;,
            autoLine=false,
            linePattern=Plot.Types.LinePattern.None,
            lineSymbol=Plot.Types.PointSymbol.Cross);
        <font color="blue">end if</font>;
   <font color="darkgreen">// Plot invariant zeros</font>
        <font color="blue">if </font><font color="red">size</font>(systemZeros, 1) &gt; 0<font color="blue"> and </font>analyseOptions.plotInvariantZeros<font color="blue"> then</font>
          i := i + 1;
          curves[i] := <font color="red">Plot.Records.Curve</font>(
            x=systemZeros[:].re,
            y=systemZeros[:].im,
            legend=&quot;zeros&quot;,
            autoLine=false,
            linePattern=Plot.Types.LinePattern.None,
            lineSymbol=Plot.Types.PointSymbol.Circle);
        <font color="blue">end if</font>;

        diagram2 := defaultDiagram;
        diagram2.curve := curves[1:i];
        <font color="red">Plot.diagram</font>(diagram2, device);
      <font color="blue">else</font>
        <font color="red">print</font>(&quot;&lt;b&gt;The system has no conjugated complex eigenvalues&lt;/b&gt;&lt;br&gt;&lt;br&gt;&quot;, fileName);
        <font color="red">Modelica.Utilities.Files.removeFile</font>(dummyFileName);
        <font color="red">print</font>(&quot;</pre><body><b>No conjugated complex eigenvalues</b><br><br></body><pre>&quot;,
          dummyFileName);
        <font color="red">Modelica.Utilities.Streams.readFile</font>(dummyFileName);
      <font color="blue">end if</font>;

      <font color="blue">if </font>analyseOptions.printEigenValueProperties<font color="blue"> then</font>
        <font color="red">printHead3</font>(fileName);
        <font color="red">printTab3</font>(
          evSorted,
          evecComplex,
          evIndex,
          cev,
          nReal,
          xNames2,
          fileName);

        <font color="red">Modelica.Utilities.Files.removeFile</font>(dummyFileName);
        <font color="red">printHead3</font>(dummyFileName);
        <font color="red">printTab3</font>(
          evSorted,
          evecComplex,
          evIndex,
          cev,
          nReal,
          xNames2,
          dummyFileName);
        <font color="red">Modelica.Utilities.Streams.readFile</font>(dummyFileName);

      <font color="blue">end if</font>;
    <font color="blue">end if</font>;

  <font color="darkgreen">// ZEROS</font>
    (zerosSorted,zerosIndex) :=
      <font color="red">Modelica_LinearSystems2.Math.Complex.Vectors.sortComplex</font>(systemZeros);
    nReal := <font color="red">Modelica_LinearSystems2.Internal.numberOfRealZeros</font>(zerosSorted);

    <font color="blue">if </font>analyseOptions.printInvariantZeros<font color="blue"> then</font>
      <font color="blue">if </font><font color="red">size</font>(systemZeros, 1) &gt; 0<font color="blue"> then</font>
        <font color="red">printHead4</font>(fileName);
        <font color="red">Modelica_LinearSystems2.StateSpace.Analysis.analysis.printTab4</font>(
          zerosSorted,
          zerosIndex,
          nReal,
          fileName);

        <font color="red">Modelica.Utilities.Files.removeFile</font>(dummyFileName);
        <font color="red">printHead4</font>(dummyFileName);
        <font color="red">printTab4</font>(
          zerosSorted,
          zerosIndex,
          nReal,
          dummyFileName);
      <font color="blue">else</font>
        <font color="red">print</font>(&quot;The system has no invariant zeros&lt;br&gt;&lt;br&gt;&quot;, fileName);
        <font color="red">Modelica.Utilities.Files.removeFile</font>(dummyFileName);
        <font color="red">print</font>(&quot;</pre><body><p><br><br><b>Invariant zeros</b><br>The system has no invariant zeros<br><br></body><pre>&quot;,
          dummyFileName);
      <font color="blue">end if</font>;
      k := 0;
      <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(systemZeros, 1)<font color="blue"> loop</font>
        <font color="blue">if </font>systemZeros[i].re &gt; 0<font color="blue"> then</font>
          k := k + 1;
        <font color="blue">end if</font>;
      <font color="blue">end for</font>;
      <font color="blue">if </font>k &gt; 0<font color="blue"> then</font>
        <font color="red">print</font>(&quot;&lt;b&gt;Note, that the system has &quot; + <font color="red">String</font>(k) + &quot; zeros in the right complex half-plane&lt;/b&gt;&quot;,
          fileName);
        <font color="red">print</font>(&quot;</pre><body><b>Note, that the system has "<em>Error:Found no end-tag in HTML-documentation</em><pre> + <font color="red">String</font>(k) + &quot; zeros in the right complex half-plane&lt;/b&gt;&lt;/body&gt;&lt;/html&gt;&quot;,
          dummyFileName);
      <font color="blue">end if</font>;

    <font color="blue">end if</font>;
    <font color="red">print</font>(&quot;&lt;/body&gt;&lt;/html&gt;&quot;, fileName);
    <font color="red">print</font>(&quot;&lt;/body&gt;&lt;/html&gt;&quot;, dummyFileName);
    <font color="red">Modelica.Utilities.Streams.readFile</font>(dummyFileName);
    <font color="red">Modelica.Utilities.Files.removeFile</font>(dummyFileName);

    <font color="red">print</font>(&quot;\n\nAnalysis results have been written to file \&quot;&quot; +
      <font color="red">Modelica.Utilities.Files.fullPathName</font>(fileName) + &quot;\&quot;&quot;);

  <font color="darkgreen">// SUB FUNCTIONS</font>

  <font color="blue">equation </font>

    <font color="blue">public </font>
    <font color="blue">encapsulated </font><font color="blue">function</font> printSystem <font color="darkgreen">
        &quot;Print the state space system in html format on file&quot;</font>
        <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
        <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams.print"
>Modelica.Utilities.Streams.print</A>;
        <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
        <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;state space system to analyze&quot;</font>;
      <font color="blue">input </font>String fileName=&quot;systemAnalysis.html&quot; <font color="darkgreen">
          &quot;File on which the state space is written in html format&quot;</font>;
      <font color="blue">input </font>String systemName=&quot;State Space System&quot; <font color="darkgreen">
          &quot;name of the state space system&quot;</font>;
      <font color="blue">input </font>String description=&quot;&quot; <font color="darkgreen">&quot;Description of system (used in html file)&quot;</font>;
      <font color="blue">input </font>String format=&quot;.3g&quot; <font color="darkgreen">&quot;Format of numbers (e.g. \&quot;20.8e\&quot;)&quot;</font>;
      <font color="blue">protected </font>
      Integer nx=<font color="red">size</font>(ss.A, 1);
      Integer nu=<font color="red">size</font>(ss.B, 2);
      Integer ny=<font color="red">size</font>(ss.C, 1);
      Integer c1=<font color="red">integer</font>(<font color="red">ceil</font>(nx/2) - 1);
      Integer c2=<font color="red">integer</font>(<font color="red">ceil</font>(ny/2) - 1);
      Integer dist=8;

    <font color="blue">algorithm </font>
      <font color="red">Modelica.Utilities.Files.removeFile</font>(fileName);
      <font color="red">print</font>(&quot;</pre><body><p><br><br><b>System report</b></p>"<em>Error:Found no end-tag in HTML-documentation</em><pre>, fileName);
      <font color="red">print</font>(&quot;&lt;p&gt;&lt;br&gt; The system &lt;b&gt;&quot; + systemName + &quot;&lt;/b&gt;&lt;br&gt;&lt;/p&gt;&quot;, fileName);
      <font color="red">print</font>(&quot;&lt;table style=\&quot;font-size:10pt; font-family:Arial; border-collapse:collapse; text-align:right\&quot; &quot;
         + &quot;cellpadding=\&quot;3\&quot; border=\&quot;0\&quot;&gt; &quot;, fileName);
      <font color="red">print</font>(&quot;&lt;tr&gt;&lt;td&gt;der(x) &lt;/td&gt; &lt;td&gt;=&lt;/td&gt; &lt;td&gt; Ax&lt;/td&gt; &lt;td&gt; +&lt;/td&gt;&lt;td&gt; Bu&lt;/td&gt;&lt;/tr&gt;
         &lt;tr&gt;&lt;td&gt; y &lt;/td&gt;     &lt;td&gt;=&lt;/td&gt; &lt;td&gt; Cx&lt;/td&gt; &lt;td&gt; + &lt;/td&gt;&lt;td&gt;Du&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; &lt;br&gt;&lt;br&gt;is defined by&lt;br&gt;&quot;,
        fileName);

    <font color="darkgreen">// print A and B</font>
      <font color="red">print</font>(&quot;&lt;table style=\&quot;font-size:10pt; font-family:Arial; border-collapse:collapse; text-align:right\&quot; &quot;
         + &quot;cellpadding=\&quot;3\&quot; border=\&quot;0\&quot;&gt; &quot;, fileName);
      <font color="red">print</font>(&quot;&lt;tr&gt;&lt;td&gt;&lt;br&gt;&lt;/td&gt;&lt;td&gt;&lt;br&gt;&lt;/td&gt;&lt;td&gt;&lt;br&gt;&lt;/td&gt;&quot;, fileName);
      <font color="blue">for </font>i1<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
        <font color="red">print</font>(&quot;&lt;td style=\&quot;text-align:center\&quot; valign=\&quot;top\&quot;&gt; &quot; + ss.xNames[i1] + &quot; &lt;/td&gt;&quot;,
          fileName);
      <font color="blue">end for</font>;
      <font color="blue">for </font>i1<font color="blue"> in </font>1:dist<font color="blue"> loop</font>
        <font color="red">print</font>(&quot;&lt;td&gt;&lt;br&gt;&lt;/td&gt;&quot;, fileName);
      <font color="blue">end for</font>;
      <font color="blue">for </font>i1<font color="blue"> in </font>1:nu<font color="blue"> loop</font>
        <font color="red">print</font>(&quot;&lt;td&gt;&quot; + ss.uNames[i1] + &quot;&lt;/td&gt;&quot;, fileName);
      <font color="blue">end for</font>;

      <font color="red">print</font>(&quot;&lt;/tr&gt;&quot;, fileName);

    <font color="darkgreen">//print upper parts of A and B</font>
      <font color="blue">for </font>i1<font color="blue"> in </font>1:c1<font color="blue"> loop</font>
        <font color="red">print</font>(&quot;&lt;tr&gt; &lt;td&gt;&lt;br&gt;&lt;/td&gt;&lt;td&gt;&lt;br&gt;&lt;/td&gt;&lt;td&gt; &quot; + ss.xNames[i1] + &quot; &lt;/td&gt;&quot;,
          fileName);
        <font color="blue">for </font>i2<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
          <font color="red">print</font>(&quot;&lt;td&gt; &quot; + <font color="red">String</font>(ss.A[i1, i2], format=format) + &quot; &lt;/td&gt;&quot;, fileName);
        <font color="blue">end for</font>;

        <font color="blue">for </font>i2<font color="blue"> in </font>1:dist - 1<font color="blue"> loop</font>
          <font color="red">print</font>(&quot;&lt;td&gt;&lt;br&gt;&lt;/td&gt;&quot;, fileName);
        <font color="blue">end for</font>;

        <font color="blue">if </font>nu &gt; 0<font color="blue"> then</font>
          <font color="red">print</font>(&quot;&lt;td&gt;&quot; + ss.xNames[i1] + &quot; &lt;/td&gt;&quot;, fileName);
          <font color="blue">for </font>i2<font color="blue"> in </font>1:nu<font color="blue"> loop</font>
            <font color="red">print</font>(&quot;&lt;td&gt; &quot; + <font color="red">String</font>(ss.B[i1, i2], format=format) + &quot; &lt;/td&gt;&quot;,
              fileName);
          <font color="blue">end for</font>;
        <font color="blue">end if</font>;
           <font color="darkgreen">//nu&gt;0</font>
        <font color="red">print</font>(&quot;&lt;/tr&gt;&quot;, fileName);
      <font color="blue">end for</font>;

    <font color="darkgreen">//print middle part of A and B</font>
      <font color="red">print</font>(&quot;&lt;tr&gt;&lt;td&gt;A&lt;/td&gt;&lt;td&gt;=&lt;/td&gt;&lt;td&gt;&quot; + ss.xNames[c1 + 1] + &quot; &lt;/td&gt;&quot;, fileName);
      <font color="blue">for </font>i2<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
        <font color="red">print</font>(&quot;&lt;td&gt; &quot; + <font color="red">String</font>(ss.A[c1 + 1, i2], format=format) + &quot; &lt;/td&gt;&quot;,
          fileName);
      <font color="blue">end for</font>;
      <font color="blue">for </font>i2<font color="blue"> in </font>1:dist - 3<font color="blue"> loop</font>
        <font color="red">print</font>(&quot;&lt;td&gt;&lt;br&gt;&lt;/td&gt;&quot;, fileName);
      <font color="blue">end for</font>;

      <font color="blue">if </font>nu &gt; 0<font color="blue"> then</font>
        <font color="red">print</font>(&quot;&lt;td&gt;B&lt;/td&gt;&lt;td&gt;=&lt;/td&gt;&lt;td&gt;&quot; + ss.xNames[c1 + 1] + &quot; &lt;/td&gt;&quot;, fileName);

        <font color="blue">for </font>i2<font color="blue"> in </font>1:nu<font color="blue"> loop</font>
          <font color="red">print</font>(&quot;&lt;td&gt; &quot; + <font color="red">String</font>(ss.B[c1 + 1, i2], format=format) + &quot; &lt;/td&gt;&quot;,
            fileName);
        <font color="blue">end for</font>;
      <font color="blue">else</font>
        <font color="red">print</font>(&quot;&lt;td&gt;B&lt;/td&gt;&lt;td&gt;=&lt;/td&gt;&lt;td&gt;[ ],  empty matrix: &quot; +<font color="red">String</font>(nx)+&quot; by &quot;+<font color="red">String</font>(nu) + &quot; &lt;/td&gt;&quot;, fileName);

      <font color="blue">end if</font>;
           <font color="darkgreen">//nu&gt;0</font>

    <font color="darkgreen">//print lower parts of A and B</font>
      <font color="blue">for </font>i1<font color="blue"> in </font>c1 + 2:nx<font color="blue"> loop</font>
        <font color="red">print</font>(&quot;&lt;tr&gt;&lt;td&gt;&lt;br&gt;&lt;/td&gt;&lt;td&gt;&lt;br&gt;&lt;/td&gt;&lt;td&gt; &quot; + ss.xNames[i1] + &quot; &lt;/td&gt;&quot;,
          fileName);
        <font color="blue">for </font>i2<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
          <font color="red">print</font>(&quot;&lt;td&gt; &quot; + <font color="red">String</font>(ss.A[i1, i2], format=format) + &quot; &lt;/td&gt;&quot;, fileName);
        <font color="blue">end for</font>;

        <font color="blue">for </font>i2<font color="blue"> in </font>1:dist - 1<font color="blue"> loop</font>
          <font color="red">print</font>(&quot;&lt;td&gt;&lt;br&gt;&lt;/td&gt;&quot;, fileName);
        <font color="blue">end for</font>;
        <font color="blue">if </font>nu &gt; 0<font color="blue"> then</font>
          <font color="red">print</font>(&quot;&lt;td&gt;&quot; + ss.xNames[i1] + &quot; &lt;/td&gt;&quot;, fileName);
          <font color="blue">for </font>i2<font color="blue"> in </font>1:nu<font color="blue"> loop</font>
            <font color="red">print</font>(&quot;&lt;td&gt; &quot; + <font color="red">String</font>(ss.B[i1, i2], format=format) + &quot; &lt;/td&gt;&quot;,
              fileName);
          <font color="blue">end for</font>;
        <font color="blue">end if</font>;
           <font color="darkgreen">//nu&gt;0</font>
        <font color="red">print</font>(&quot;&lt;/tr&gt;&quot;, fileName);
      <font color="blue">end for</font>;

      <font color="red">print</font>(&quot;&lt;/table&gt;\n&quot;, fileName);

      <font color="red">print</font>(&quot;&lt;br&gt;&lt;br&gt;&quot;, fileName);

    <font color="darkgreen">// print C and D</font>
      <font color="red">print</font>(&quot;&lt;table style=\&quot;font-size:10pt; font-family:Arial; border-collapse:collapse; text-align:right\&quot; &quot;
         + &quot;cellpadding=\&quot;3\&quot; border=\&quot;0\&quot;&gt;&quot;, fileName);
      <font color="red">print</font>(&quot;&lt;tr&gt;&lt;td&gt;&lt;br&gt;&lt;/td&gt;&lt;td&gt;&lt;br&gt;&lt;/td&gt;&lt;td&gt;&lt;br&gt;&lt;/td&gt;&quot;, fileName);

      <font color="blue">if </font>ny &gt; 0<font color="blue"> then</font>
        <font color="blue">for </font>i1<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
          <font color="red">print</font>(&quot;&lt;td style=\&quot;text-align:center\&quot; valign=\&quot;top\&quot;&gt; &quot; + ss.xNames[i1] + &quot; &lt;/td&gt;&quot;,
            fileName);
        <font color="blue">end for</font>;
        <font color="blue">for </font>i1<font color="blue"> in </font>1:dist<font color="blue"> loop</font>
          <font color="red">print</font>(&quot;&lt;td&gt;&lt;br&gt;&lt;/td&gt;&quot;, fileName);
        <font color="blue">end for</font>;
        <font color="blue">for </font>i1<font color="blue"> in </font>1:nu<font color="blue"> loop</font>
          <font color="red">print</font>(&quot;&lt;td&gt;&quot; + ss.uNames[i1] + &quot;&lt;/td&gt;&quot;, fileName);
        <font color="blue">end for</font>;
      <font color="blue">end if</font>;
           <font color="darkgreen">//ny&gt;0</font>
      <font color="red">print</font>(&quot;&lt;/tr&gt;&quot;, fileName);

      <font color="blue">if </font>ny &gt; 0<font color="blue"> then</font>
     <font color="darkgreen">//print upper parts of C and D</font>
        <font color="blue">for </font>i1<font color="blue"> in </font>1:c2<font color="blue"> loop</font>
          <font color="red">print</font>(&quot;&lt;tr&gt; &lt;td&gt;&lt;br&gt;&lt;/td&gt;&lt;td&gt;&lt;br&gt;&lt;/td&gt;&lt;td&gt; &quot; + ss.yNames[i1] + &quot; &lt;/td&gt;&quot;,
            fileName);
          <font color="blue">for </font>i2<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
            <font color="red">print</font>(&quot;&lt;td&gt; &quot; + <font color="red">String</font>(ss.C[i1, i2], format=format) + &quot; &lt;/td&gt;&quot;,
              fileName);
          <font color="blue">end for</font>;

          <font color="blue">for </font>i2<font color="blue"> in </font>1:dist - 1<font color="blue"> loop</font>
            <font color="red">print</font>(&quot;&lt;td&gt;&lt;br&gt;&lt;/td&gt;&quot;, fileName);
          <font color="blue">end for</font>;
          <font color="red">print</font>(&quot;&lt;td&gt;&quot; + ss.yNames[i1] + &quot; &lt;/td&gt;&quot;, fileName);
          <font color="blue">for </font>i2<font color="blue"> in </font>1:nu<font color="blue"> loop</font>
            <font color="red">print</font>(&quot;&lt;td&gt; &quot; + <font color="red">String</font>(ss.D[i1, i2], format=format) + &quot; &lt;/td&gt;&quot;,
              fileName);
          <font color="blue">end for</font>;

          <font color="red">print</font>(&quot;&lt;/tr&gt;&quot;, fileName);
        <font color="blue">end for</font>;
      <font color="blue">end if</font>;
           <font color="darkgreen">//ny&gt;0</font>

     <font color="darkgreen">//print middle part of C and D</font>
      <font color="blue">if </font>ny &gt; 0<font color="blue"> then</font>
        <font color="red">print</font>(&quot;&lt;tr&gt;&lt;td&gt;C&lt;/td&gt;&lt;td&gt;=&lt;/td&gt;&lt;td&gt;&quot; + ss.yNames[c2 + 1] + &quot; &lt;/td&gt;&quot;,
          fileName);
        <font color="blue">for </font>i2<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
          <font color="red">print</font>(&quot;&lt;td&gt; &quot; + <font color="red">String</font>(ss.C[c2 + 1, i2], format=format) + &quot; &lt;/td&gt;&quot;,
            fileName);
        <font color="blue">end for</font>;
        <font color="blue">for </font>i2<font color="blue"> in </font>1:dist - 3<font color="blue"> loop</font>
          <font color="red">print</font>(&quot;&lt;td&gt;&lt;br&gt;&lt;/td&gt;&quot;, fileName);
        <font color="blue">end for</font>;
        <font color="red">print</font>(&quot;&lt;td&gt;D&lt;/td&gt;&lt;td&gt;=&lt;/td&gt;&lt;td&gt;&quot; + (<font color="blue">if </font>nu&gt;0<font color="blue"> then </font>ss.yNames[<font color="red">min</font>(c2 + 1, ny)]<font color="blue"> else </font>&quot;[ ],  empty matrix: &quot; +<font color="red">String</font>(ny)+&quot; by &quot;+<font color="red">String</font>(nu)) + &quot; &lt;/td&gt;&quot;,
          fileName);

        <font color="blue">for </font>i2<font color="blue"> in </font>1:nu<font color="blue"> loop</font>
          <font color="red">print</font>(&quot;&lt;td&gt; &quot; + <font color="red">String</font>(ss.D[c2 + 1, i2], format=format) + &quot; &lt;/td&gt;&quot;,
            fileName);
        <font color="blue">end for</font>;
      <font color="blue">else</font>
        <font color="red">print</font>(&quot;&lt;tr&gt;&lt;td&gt;C&lt;/td&gt;&lt;td&gt;=&lt;/td&gt;&lt;td&gt;[ ],  empty matrix: &quot; +<font color="red">String</font>(ny)+&quot; by &quot;+<font color="red">String</font>(nx) + &quot; &lt;/td&gt;&quot;, fileName);
        <font color="blue">for </font>i2<font color="blue"> in </font>1:dist - 3<font color="blue"> loop</font>
          <font color="red">print</font>(&quot;&lt;td&gt;&lt;br&gt;&lt;/td&gt;&quot;, fileName);
        <font color="blue">end for</font>;
        <font color="red">print</font>(&quot;&lt;td&gt;D&lt;/td&gt;&lt;td&gt;=&lt;/td&gt;&lt;td&gt;[ ],  empty matrix: &quot; +<font color="red">String</font>(ny)+&quot; by &quot;+<font color="red">String</font>(nu) + &quot; &lt;/td&gt;&quot;, fileName);
      <font color="blue">end if</font>;
           <font color="darkgreen">//ny&gt;0</font>

     <font color="darkgreen">//print lower parts of C and D</font>
      <font color="blue">if </font>ny &gt; 0<font color="blue"> then</font>
        <font color="blue">for </font>i1<font color="blue"> in </font>c2 + 2:ny<font color="blue"> loop</font>
          <font color="red">print</font>(&quot;&lt;tr&gt;&lt;td&gt;&lt;br&gt;&lt;/td&gt;&lt;td&gt;&lt;br&gt;&lt;/td&gt;&lt;td&gt; &quot; + ss.yNames[i1] + &quot; &lt;/td&gt;&quot;,
            fileName);
          <font color="blue">for </font>i2<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
            <font color="red">print</font>(&quot;&lt;td&gt; &quot; + <font color="red">String</font>(ss.C[i1, i2], format=format) + &quot; &lt;/td&gt;&quot;,
              fileName);
          <font color="blue">end for</font>;

          <font color="blue">for </font>i2<font color="blue"> in </font>1:dist - 1<font color="blue"> loop</font>
            <font color="red">print</font>(&quot;&lt;td&gt;&lt;br&gt;&lt;/td&gt;&quot;, fileName);
          <font color="blue">end for</font>;
          <font color="red">print</font>(&quot;&lt;td&gt;&quot; + ss.yNames[i1] + &quot; &lt;/td&gt;&quot;, fileName);
          <font color="blue">for </font>i2<font color="blue"> in </font>1:nu<font color="blue"> loop</font>
            <font color="red">print</font>(&quot;&lt;td&gt; &quot; + <font color="red">String</font>(ss.D[i1, i2], format=format) + &quot; &lt;/td&gt;&quot;,
              fileName);
          <font color="blue">end for</font>;
          <font color="red">print</font>(&quot;&lt;/tr&gt;&quot;, fileName);
        <font color="blue">end for</font>;
      <font color="blue">end if</font>;
           <font color="darkgreen">// ny&gt;0</font>

      <font color="blue">if </font>description == &quot;&quot;<font color="blue"> then</font>
        <font color="red">print</font>(&quot;&lt;/table&gt;\n&quot;, fileName);
      <font color="blue">else</font>
        <font color="red">print</font>(&quot;&lt;/table&gt;&quot;, fileName);
        <font color="red">print</font>(&quot;&lt;p&gt;\n&lt;b&gt;Description&lt;/b&gt;\n&lt;/p&gt;&quot;, fileName);
        <font color="red">print</font>(description, fileName);
      <font color="blue">end if</font>;

      <font color="blue">if </font>ny==0<font color="blue"> and </font>nu==0<font color="blue"> then</font>
        <font color="red">print</font>(&quot;&lt;p&gt;\n&lt;b&gt;Note&lt;/b&gt;, that matrices &lt;b&gt;B&lt;/b&gt; and &lt;b&gt;C&lt;/b&gt; are empty matrices, i.e. the system has neither inputs nor outputs!\n&lt;/p&gt;&quot;, fileName);
      <font color="blue">elseif </font>ny==0<font color="blue"> then</font>
         <font color="red">print</font>(&quot;&lt;p&gt;\n&lt;b&gt;Note&lt;/b&gt;, that atrix &lt;b&gt;C&lt;/b&gt; is empty matrix, i.e. the system has no outputs!\n&lt;/p&gt;&quot;, fileName);
      <font color="blue">elseif </font>nu==0<font color="blue"> then</font>
         <font color="red">print</font>(&quot;&lt;p&gt;\n&lt;b&gt;Note&lt;/b&gt;, that matrix &lt;b&gt;B&lt;/b&gt; is empty matrix, i.e. the system has no inputs!\n&lt;/p&gt;&quot;, fileName);
      <font color="blue">end if</font>;

      <font color="red">print</font>(&quot;&lt;/body&gt;&lt;/html&gt;&quot;, fileName);

    <font color="blue">end </font>printSystem;

    <font color="blue">encapsulated </font><font color="blue">function</font> printHead1
        <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
        <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Strings.html#Modelica.Utilities.Strings"
>Modelica.Utilities.Strings</A>;
        <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
        <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams.print"
>Modelica.Utilities.Streams.print</A>;
        <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;
      <font color="blue">input </font>Boolean isStable;
      <font color="blue">input </font>Boolean isControllable;
      <font color="blue">input </font>Boolean isStabilizable;
      <font color="blue">input </font>Boolean isObservable;
      <font color="blue">input </font>Boolean isDetectable;
      <font color="blue">input </font>String fileName;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.AnalyseOptions"
>Modelica_LinearSystems2.Internal.AnalyseOptions</A> analyseOptions=
          <font color="red">Modelica_LinearSystems2.Internal.AnalyseOptions</font>(
            plotEigenValues=true,
            plotInvariantZeros=true,
            plotStepResponse=true,
            plotFrequencyResponse=true,
            printEigenValues=true,
            printEigenValueProperties=true,
            printInvariantZeros=true,
            printControllability=true,
            printObservability=true,
            headingEigenValues=&quot;Eigenvalues&quot;,
            headingInvariantzeros=&quot;Invariant zeros&quot;,
            headingStepResponse=&quot;Step response&quot;,
            headingFrequencyResponse=&quot;Frequency response&quot;);

    <font color="blue">algorithm </font>
      <font color="red">print</font>(&quot;</pre>\n<body>\n<p>\n<b>Characteristics</b>\n</p>The system\n<p>"<em>Error:Found no end-tag in HTML-documentation</em><pre> + &quot;&lt;/p&gt; is &quot;,
        fileName);
      <font color="blue">if </font>analyseOptions.printControllability<font color="blue"> and </font>analyseOptions.printObservability<font color="blue"> then</font>
        <font color="red">print</font>((<font color="blue">if </font>isStable<font color="blue"> then </font>&quot; &quot;<font color="blue"> else </font>&quot;not &quot;) + &quot;stable&quot; + &quot;\n&lt;br&gt;&quot; + (<font color="blue">if </font>
          isStable<font color="blue"> then </font><font color="blue">if </font>isControllable<font color="blue"> then </font>&quot;and it is &quot;<font color="blue"> else </font>&quot;but it is not &quot;<font color="blue"> else </font>
                <font color="blue">if </font>isControllable<font color="blue"> then </font>&quot;but it is &quot;<font color="blue"> else </font>&quot;and it is not &quot;) + &quot;controllable&quot;
           + (<font color="blue">if </font>isStable<font color="blue"> then </font>&quot;&quot;<font color="blue"> else </font>&quot;\n&lt;br&gt;&quot; + (<font color="blue">if </font>isControllable<font color="blue"> then </font>&quot; and therefore it is &quot;<font color="blue"> else </font>
                <font color="blue">if </font>isStabilizable<font color="blue"> then </font>&quot; but it is &quot;<font color="blue"> else </font>&quot;and is not &quot;) + &quot;stabilizable&quot;)
           + &quot;\n&lt;br&gt; The system is &quot; + (<font color="blue">if </font>isObservable<font color="blue"> then </font>&quot; &quot;<font color="blue"> else </font>&quot;not &quot;) + &quot;observable&quot;
           + (<font color="blue">if </font>isStable<font color="blue"> then </font>&quot;&quot;<font color="blue"> else </font>&quot;\n&lt;br&gt;&quot; + (<font color="blue">if </font>isObservable<font color="blue"> then </font>&quot; and therefore it is &quot;<font color="blue"> else </font>
                <font color="blue">if </font>isDetectable<font color="blue"> then </font>&quot; but it is &quot;<font color="blue"> else </font>&quot;and is not &quot;) + &quot;detectable&quot;)
           + &quot;\n&lt;br&gt;&lt;/br&gt;&quot;, fileName);
      <font color="blue">elseif </font><font color="blue">not </font>analyseOptions.printObservability<font color="blue"> and </font>analyseOptions.printControllability<font color="blue"> then</font>
        <font color="red">print</font>((<font color="blue">if </font>isStable<font color="blue"> then </font>&quot; &quot;<font color="blue"> else </font>&quot;not &quot;) + &quot;stable&quot; + &quot;\n&lt;br&gt;&quot; + (<font color="blue">if </font>
          isStable<font color="blue"> then </font><font color="blue">if </font>isControllable<font color="blue"> then </font>&quot;and it is &quot;<font color="blue"> else </font>&quot;but it is not &quot;<font color="blue"> else </font>
                <font color="blue">if </font>isControllable<font color="blue"> then </font>&quot;but it is &quot;<font color="blue"> else </font>&quot;and it is not &quot;) + &quot;controllable&quot;
           + (<font color="blue">if </font>isStable<font color="blue"> then </font>&quot;&quot;<font color="blue"> else </font>&quot;\n&lt;br&gt;&quot; + (<font color="blue">if </font>isControllable<font color="blue"> then </font>&quot; and therefore it is &quot;<font color="blue"> else </font>
                <font color="blue">if </font>isStabilizable<font color="blue"> then </font>&quot; but it is &quot;<font color="blue"> else </font>&quot;and is not &quot;) + &quot;stabilizable&quot;)
           + &quot;\n&lt;br&gt;&lt;/br&gt;&quot;, fileName);
      <font color="blue">elseif </font><font color="blue">not </font>analyseOptions.printControllability<font color="blue"> and </font>analyseOptions.printObservability<font color="blue"> then</font>
        <font color="red">print</font>((<font color="blue">if </font>isStable<font color="blue"> then </font>&quot; &quot;<font color="blue"> else </font>&quot;not &quot;) + &quot;stable&quot; + &quot;\n&lt;br&gt; The system is &quot;
           + (<font color="blue">if </font>isObservable<font color="blue"> then </font>&quot; &quot;<font color="blue"> else </font>&quot;not &quot;) + &quot;observable&quot; + (<font color="blue">if </font>isStable<font color="blue"> then </font>
                &quot;&quot;<font color="blue"> else </font>&quot;\n&lt;br&gt;&quot; + (<font color="blue">if </font>isObservable<font color="blue"> then </font>&quot; and therefore it is &quot;<font color="blue"> else </font>
                <font color="blue">if </font>isDetectable<font color="blue"> then </font>&quot; but it is &quot;<font color="blue"> else </font>&quot;and is not &quot;) + &quot;detectable&quot;)
           + &quot;\n&lt;br&gt;&lt;/br&gt;&quot;, fileName);
      <font color="blue">else</font>
        <font color="red">print</font>((<font color="blue">if </font>isStable<font color="blue"> then </font>&quot; &quot;<font color="blue"> else </font>&quot;not &quot;) + &quot;stable&quot; + &quot;\n&lt;br&gt;&lt;/br&gt;&quot;,
          fileName);
      <font color="blue">end if</font>;
      <font color="red">print</font>(&quot;&lt;/body&gt;&lt;/html&gt;&quot;, fileName);

    <font color="blue">end </font>printHead1;

    <font color="blue">public </font>
    <font color="blue">encapsulated </font><font color="blue">function</font> printHead2a
        <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
        <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Strings.html#Modelica.Utilities.Strings"
>Modelica.Utilities.Strings</A>;
        <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
        <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams.print"
>Modelica.Utilities.Streams.print</A>;

      <font color="blue">input </font>String fileName;
      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.AnalyseOptions"
>Modelica_LinearSystems2.Internal.AnalyseOptions</A> analyseOptions=
          <font color="red">Modelica_LinearSystems2.Internal.AnalyseOptions</font>(
            plotEigenValues=true,
            plotInvariantZeros=true,
            plotStepResponse=true,
            plotFrequencyResponse=true,
            printEigenValues=true,
            printEigenValueProperties=true,
            printInvariantZeros=true,
            printControllability=true,
            printObservability=true,
            headingEigenValues=&quot;Eigenvalues&quot;,
            headingInvariantzeros=&quot;Invariant zeros&quot;,
            headingStepResponse=&quot;Step response&quot;,
            headingFrequencyResponse=&quot;Frequency response&quot;);

    <font color="blue">algorithm </font>
      <font color="blue">if </font>analyseOptions.printEigenValueProperties<font color="blue"> then</font>
        <font color="red">print</font>(&quot;</pre>\n<body>\n<b><big>Eigenvalues analysis</big></b><br><br><b>Real eigenvalues</b>\n<br>"<em>Error:Found no end-tag in HTML-documentation</em><pre>
           + &quot;&lt;table style=\&quot;font-size:10pt; font-family:Arial; border-collapse:collapse; text-align:right\&quot; &quot;
           + &quot;cellpadding=\&quot;3\&quot; border=\&quot;1\&quot;&gt;\n&quot; + &quot;&lt;tr style=\&quot;background-color:rgb(230, 230, 230); text-align:center;\&quot;&gt;&quot;
           + &quot;&lt;td&gt; number &lt;/td&gt;&lt;td&gt; eigenvalue &lt;/td&gt; &lt;td&gt; T [s] &lt;/td&gt;  &lt;td&gt; characteristics &lt;/td&gt;&lt;td&gt; contribution to states&lt;/td&gt;&lt;/tr&gt;&quot;,
          fileName);
      <font color="blue">else</font>
        <font color="red">print</font>(&quot;</pre>\n<body>\n<b><big>Eigenvalues analysis</big></b><br><br><b>Real eigenvalues</b>\n<br>"<em>Error:Found no end-tag in HTML-documentation</em><pre>
           + &quot;&lt;table style=\&quot;font-size:10pt; font-family:Arial; border-collapse:collapse; text-align:right\&quot; &quot;
           + &quot;cellpadding=\&quot;3\&quot; border=\&quot;1\&quot;&gt;\n&quot; + &quot;&lt;tr style=\&quot;background-color:rgb(230, 230, 230); text-align:center;\&quot;&gt;&quot;
           + &quot;&lt;td&gt; number &lt;/td&gt;&lt;td&gt; eigenvalue &lt;/td&gt; &lt;td&gt; T [s] &lt;/td&gt;  &lt;td&gt; characteristics &lt;/td&gt;&lt;/tr&gt;&quot;,
          fileName);
      <font color="blue">end if</font>;
    <font color="blue">end </font>printHead2a;

    <font color="blue">public </font>
    <font color="blue">encapsulated </font><font color="blue">function</font> printHead2b
        <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
        <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Strings.html#Modelica.Utilities.Strings"
>Modelica.Utilities.Strings</A>;
        <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
        <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams.print"
>Modelica.Utilities.Streams.print</A>;

      <font color="blue">input </font>String fileName;
      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.AnalyseOptions"
>Modelica_LinearSystems2.Internal.AnalyseOptions</A> analyseOptions=
          <font color="red">Modelica_LinearSystems2.Internal.AnalyseOptions</font>(
            plotEigenValues=true,
            plotInvariantZeros=true,
            plotStepResponse=true,
            plotFrequencyResponse=true,
            printEigenValues=true,
            printEigenValueProperties=true,
            printInvariantZeros=true,
            printControllability=true,
            printObservability=true,
            headingEigenValues=&quot;Eigenvalues&quot;,
            headingInvariantzeros=&quot;Invariant zeros&quot;,
            headingStepResponse=&quot;Step response&quot;,
            headingFrequencyResponse=&quot;Frequency response&quot;);

    <font color="blue">algorithm </font>
      <font color="red">print</font>(&quot;</pre>\n<body>"<em>Error:Found no end-tag in HTML-documentation</em><pre>, fileName);
      <font color="blue">if </font>analyseOptions.printEigenValueProperties<font color="blue"> then</font>
        <font color="red">print</font>(&quot;&lt;b&gt;Conjugated complex pairs of eigenvalues&lt;/b&gt;\n&lt;br&gt;&quot; + &quot;&lt;table style=\&quot;font-size:10pt; font-family:Arial; border-collapse:collapse; text-align:right\&quot; &quot;
           + &quot;cellpadding=\&quot;3\&quot; border=\&quot;1\&quot;&gt;\n&quot; + &quot;&lt;tr style=\&quot;background-color:rgb(230, 230, 230); text-align:center;\&quot;&gt;&quot;
           + &quot;&lt;td&gt; number &lt;/td&gt; &lt;td&gt; eigenvalue &lt;/td&gt;&lt;td&gt; freq. [Hz] &lt;/td&gt; &lt;td&gt; damping &lt;/td&gt;&lt;td&gt; characteristics &lt;/td&gt;  &lt;td&gt; contribution to states&lt;/td&gt;&lt;/tr&gt;&quot;,
          fileName);
      <font color="blue">else</font>
        <font color="red">print</font>(&quot;&lt;b&gt;Conjugated complex pairs of eigenvalues&lt;/b&gt;\n&lt;br&gt;&quot; + &quot;&lt;table style=\&quot;font-size:10pt; font-family:Arial; border-collapse:collapse; text-align:right\&quot; &quot;
           + &quot;cellpadding=\&quot;3\&quot; border=\&quot;1\&quot;&gt;\n&quot; + &quot;&lt;tr style=\&quot;background-color:rgb(230, 230, 230); text-align:center;\&quot;&gt;&quot;
           + &quot;&lt;td&gt; number &lt;/td&gt; &lt;td&gt; eigenvalue &lt;/td&gt;&lt;td&gt; freq. [Hz] &lt;/td&gt; &lt;td&gt; damping &lt;/td&gt;&lt;td&gt; characteristics &lt;/td&gt; &lt;/tr&gt;&quot;,
          fileName);
      <font color="blue">end if</font>;
    <font color="blue">end </font>printHead2b;

    <font color="blue">encapsulated </font><font color="blue">function</font> printHead3
        <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
        <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Strings.html#Modelica.Utilities.Strings"
>Modelica.Utilities.Strings</A>;
        <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
        <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams.print"
>Modelica.Utilities.Streams.print</A>;

      <font color="blue">input </font>String fileName;
      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.AnalyseOptions"
>Modelica_LinearSystems2.Internal.AnalyseOptions</A> analyseOptions=
          <font color="red">Modelica_LinearSystems2.Internal.AnalyseOptions</font>(
            plotEigenValues=true,
            plotInvariantZeros=true,
            plotStepResponse=true,
            plotFrequencyResponse=true,
            printEigenValues=true,
            printEigenValueProperties=true,
            printInvariantZeros=true,
            printControllability=true,
            printObservability=true,
            headingEigenValues=&quot;Eigenvalues&quot;,
            headingInvariantzeros=&quot;Invariant zeros&quot;,
            headingStepResponse=&quot;Step response&quot;,
            headingFrequencyResponse=&quot;Frequency response&quot;);

    <font color="blue">algorithm </font>
      <font color="red">print</font>(&quot;</pre><body>"<em>Error:Found no end-tag in HTML-documentation</em><pre>, fileName);
      <font color="red">print</font>(&quot;&lt;p&gt; In the tables above, the column &lt;b&gt;contribution to states&lt;/b&gt; lists for each eigenvalue the states to which the&quot;
         + &quot;corresponding modal state contributes most. This information is based on the &quot;
         + &quot;two largest absolute values of the corresponding right eigenvector (if the second large value &quot;
         + &quot;is less than 5 % of the largest contribution, it is not shown).&lt;br&gt;&quot; + &quot;&lt;/p&gt;&lt;p&gt;&quot;
         + &quot;In the next table, for each state in the column &lt;b&gt;correlation to modal states&lt;/b&gt;, the modal  &quot;
         + &quot;states which contribute most to the coresponding state are summarized, i.e. the state is mostly composed of these modal states &quot;
         + &quot;This information is based on the two largest absolute values of row i of the &quot;
         + &quot;eigenvector matrix that is associated with eigenvalue i (if the second large value  &quot;
         + &quot;is less than 5 % of the largest contribution, it is not shown). This only holds &quot;
         + &quot;if the modal states are in the same order of magnitude. Otherwise, the modal states &quot;
         + &quot;listed in the last column might be not the most relevant one. &lt;/p&gt;&lt;br&gt;&lt;br&gt; &quot;
         + &quot;&lt;table style=\&quot;font-size:10pt; font-family:Arial; border-collapse:collapse; text-align:right\&quot; &quot;
         + &quot;cellpadding=\&quot;3\&quot; border=\&quot;1\&quot;&gt; &quot; + &quot;&lt;tr style=\&quot;background-color:rgb(230, 230, 230); text-align:center;\&quot;&gt;&quot;
         + &quot;&lt;td&gt; state &lt;/td&gt; &lt;td&gt; composition &lt;/td&gt; &lt;td&gt; eigenvalue #&lt;/td&gt; &lt;td&gt; freq. [Hz] &lt;/td&gt; &lt;td&gt; damping &lt;/td&gt;  &lt;/td&gt; &lt;td&gt; T [s] &lt;/td&gt;&lt;/tr&gt;&quot;,
        fileName);

    <font color="blue">end </font>printHead3;

    <font color="blue">encapsulated </font><font color="blue">function</font> printHead4
        <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
        <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Strings.html#Modelica.Utilities.Strings"
>Modelica.Utilities.Strings</A>;
        <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
        <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams.print"
>Modelica.Utilities.Streams.print</A>;

      <font color="blue">input </font>String fileName;
      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.AnalyseOptions"
>Modelica_LinearSystems2.Internal.AnalyseOptions</A> analyseOptions=
          <font color="red">Modelica_LinearSystems2.Internal.AnalyseOptions</font>(
            plotEigenValues=true,
            plotInvariantZeros=true,
            plotStepResponse=true,
            plotFrequencyResponse=true,
            printEigenValues=true,
            printEigenValueProperties=true,
            printInvariantZeros=true,
            printControllability=true,
            printObservability=true,
            headingEigenValues=&quot;Eigenvalues&quot;,
            headingInvariantzeros=&quot;Invariant zeros&quot;,
            headingStepResponse=&quot;Step response&quot;,
            headingFrequencyResponse=&quot;Frequency response&quot;);

    <font color="blue">algorithm </font>
      <font color="red">print</font>(&quot;</pre><body>"<em>Error:Found no end-tag in HTML-documentation</em><pre>, fileName);
      <font color="red">print</font>(&quot;&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;b&gt;Invariant zeros&lt;/b&gt;&lt;br&gt;&quot; + &quot;&lt;table style=\&quot;font-size:10pt; font-family:Arial; border-collapse:collapse; text-align:right\&quot; &quot;
         + &quot;cellpadding=\&quot;3\&quot; border=\&quot;1\&quot;&gt;&quot; + &quot;&lt;tr style=\&quot;background-color:rgb(230, 230, 230); text-align:center;\&quot;&gt;&quot;
         + &quot;&lt;td&gt; number &lt;/td&gt; &lt;td&gt; invariant zero &lt;/td&gt;&lt;td&gt; Time constant [s] &lt;/td&gt; &lt;td&gt; freq. [Hz] &lt;/td&gt; &lt;td&gt; damping &lt;/td&gt;&lt;/tr&gt;&quot;,
        fileName);
    <font color="blue">end </font>printHead4;

    <font color="blue">encapsulated </font><font color="blue">function</font> printTab1
        <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
        <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Strings.html#Modelica.Utilities.Strings"
>Modelica.Utilities.Strings</A>;
        <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
        <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams.print"
>Modelica.Utilities.Streams.print</A>;
        <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Modelica_LinearSystems2.Internal.Eigenvalue</A>;
        <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Eigenvalue</A> evSorted[:];
      <font color="blue">input </font>Integer evIndex[<font color="red">size</font>(evSorted, 1)];
      <font color="blue">input </font>Real r_evec[<font color="red">size</font>(evSorted, 1),<font color="red">size</font>(evSorted, 1)];
      <font color="blue">input </font>Real l_evec[<font color="red">size</font>(evSorted, 1),<font color="red">size</font>(evSorted, 1)];
      <font color="blue">input </font>Integer nReal;
      <font color="blue">input </font>String xNames2[<font color="red">size</font>(evSorted, 1)];
      <font color="blue">input </font>String fileName;
      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.AnalyseOptions"
>Modelica_LinearSystems2.Internal.AnalyseOptions</A> analyseOptions=
          <font color="red">Modelica_LinearSystems2.Internal.AnalyseOptions</font>(
            plotEigenValues=true,
            plotInvariantZeros=true,
            plotStepResponse=true,
            plotFrequencyResponse=true,
            printEigenValues=true,
            printEigenValueProperties=true,
            printInvariantZeros=true,
            printControllability=true,
            printObservability=true,
            headingEigenValues=&quot;Eigenvalues&quot;,
            headingInvariantzeros=&quot;Invariant zeros&quot;,
            headingStepResponse=&quot;Step response&quot;,
            headingFrequencyResponse=&quot;Frequency response&quot;);

      <font color="blue">protected </font>
      Integer nx=<font color="red">size</font>(evSorted, 1);
      Real w;
      Real d;

      Integer i;
      Integer j;
      Integer k;
      String number;

      Real r_abs_evec[nx];
      Real l_abs_evec[nx];
      Integer r_maxIndex1;
      Integer l_maxIndex1;
      Integer r_maxIndex2;
      Integer l_maxIndex2;
    <font color="darkgreen">//  Complex v_normalized[size(evSorted,1)];</font>
      Real r_abs_v_normalized;
      Real l_abs_v_normalized;
      Real r_v;
      Real l_v;
      Real r_absMax1;
      Real l_absMax1;
      Real r_absMax2;
      Real l_absMax2;
      Boolean r_two;
      Boolean l_two;
      Boolean r_first;
      Boolean l_first;

    <font color="blue">algorithm </font>
      i := 1;
      j := i;
      <font color="blue">while </font>i &lt;= nReal<font color="blue"> loop</font>
       <font color="darkgreen">// Build eigenvalue number</font>

        number := <font color="red">String</font>(
            i,
            minimumLength=7,
            leftJustified=false);
        j := j + 1;

       <font color="darkgreen">// Determine largest value in eigenvector</font>
        k := evIndex[i] <font color="darkgreen">&quot;Index with respect to unsorted eigen values&quot;</font>;
        r_abs_evec := <font color="red">abs</font>(r_evec[:, k]);
        l_abs_evec := <font color="red">abs</font>(l_evec[:, k]);

        r_first := true;
        r_two := false;
        r_absMax1 := 0;
        r_maxIndex1 := 0;
        r_absMax2 := 0;
        r_maxIndex2 := 0;
        r_abs_v_normalized := <font color="red">Modelica.Math.Vectors.norm</font>(r_abs_evec, 1);

        l_first := true;
        l_two := false;
        l_absMax1 := 0;
        l_maxIndex1 := 0;
        l_absMax2 := 0;
        l_maxIndex2 := 0;
        l_abs_v_normalized := <font color="red">Modelica.Math.Vectors.norm</font>(l_abs_evec, 1);
        <font color="blue">for </font>j<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
          r_v := r_abs_evec[j];
          l_v := l_abs_evec[j];

          <font color="blue">if </font>r_first<font color="blue"> then</font>
            r_first := false;
            r_absMax1 := r_v;
            r_maxIndex1 := j;
          <font color="blue">elseif </font><font color="blue">not </font>r_two<font color="blue"> then</font>
            r_two := true;
            <font color="blue">if </font>r_v &lt; r_absMax1<font color="blue"> then</font>
              r_absMax2 := r_v;
              r_maxIndex2 := j;
            <font color="blue">else</font>
              r_absMax2 := r_absMax1;
              r_maxIndex2 := r_maxIndex1;
              r_absMax1 := r_v;
              r_maxIndex1 := j;
            <font color="blue">end if</font>;
          <font color="blue">elseif </font>r_v &gt; r_absMax1<font color="blue"> then</font>
            r_absMax2 := r_absMax1;
            r_maxIndex2 := r_maxIndex1;
            r_absMax1 := r_v;
            r_maxIndex1 := j;
          <font color="blue">elseif </font>r_v &gt; r_absMax2<font color="blue"> then</font>
            r_absMax2 := r_v;
            r_maxIndex2 := j;
          <font color="blue">end if</font>;

          <font color="blue">if </font>l_first<font color="blue"> then</font>
            l_first := false;
            l_absMax1 := l_v;
            l_maxIndex1 := j;
          <font color="blue">elseif </font><font color="blue">not </font>l_two<font color="blue"> then</font>
            l_two := true;
            <font color="blue">if </font>l_v &lt; l_absMax1<font color="blue"> then</font>
              l_absMax2 := l_v;
              l_maxIndex2 := j;
            <font color="blue">else</font>
              l_absMax2 := l_absMax1;
              l_maxIndex2 := l_maxIndex1;
              l_absMax1 := l_v;
              l_maxIndex1 := j;
            <font color="blue">end if</font>;
          <font color="blue">elseif </font>l_v &gt; l_absMax1<font color="blue"> then</font>
            l_absMax2 := l_absMax1;
            l_maxIndex2 := l_maxIndex1;
            l_absMax1 := l_v;
            l_maxIndex1 := j;
          <font color="blue">elseif </font>l_v &gt; l_absMax2<font color="blue"> then</font>
            l_absMax2 := l_v;
            l_maxIndex2 := j;
          <font color="blue">end if</font>;

        <font color="blue">end for</font>;

        r_absMax1 := 100*r_absMax1/r_abs_v_normalized;
        r_absMax2 := 100*r_absMax2/r_abs_v_normalized;

        <font color="blue">if </font>r_absMax2 &lt; 0.05*r_absMax1<font color="blue"> then</font>
          r_two := false;
        <font color="blue">end if</font>;

        l_absMax1 := 100*l_absMax1/l_abs_v_normalized;
        l_absMax2 := 100*l_absMax2/l_abs_v_normalized;

        <font color="blue">if </font>l_absMax2 &lt; 0.05*l_absMax1<font color="blue"> then</font>
          l_two := false;
        <font color="blue">end if</font>;

       <font color="darkgreen">// Print data for one eigen value</font>
        <font color="blue">if </font>analyseOptions.printEigenValueProperties<font color="blue"> then</font>
          <font color="red">print</font>(&quot;&lt;tr&gt;\n &lt;td style=\&quot;text-align:center\&quot;&gt; &quot; + number + &quot; &lt;/td&gt; &lt;td style=\&quot;text-align:left\&quot;&gt; &amp;nbsp; &quot;
             + <font color="red">String</font>(evSorted[i].ev.re, format=&quot;14.4e&quot;) + &quot; &lt;/td&gt; &lt;td style=\&quot;text-align:left\&quot;&gt; &amp;nbsp; &quot;
             + <font color="red">String</font>(evSorted[i].timeConstant, format=&quot;9.4f&quot;) + &quot; &lt;/td&gt; &lt;td style=\&quot;text-align:left\&quot;&gt; &amp;nbsp; &quot;
             + (<font color="blue">if </font>evSorted[i].isStable<font color="blue"> then </font>&quot;&quot;<font color="blue"> else </font>&quot;not &quot;) + &quot;stable, &quot; + (<font color="blue">if </font>
            evSorted[i].isStable<font color="blue"> then </font>(<font color="blue">if </font>evSorted[i].isControllable<font color="blue"> then </font>&quot;&quot;<font color="blue"> else </font>
                  &quot;not &quot;) + &quot;controllable, &quot;<font color="blue"> else </font>(<font color="blue">if </font>evSorted[i].isStabilizable<font color="blue"> then </font>
                  &quot;&quot;<font color="blue"> else </font>&quot;not &quot;) + &quot;stabilizable, &quot;) + (<font color="blue">if </font>evSorted[i].isStable<font color="blue"> then </font>
                  (<font color="blue">if </font>evSorted[i].isObservable<font color="blue"> then </font>&quot;&quot;<font color="blue"> else </font>&quot;not &quot;) + &quot;observable &quot;<font color="blue"> else </font>
                  (<font color="blue">if </font>evSorted[i].isDetectable<font color="blue"> then </font>&quot;&quot;<font color="blue"> else </font>&quot;not &quot;) + &quot;detectable &quot;)
             + &quot; &lt;/td&gt; &lt;td style=\&quot;text-align:left\&quot;&gt; &amp;nbsp; &quot; + &quot; z[&quot; + <font color="red">String</font>(i)
             + &quot;]&quot; + &quot; contributes to &quot; + xNames2[r_maxIndex1] + &quot; with &quot; +
            <font color="red">String</font>(r_absMax1, format=&quot;.3g&quot;) + &quot; %&lt;br&gt;&quot; + (<font color="blue">if </font>r_two<font color="blue"> then </font>&quot;&amp;nbsp; &quot; + &quot; z[&quot;
             + <font color="red">String</font>(i) + &quot;]&quot; + &quot; contributes to &quot; + xNames2[r_maxIndex2] + &quot; with &quot;
             + <font color="red">String</font>(r_absMax2, format=&quot;.3g&quot;) + &quot; %&quot;<font color="blue"> else </font>&quot;&quot;) + &quot; &lt;/td&gt; &lt;/tr&gt; &quot;,
            fileName);

        <font color="blue">else</font>
          <font color="red">print</font>(&quot;&lt;tr&gt;\n &lt;td style=\&quot;text-align:center\&quot;&gt; &quot; + number + &quot; &lt;/td&gt; &lt;td style=\&quot;text-align:left\&quot;&gt; &amp;nbsp; &quot;
             + <font color="red">String</font>(evSorted[i].ev.re, format=&quot;14.4e&quot;) + &quot; &lt;/td&gt; &lt;td style=\&quot;text-align:left\&quot;&gt; &amp;nbsp; &quot;
             + <font color="red">String</font>(evSorted[i].timeConstant, format=&quot;9.4f&quot;) + &quot; &lt;/td&gt; &lt;td style=\&quot;text-align:left\&quot;&gt; &amp;nbsp; &quot;
             + (<font color="blue">if </font>evSorted[i].isStable<font color="blue"> then </font>&quot;&quot;<font color="blue"> else </font>&quot;not &quot;) + &quot;stable, &quot; + (<font color="blue">if </font>
            evSorted[i].isStable<font color="blue"> then </font>(<font color="blue">if </font>evSorted[i].isControllable<font color="blue"> then </font>&quot;&quot;<font color="blue"> else </font>
                  &quot;not &quot;) + &quot;controllable, &quot;<font color="blue"> else </font>(<font color="blue">if </font>evSorted[i].isStabilizable<font color="blue"> then </font>
                  &quot;&quot;<font color="blue"> else </font>&quot;not &quot;) + &quot;stabilizable, &quot;) + (<font color="blue">if </font>evSorted[i].isStable<font color="blue"> then </font>
                  (<font color="blue">if </font>evSorted[i].isObservable<font color="blue"> then </font>&quot;&quot;<font color="blue"> else </font>&quot;not &quot;) + &quot;observable &quot;<font color="blue"> else </font>
                  (<font color="blue">if </font>evSorted[i].isDetectable<font color="blue"> then </font>&quot;&quot;<font color="blue"> else </font>&quot;not &quot;) + &quot;detectable &quot;)
             + &quot; &lt;/td&gt; &lt;/tr&gt; &quot;, fileName);
        <font color="blue">end if</font>;
        i := j;
      <font color="blue">end while</font>;

      <font color="red">print</font>(&quot;&lt;/table&gt;&lt;br&gt;&lt;br&gt;\n\n&lt;/body&gt;&lt;/html&gt;&quot;, fileName);
    <font color="blue">end </font>printTab1;

    <font color="blue">encapsulated </font><font color="blue">function</font> printTab2
        <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
        <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Strings.html#Modelica.Utilities.Strings"
>Modelica.Utilities.Strings</A>;
        <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
        <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams.print"
>Modelica.Utilities.Streams.print</A>;
        <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Modelica_LinearSystems2.Internal.Eigenvalue</A>;
        <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Eigenvalue</A> evSorted[:];
      <font color="blue">input </font>Integer evIndex[<font color="red">size</font>(evSorted, 1)];
      <font color="blue">input </font>Real r_evec[<font color="red">size</font>(evSorted, 1),<font color="red">size</font>(evSorted, 1)];
      <font color="blue">input </font>Real l_evec[<font color="red">size</font>(evSorted, 1),<font color="red">size</font>(evSorted, 1)];
      <font color="blue">input </font>Integer nReal;
      <font color="blue">input </font>String xNames2[<font color="red">size</font>(evSorted, 1)];
      <font color="blue">input </font>String fileName;
      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.AnalyseOptions"
>Modelica_LinearSystems2.Internal.AnalyseOptions</A> analyseOptions=
          <font color="red">Modelica_LinearSystems2.Internal.AnalyseOptions</font>(
            plotEigenValues=true,
            plotInvariantZeros=true,
            plotStepResponse=true,
            plotFrequencyResponse=true,
            printEigenValues=true,
            printEigenValueProperties=true,
            printInvariantZeros=true,
            printControllability=true,
            printObservability=true,
            headingEigenValues=&quot;Eigenvalues&quot;,
            headingInvariantzeros=&quot;Invariant zeros&quot;,
            headingStepResponse=&quot;Step response&quot;,
            headingFrequencyResponse=&quot;Frequency response&quot;);

      <font color="blue">protected </font>
      Integer nx=<font color="red">size</font>(evSorted, 1);

      Integer i;
      Integer k;
      String number;
      Integer j;

      Real r_abs_evec[nx];
      Real l_abs_evec[nx];
      Integer r_maxIndex1;
      Integer r_maxIndex2;
      Integer l_maxIndex1;
      Integer l_maxIndex2;
      Real r_abs_v_normalized;
      Real l_abs_v_normalized;
      Real r_v;
      Real l_v;
      Real r_absMax1;
      Real r_absMax2;
      Real l_absMax1;
      Real l_absMax2;
      Boolean r_two;
      Boolean l_two;
      Boolean r_first;
      Boolean l_first;

    <font color="blue">algorithm </font>
      i := nReal + 1;
      j := i;
      <font color="blue">while </font>i &lt;= nx<font color="blue"> loop</font>
       <font color="darkgreen">// Build eigenvalue number</font>
        number := <font color="red">String</font>(i) + &quot;/&quot; + <font color="red">String</font>(i + 1);
        number := <font color="red">Strings.repeat</font>(<font color="red">max</font>(0, 7 - <font color="red">Strings.length</font>(number))) + number;
        j := j + 2;

       <font color="darkgreen">// Determine largest value in eigenvector</font>
        k := evIndex[i] <font color="darkgreen">&quot;Index with respect to unsorted eigen values&quot;</font>;

        <font color="blue">for </font>i2<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
          r_abs_evec[i2] := <font color="red">sqrt</font>(r_evec[i2, k]^2 + r_evec[i2, k + 1]^2);
          l_abs_evec[i2] := <font color="red">sqrt</font>(l_evec[i2, k]^2 + l_evec[i2, k + 1]^2);
        <font color="blue">end for</font>;

        r_first := true;
        r_two := false;
        r_absMax1 := 0;
        r_maxIndex1 := 0;
        r_absMax2 := 0;
        r_maxIndex2 := 0;
        r_abs_v_normalized := <font color="red">Modelica.Math.Vectors.norm</font>(r_abs_evec, 1);
        l_first := true;
        l_two := false;
        l_absMax1 := 0;
        l_maxIndex1 := 0;
        l_absMax2 := 0;
        l_maxIndex2 := 0;
        l_abs_v_normalized := <font color="red">Modelica.Math.Vectors.norm</font>(l_abs_evec, 1);

        <font color="blue">for </font>j<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
          r_v := r_abs_evec[j];
          l_v := l_abs_evec[j];

          <font color="blue">if </font>r_first<font color="blue"> then</font>
            r_first := false;
            r_absMax1 := r_v;
            r_maxIndex1 := j;
          <font color="blue">elseif </font><font color="blue">not </font>r_two<font color="blue"> then</font>
            r_two := true;
            <font color="blue">if </font>r_v &lt; r_absMax1<font color="blue"> then</font>
              r_absMax2 := r_v;
              r_maxIndex2 := j;
            <font color="blue">else</font>
              r_absMax2 := r_absMax1;
              r_maxIndex2 := r_maxIndex1;
              r_absMax1 := r_v;
              r_maxIndex1 := j;
            <font color="blue">end if</font>;
          <font color="blue">elseif </font>r_v &gt; r_absMax1<font color="blue"> then</font>
            r_absMax2 := r_absMax1;
            r_maxIndex2 := r_maxIndex1;
            r_absMax1 := r_v;
            r_maxIndex1 := j;
          <font color="blue">elseif </font>r_v &gt; r_absMax2<font color="blue"> then</font>
            r_absMax2 := r_v;
            r_maxIndex2 := j;
          <font color="blue">end if</font>;

          <font color="blue">if </font>l_first<font color="blue"> then</font>
            l_first := false;
            l_absMax1 := l_v;
            l_maxIndex1 := j;
          <font color="blue">elseif </font><font color="blue">not </font>l_two<font color="blue"> then</font>
            l_two := true;
            <font color="blue">if </font>l_v &lt; l_absMax1<font color="blue"> then</font>
              l_absMax2 := l_v;
              l_maxIndex2 := j;
            <font color="blue">else</font>
              l_absMax2 := l_absMax1;
              l_maxIndex2 := l_maxIndex1;
              l_absMax1 := l_v;
              l_maxIndex1 := j;
            <font color="blue">end if</font>;
          <font color="blue">elseif </font>l_v &gt; l_absMax1<font color="blue"> then</font>
            l_absMax2 := l_absMax1;
            l_maxIndex2 := l_maxIndex1;
            l_absMax1 := l_v;
            l_maxIndex1 := j;
          <font color="blue">elseif </font>l_v &gt; l_absMax2<font color="blue"> then</font>
            l_absMax2 := l_v;
            l_maxIndex2 := j;
          <font color="blue">end if</font>;

        <font color="blue">end for</font>;
        r_absMax1 := 100*r_absMax1/r_abs_v_normalized;
        r_absMax2 := 100*r_absMax2/r_abs_v_normalized;
        <font color="blue">if </font>r_absMax2 &lt; 0.05*r_absMax1<font color="blue"> then</font>
          r_two := false;
        <font color="blue">end if</font>;

        l_absMax1 := 100*l_absMax1/l_abs_v_normalized;
        l_absMax2 := 100*l_absMax2/l_abs_v_normalized;
        <font color="blue">if </font>l_absMax2 &lt; 0.05*l_absMax1<font color="blue"> then</font>
          l_two := false;
        <font color="blue">end if</font>;

       <font color="darkgreen">// Print data for one eigen value</font>
        <font color="blue">if </font>analyseOptions.printEigenValueProperties<font color="blue"> then</font>
          <font color="red">print</font>(&quot;&lt;tr&gt;\n &lt;td style=\&quot;text-align:left\&quot;&gt; &quot; + number + &quot; &lt;/td&gt; &lt;td style=\&quot;text-align:left\&quot;&gt; &amp;nbsp; &quot;
             + <font color="red">String</font>(evSorted[i].ev.re, format=&quot;14.4e&quot;) + &quot; &amp;plusmn; &quot; + <font color="red">String</font>(
            evSorted[i].ev.im, format=&quot;12.4e&quot;) + &quot;j&quot; + &quot; &lt;/td&gt; &lt;td style=\&quot;text-align:left\&quot;&gt; &amp;nbsp; &quot;
             + <font color="red">String</font>(evSorted[i].frequency, format=&quot;9.4f&quot;) + &quot; &lt;/td&gt; &lt;td style=\&quot;text-align:left\&quot;&gt; &amp;nbsp; &quot;
             + <font color="red">String</font>(evSorted[i].damping, format=&quot;9.4f&quot;) + &quot; &lt;/td&gt; &lt;td style=\&quot;text-align:left\&quot;&gt; &amp;nbsp; &quot;
             + (<font color="blue">if </font>evSorted[i].isStable<font color="blue"> then </font>&quot;&quot;<font color="blue"> else </font>&quot;not &quot;) + &quot;stable, &quot; + (<font color="blue">if </font>
            evSorted[i].isStable<font color="blue"> then </font>(<font color="blue">if </font>evSorted[i].isControllable<font color="blue"> then </font>&quot;&quot;<font color="blue"> else </font>
                  &quot;not &quot;) + &quot;controllable, &quot;<font color="blue"> else </font>(<font color="blue">if </font>evSorted[i].isStabilizable<font color="blue"> then </font>
                  &quot;&quot;<font color="blue"> else </font>&quot;not &quot;) + &quot;stabilizable, &quot;) + (<font color="blue">if </font>evSorted[i].isStable<font color="blue"> then </font>
                  (<font color="blue">if </font>evSorted[i].isObservable<font color="blue"> then </font>&quot;&quot;<font color="blue"> else </font>&quot;not &quot;) + &quot;observable &quot;<font color="blue"> else </font>
                  (<font color="blue">if </font>evSorted[i].isDetectable<font color="blue"> then </font>&quot;&quot;<font color="blue"> else </font>&quot;not &quot;) + &quot;detectable &quot;)
             + &quot; &lt;/td&gt; &lt;td style=\&quot;text-align:left\&quot;&gt; &amp;nbsp; &quot; + &quot; z[&quot; + number + &quot;]&quot;
             + &quot; contribute to &quot; + xNames2[r_maxIndex1] + &quot; with &quot; + <font color="red">String</font>(
            r_absMax1, format=&quot;.3g&quot;) + &quot; %&lt;br&gt;&quot; + (<font color="blue">if </font>r_two<font color="blue"> then </font>&quot;&amp;nbsp; &quot; + &quot; z[&quot;
             + number + &quot;]&quot; + &quot; contribute to &quot; + xNames2[r_maxIndex2] + &quot; with &quot; +
            <font color="red">String</font>(r_absMax2, format=&quot;.3g&quot;) + &quot; %&quot;<font color="blue"> else </font>&quot;&quot;) + &quot; &lt;/td&gt; &lt;/tr&gt; &quot;,
            fileName);
        <font color="blue">else</font>
          <font color="red">print</font>(&quot;&lt;tr&gt;\n &lt;td style=\&quot;text-align:left\&quot;&gt; &quot; + number + &quot; &lt;/td&gt; &lt;td style=\&quot;text-align:left\&quot;&gt; &amp;nbsp; &quot;
             + <font color="red">String</font>(evSorted[i].ev.re, format=&quot;14.4e&quot;) + &quot; &amp;plusmn; &quot; + <font color="red">String</font>(
            evSorted[i].ev.im, format=&quot;12.4e&quot;) + &quot;j&quot; + &quot; &lt;/td&gt; &lt;td style=\&quot;text-align:left\&quot;&gt; &amp;nbsp; &quot;
             + <font color="red">String</font>(evSorted[i].frequency, format=&quot;9.4f&quot;) + &quot; &lt;/td&gt; &lt;td style=\&quot;text-align:left\&quot;&gt; &amp;nbsp; &quot;
             + <font color="red">String</font>(evSorted[i].damping, format=&quot;9.4f&quot;) + &quot; &lt;/td&gt; &lt;td style=\&quot;text-align:left\&quot;&gt; &amp;nbsp; &quot;
             + (<font color="blue">if </font>evSorted[i].isStable<font color="blue"> then </font>&quot;&quot;<font color="blue"> else </font>&quot;not &quot;) + &quot;stable, &quot; + (<font color="blue">if </font>
            evSorted[i].isStable<font color="blue"> then </font>(<font color="blue">if </font>evSorted[i].isControllable<font color="blue"> then </font>&quot;&quot;<font color="blue"> else </font>
                  &quot;not &quot;) + &quot;controllable, &quot;<font color="blue"> else </font>(<font color="blue">if </font>evSorted[i].isStabilizable<font color="blue"> then </font>
                  &quot;&quot;<font color="blue"> else </font>&quot;not &quot;) + &quot;stabilizable, &quot;) + (<font color="blue">if </font>evSorted[i].isStable<font color="blue"> then </font>
                  (<font color="blue">if </font>evSorted[i].isObservable<font color="blue"> then </font>&quot;&quot;<font color="blue"> else </font>&quot;not &quot;) + &quot;observable &quot;<font color="blue"> else </font>
                  (<font color="blue">if </font>evSorted[i].isDetectable<font color="blue"> then </font>&quot;&quot;<font color="blue"> else </font>&quot;not &quot;) + &quot;detectable &quot;)
             + &quot; &lt;/td&gt; &lt;/tr&gt; &quot;, fileName);
        <font color="blue">end if</font>;
        i := j;
      <font color="blue">end while</font>;

      <font color="red">print</font>(&quot;&lt;/table&gt;&quot;, fileName);
      <font color="red">print</font>(&quot;&lt;/table&gt;&lt;br&gt;&lt;br&gt;\n\n&lt;/body&gt;&lt;/html&gt;&quot;, fileName);
    <font color="blue">end </font>printTab2;

    <font color="blue">encapsulated </font><font color="blue">function</font> printTab3
        <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
        <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Strings.html#Modelica.Utilities.Strings"
>Modelica.Utilities.Strings</A>;
        <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
        <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams.print"
>Modelica.Utilities.Streams.print</A>;
        <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Modelica_LinearSystems2.Internal.Eigenvalue</A>;
        <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Eigenvalue</A> evSorted[:];
      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> evecComplex[:,:];
      <font color="blue">input </font>Integer evIndex[<font color="red">size</font>(evecComplex, 1)];
      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> cev[<font color="red">size</font>(evecComplex, 1)];
      <font color="blue">input </font>Integer nReal;
      <font color="blue">input </font>String xNames2[<font color="red">size</font>(evecComplex, 1)];
      <font color="blue">input </font>String fileName;
      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.AnalyseOptions"
>Modelica_LinearSystems2.Internal.AnalyseOptions</A> analyseOptions=
          <font color="red">Modelica_LinearSystems2.Internal.AnalyseOptions</font>(
            plotEigenValues=true,
            plotInvariantZeros=true,
            plotStepResponse=true,
            plotFrequencyResponse=true,
            printEigenValues=true,
            printEigenValueProperties=true,
            printInvariantZeros=true,
            printControllability=true,
            printObservability=true,
            headingEigenValues=&quot;Eigenvalues&quot;,
            headingInvariantzeros=&quot;Invariant zeros&quot;,
            headingStepResponse=&quot;Step response&quot;,
            headingFrequencyResponse=&quot;Frequency response&quot;);

      <font color="blue">protected </font>
      Integer nx=<font color="red">size</font>(evecComplex, 1);

      Integer maxIndex1;
      Integer maxIndex2;

      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> v_normalized[<font color="red">size</font>(evecComplex, 1)];
      Real abs_v_normalized;
      Real v;
      Real absMax1;
      Real absMax2;
      Boolean two;
      Boolean first;
      Integer j;
      Integer k;
      Integer iw1;
      Integer iw2;
      String number1;
      String number2;
      Real w1;
      Real w2;
      Real d1;
      Real d2;

    <font color="blue">algorithm </font>
      <font color="blue">for </font>i<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
         <font color="darkgreen">// Normalize i-th row of complex eigenvector matrix and determine two largest elements</font>
        v_normalized := <font color="red">Complex.Vectors.normalize</font>(evecComplex[i, :]);
        first := true;
        two := false;
        absMax1 := 0;
        maxIndex1 := 0;
        absMax2 := 0;
        maxIndex2 := 0;
        j := 1;
        abs_v_normalized := <font color="red">Complex.Vectors.norm</font>(v_normalized, 1);
        <font color="blue">while </font>j &lt;= nx<font color="blue"> loop</font>
          <font color="blue">if </font>cev[j].im == 0<font color="blue"> then</font>
            v := <font color="red">abs</font>(v_normalized[j].re);
            k := j;
            j := j + 1;
          <font color="blue">else</font>
            v := 2*<font color="red">Complex.&#39;abs&#39;</font>(v_normalized[j]);
            k := j;
            j := j + 2;
          <font color="blue">end if</font>;

          <font color="blue">if </font>first<font color="blue"> then</font>
            first := false;
            absMax1 := v;
            maxIndex1 := k;
          <font color="blue">elseif </font><font color="blue">not </font>two<font color="blue"> then</font>
            two := true;
            <font color="blue">if </font>v &lt; absMax1<font color="blue"> then</font>
              absMax2 := v;
              maxIndex2 := k;
            <font color="blue">else</font>
              absMax2 := absMax1;
              maxIndex2 := maxIndex1;
              absMax1 := v;
              maxIndex1 := k;
            <font color="blue">end if</font>;
          <font color="blue">elseif </font>v &gt; absMax1<font color="blue"> then</font>
            absMax2 := absMax1;
            maxIndex2 := maxIndex1;
            absMax1 := v;
            maxIndex1 := k;
          <font color="blue">elseif </font>v &gt; absMax2<font color="blue"> then</font>
            absMax2 := v;
            maxIndex2 := k;
          <font color="blue">end if</font>;
        <font color="blue">end while</font>;
        absMax1 := absMax1/abs_v_normalized;
        absMax2 := absMax2/abs_v_normalized;

        <font color="blue">if </font>absMax2 &lt; 0.05*absMax1<font color="blue"> then</font>
          two := false;
        <font color="blue">end if</font>;

         <font color="darkgreen">// Determine frequency and number of corresponding eigenvalue</font>
        (w1,d1) := <font color="red">Complex.frequency</font>(cev[maxIndex1]);
        iw1 := <font color="red">Modelica_LinearSystems2.Math.Vectors.find</font>(maxIndex1, evIndex);
        <font color="blue">if </font>iw1 &lt;= nReal<font color="blue"> then</font>
          number1 := <font color="red">String</font>(iw1);
        <font color="blue">else</font>
          number1 := <font color="red">String</font>(iw1) + &quot;/&quot; + <font color="red">String</font>(iw1 + 1);
        <font color="blue">end if</font>;

        <font color="blue">if </font>two<font color="blue"> then</font>
          (w2,d2) := <font color="red">Complex.frequency</font>(cev[maxIndex2]);
          iw2 := <font color="red">Modelica_LinearSystems2.Math.Vectors.find</font>(maxIndex2, evIndex);
          <font color="blue">if </font>iw2 &lt;= nReal<font color="blue"> then</font>
            number2 := <font color="red">String</font>(iw2);
          <font color="blue">else</font>
            number2 := <font color="red">String</font>(iw2) + &quot;/&quot; + <font color="red">String</font>(iw2 + 1);
          <font color="blue">end if</font>;
        <font color="blue">end if</font>;

        <font color="red">print</font>(&quot;&lt;tr&gt;\n &lt;td style=\&quot;text-align:left\&quot;&gt; &amp;nbsp; &quot; + xNames2[i] + &quot; &lt;/td&gt; &lt;td style=\&quot;text-align:left\&quot;&gt; &amp;nbsp; &quot;
           + &quot; is composed of &quot; + <font color="red">String</font>(100*absMax1, format=&quot;5.1f&quot;) + &quot;% by z[&quot; +
          number1 + &quot;]&quot; + (<font color="blue">if </font>two<font color="blue"> then </font>&quot; &lt;br&gt;&quot; + &quot; &amp;nbsp; &quot; + &quot; is composed of &quot; +
          <font color="red">String</font>(100*absMax2, format=&quot;5.1f&quot;) + &quot;% by z[&quot; + number2 + &quot;]&quot;<font color="blue"> else </font>&quot;&quot;) + &quot; &lt;/td&gt; &lt;td style=\&quot;text-align:center\&quot;&gt; &amp;nbsp; &quot;
           + number1 + (<font color="blue">if </font>two<font color="blue"> then </font>&quot;&lt;br&gt; &amp;nbsp; &quot; + number2<font color="blue"> else </font><font color="red">Strings.repeat</font>(9))
           + &quot; &lt;/td&gt; &lt;td style=\&quot;text-align:center\&quot;&gt; &amp;nbsp; &quot; + (<font color="blue">if </font>iw1 &lt;= nReal<font color="blue"> then </font>
                &quot;---&quot;<font color="blue"> else </font><font color="red">String</font>(w1, format=&quot;9.4f&quot;)) + (<font color="blue">if </font>two<font color="blue"> then </font>&quot;&lt;br&gt; &amp;nbsp; &quot;
           + (<font color="blue">if </font>iw2 &lt;= nReal<font color="blue"> then </font>&quot;---&quot;<font color="blue"> else </font><font color="red">String</font>(w2, format=&quot;9.4f&quot;))<font color="blue"> else </font>
          <font color="red">Strings.repeat</font>(9)) + &quot; &lt;/td&gt; &lt;td style=\&quot;text-align:center\&quot;&gt; &amp;nbsp; &quot; +
          (<font color="blue">if </font>iw1 &lt;= nReal<font color="blue"> then </font>&quot;---&quot;<font color="blue"> else </font><font color="red">String</font>(d1, format=&quot;9.4f&quot;)) + (<font color="blue">if </font>two<font color="blue"> then </font>
                &quot;&lt;br&gt; &amp;nbsp; &quot; + (<font color="blue">if </font>iw2 &lt;= nReal<font color="blue"> then </font>&quot;---&quot;<font color="blue"> else </font><font color="red">String</font>(d2,
          format=&quot;9.4f&quot;))<font color="blue"> else </font>&quot;&quot;) + &quot; &lt;/td&gt; &lt;td style=\&quot;text-align:center\&quot;&gt; &amp;nbsp; &quot;
           + (<font color="blue">if </font>(iw1 &lt;= nReal)<font color="blue"> then </font><font color="red">String</font>(evSorted[i].timeConstant, format=&quot;9.4f&quot;)<font color="blue"> else </font>
                &quot;---&quot;) + (<font color="blue">if </font>two<font color="blue"> then </font>&quot;&lt;br&gt; &amp;nbsp; &quot; + (<font color="blue">if </font>(iw2 &lt;= nReal<font color="blue"> and </font><font color="red">abs</font>(
          cev[maxIndex2].re) &gt; 1e-10)<font color="blue"> then </font><font color="red">String</font>(1/<font color="red">abs</font>(cev[maxIndex2].re),
          format=&quot;9.4f&quot;)<font color="blue"> else </font>&quot;---&quot;)<font color="blue"> else </font>&quot;&quot;) + &quot; &lt;/td&gt; &lt;/tr&gt; &quot;, fileName);

      <font color="blue">end for</font>;
      <font color="red">print</font>(&quot;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;&quot;, fileName);

    <font color="blue">end </font>printTab3;

    <font color="blue">encapsulated </font><font color="blue">function</font> printTab4
        <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
        <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Strings.html#Modelica.Utilities.Strings"
>Modelica.Utilities.Strings</A>;
        <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
        <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams.print"
>Modelica.Utilities.Streams.print</A>;
        <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Modelica_LinearSystems2.Internal.Eigenvalue</A>;
        <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> systemZeros[:];
      <font color="blue">input </font>Integer evIndex[<font color="red">size</font>(systemZeros, 1)];
      <font color="blue">input </font>Integer nReal;
      <font color="blue">input </font>String fileName;
      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.AnalyseOptions"
>Modelica_LinearSystems2.Internal.AnalyseOptions</A> analyseOptions=
          <font color="red">Modelica_LinearSystems2.Internal.AnalyseOptions</font>(
            plotEigenValues=true,
            plotInvariantZeros=true,
            plotStepResponse=true,
            plotFrequencyResponse=true,
            printEigenValues=true,
            printEigenValueProperties=true,
            printInvariantZeros=true,
            printControllability=true,
            printObservability=true,
            headingEigenValues=&quot;Eigenvalues&quot;,
            headingInvariantzeros=&quot;Invariant zeros&quot;,
            headingStepResponse=&quot;Step response&quot;,
            headingFrequencyResponse=&quot;Frequency response&quot;);

      <font color="blue">protected </font>
      Integer nz=<font color="red">size</font>(systemZeros, 1);

      String number;
      Real timeConstant;
      Real freq;
      Real damp;

    <font color="blue">algorithm </font>
      <font color="blue">for </font>i<font color="blue"> in </font>1:nReal<font color="blue"> loop</font>
      <font color="darkgreen">// Build eigenvalue number</font>

        number := <font color="red">String</font>(
            i,
            minimumLength=7,
            leftJustified=false);
        timeConstant := <font color="blue">if </font><font color="red">abs</font>(systemZeros[i].re) &gt; 10*Modelica.Constants.eps<font color="blue"> then </font>
                1/<font color="red">abs</font>(systemZeros[i].re)<font color="blue"> else </font>1/(10*Modelica.Constants.eps);

        <font color="red">print</font>(&quot;&lt;tr&gt;\n &lt;td style=\&quot;text-align:left\&quot;&gt; &amp;nbsp; &quot; + number + &quot; &lt;/td&gt; &lt;td&gt; &amp;nbsp; &quot;
           + <font color="red">String</font>(systemZeros[i].re, format=&quot;14.4e&quot;) + &quot; &lt;/td&gt; &lt;td&gt; &amp;nbsp; &quot; +
          <font color="red">String</font>(timeConstant, format=&quot;9.4f&quot;) + &quot; &lt;/td&gt; &lt;td style=\&quot;text-align:center\&quot;&gt; &amp;nbsp; &quot;
           + &quot;---&quot; + &quot; &lt;/td&gt; &lt;td style=\&quot;text-align:center\&quot;&gt; &amp;nbsp; &quot; + &quot;---&quot; + &quot; &lt;/td&gt; &lt;/tr&gt; &quot;,
          fileName);

      <font color="blue">end for</font>;

      <font color="blue">for </font>i<font color="blue"> in </font>nReal + 1:2:nz<font color="blue"> loop</font>
        number := <font color="red">String</font>(i) + &quot;/&quot; + <font color="red">String</font>(i + 1);
        number := <font color="red">Strings.repeat</font>(<font color="red">max</font>(0, 7 - <font color="red">Strings.length</font>(number))) + number;

       <font color="darkgreen">// Determine frequency and number of corresponding zero</font>
        (freq,damp) := <font color="red">Complex.frequency</font>(systemZeros[i]);

        <font color="red">print</font>(&quot;&lt;tr&gt;\n &lt;td style=\&quot;text-align:left\&quot;&gt; &amp;nbsp; &quot; + number + &quot; &lt;/td&gt; &lt;td style=\&quot;text-align:left\&quot;&gt; &amp;nbsp; &quot;
           + <font color="red">String</font>(systemZeros[i].re, format=&quot;14.4e&quot;) + &quot; &amp;plusmn; &quot; + <font color="red">String</font>(
          systemZeros[i].im, format=&quot;12.4e&quot;) + &quot;j&quot; + &quot; &lt;/td&gt; &lt;td style=\&quot;text-align:center\&quot;&gt; &amp;nbsp; &quot;
           + &quot;---&quot; + &quot; &lt;/td&gt; &lt;td style=\&quot;text-align:left\&quot;&gt; &amp;nbsp; &quot; + <font color="red">String</font>(
          freq, format=&quot;9.4f&quot;) + &quot; &lt;/td&gt; &lt;td style=\&quot;text-align:left\&quot;&gt; &amp;nbsp; &quot; +
          <font color="red">String</font>(damp, format=&quot;9.4f&quot;) + &quot; &lt;/td&gt; &lt;/tr&gt; &quot;, fileName);

      <font color="blue">end for</font>;

      <font color="red">print</font>(&quot;&lt;/table&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&quot;, fileName);
    <font color="blue">end </font>printTab4;
<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>analysis</textblock>;

 <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Analysis.timeResponse"><font color="blue">encapsulated </font><font color="blue">function</font> timeResponse <font color="darkgreen">
      &quot;Calculate the time response of a state space system&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.TimeResponse"
>Modelica_LinearSystems2.Types.TimeResponse</A>;
 <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.TimeResponse"
>Modelica_LinearSystems2.Types.TimeResponse</A> response=Modelica_LinearSystems2.Types.TimeResponse.Step;
  <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.timeResponseMask2"
>Modelica_LinearSystems2.Internal.timeResponseMask2</A>(<font color="blue">redeclare </font>Real y[:,<font color="red">size</font>(sc.C,1),<font color="blue">if </font>response == TimeResponse.Initial<font color="blue"> then </font>1<font color="blue"> else </font><font color="red">size</font>(sc.B,2)], <font color="blue">redeclare </font>
          Real x_continuous[
                         :,<font color="red">size</font>(sc.A,1),<font color="blue">if </font>response == TimeResponse.Initial<font color="blue"> then </font>1<font color="blue"> else </font><font color="red">size</font>(sc.B,2)]);<font color="darkgreen">     // Input/Output declarations of time response functions</font>

  <font color="blue">input </font>Real x0[<font color="red">size</font>(sc.A, 1)]=<font color="red">zeros</font>(<font color="red">size</font>(sc.A, 1)) <font color="darkgreen">&quot;Initial state vector&quot;</font>;

    <font color="blue">protected </font>
  Real dtVar;
  Real tSpanVar;
  Integer samples;
  Real u[:,<font color="red">size</font>(sc.B, 2)];
  Real new_x[<font color="red">size</font>(sc.A, 1),1];
  Real x[<font color="red">size</font>(sc.A, 1),1]=<font color="red">zeros</font>(<font color="red">size</font>(sc.A, 1), 1);
  <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.DiscreteStateSpace"
>Modelica_LinearSystems2.DiscreteStateSpace</A> sd(
    <font color="blue">redeclare </font>Real A[<font color="red">size</font>(sc.A, 1),<font color="red">size</font>(sc.A, 2)],
    <font color="blue">redeclare </font>Real B[<font color="red">size</font>(sc.B, 1),<font color="red">size</font>(sc.B, 2)],
    <font color="blue">redeclare </font>Real C[<font color="red">size</font>(sc.C, 1),<font color="red">size</font>(sc.C, 2)],
    <font color="blue">redeclare </font>Real D[<font color="red">size</font>(sc.D, 1),<font color="red">size</font>(sc.D, 2)],
    <font color="blue">redeclare </font>Real B2[<font color="red">size</font>(sc.B, 1),<font color="red">size</font>(sc.B, 2)]);
  Real i1;
  Real i2;

 <font color="blue">algorithm </font>
      <font color="darkgreen">// set sample time and simulation time span</font>
  <font color="blue">if </font>(dt == 0<font color="blue"> and </font>tSpan == 0)<font color="blue"> then</font>
    (dtVar,tSpanVar) :=<font color="red"> Modelica_LinearSystems2.Internal.timeResponseSamples</font>(
      sc);
  <font color="blue">elseif </font>(dt == 0<font color="blue"> and </font>tSpan &lt;&gt; 0)<font color="blue"> then</font>
    dtVar :=<font color="red"> Modelica_LinearSystems2.Internal.timeResponseSamples</font>(sc);
    tSpanVar := tSpan;
  <font color="blue">elseif </font>(dt &lt;&gt; 0<font color="blue"> and </font>tSpan == 0)<font color="blue"> then</font>
    (,tSpanVar) :=<font color="red"> Modelica_LinearSystems2.Internal.timeResponseSamples</font>(sc);
    dtVar := dt;
  <font color="blue">else</font>
    dtVar := dt;
    tSpanVar := tSpan;
  <font color="blue">end if</font>;

  samples :=<font color="red"> integer</font>(tSpanVar/dtVar + 1);
  t := 0:dtVar:tSpanVar;
  u :=<font color="red"> zeros</font>(samples,<font color="red"> size</font>(sc.B, 2));
  y := <font color="blue">if </font>response == TimeResponse.Initial<font color="blue"> then </font><font color="red">zeros</font>(samples,<font color="red"> size</font>(sc.C, 1),1)<font color="blue"> else </font><font color="red">zeros</font>(samples,<font color="red"> size</font>(sc.C, 1),<font color="red">size</font>(sc.B, 2));
  x_continuous :=  <font color="blue">if </font>response == TimeResponse.Initial<font color="blue"> then </font><font color="red">zeros</font>(samples,<font color="red"> size</font>(sc.A, 1),  1)<font color="blue"> else </font><font color="red">zeros</font>(samples,<font color="red"> size</font>(sc.A, 1),<font color="red">  size</font>(sc.B, 2));

 <font color="blue">if </font>response == TimeResponse.Initial<font color="blue"> then</font>
      sd :=<font color="red"> Modelica_LinearSystems2.DiscreteStateSpace</font>(
          sc,
          dtVar,
          Modelica_LinearSystems2.Types.Method.Trapezoidal);
    (y[:, :, 1],x_continuous[:, :, 1]) :=
      <font color="red">Modelica_LinearSystems2.DiscreteStateSpace.initialResponse</font>(sd, x0, samples);
    <font color="blue">else</font>

  <font color="blue">for </font>i1<font color="blue"> in </font>1:<font color="red">size</font>(sc.B, 2)<font color="blue"> loop</font>
        <font color="darkgreen">// Loop over inputs</font>

        <font color="darkgreen">// time response to plot</font>
    <font color="blue">if </font>response == TimeResponse.Impulse<font color="blue"> then</font>
      u[1, :] :=<font color="red"> zeros</font>(<font color="red">size</font>(sc.B, 2));
      u[1, i1] := 1;
      sd :=<font color="red"> Modelica_LinearSystems2.DiscreteStateSpace</font>(
          sc,
          dtVar,
          Modelica_LinearSystems2.Types.Method.ImpulseExact);
    <font color="blue">elseif </font>response == TimeResponse.Step<font color="blue"> then</font>
      u[:, :] :=<font color="red"> zeros</font>(samples,<font color="red"> size</font>(sc.B, 2));
      u[:, i1] :=<font color="red"> ones</font>(samples);
      sd :=<font color="red"> Modelica_LinearSystems2.DiscreteStateSpace</font>(
          sc,
          dtVar,
          Modelica_LinearSystems2.Types.Method.StepExact);
    <font color="blue">elseif </font>response == TimeResponse.Ramp<font color="blue"> then</font>
      u[:, :] :=<font color="red"> zeros</font>(samples,<font color="red"> size</font>(sc.B, 2));
      u[:, i1] := 0:dtVar:tSpanVar;
      sd :=<font color="red"> Modelica_LinearSystems2.DiscreteStateSpace</font>(
          sc,
          dtVar,
          Modelica_LinearSystems2.Types.Method.RampExact);
 <font color="darkgreen">//    elseif response == TimeResponse.Initial then</font>
 <font color="darkgreen">//      u[:, :] := zeros(samples, size(sc.B, 2));</font>
 <font color="darkgreen">//      sd := Modelica_LinearSystems2.DiscreteStateSpace(</font>
 <font color="darkgreen">//          sc,</font>
 <font color="darkgreen">//          dtVar,</font>
 <font color="darkgreen">//          Modelica_LinearSystems2.Types.Method.Trapezoidal);</font>
    <font color="blue">else</font>
      <font color="red">assert</font>(false, &quot;Argument response (= &quot; +<font color="red"> String</font>(response) +
        &quot;) of \&quot;Time response to plot\&quot; is wrong.&quot;);
    <font color="blue">end if</font>;
    (y[:, :, i1],x_continuous[:, :, i1]) :=
      <font color="red">Modelica_LinearSystems2.DiscreteStateSpace.timeResponse</font>(
        sd,
        u,
        x0);

  <font color="blue">end for</font>;
 <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false"> <font color="blue">end </font>timeResponse</textblock>;

<textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Analysis.impulseResponse"><font color="blue">encapsulated </font><font color="blue">function</font> impulseResponse <font color="darkgreen">
      &quot;Calculate the impulse time response of a state space system&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;

    <font color="darkgreen">// Input/Output declarations of time response functions:</font>
  <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.timeResponseMask2"
>Modelica_LinearSystems2.Internal.timeResponseMask2</A>;

<font color="blue">algorithm </font>
  (y,t,x_continuous) :=<font color="red"> Modelica_LinearSystems2.StateSpace.Analysis.timeResponse</font>(
      sc=sc,
      dt=dt,
      tSpan=tSpan,
      response=Modelica_LinearSystems2.Types.TimeResponse.Impulse,
      x0=<font color="red">zeros</font>(<font color="red">size</font>(sc.A, 1)));

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>impulseResponse</textblock>;

<textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Analysis.stepResponse"><font color="blue">encapsulated </font><font color="blue">function</font> stepResponse <font color="darkgreen">
      &quot;Calculate the step time response of a state space system&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;

    <font color="darkgreen">// Input/Output declarations of time response functions:</font>
  <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.timeResponseMask2"
>Modelica_LinearSystems2.Internal.timeResponseMask2</A>;

<font color="blue">algorithm </font>
  (y,t,x_continuous) :=<font color="red"> Modelica_LinearSystems2.StateSpace.Analysis.timeResponse</font>(
      sc=sc,
      dt=dt,
      tSpan=tSpan,
      response=Modelica_LinearSystems2.Types.TimeResponse.Step,
      x0=<font color="red">zeros</font>(<font color="red">size</font>(sc.A, 1)));

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>stepResponse</textblock>;

<textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Analysis.rampResponse"><font color="blue">encapsulated </font><font color="blue">function</font> rampResponse <font color="darkgreen">
      &quot;Calculate the ramp time response of a state space system&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;

    <font color="darkgreen">// Input/Output declarations of time response functions:</font>
  <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.timeResponseMask2"
>Modelica_LinearSystems2.Internal.timeResponseMask2</A>;

<font color="blue">algorithm </font>
  (y,t,x_continuous) :=<font color="red"> Modelica_LinearSystems2.StateSpace.Analysis.timeResponse</font>(
      sc=sc,
      dt=dt,
      tSpan=tSpan,
      response=Modelica_LinearSystems2.Types.TimeResponse.Ramp,
      x0=<font color="red">zeros</font>(<font color="red">size</font>(sc.A, 1)));

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>rampResponse</textblock>;

<textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Analysis.initialResponse"><font color="blue">encapsulated </font><font color="blue">function</font> initialResponse <font color="darkgreen">
      &quot;Calculate the time response of a state space system for given initial condition and zero inputs&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;

  <font color="blue">input </font>Real x0[:]=<font color="red">fill</font>(0,0) <font color="darkgreen">&quot;Initial state vector&quot;</font>;

    <font color="darkgreen">// Input/Output declarations of time response functions:</font>
  <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.timeResponseMask2"
>Modelica_LinearSystems2.Internal.timeResponseMask2</A>(<font color="blue">redeclare </font>Real y[:,<font color="red">size</font>(sc.C,1),1], <font color="blue">redeclare </font>
          Real x_continuous[
                        :,<font color="red">size</font>(sc.A,1),1]);

<font color="blue">algorithm </font>
  (y,t,x_continuous) :=<font color="red"> Modelica_LinearSystems2.StateSpace.Analysis.timeResponse</font>(
      sc=sc,
      dt=dt,
      tSpan=tSpan,
      response=Modelica_LinearSystems2.Types.TimeResponse.Initial,
      x0=x0);

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>initialResponse</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Analysis.numeratorDegree"><font color="blue">encapsulated </font><font color="blue">function</font> numeratorDegree <font color="darkgreen">
      &quot;Return numerator degree of the corresponding transfer function&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Modelica_LinearSystems2.Math.Polynomial</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A> ss;
      <font color="blue">output </font>Integer result;

    <font color="blue">protected </font>
      <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A> tf= <font color="blue">if </font><font color="red">StateSpace.Internal.isSISO</font>(ss)<font color="blue"> then </font><font color="red">StateSpace.Conversion.toTransferFunction</font>(ss)<font color="blue"> else </font><font color="red">TransferFunction</font>(1);

  <font color="blue">algorithm </font>
    <font color="red">assert</font>(<font color="red">StateSpace.Internal.isSISO</font>(ss),&quot;System must be SISO but is &quot;+ <font color="red">String</font>(<font color="red">size</font>(ss.B,2)) +&quot;-by-&quot; +<font color="red">String</font>(<font color="red">size</font>(ss.C,1)) +&quot; system&quot;);
   result := <font color="red">size</font>(tf.n,1)-1;

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>numeratorDegree</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Analysis.denominatorDegree"><font color="blue">encapsulated </font><font color="blue">function</font> denominatorDegree <font color="darkgreen">
      &quot;Return denominator degree of the corresponding transfer function&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Modelica_LinearSystems2.Math.Polynomial</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A> ss;
    <font color="blue">output </font>Integer result;
    <font color="blue">protected </font>
    <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A> tf= <font color="blue">if </font><font color="red">StateSpace.Internal.isSISO</font>(ss)<font color="blue"> then </font><font color="red">StateSpace.Conversion.toTransferFunction</font>(ss)<font color="blue"> else </font><font color="red">TransferFunction</font>(1);

  <font color="blue">algorithm </font>
    <font color="red">assert</font>(<font color="red">StateSpace.Internal.isSISO</font>(ss),&quot;System must be SISO but is &quot;+ <font color="red">String</font>(<font color="red">size</font>(ss.B,2)) +&quot;-by-&quot; +<font color="red">String</font>(<font color="red">size</font>(ss.C,1)) +&quot; system&quot;);
  result := <font color="red">size</font>(tf.d,1)-1;

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>denominatorDegree</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Analysis.evaluate"><font color="blue">encapsulated </font><font color="blue">function</font> evaluate <font color="darkgreen">
      &quot;Evaluate a the corresponding transfer function at a given (complex) value of s&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Modelica_LinearSystems2.Math.Polynomial</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;
    <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> s <font color="darkgreen">&quot;Value of s where tf shall be evaluated&quot;</font>;
    <font color="blue">input </font>Real den_min=0 <font color="darkgreen">&quot;|denominator(s)| is limited by den_min&quot;</font>;
    <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> result <font color="darkgreen">&quot;= tf(s)&quot;</font>;

    <font color="blue">protected </font>
    Boolean issiso=<font color="red">StateSpace.Internal.isSISO</font>(ss);
    <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf= <font color="blue">if </font>issiso<font color="blue"> then </font><font color="red">StateSpace.Conversion.toTransferFunction</font>(ss)<font color="blue"> else </font><font color="red">TransferFunction</font>(1);
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> j=<font color="red">Modelica_LinearSystems2.Math.Complex.j</font>();
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> den=<font color="red">Polynomial.evaluateComplex</font>(<font color="red">Polynomial</font>(tf.d), s);
    Real abs_den=<font color="red">Complex.&#39;abs&#39;</font>(den);
  <font color="blue">algorithm </font>
    <font color="red">assert</font>(issiso,&quot;System must be SISO but is &quot;+ <font color="red">String</font>(<font color="red">size</font>(ss.B,2)) +&quot;-by-&quot; +<font color="red">String</font>(<font color="red">size</font>(ss.C,1)) +&quot; system&quot;);
    den := <font color="blue">if </font>abs_den &gt;= den_min<font color="blue"> then </font>den<font color="blue"> else </font>-abs_den + 0*j;
    result := <font color="red">Polynomial.evaluateComplex</font>(<font color="red">Polynomial</font>(tf.n), s)/den;

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>evaluate</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Analysis.zerosAndPoles"><font color="blue">encapsulated </font><font color="blue">function</font> zerosAndPoles <font color="darkgreen">
      &quot;Calculate zeros and poles of the TransferFunction corresponding to a state space representation&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Modelica_LinearSystems2.Math.Polynomial</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;

    <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> z[:] <font color="darkgreen">&quot;Zeros (Complex vector of numerator zeros)&quot;</font>;
    <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> p[:] <font color="darkgreen">&quot;Poles (Complex vector of denominator zeros)&quot;</font>;
    <font color="blue">output </font>Real k <font color="darkgreen">
        &quot;Constant multiplied with transfer function that is factorized with zeros and poles&quot;</font>;

    <font color="blue">protected </font>
    <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf=<font color="red">StateSpace.Conversion.toTransferFunction</font>(ss);
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Polynomial</A> pn;
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Polynomial</A> pd;
    <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf2;
    Real r;
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> s;
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> y1;
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> y2;
  <font color="blue">algorithm </font>

    z:=<font color="red">Polynomial.roots</font>(<font color="red">Polynomial</font>(tf.n));
    p:=<font color="red">Polynomial.roots</font>(<font color="red">Polynomial</font>(tf.d));
    pn:=<font color="red">Polynomial</font>(z);
    pd:=<font color="red">Polynomial</font>(p);
    tf2:=<font color="red">TransferFunction</font>(pn, pd);
    <font color="darkgreen">// Determine an s-value that is neither a zero nor a pole</font>
    r := 1.0;
    <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(z, 1)<font color="blue"> loop</font>
      r := <font color="red">max</font>(r, <font color="red">abs</font>(z[i].re));
    <font color="blue">end for</font>;
    <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(p, 1)<font color="blue"> loop</font>
      r := <font color="red">max</font>(r, <font color="red">abs</font>(p[i].re));
    <font color="blue">end for</font>;
    r := 2*r;
    s := <font color="red">Complex</font>(r, 0);

    <font color="darkgreen">// Evaluate both tf and tf2 and determine k from the quotient</font>
    y1 := <font color="red">TransferFunction.Analysis.evaluate</font>(tf, s);
    y2 := <font color="red">TransferFunction.Analysis.evaluate</font>(tf2, s);
    k := y1.re/y2.re;
<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>zerosAndPoles</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Analysis.eigenValues"><font color="blue">encapsulated </font><font color="blue">function</font> eigenValues <font color="darkgreen">
      &quot;Calculate the eigenvalues of a linear state space system and write them in a complex vector&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;state space system&quot;</font>;
    <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> eigvalues[<font color="red">size</font>(ss.A, 1)]=<font color="red">Complex.eigenValues</font>(ss.A) <font color="darkgreen">
        &quot;eigen values of the system&quot;</font>;
  <font color="blue">algorithm </font>

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>eigenValues</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Analysis.eigenVectors"><font color="blue">encapsulated </font><font color="blue">function</font> eigenVectors <font color="darkgreen">
      &quot;Calculate the rigth eigenvectors of a linear state space system and write them columnwise in a matrix. Optionally, the eigenvalues are computed&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;state space system&quot;</font>;
    <font color="blue">input </font>Boolean onlyEigenvectors=true;
    <font color="blue">output </font>Real eigvec[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)] <font color="darkgreen">
        &quot;eigen values of the system&quot;</font>;
    <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> eigval[<font color="red">size</font>(ss.A, 1)]=<font color="red">fill</font>(<font color="red">Complex</font>(0), <font color="red">size</font>(ss.A, 1)) <font color="darkgreen">
        &quot;eigen values of the system&quot;</font>;
    <font color="blue">protected </font>
    Integer info;
    Real eigvalRe[<font color="red">size</font>(ss.A, 1)]=<font color="red">fill</font>(0, <font color="red">size</font>(ss.A, 1));
    Real eigvalIm[<font color="red">size</font>(ss.A, 1)]=<font color="red">fill</font>(0, <font color="red">size</font>(ss.A, 1));

  <font color="blue">algorithm </font>
    <font color="blue">if </font><font color="red">size</font>(ss.A, 1) &gt; 0<font color="blue"> then</font>
      <font color="blue">if </font>onlyEigenvectors<font color="blue"> then</font>
        (,,eigvec,info) := <font color="red">LAPACK.dgeev</font>(ss.A);
      <font color="blue">else</font>
        (eigvalRe,eigvalIm,eigvec,info) := <font color="red">LAPACK.dgeev</font>(ss.A);
        <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(ss.A, 1)<font color="blue"> loop</font>
          eigval[i].re := eigvalRe[i];
          eigval[i].im := eigvalIm[i];
        <font color="blue">end for</font>;
      <font color="blue">end if</font>;

      <font color="red">assert</font>(info == 0, &quot;Calculating the eigen values with function
\&quot;StateSpace.Analysis.eigenVectors\&quot; is not possible, since the
numerical algorithm does not converge.&quot;);
    <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>eigenVectors</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Analysis.invariantZeros"><font color="blue">encapsulated </font><font color="blue">function</font> invariantZeros <font color="darkgreen">
      &quot;Compute invariant zeros of linear state space system&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;Linear system in state space form&quot;</font>;

    <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> Zeros[:] <font color="darkgreen">
        &quot;Finite, invariant zeros of ss; size(Zeros,1) &lt;= size(ss.A,1)&quot;</font>;

    <font color="blue">protected </font>
    Integer n=10;
    Integer m;
    Integer p;
    Real Ar[:,:];
    Real Br[:,:];
    Real Cr[:,:];
    Real Dr[:,:];

    Real Af[:,:];
    Real Bf[:,:];
    Real AfBf[:,:];

    Real V2[:,:];
    Real Vf[:,:];
    Real R[:,:];

    Integer na;
   Real alphaReal[:];
    Real alphaImag[:];
    Real beta[:];
    Integer info;
    Real beta_small=100*Modelica.Constants.eps;
    Real normB=<font color="red">max</font>(<font color="red">Modelica.Math.Matrices.norm</font>(ss.B, p=1),beta_small);
    Real normA=<font color="red">max</font>(<font color="red">Modelica.Math.Matrices.norm</font>(ss.A, p=1),beta_small);

  <font color="blue">algorithm </font>
    <font color="blue">if </font><font color="red">min</font>(<font color="red">size</font>(ss.B)) == 0<font color="blue"> or </font><font color="red">min</font>(<font color="red">size</font>(ss.C)) == 0<font color="blue"> then</font>
      Zeros := <font color="red">fill</font>(<font color="red">Complex</font>(0), 0);
    <font color="blue">else</font>
      (Ar,Br,Cr,Dr,n,m,p) := <font color="red">StateSpace.Internal.reduceRosenbrock</font>(ss.A, ss.B, ss.C, ss.D);
      <font color="blue">if </font>n &gt; 0<font color="blue"> then</font>
        (Ar,Br,Cr,Dr,n,m,p) := <font color="red">StateSpace.Internal.reduceRosenbrock</font>(<font color="red">transpose</font>(Ar), <font color="red">transpose</font>(Cr), <font color="red">transpose</font>(Br), <font color="red">transpose</font>(Dr));
      <font color="blue">end if</font>;
      <font color="blue">if </font>n == 0<font color="blue"> then</font>
        Zeros := <font color="red">fill</font>(<font color="red">Complex</font>(0), 0);
      <font color="blue">else</font>

        (,R,,V2) := <font color="red">Matrices.QR</font>(<font color="red">Matrices.fliplr</font>(<font color="red">transpose</font>([Cr,Dr])));
        Vf := <font color="red">Matrices.fliplr</font>(V2);
        AfBf := [Ar,Br]*Vf;
        Af := AfBf[:, 1:<font color="red">size</font>(Ar, 2)];
        Bf := Vf[1:<font color="red">size</font>(Ar, 1), 1:<font color="red">size</font>(Ar, 2)];

        (alphaReal,alphaImag,beta,,,info) := <font color="red">LAPACK.dggev</font>(Af, Bf, n);
        <font color="red">assert</font>(info == 0, &quot;Failed to compute invariant zeros with function invariantZeros(..)&quot;);

        Zeros := <font color="red">fill</font>(<font color="red">Complex</font>(0), <font color="red">size</font>(beta, 1));

  <font color="darkgreen">// If beta[i] is zero, then zero i is infinite.</font>
        <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(beta, 1)<font color="blue"> loop</font>
          <font color="blue">if </font>beta[i] &gt;= normB*1e-6<font color="blue"> then</font>
       <font color="darkgreen">// finite eigenvalue</font>
            Zeros[i].re := <font color="blue">if </font><font color="red">abs</font>(alphaReal[i]) &gt;= normB*1e-12<font color="blue"> then </font>alphaReal[i]/
              beta[i]<font color="blue"> else </font>0;
            Zeros[i].im := <font color="blue">if </font><font color="red">abs</font>(alphaImag[i]) &gt;= normB*1e-12<font color="blue"> then </font>alphaImag[i]/
              beta[i]<font color="blue"> else </font>0;
          <font color="blue">end if</font>;
        <font color="blue">end for</font>;

      <font color="blue">end if</font>;
    <font color="blue">end if</font>;
<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>invariantZeros</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Analysis.isControllable"><font color="blue">encapsulated </font><font color="blue">function</font> isControllable <font color="darkgreen">
      &quot;Check controllability of a state space system&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;
    <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.Method"
>Modelica_LinearSystems2.Types.Method</A> method=Modelica_LinearSystems2.Types.StaircaseMethod.SVD;

    <font color="blue">output </font>Boolean controllable;
  <font color="blue">algorithm </font>

    controllable := <font color="blue">if </font><font color="red">StateSpace.Internal.isSISO</font>(ss)<font color="blue"> then </font>
      <font color="red">StateSpace.Internal.isControllableSISO</font>(ss)<font color="blue"> else </font><font color="red">StateSpace.Internal.isControllableMIMO</font>(ss,method);

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>isControllable</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Analysis.isObservable"><font color="blue">encapsulated </font><font color="blue">function</font> isObservable <font color="darkgreen">
      &quot;Check observability of a state space system&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;
    <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.StaircaseMethod"
>Modelica_LinearSystems2.Types.StaircaseMethod</A> method=
        Modelica_LinearSystems2.Types.StaircaseMethod.SVD;

    <font color="blue">output </font>Boolean observable;
  <font color="blue">algorithm </font>

    observable := <font color="blue">if </font><font color="red">StateSpace.Internal.isSISO</font>(ss)<font color="blue"> then </font>
      <font color="red">StateSpace.Internal.isObservableSISO</font>(ss)<font color="blue"> else </font>
      <font color="red">StateSpace.Internal.isObservableMIMO</font>(ss, method);

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>isObservable</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Analysis.isStabilizable"><font color="blue">encapsulated </font><font color="blue">function</font> isStabilizable <font color="darkgreen">
      &quot;Check stabilizability of a state space system&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;

    <font color="blue">output </font>Boolean stabilizable;

  <font color="blue">algorithm </font>
    <font color="blue">if </font><font color="red">StateSpace.Internal.isSISO</font>(ss)<font color="blue"> then</font>
      stabilizable := <font color="red">StateSpace.Internal.isStabilizableSISO</font>(ss);
    <font color="blue">else</font>
      stabilizable := <font color="red">StateSpace.Internal.isStabilizableMIMO</font>(ss);
    <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>isStabilizable</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Analysis.isDetectable"><font color="blue">encapsulated </font><font color="blue">function</font> isDetectable <font color="darkgreen">
      &quot;Check detectability of a state space system&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;

    <font color="blue">output </font>Boolean detectable;

  <font color="blue">algorithm </font>
   <font color="blue">if </font><font color="red">StateSpace.Internal.isSISO</font>(ss)<font color="blue"> then</font>
    detectable := <font color="red">StateSpace.Internal.isDetectableSISO</font>(ss);
    <font color="blue">else</font>
     detectable := <font color="red">StateSpace.Internal.isDetectableMIMO</font>(ss);
     <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>isDetectable</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Analysis.controllabilityMatrix"><font color="blue">encapsulated </font><font color="blue">function</font> controllabilityMatrix <font color="darkgreen">
      &quot;Compute the controllability matrix [B, A*B, ..., A^(n-1)*B] of a state space system&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;
    <font color="blue">output </font>Real cm[<font color="red">size</font>(ss.B, 1),<font color="red">size</font>(ss.A, 2)*<font color="red">size</font>(ss.B, 2)];

  <font color="blue">algorithm </font>
    <font color="blue">if </font><font color="red">size</font>(ss.A, 2) == 0<font color="blue"> then</font>
      cm := <font color="red">fill</font>(
          0,
          <font color="red">size</font>(ss.B, 1),
          0);
    <font color="blue">else</font>
      cm[:, 1:<font color="red">size</font>(ss.B, 2)] := ss.B;

      <font color="blue">for </font>i<font color="blue"> in </font>2:<font color="red">size</font>(ss.A, 1)<font color="blue"> loop</font>
        cm[:, ((i - 1)*<font color="red">size</font>(ss.B, 2) + 1):(i*<font color="red">size</font>(ss.B, 2))] := ss.A*cm[:, ((i
           - 2)*<font color="red">size</font>(ss.B, 2) + 1):((i - 1)*<font color="red">size</font>(ss.B, 2))];
      <font color="blue">end for</font>;
    <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>controllabilityMatrix</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Analysis.observabilityMatrix"><font color="blue">encapsulated </font><font color="blue">function</font> observabilityMatrix <font color="darkgreen">
      &quot;Compute the observability matrix of a state space system&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;
    <font color="blue">output </font>Real om[<font color="red">size</font>(ss.A, 1)*<font color="red">size</font>(ss.C, 1),<font color="red">size</font>(ss.C, 2)];

  <font color="blue">algorithm </font>
    <font color="blue">if </font><font color="red">size</font>(ss.A, 1) == 0<font color="blue"> then</font>
      om := <font color="red">fill</font>(
          0,
          0,
          <font color="red">size</font>(ss.C, 2));
    <font color="blue">else</font>
      om[1:<font color="red">size</font>(ss.C, 1), :] := ss.C;

      <font color="blue">for </font>i<font color="blue"> in </font>2:<font color="red">size</font>(ss.A, 1)<font color="blue"> loop</font>
        om[((i - 1)*<font color="red">size</font>(ss.C, 1) + 1):(i*<font color="red">size</font>(ss.C, 1)), :] := om[((i - 2)*
          <font color="red">size</font>(ss.C, 1) + 1):((i - 1)*<font color="red">size</font>(ss.C, 1)), :]*ss.A;
      <font color="blue">end for</font>;
    <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>observabilityMatrix</textblock>;

<font color="blue">end </font>Analysis</textblock>;

  <textblock type="packagesmall" expanded="false" path="Modelica_LinearSystems2.StateSpace.Design"><font color="blue">encapsulated </font><font color="blue">package</font> Design <font color="darkgreen">
    &quot;Functions for state space controller design&quot;</font>
    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Design.assignPolesSI"><font color="blue">encapsulated </font><font color="blue">function</font> assignPolesSI <font color="darkgreen">
      &quot;Pole placement for single input systems using Ackermann&#39;s formula.&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;
      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A> p[<font color="red">size</font>(ss.A, 1)] <font color="darkgreen">
        &quot;Vector of desired poles&quot;</font>;
      <font color="blue">output </font>Real k[<font color="red">size</font>(ss.A, 1)] <font color="darkgreen">&quot;Feedback gain matrix&quot;</font>;

    <font color="blue">protected </font>
      Real cm[<font color="red">size</font>(ss.B, 1),<font color="red">size</font>(ss.A, 1)*<font color="red">size</font>(ss.B, 2)];
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Modelica_LinearSystems2.Math.Polynomial</A> poly;
      Real Y[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)];
      Real X[:,:];
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A> p_actual[<font color="red">size</font>(p, 1)];
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A> p_sorted[<font color="red">size</font>(p, 1)];
      Real poleError;
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A> smaller;
    <font color="blue">algorithm </font>
      <font color="red">assert</font>(<font color="red">size</font>(ss.B,2)==1,&quot;System must be SI but has &quot;+ <font color="red">String</font>(<font color="red">size</font>(ss.B,2)) +&quot; inputs&quot;);
      cm := <font color="red">StateSpace.Analysis.controllabilityMatrix</font>(ss);
      <font color="red">assert</font>(<font color="red">Modelica.Math.Matrices.rank</font>(cm) == <font color="red">size</font>(cm, 1)<font color="blue"> or </font>
        <font color="red">Modelica.Math.Matrices.rank</font>(cm) == <font color="red">size</font>(cm, 2),
        &quot;Controllability matrix has not full rank. System is not controllable!&quot;);
      poly := <font color="red">Modelica_LinearSystems2.Math.Polynomial</font>(p);
      Y := <font color="red">Modelica_LinearSystems2.Math.Polynomial.evaluateMatrix</font>(poly, ss.A);
      X := <font color="red">zeros</font>(<font color="red">size</font>(cm, 2), <font color="red">size</font>(Y, 2));
      <font color="blue">for </font>j<font color="blue"> in </font>1:<font color="red">size</font>(Y, 2)<font color="blue"> loop</font>
        X[:, j] := <font color="red">Modelica.Math.Matrices.leastSquares</font>(cm, <font color="red">vector</font>(Y[:, j]));
      <font color="blue">end for</font>;
      k := X[<font color="red">size</font>(ss.A, 1), :];

      <font color="darkgreen">// Check results</font>
      <font color="darkgreen">// sort p</font>
      p_sorted := p;
      <font color="blue">for </font>i1<font color="blue"> in </font>1:<font color="red">size</font>(p_sorted, 1)<font color="blue"> loop</font>
        <font color="blue">for </font>i2<font color="blue"> in </font>(1 + i1):<font color="red">size</font>(p_sorted, 1)<font color="blue"> loop</font>
          <font color="blue">if </font><font color="red">Modelica_LinearSystems2.Math.Complex.&#39;abs&#39;</font>(p_sorted[i1]) &gt;
              <font color="red">Modelica_LinearSystems2.Math.Complex.&#39;abs&#39;</font>(p_sorted[i2])<font color="blue"> then</font>
            smaller := p_sorted[i2];
            p_sorted[i2] := p_sorted[i1];
            p_sorted[i1] := smaller;
          <font color="blue">end if</font>;
        <font color="blue">end for</font>;
      <font color="blue">end for</font>;

      p_actual := <font color="red">Modelica_LinearSystems2.Math.Complex.eigenValues</font>(ss.A - ss.B*
        <font color="red">transpose</font>(<font color="red">matrix</font>(k)));
       <font color="darkgreen">// sort actual eigenvalues</font>
      <font color="blue">for </font>i1<font color="blue"> in </font>1:<font color="red">size</font>(p_actual, 1)<font color="blue"> loop</font>
        <font color="blue">for </font>i2<font color="blue"> in </font>(1 + i1):<font color="red">size</font>(p_actual, 1)<font color="blue"> loop</font>
          <font color="blue">if </font><font color="red">Modelica_LinearSystems2.Math.Complex.&#39;abs&#39;</font>(p_actual[i1]) &gt;
              <font color="red">Modelica_LinearSystems2.Math.Complex.&#39;abs&#39;</font>(p_actual[i2])<font color="blue"> then</font>
            smaller := p_actual[i2];
            p_actual[i2] := p_actual[i1];
            p_actual[i1] := smaller;
          <font color="blue">end if</font>;
        <font color="blue">end for</font>;
      <font color="blue">end for</font>;

      <font color="darkgreen">// check for poles that have an error of more than 10%</font>
      <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(p_sorted, 1)<font color="blue"> loop</font>
        <font color="blue">if </font>(<font color="red">Modelica_LinearSystems2.Math.Complex.&#39;abs&#39;</font>(p_sorted[i]) &lt;&gt; 0)<font color="blue"> then</font>
           poleError := <font color="red">Modelica_LinearSystems2.Math.Complex.&#39;abs&#39;</font>((p_sorted[i] -
            p_actual[i]))/<font color="red">Modelica_LinearSystems2.Math.Complex.&#39;abs&#39;</font>(p_sorted[i]);

          <font color="blue">if </font>poleError &gt; 0.1<font color="blue"> then</font>
              <font color="red">Modelica.Utilities.Streams.print</font>(&quot;Warning: Pole location of pole &quot; +
              <font color="red">String</font>(p_sorted[i]) + &quot; has an error of &quot; + <font color="red">String</font>(100*poleError)
               + &quot;%. (Is &quot; + <font color="red">String</font>(p_actual[i]) + &quot;)&quot;);

          <font color="blue">end if</font>;
        <font color="blue">end if</font>;
      <font color="blue">end for</font>;

    <font color="blue">end </font>assignPolesSI</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Design.assignPolesMI"><font color="blue">encapsulated </font><font color="blue">function</font> assignPolesMI <font color="darkgreen">
      &quot;Pole assigment design algorithm for multi input systems&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams.print"
>Modelica.Utilities.Streams.print</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;state space system&quot;</font>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> gamma[:]=<font color="red">fill</font>(<font color="red">Complex</font>(0), 0) <font color="darkgreen">&quot;Designed Poles&quot;</font>;
    <font color="darkgreen">//  input Integer np=size(gamma, 1) &quot;number of given eigenvalues to assign&quot;;</font>
      <font color="blue">input </font>Real alpha=-1e10 <font color="darkgreen">
        &quot;maximum admissible value for real parts(continuous) or for moduli (discrete) of the eigenvalues of A which will not be modified by the eigenvalue assignment algorithm&quot;</font>;
      <font color="blue">input </font>Real tolerance=<font color="red">Modelica.Math.Matrices.norm</font>(ss.A, 1)*1e-12 <font color="darkgreen">
        &quot;The tolerance to be used in determining the controllability of (A,B)&quot;</font>;
      <font color="blue">input </font>Boolean calculateEigenvectors=false <font color="darkgreen">
        &quot;Calculate the eigenvectors X of the closed loop system when true&quot;</font>;

      <font color="blue">output </font>Real K[<font color="red">size</font>(ss.B, 2),<font color="red">size</font>(ss.A, 1)] <font color="darkgreen">
        &quot;State feedback matrix assigning the desired poles&quot;</font>;
      <font color="blue">output </font>Real S[:,:] <font color="darkgreen">&quot;Closed loop System matrix&quot;</font>;
      <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> po[<font color="red">size</font>(ss.A, 1)] <font color="darkgreen">&quot;poles of the closed loop system&quot;</font>;
      <font color="blue">output </font>Integer nfp <font color="darkgreen">
        &quot;number of eigenvalues that are not modified with respect to alpha&quot;</font>;
      <font color="blue">output </font>Integer nap <font color="darkgreen">&quot;number of assigned eigenvalues&quot;</font>;
      <font color="blue">output </font>Integer nup <font color="darkgreen">&quot;number of uncontrollable eigenvalues&quot;</font>;
      <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> X[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 1)] <font color="darkgreen">
        &quot;eigenvectors of the closed loop system&quot;</font>;

    <font color="blue">protected </font>
      Real A_rsf[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)];
      Real B_rsf[<font color="red">size</font>(ss.B, 1),<font color="red">size</font>(ss.B, 2)];
      Real Q[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 1)];
      Real Ks1[:,:];
      Real Ks2[:,:];
      Real Q2[:,:];
      Real A_rsf_1[:,:];
      Real Q1[:,:];
      Boolean select[:];
      Boolean rselectA[:];
      Real Z[:,:] <font color="darkgreen">&quot;orthogonal transformation matrix&quot;</font>;
      Real ZT[:,:] <font color="darkgreen">&quot;orthogonal transformation matrix&quot;</font>;
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> pf[:];
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> gammaReordered[:]=gamma;
      Integer info;
      Real wr[<font color="red">size</font>(gamma, 1)];
      Real wi[<font color="red">size</font>(gamma, 1)];
      Boolean imag=false;
      Integer i;
      Integer ii;
      Integer iii;
      Integer counter;
      Integer counter2;
      Integer n=<font color="red">size</font>(ss.A, 1);
      Integer nccA <font color="darkgreen">&quot;number of conjugated complex pole pairs of openloop system&quot;</font>;
      Integer nccg <font color="darkgreen">&quot;number of conjugated complex pole pairs of gamma&quot;</font>;
      Integer rpg <font color="darkgreen">&quot;number of real poles in gamma&quot;</font>;
      Integer rpA <font color="darkgreen">&quot;number of real poles of open loop system&quot;</font>;
      Integer ncc <font color="darkgreen">&quot;Min(nccA, nccg)&quot;</font>;
      Integer rp <font color="darkgreen">&quot;Min(rpg, rpA)&quot;</font>;
      Integer ng=<font color="red">size</font>(gamma,1);
      Integer nr <font color="darkgreen">&quot;Differenz between rpA and rpg; Sign(rpA-rpg)*(rpA-rpg)&quot;</font>;

      Real alphaReal[<font color="red">size</font>(ss.A, 1)] <font color="darkgreen">
        &quot;Real part of eigenvalue=alphaReal+i*alphaImag&quot;</font>;
      Real alphaImag[<font color="red">size</font>(ss.A, 1)] <font color="darkgreen">
        &quot;Imaginary part of eigenvalue=(alphaReal+i*alphaImag&quot;</font>;

      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> SS[:,:];
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> Xj[:,:];
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> h;

      Real dist;
      Real evImag;

    <font color="blue">algorithm </font>
      <font color="red">assert</font>(<font color="red">size</font>(gamma, 1) &lt;= <font color="red">size</font>(ss.A, 1),
        &quot;At most n (order of ss) eigenvalues can be assigned&quot;);

     <font color="darkgreen">/* Extraction of Poles (Variable conversation) and pole sequence check */</font>
      <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(gamma, 1)<font color="blue"> loop</font>
        wr[i] := gamma[i].re;
        wi[i] := gamma[i].im;
        <font color="blue">if </font>imag<font color="blue"> then</font>
          <font color="red">assert</font>(wi[i - 1] == -wi[i]<font color="blue"> and </font>wr[i - 1] == wr[i],
            &quot;Poles are in wrong sequence&quot;);
          imag := false;
        <font color="blue">elseif </font>wi[i] &lt;&gt; 0<font color="blue"> then</font>
          imag := true;
        <font color="blue">end if</font>;
      <font color="blue">end for</font>;

      <font color="darkgreen">// put matrix ss.A to real Schur form A &lt;- QAQ&#39; and compute B &lt;- QB</font>
      (A_rsf,Z,alphaReal,alphaImag) := <font color="red">Matrices.rsf2</font>(ss.A);
      ZT := <font color="red">transpose</font>(Z);

      <font color="darkgreen">// reorder real Schur form according to alpha</font>
      (A_rsf,Z,alphaReal,alphaImag) := <font color="red">Matrices.Internal.reorderRSF2</font>(
          A_rsf,
          <font color="red">identity</font>(<font color="red">size</font>(A_rsf, 1)),
          alphaReal,
          alphaImag,
          alpha);
      ZT := <font color="red">transpose</font>(Z)*ZT;
      B_rsf := ZT*ss.B;

      <font color="darkgreen">// determine number of poles not to be assigned according to alpha</font>
      nfp := 0;
      <font color="blue">for </font>i<font color="blue"> in </font>1:n<font color="blue"> loop</font>
        <font color="blue">if </font>alphaReal[i] &lt; alpha<font color="blue"> then</font>
          nfp := nfp + 1;
        <font color="blue">end if</font>;
      <font color="blue">end for</font>;
      nap := n - nfp;

      <font color="red">assert</font>(<font color="red">size</font>(gamma, 1) &gt;= nap, <font color="red">String</font>(nap) +
        &quot; poles should be modified, therefore gamma should contain at at least &quot;
         + <font color="red">String</font>(nap) + &quot; assigned eigenvalues&quot;);

      <font color="darkgreen">// second reorder (reorderRSF3) according to conjugated complex pairs in A and p</font>
      <font color="darkgreen">// count numbre of conjugated complex pole pairs = max(number_ccpp(eig(A), number_ccpp(gamma))</font>
      nccA := 0;
      <font color="darkgreen">//mark the real poles of original system</font>
      rselectA := <font color="red">fill</font>(true, nap);
      ii := 1;
      <font color="blue">for </font>i<font color="blue"> in </font>nfp + 1:n<font color="blue"> loop</font>
        <font color="blue">if </font><font color="red">abs</font>(alphaImag[i]) &gt; 0<font color="blue"> then</font>
          nccA := nccA + 1;
        <font color="blue">else</font>
          rselectA[ii] := false;

        <font color="blue">end if</font>;
        ii := ii + 1;
        <font color="blue">end for</font>;
        rpA := n-nccA;
        nccA := <font color="red">div</font>(nccA, 2);

      <font color="darkgreen">// reorder gamma and A_rsf</font>
      (gammaReordered,rpg) := <font color="red">Modelica_LinearSystems2.Internal.reorderZeros</font>(gamma);
      gammaReordered := <font color="red">Complex.Vectors.reverse</font>(gammaReordered);
      nccg := <font color="red">div</font>(<font color="red">size</font>(gammaReordered, 1) - rpg, 2);
      ncc := <font color="red">min</font>(nccA, nccg);
      rp := <font color="red">min</font>(rpA, rpg);
      <font color="blue">if </font>nccA &gt; 0<font color="blue"> then</font>
        (A_rsf[nfp + 1:n, nfp + 1:n],Q2) := <font color="red">Matrices.LAPACK.dtrsen</font>(
            &quot;E&quot;,
            &quot;V&quot;,
            rselectA,
            A_rsf[nfp + 1:n, nfp + 1:n],
            <font color="red">identity</font>(n - nfp));<font color="darkgreen">//The Schur vector matrix is identity, since A_rsf already has Schur form</font>

        A_rsf[1:nfp, nfp + 1:n] := A_rsf[1:nfp, nfp + 1:n]*Q2;
        B_rsf[nfp + 1:n, :] := <font color="red">transpose</font>(Q2)*B_rsf[nfp + 1:n, :];
        ZT[nfp + 1:n, :] := <font color="red">transpose</font>(Q2)*ZT[nfp + 1:n, :];
      <font color="blue">end if</font>;

      <font color="darkgreen">// main algorithm</font>
      K := <font color="red">zeros</font>(<font color="red">size</font>(ss.B, 2), <font color="red">size</font>(ss.A, 1));
      counter := nfp + 1;
      counter2 := 1;

        <font color="blue">for </font>i<font color="blue"> in </font>1:rp<font color="blue"> loop</font> <font color="darkgreen">// 1x1 blocks; real system pole and real assigned poles; take the next eigenvalue in the</font>
        <font color="darkgreen">                   // diagonal of the Schur form and search the nearest pole in the set of the real poles to assign</font>
          dist := Modelica.Constants.inf;
          <font color="blue">for </font>ii<font color="blue"> in </font>i:rpg<font color="blue"> loop</font> <font color="darkgreen">// looking for nearest pole and reorder gamma</font>
            <font color="blue">if </font><font color="red">abs</font>(A_rsf[n, n] - gammaReordered[ng - ii + 1].re) &lt; dist<font color="blue"> then</font>
              iii := ng - ii + 1;
              dist := <font color="red">abs</font>(A_rsf[n, n] - gammaReordered[ng - ii + 1].re);
            <font color="blue">end if</font>;
          <font color="blue">end for</font>;
          h := gammaReordered[ng - i + 1];
          gammaReordered[ng - i + 1] := gammaReordered[iii];
          gammaReordered[iii] := h;

          Ks1 := <font color="red">StateSpace.Internal.assignOneOrTwoPoles</font>(
            <font color="red">matrix</font>(A_rsf[n, n]),
            <font color="red">transpose</font>(<font color="red">matrix</font>(B_rsf[n, :])),
            {gammaReordered[ng - i + 1]},
            tolerance);
          K := K + [<font color="red">zeros</font>(<font color="red">size</font>(Ks1, 1), <font color="red">size</font>(K, 2) - 1),Ks1]*ZT;
          A_rsf := A_rsf - B_rsf*[<font color="red">zeros</font>(<font color="red">size</font>(Ks1, 1), <font color="red">size</font>(K, 2) - 1),Ks1];
          select := <font color="red">fill</font>(false, n - counter + 1);
          select[n - counter + 1] := true;

          (A_rsf[counter:n, counter:n],Q1) := <font color="red">Matrices.LAPACK.dtrsen</font>(
            &quot;E&quot;,
            &quot;V&quot;,
            select,
            A_rsf[counter:n, counter:n],
            <font color="red">identity</font>(n - counter + 1));<font color="darkgreen">//The Schur vector matrix is identity, since A_rsf already has Schur form</font>

          A_rsf[1:counter - 1, counter:n] := A_rsf[1:counter - 1, counter:n]*Q1;
          B_rsf[counter:n, :] := <font color="red">transpose</font>(Q1)*B_rsf[counter:n, :];
          ZT[counter:n, :] := <font color="red">transpose</font>(Q1)*ZT[counter:n, :];
          counter := counter + 1;
          counter2 := counter2 + 1;
        <font color="blue">end for</font>;

        <font color="blue">if </font>counter2&lt;rpg<font color="blue"> and </font>counter2&gt;rpA<font color="blue"> then</font> <font color="darkgreen">//System has less real eigenvalues than real assigned poles</font>
        <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">div</font>(rpg - rpA, 2)<font color="blue"> loop</font> <font color="darkgreen">// 2x2 blocks; complex pair of system poles and 2 real assigned poles; take the next complex pair</font>
          <font color="darkgreen">                                // (Schur bump) in the diagonal of the Schur form and search the two nearest poles in the set of the</font>
          <font color="darkgreen">                                // remaining real assigned poles</font>
          dist := Modelica.Constants.inf;
          evImag := <font color="red">sqrt</font>(-A_rsf[n - 1, n]*A_rsf[n, n - 1]);<font color="darkgreen">//positive imaginary part of the complex system pole pair</font>
          <font color="blue">for </font>ii<font color="blue"> in </font>2*(i - 1) + 1:2:rpg - rpA<font color="blue"> loop</font>
            <font color="blue">if </font><font color="red">abs</font>(A_rsf[n, n] - gammaReordered[ng - rp - ii + 1].re) + evImag &lt; dist<font color="blue"> then</font>
              iii := ng - rp - ii + 1;
              dist := <font color="red">abs</font>(A_rsf[n, n] - gammaReordered[ng - rp - ii + 1].re) + evImag;
            <font color="blue">end if</font>;
          <font color="blue">end for</font>;
          h := gammaReordered[ng - rp - 2*(i - 1)];
          gammaReordered[ng - rp - 2*(i - 1)] := gammaReordered[iii];
          gammaReordered[iii] := h;
          dist := Modelica.Constants.inf;
          <font color="blue">for </font>ii<font color="blue"> in </font>2*(i - 1) + 1:2:rpg - rpA<font color="blue"> loop</font>
            <font color="blue">if </font><font color="red">abs</font>(A_rsf[n, n] - gammaReordered[ng - rp - ii + 1].re) + evImag &lt; dist<font color="blue"> then</font>
              iii := ng - rp - ii + 1;
              dist := <font color="red">abs</font>(A_rsf[n, n] - gammaReordered[ng - rp - ii + 1].re) + evImag;
            <font color="blue">end if</font>;
          <font color="blue">end for</font>;
          h := gammaReordered[ng - rp - 2*i + 1];
          gammaReordered[ng - rp - 2*i + 1] := gammaReordered[iii];
          gammaReordered[iii] := h;

          Ks2 := <font color="red">StateSpace.Internal.assignOneOrTwoPoles</font>(
            A_rsf[n - 1:n, n - 1:n],
            <font color="red">matrix</font>(B_rsf[n - 1:n, :]),
            gammaReordered[ng - rp - 2*i + 1:ng - rp - 2*(i - 1)],
            tolerance);

          K := K + [<font color="red">zeros</font>(<font color="red">size</font>(Ks2, 1), <font color="red">size</font>(K, 2) - 2),Ks2]*ZT;
          A_rsf := A_rsf - B_rsf*[<font color="red">zeros</font>(<font color="red">size</font>(Ks2, 1), <font color="red">size</font>(K, 2) - 2),Ks2];
          select := <font color="red">fill</font>(false, n - counter + 1);
          select[n - counter:n - counter + 1] := {true,true};

          (A_rsf[counter:n, counter:n],Q2) := <font color="red">Matrices.LAPACK.dtrsen</font>(
            &quot;E&quot;,
            &quot;V&quot;,
            select,
            A_rsf[counter:n, counter:n],
            <font color="red">identity</font>(n - counter + 1)); <font color="darkgreen">//The Schur vector matrix is identity, since A_rsf already has Schur form</font>

          A_rsf[1:counter - 1, counter:n] := A_rsf[1:counter - 1, counter:n]*Q2;
          B_rsf[counter:n, :] := <font color="red">transpose</font>(Q2)*B_rsf[counter:n, :];
          ZT[counter:n, :] := <font color="red">transpose</font>(Q2)*ZT[counter:n, :];
          counter := counter + 2;
          counter2 := counter2 + 2;
        <font color="blue">end for</font>;
      <font color="blue">end if</font>;

      <font color="blue">if </font>counter2&gt;rpg<font color="blue"> and </font>counter2&lt;rpA<font color="blue"> then</font><font color="darkgreen">//System has more real eigenvalues than real assigned poles</font>
        <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">div</font>(rpA - rpg, 2)<font color="blue"> loop</font><font color="darkgreen">// 2x2 blocks; 2 real system poles and a pair of complex assigned poles; take the next two real</font>
          <font color="darkgreen">                                // eigenvalues in the diagonal of the Schur form and search the complex pole pair of the assigned poles</font>
          <font color="darkgreen">                                // which is nearest to the two real poles</font>
          dist := Modelica.Constants.inf;
          <font color="blue">for </font>ii<font color="blue"> in </font>2*(i - 1)+1:2:rpA - rpg<font color="blue"> loop</font>
            <font color="blue">if </font><font color="red">abs</font>(A_rsf[n, n] - gammaReordered[ng - rp - ii + 1].re) + <font color="red">abs</font>(gammaReordered[ng - rp - ii + 1].im) + <font color="red">abs</font>(A_rsf[n - 1, n - 1] -
              gammaReordered[ng - rp - ii + 1].re) + <font color="red">abs</font>(gammaReordered[ng - rp - ii + 1].re) &lt; dist<font color="blue"> then</font>
              iii := ng - rp - ii + 1;
              dist := <font color="red">abs</font>(A_rsf[n, n] - gammaReordered[ng - rp - ii + 1].re)
                 + <font color="red">abs</font>(gammaReordered[ng - rp - ii + 1].im) + <font color="red">abs</font>(A_rsf[
                n - 1, n - 1] - gammaReordered[ng - rp - ii + 1].re) +
                <font color="red">abs</font>(gammaReordered[ng - rp - ii + 1].re);
            <font color="blue">end if</font>;
          <font color="blue">end for</font>;
          h := gammaReordered[ng - rp - 2*(i - 1)];
          gammaReordered[ng - rp - 2*(i - 1)] := gammaReordered[iii];
          gammaReordered[iii] := h;
          h := gammaReordered[ng - rp - 2*i + 1];
          gammaReordered[ng - rp - 2*i + 1] := gammaReordered[iii - 1];
          gammaReordered[iii - 1] := h;

          Ks2 := <font color="red">StateSpace.Internal.assignOneOrTwoPoles</font>(
            A_rsf[n - 1:n, n - 1:n],
            <font color="red">matrix</font>(B_rsf[n - 1:n, :]),
            gammaReordered[ng - rp - 2*i + 1:ng - rp - 2*(i - 1)],
            tolerance);

          K := K + [<font color="red">zeros</font>(<font color="red">size</font>(Ks2, 1), <font color="red">size</font>(K, 2) - 2),Ks2]*ZT;
          A_rsf := A_rsf - B_rsf*[<font color="red">zeros</font>(<font color="red">size</font>(Ks2, 1), <font color="red">size</font>(K, 2) - 2),Ks2];
          select := <font color="red">fill</font>(false, n - counter + 1);
          select[n - counter:n - counter + 1] := {true,true};

          (A_rsf[counter:n, counter:n],Q2) := <font color="red">Matrices.LAPACK.dtrsen</font>(
            &quot;E&quot;,
            &quot;V&quot;,
            select,
            A_rsf[counter:n, counter:n],
            <font color="red">identity</font>(n - counter + 1)); <font color="darkgreen">//The Schur vector matrix is identity, since A_rsf already has Schur form</font>

          A_rsf[1:counter - 1, counter:n] := A_rsf[1:counter - 1, counter:n]*Q2;
          B_rsf[counter:n, :] := <font color="red">transpose</font>(Q2)*B_rsf[counter:n, :];
          ZT[counter:n, :] := <font color="red">transpose</font>(Q2)*ZT[counter:n, :];
          counter := counter + 2;
          counter2 := counter2 + 2;
          <font color="red">Modelica.Utilities.Streams.print</font>(&quot;counter2Case3 = &quot; + <font color="red">String</font>(counter2));
        <font color="blue">end for</font>;
      <font color="blue">end if</font>;
    <font color="darkgreen">//      else</font>

      <font color="blue">for </font>i<font color="blue"> in </font>1:ncc<font color="blue"> loop</font> <font color="darkgreen">// 2x2 blocks; 2 complex system poles and two complex assigned poles; take the next complex</font>
        <font color="darkgreen">                  // system pole pair (next Schur bump) in the diagonal of the Schur form and search the complex</font>
        <font color="darkgreen">                  //  assigned pole pair which is nearest</font>
        dist := Modelica.Constants.inf;
        evImag := <font color="red">sqrt</font>(-A_rsf[n - 1, n]*A_rsf[n, n - 1]);<font color="darkgreen">//positive imaginary part of the complex system pole pair</font>
        <font color="blue">for </font>ii<font color="blue"> in </font>2*(i - 1) + 1:2:2*ncc<font color="blue"> loop</font>
          <font color="blue">if </font><font color="red">abs</font>(A_rsf[n, n] - gammaReordered[2*ncc - ii + 1].re) + <font color="red">abs</font>(evImag -
              <font color="red">abs</font>(gammaReordered[2*ncc - ii + 1].im)) &lt; dist<font color="blue"> then</font>
            iii := 2*ncc - ii + 1;
            dist := <font color="red">abs</font>(A_rsf[n, n] - gammaReordered[2*ncc - ii + 1].re) + <font color="red">abs</font>(
              evImag - <font color="red">abs</font>(gammaReordered[2*ncc - ii + 1].im));
          <font color="blue">end if</font>;
        <font color="blue">end for</font>;
        h := gammaReordered[2*ncc - 2*(i - 1)];
        gammaReordered[2*ncc - 2*(i - 1)] := gammaReordered[iii];
        gammaReordered[iii] := h;
        h := gammaReordered[2*ncc - 2*i + 1];
        gammaReordered[2*ncc - 2*i + 1] := gammaReordered[iii - 1];
        gammaReordered[iii - 1] := h;
        Ks2 := <font color="red">StateSpace.Internal.assignOneOrTwoPoles</font>(
          A_rsf[n - 1:n, n - 1:n],
          <font color="red">matrix</font>(B_rsf[n - 1:n, :]),
          gammaReordered[2*ncc - 2*i + 1:2*ncc - 2*(i - 1)],
          tolerance);
        K := K + [<font color="red">zeros</font>(<font color="red">size</font>(Ks2, 1), <font color="red">size</font>(K, 2) - 2),Ks2]*ZT;
        A_rsf := A_rsf - B_rsf*[<font color="red">zeros</font>(<font color="red">size</font>(Ks2, 1), <font color="red">size</font>(K, 2) - 2),Ks2];
        select := <font color="red">fill</font>(false, n - counter + 1);
        select[n - counter:n - counter + 1] := {true,true};

        (A_rsf[counter:n, counter:n],Q2) := <font color="red">Matrices.LAPACK.dtrsen</font>(
          &quot;E&quot;,
          &quot;V&quot;,
          select,
          A_rsf[counter:n, counter:n],
          <font color="red">identity</font>(n - counter + 1));   <font color="darkgreen">//The Schur vector matrix is identity, since A_rsf already has Schur form</font>

        A_rsf[1:counter - 1, counter:n] := A_rsf[1:counter - 1, counter:n]*Q2;
        B_rsf[counter:n, :] := <font color="red">transpose</font>(Q2)*B_rsf[counter:n, :];
        ZT[counter:n, :] := <font color="red">transpose</font>(Q2)*ZT[counter:n, :];
        counter := counter + 2;
        counter2 := counter2 + 2;
      <font color="blue">end for</font>;

      S := ss.A - ss.B*K;
      po := <font color="red">Complex.eigenValues</font>(S);

      <font color="blue">if </font>calculateEigenvectors<font color="blue"> then</font>
    <font color="darkgreen">//     X := fill(Complex(0), n, n);</font>
    <font color="darkgreen">//     for i in 1:n loop</font>
    <font color="darkgreen">//       SS := Complex(1)*S;</font>
    <font color="darkgreen">//       for ii in 1:n loop</font>
    <font color="darkgreen">//         SS[ii, ii] := SS[ii, ii] - po[i];</font>
    <font color="darkgreen">//       end for;</font>
    <font color="darkgreen">//       Xj := Modelica_LinearSystems2.WorkInProgress.Math.Matrices.C_nullspace(</font>
    <font color="darkgreen">//                                  SS);</font>
    <font color="darkgreen">//       for ii in 1:n loop</font>
    <font color="darkgreen">//         X[ii, i] := Xj[ii, 1];</font>
    <font color="darkgreen">//       end for;</font>
    <font color="darkgreen">//     end for;</font>
    <font color="darkgreen">//      Modelica_LinearSystems2.Math.Complex.Matrices.print(X,6,&quot;X1&quot;);</font>
        X := <font color="red">Complex.eigenVectors</font>(S);
    <font color="darkgreen">//      Modelica_LinearSystems2.Math.Complex.Matrices.print(X,6,&quot;X2&quot;);</font>

      <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>assignPolesMI</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Design.kalmanFilter"><font color="blue">function</font> kalmanFilter <font color="darkgreen">&quot;Design of a Kalman estimator matrix&quot;</font>
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;Time-continuous system in state space form&quot;</font>;
    <font color="blue">input </font>Real Q[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 1)] <font color="darkgreen">
        &quot;Covariance Matrix of state noise (n x n), n number of states&quot;</font>;
    <font color="blue">input </font>Real R[<font color="red">size</font>(ss.B, 2),<font color="red">size</font>(ss.B, 2)] <font color="darkgreen">
        &quot;Covariance Matrix of input noise (m x m), m number of inputs&quot;</font>;

    <font color="blue">public </font>
    <font color="blue">output </font>Real L[:,:] <font color="darkgreen">&quot;Kalman filter matrix&quot;</font>;
    <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> kss(
      <font color="blue">redeclare </font>Real A[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 1)],
      <font color="blue">redeclare </font>Real B[<font color="red">size</font>(ss.B, 1),<font color="red">size</font>(ss.B, 2) + <font color="red">size</font>(ss.C, 1)],
      <font color="blue">redeclare </font>Real C[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)],
      <font color="blue">redeclare </font>Real D[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.B, 2) + <font color="red">size</font>(ss.C, 1)]) <font color="darkgreen">
        &quot;kalman system&quot;</font>;

    <font color="blue">protected </font>
    Real AR[:,:]=<font color="red">transpose</font>(ss.A);
    Real BR[:,:]=<font color="red">transpose</font>(ss.C);
    Real CR[:,:]=<font color="red">zeros</font>(1, <font color="red">size</font>(AR, 1));
    Real DR[:,:]=<font color="red">zeros</font>(1, <font color="red">size</font>(BR, 2));
    <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> rss=<font color="red">StateSpace</font>(AR, BR, CR, DR) <font color="darkgreen">
        &quot;System to calculate the Kalman estimator with lqr algorithm&quot;</font>;

    Real AK[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 1)];
    Real BK[<font color="red">size</font>(ss.B, 1),<font color="red">size</font>(ss.B, 2) + <font color="red">size</font>(ss.C, 1)];
    Real CK[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)];
    Real DK[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.B, 2) + <font color="red">size</font>(ss.C, 1)];<font color="darkgreen">// matrices of the kalman system kss</font>

  <font color="blue">algorithm </font>
    (L) := <font color="red">StateSpace.Design.lqr</font>(rss, Q, R, true);
    L := <font color="red">transpose</font>(L);

    AK := ss.A - L*ss.C;
    BK[:, 1:<font color="red">size</font>(ss.B, 2)] := ss.B - L*ss.D;
    BK[:, <font color="red">size</font>(ss.B, 2) + 1:<font color="red">size</font>(BK, 2)] := L;
    CK := <font color="red">identity</font>(<font color="red">size</font>(ss.A, 1));
    DK := <font color="red">zeros</font>(<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.B, 2) + <font color="red">size</font>(ss.C, 1));

    kss := <font color="red">StateSpace</font>(AK, BK, CK, DK);

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>kalmanFilter</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Design.lqr"><font color="blue">encapsulated </font><font color="blue">function</font> lqr <font color="darkgreen">&quot;LQR design algorithm&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math"
>Modelica_LinearSystems2.Math</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;open loop system&quot;</font>;
      <font color="blue">input </font>Real Q[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)]=<font color="red">identity</font>(<font color="red">size</font>(ss.A, 1)) <font color="darkgreen">
        &quot; state weighting matrix&quot;</font>;
      <font color="blue">input </font>Real R[<font color="red">size</font>(ss.B, 2),<font color="red">size</font>(ss.B, 2)]=<font color="red">identity</font>(<font color="red">size</font>(ss.B, 2)) <font color="darkgreen">
        &quot; input weighting matrix&quot;</font>;
    <font color="blue">protected </font>
      <font color="blue">input </font>Boolean iscontinuousSystem=true;
    <font color="blue">public </font>
      <font color="blue">output </font>Real K[<font color="red">size</font>(ss.B, 2),<font color="red">size</font>(ss.A, 1)] <font color="darkgreen">&quot;Feedback gain matrix&quot;</font>;
      <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> sslqr(
        <font color="blue">redeclare </font>Real A[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)],
        <font color="blue">redeclare </font>Real B[<font color="red">size</font>(ss.B, 1),<font color="red">size</font>(ss.B, 2)],
        <font color="blue">redeclare </font>Real C[<font color="red">size</font>(ss.C, 1),<font color="red">size</font>(ss.C, 2)],
        <font color="blue">redeclare </font>Real D[<font color="red">size</font>(ss.D, 1),<font color="red">size</font>(ss.D, 2)]) <font color="darkgreen">&quot;closed loop system&quot;</font>;

      <font color="blue">output </font>Real S[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 1)] <font color="darkgreen">
        &quot;solution of the Riccati equation&quot;</font>;

      <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Math.Complex</A> ev[:];

    <font color="blue">algorithm </font>
      <font color="blue">if </font><font color="red">min</font>(<font color="red">size</font>(ss.A,1),<font color="red">size</font>(ss.A,2))&gt;0<font color="blue"> then</font>
      <font color="red">assert</font>(<font color="red">StateSpace.Analysis.isControllable</font>(ss),&quot;System in function \&quot;Modelica_LinearSystems2.StateSpace.Design.lqr\&quot; has to be controllable&quot;);
      <font color="blue">if </font>iscontinuousSystem<font color="blue"> then</font>
        (S,ev) := <font color="red">Math.Matrices.care</font>(
            ss.A,
            ss.B,
            R,
            Q);
        K := <font color="red">Math.Matrices.solve2</font>(R, <font color="red">transpose</font>(ss.B)*S);
      <font color="blue">else</font>
        (S,ev) := <font color="red">Math.Matrices.dare</font>(
            ss.A,
            ss.B,
            R,
            Q);
        K := <font color="red">Math.Matrices.solve2</font>(R + <font color="red">transpose</font>(ss.B)*S*ss.B, <font color="red">transpose</font>(ss.B)*S*
          ss.A);
      <font color="blue">end if</font>;

      sslqr.A := ss.A - ss.B*K;
      sslqr.B := ss.B;
      sslqr.C := ss.C - ss.D*K;
      sslqr.D := ss.D;

      <font color="blue">else</font>
        K := <font color="red">fill</font>(
          0,
          <font color="red">size</font>(ss.B, 2),
          <font color="red">size</font>(ss.A, 1));
        ev := <font color="red">fill</font>(<font color="red">Modelica_LinearSystems2.Math.Complex</font>(0), 0);
      <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>lqr</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Design.lqg"><font color="blue">encapsulated </font><font color="blue">function</font> lqg <font color="darkgreen">&quot;LQG design algorithm&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math"
>Modelica_LinearSystems2.Math</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;open loop system&quot;</font>;
      <font color="blue">input </font>Real Q[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)]=<font color="red">identity</font>(<font color="red">size</font>(ss.A, 1)) <font color="darkgreen">
        &quot; state weighting matrix&quot;</font>;
      <font color="blue">input </font>Real R[<font color="red">size</font>(ss.B, 2),<font color="red">size</font>(ss.B, 2)]=<font color="red">identity</font>(<font color="red">size</font>(ss.B, 2)) <font color="darkgreen">
        &quot; input weighting matrix&quot;</font>;
      <font color="blue">input </font>Real V[<font color="red">size</font>(ss.C, 1),<font color="red">size</font>(ss.C, 1)]=<font color="red">identity</font>(<font color="red">size</font>(ss.C, 1)) <font color="darkgreen">
        &quot; covariance output noise matrix&quot;</font>;
      <font color="blue">input </font>Real W[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 1)]=<font color="red">identity</font>(<font color="red">size</font>(ss.A, 1)) <font color="darkgreen">
        &quot; covariance input noise matrix&quot;</font>;

      <font color="blue">input </font>Boolean iscontinuousSystem=true;

      <font color="blue">output </font>Real Kc[<font color="red">size</font>(ss.B, 2),<font color="red">size</font>(ss.A, 1)] <font color="darkgreen">
        &quot;Controller feedback gain matrix&quot;</font>;
      <font color="blue">output </font>Real Kf[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.C, 1)] <font color="darkgreen">&quot;Kalman feedback gain matrix&quot;</font>;

      <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> sslqg(
        <font color="blue">redeclare </font>Real A[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)],
        <font color="blue">redeclare </font>Real B[<font color="red">size</font>(ss.B, 1),<font color="red">size</font>(ss.B, 2)],
        <font color="blue">redeclare </font>Real C[<font color="red">size</font>(ss.C, 1),<font color="red">size</font>(ss.C, 2)],
        <font color="blue">redeclare </font>Real D[<font color="red">size</font>(ss.D, 1),<font color="red">size</font>(ss.D, 2)]) <font color="darkgreen">&quot;closed loop system&quot;</font>;

    <font color="blue">protected </font>
     Real AR[:,:]=<font color="red">transpose</font>(ss.A);
     Real BR[:,:]=<font color="red">transpose</font>(ss.C);
     Real CR[:,:]=<font color="red">zeros</font>(1, <font color="red">size</font>(AR, 1));
     Real DR[:,:]=<font color="red">zeros</font>(1, <font color="red">size</font>(BR, 2));  <font color="darkgreen">// System for lqr</font>
     <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> rss=<font color="red">StateSpace</font>(
         AR,
         BR,
         CR,
         DR);
      Real Sc[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 1)] <font color="darkgreen">
        &quot;solution of the Riccati equation, controller&quot;</font>;
      Real Sf[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 1)] <font color="darkgreen">
        &quot;solution of the Riccati equation, filter&quot;</font>;

    <font color="blue">algorithm </font>
      <font color="blue">if </font><font color="red">min</font>(<font color="red">size</font>(ss.A,1),<font color="red">size</font>(ss.A,2))&gt;0<font color="blue"> then</font>
      <font color="red">assert</font>(<font color="red">StateSpace.Analysis.isControllable</font>(ss),&quot;System in function \&quot;Modelica_LinearSystems2.StateSpace.Design.lqg\&quot; has to be controllable&quot;);

      <font color="blue">if </font>iscontinuousSystem<font color="blue"> then</font>
        (Sc,) := <font color="red">Math.Matrices.care</font>(
            ss.A,
            ss.B,
            R,
            Q);
        Kc := <font color="red">Math.Matrices.solve2</font>(R, <font color="red">transpose</font>(ss.B)*Sc);
      <font color="blue">else</font>
        (Sc,) := <font color="red">Math.Matrices.dare</font>(
            ss.A,
            ss.B,
            R,
            Q);
        Kc := <font color="red">Math.Matrices.solve2</font>(R + <font color="red">transpose</font>(ss.B)*Sc*ss.B, <font color="red">transpose</font>(ss.B)*Sc*
          ss.A);
      <font color="blue">end if</font>;

      <font color="red">assert</font>(<font color="red">StateSpace.Analysis.isObservable</font>(ss),&quot;System in function \&quot;Modelica_LinearSystems2.StateSpace.Design.lqg\&quot; has to be observable&quot;);
     <font color="blue">if </font>iscontinuousSystem<font color="blue"> then</font>
        (Sf,) := <font color="red">Math.Matrices.care</font>(
            rss.A,
            rss.B,
            V,
            W);
        Kf := <font color="red">transpose</font>(<font color="red">Math.Matrices.solve2</font>(V, ss.C*Sf));
      <font color="blue">else</font>
        (Sf,) := <font color="red">Math.Matrices.dare</font>(
            rss.A,
            rss.B,
            V,
            W);
        Kf := <font color="red">transpose</font>(<font color="red">Math.Matrices.solve2</font>(V + rss.C*Sf*rss.B, rss.C*Sf*rss.A));
      <font color="blue">end if</font>;

      <font color="blue">else</font>
        Kc := <font color="red">fill</font>(
          0,
          <font color="red">size</font>(ss.B, 2),
          <font color="red">size</font>(ss.A, 1));
        Kf := <font color="red">fill</font>(
          0,
          <font color="red">size</font>(ss.C, 1),
          <font color="red">size</font>(ss.A, 1));

      <font color="blue">end if</font>;

      sslqg.A := ss.A - Kf*ss.C - ss.B*Kc + Kf*ss.D*Kc;
      sslqg.B := Kf;
      sslqg.C := ss.C - ss.D*Kc;
      sslqg.D := <font color="red">zeros</font>(<font color="red">size</font>(ss.D,1),<font color="red">size</font>(ss.D,2));

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>lqg</textblock>;

  <font color="blue">end </font>Design</textblock>;

<textblock type="packagesmall" expanded="false" path="Modelica_LinearSystems2.StateSpace.Plot"><font color="blue">encapsulated </font><font color="blue">package</font> Plot <font color="darkgreen">
    &quot;Functions to plot state space system responses&quot;</font>

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Plot.polesAndZeros"><font color="blue">encapsulated </font><font color="blue">function</font> polesAndZeros <font color="darkgreen">
      &quot;Plot poles (i.e. eigenvalues) and/or invariant zeros of a state space system&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Utilities_Plot.html#Modelica_LinearSystems2.Utilities.Plot"
>Modelica_LinearSystems2.Utilities.Plot</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;Linear system in state space form&quot;</font>;
      <font color="blue">input </font>Boolean poles=true <font color="darkgreen">
        &quot;= true, to plot the poles (i.e. the eigenvalues) of ss&quot;</font>;
      <font color="blue">input </font>Boolean zeros=true <font color="darkgreen">&quot;= true, to plot the (invariant) zeros of ss &quot;</font>;

      <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.PartialPlotFunction"
>Modelica_LinearSystems2.Internal.PartialPlotFunction</A>(
         defaultDiagram = <font color="red">Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros</font>());

    <font color="blue">protected </font>
      Integer nx=<font color="red">size</font>(ss.A, 1);
      Real eval[nx,2];
      Real invZerosRe[:];
      Real invZerosIm[:];
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> invZeros[:];
      <A HREF="Modelica_LinearSystems2_Utilities_Plot_Records.html#Modelica_LinearSystems2.Utilities.Plot.Records.Curve"
>Plot.Records.Curve</A> curves[2];
      Integer i;
      <A HREF="Modelica_LinearSystems2_Utilities_Plot_Records.html#Modelica_LinearSystems2.Utilities.Plot.Records.Diagram"
>Plot.Records.Diagram</A> diagram2;
    <font color="blue">algorithm </font>
      <font color="darkgreen">// Determine eigen values</font>
      <font color="blue">if </font>poles<font color="blue"> then</font>
        eval := <font color="red">Modelica.Math.Matrices.eigenValues</font>(ss.A);
      <font color="blue">end if</font>;

      <font color="blue">if </font>zeros<font color="blue"> then</font>
        invZeros := <font color="red">StateSpace.Analysis.invariantZeros</font>(ss);
        invZerosRe := <font color="red">fill</font>(0,<font color="red">size</font>(invZeros,1));
        invZerosIm := <font color="red">fill</font>(0,<font color="red">size</font>(invZeros,1));
        <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(invZeros, 1)<font color="blue"> loop</font>
          invZerosRe[i] := invZeros[i].re;
          invZerosIm[i] := invZeros[i].im;
        <font color="blue">end for</font>;
      <font color="blue">end if</font>;

      i :=0;
      <font color="blue">if </font>poles<font color="blue"> then</font>
         i :=i + 1;
         curves[i] :=<font color="red">Plot.Records.Curve</font>(
                            x=eval[:, 1],
                            y=eval[:, 2],
                            legend=&quot;poles&quot;,
                            autoLine=false,
                            linePattern=Plot.Types.LinePattern.None,
                            lineSymbol=Plot.Types.PointSymbol.Cross);
      <font color="blue">end if</font>;

      <font color="blue">if </font>zeros<font color="blue"> then</font>
         i :=i + 1;
         curves[i] :=<font color="red">Plot.Records.Curve</font>(
                            x=invZerosRe,
                            y=invZerosIm,
                            legend=&quot;zeros&quot;,
                            autoLine=false,
                            linePattern=Plot.Types.LinePattern.None,
                            lineSymbol=Plot.Types.PointSymbol.Circle);
      <font color="blue">end if</font>;

         diagram2 :=defaultDiagram;
         diagram2.curve :=curves[1:i];
         <font color="red">Plot.diagram</font>(diagram2,device);

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>polesAndZeros</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Plot.bodeSISO"><font color="blue">encapsulated </font><font color="blue">function</font> bodeSISO <font color="darkgreen">
      &quot;Plot bode plot of the corresponding transfer function&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;state space system&quot;</font>;
      <font color="blue">input </font>Integer iu=1 <font color="darkgreen">&quot;index of input&quot;</font>;
      <font color="blue">input </font>Integer iy=1 <font color="darkgreen">&quot;index of output&quot;</font>;
      <font color="blue">input </font>Integer nPoints(min=2) = 200 <font color="darkgreen">&quot;Number of points&quot;</font>;
      <font color="blue">input </font>Boolean autoRange=true <font color="darkgreen">
        &quot;= true, if abszissa range is automatically determined&quot;</font>;
      <font color="blue">input </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Modelica.SIunits.Frequency</A> f_min=0.1 <font color="darkgreen">
        &quot;Minimum frequency value, if autoRange = false&quot;</font>;
      <font color="blue">input </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Modelica.SIunits.Frequency</A> f_max=10 <font color="darkgreen">
        &quot;Maximum frequency value, if autoRange = false&quot;</font>;

      <font color="blue">input </font>Boolean magnitude=true <font color="darkgreen">&quot;= true, to plot the magnitude of tf&quot;</font>;
      <font color="blue">input </font>Boolean phase=true <font color="darkgreen">&quot;= true, to plot the pase of tf&quot;</font>;

      <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.PartialPlotFunction"
>Modelica_LinearSystems2.Internal.PartialPlotFunction</A>(defaultDiagram=
            <font color="red">Modelica_LinearSystems2.Internal.DefaultDiagramBodePlot</font>());

    <font color="blue">protected </font>
      <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp <font color="darkgreen">&quot;ZP-Transfer functions to be plotted&quot;</font>;
      <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss_siso(
        <font color="blue">redeclare </font>Real A[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)],
        <font color="blue">redeclare </font>Real B[<font color="red">size</font>(ss.B, 1),1],
        <font color="blue">redeclare </font>Real C[1,<font color="red">size</font>(ss.C, 2)],
        <font color="blue">redeclare </font>Real D[1,1]);

    <font color="blue">algorithm </font>
      <font color="red">assert</font>(iu &lt;= <font color="red">size</font>(ss.B, 2)<font color="blue"> and </font>iu &gt; 0, &quot;index for input is &quot; + <font color="red">String</font>(iu) + &quot; which is not in [1, &quot;
         + <font color="red">String</font>(<font color="red">size</font>(ss.B, 2)) + &quot;].&quot;);
      <font color="red">assert</font>(iy &lt;= <font color="red">size</font>(ss.C, 1)<font color="blue"> and </font>iy &gt; 0, &quot;index for output is &quot; + <font color="red">String</font>(iy) + &quot; which is not in [1, &quot;
         + <font color="red">String</font>(<font color="red">size</font>(ss.C, 1)) + &quot;].&quot;);
      ss_siso := <font color="red">StateSpace</font>(
        A=ss.A,
        B=<font color="red">matrix</font>(ss.B[:, iu]),
        C=<font color="red">transpose</font>(<font color="red">matrix</font>(ss.C[iy, :])),
        D=<font color="red">matrix</font>(ss.D[iy, iu]));
      zp := <font color="red">StateSpace.Conversion.toZerosAndPoles</font>(ss_siso);

      <font color="red">ZerosAndPoles.Plot.bode</font>(
        zp,
        nPoints,
        autoRange,
        f_min,
        f_max,
        magnitude,
        phase,
        defaultDiagram=defaultDiagram,
        device=device);

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>bodeSISO</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Plot.bodeMIMO"><font color="blue">encapsulated </font><font color="blue">function</font> bodeMIMO <font color="darkgreen">
      &quot;Plot bode plot of all transfer functions, corresponding to the state space system&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Utilities_Plot.html#Modelica_LinearSystems2.Utilities.Plot"
>Modelica_LinearSystems2.Utilities.Plot</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;
      <font color="blue">input </font>Integer nPoints(min=2) = 200 <font color="darkgreen">&quot;Number of points&quot;</font>;
      <font color="blue">input </font>Boolean autoRange[:,:]=<font color="red">fill</font>(
          true,
          <font color="red">size</font>(ss.C, 1),
          <font color="red">size</font>(ss.B, 2)) <font color="darkgreen">
        &quot;= true, if abszissa range is automatically determined&quot;</font>;
      <font color="blue">input </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Modelica.SIunits.Frequency</A> f_min[:,:]=<font color="red">fill</font>(
          0.1,
          <font color="red">size</font>(ss.C, 1),
          <font color="red">size</font>(ss.B, 2)) <font color="darkgreen">&quot;Minimum frequency value, if autoRange = false&quot;</font>;
      <font color="blue">input </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Modelica.SIunits.Frequency</A> f_max[:,:]=<font color="red">fill</font>(
          10,
          <font color="red">size</font>(ss.C, 1),
          <font color="red">size</font>(ss.B, 2)) <font color="darkgreen">&quot;Maximum frequency value, if autoRange = false&quot;</font>;
      <font color="blue">input </font>Boolean magnitude=true <font color="darkgreen">&quot;= true, to plot the magnitude of tf&quot;</font>;
      <font color="blue">input </font>Boolean phase=true <font color="darkgreen">&quot;= true, to plot the pase of tf&quot;</font>;

      <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.PartialPlotFunction"
>Modelica_LinearSystems2.Internal.PartialPlotFunction</A>(defaultDiagram=
            <font color="red">Modelica_LinearSystems2.Internal.DefaultDiagramBodePlot</font>());

    <font color="blue">protected </font>
      <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf[<font color="red">size</font>(ss.C, 1),<font color="red">size</font>(ss.B, 2)] <font color="darkgreen">
        &quot;Transfer functions to be plotted&quot;</font>;
      <A HREF="Modelica_LinearSystems2_Utilities_Plot_Records.html#Modelica_LinearSystems2.Utilities.Plot.Records.Diagram"
>Plot.Records.Diagram</A> diagram2=defaultDiagram;
      String yNames[<font color="red">size</font>(ss.C, 1)];
      String uNames[<font color="red">size</font>(ss.B, 2)];

    <font color="blue">algorithm </font>
     <font color="darkgreen">// generate headings</font>
      <font color="blue">for </font>i1<font color="blue"> in </font>1:<font color="red">size</font>(ss.B, 2)<font color="blue"> loop</font>
        uNames[i1] := <font color="blue">if </font>ss.uNames[i1] == &quot;&quot;<font color="blue"> then </font>&quot;u&quot; + <font color="red">String</font>(i1)<font color="blue"> else </font>ss.uNames[i1];
      <font color="blue">end for</font>;
      <font color="blue">for </font>i1<font color="blue"> in </font>1:<font color="red">size</font>(ss.C, 1)<font color="blue"> loop</font>
        yNames[i1] := <font color="blue">if </font>ss.yNames[i1] == &quot;&quot;<font color="blue"> then </font>&quot;y&quot; + <font color="red">String</font>(i1)<font color="blue"> else </font>ss.yNames[i1];
      <font color="blue">end for</font>;

      tf := <font color="red">StateSpace.Conversion.toTransferFunctionMIMO</font>(ss);

      <font color="blue">for </font>i1<font color="blue"> in </font>1:<font color="red">size</font>(ss.C, 1)<font color="blue"> loop</font>
        <font color="blue">for </font>i2<font color="blue"> in </font>1:<font color="red">size</font>(ss.B, 2)<font color="blue"> loop</font>
          diagram2.heading := defaultDiagram.heading +&quot;  &quot;+ uNames[i2] + &quot; -&gt; &quot; + yNames[i1];
          <font color="red">TransferFunction.Plot.bode</font>(
            tf[i1, i2],
            nPoints,
            autoRange[i1, i2],
            f_min[i1, i2],
            f_max[i1, i2],
            magnitude,
            phase,
            defaultDiagram=diagram2,
            device=device);
        <font color="blue">end for</font>;
      <font color="blue">end for</font>;

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>bodeMIMO</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Plot.timeResponse"><font color="blue">encapsulated </font><font color="blue">function</font> timeResponse <font color="darkgreen">
      &quot;Plot the time response of the system. The response type is selectable&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.TimeResponse"
>Modelica_LinearSystems2.Types.TimeResponse</A>;

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Utilities_Plot.html#Modelica_LinearSystems2.Utilities.Plot"
>Modelica_LinearSystems2.Utilities.Plot</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;
      <font color="blue">input </font>Real dt=0 <font color="darkgreen">&quot;Sample time [s]&quot;</font>;
      <font color="blue">input </font>Real tSpan=0 <font color="darkgreen">&quot;Simulation time span [s]&quot;</font>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.TimeResponse"
>Modelica_LinearSystems2.Types.TimeResponse</A> response=
          Modelica_LinearSystems2.Types.TimeResponse.Step;

      <font color="blue">input </font>Real x0[<font color="red">size</font>(ss.A, 1)]=<font color="red">zeros</font>(<font color="red">size</font>(ss.A, 1)) <font color="darkgreen">&quot;Initial state vector&quot;</font>;

      <font color="blue">input </font>Boolean subPlots=true <font color="darkgreen">
        &quot;true if all subsystem time responses are plotted in one window with subplots&quot;</font>;

      <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.PartialPlotFunctionMIMO"
>Modelica_LinearSystems2.Internal.PartialPlotFunctionMIMO</A>(defaultDiagram=<font color="red">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</font>(
            heading=&quot;Time response&quot;));

    <font color="blue">protected </font>
      <A HREF="Modelica_LinearSystems2_Utilities_Plot_Records.html#Modelica_LinearSystems2.Utilities.Plot.Records.Curve"
>Plot.Records.Curve</A> curve;
      Integer i1;
      Integer i2;
      <A HREF="Modelica_LinearSystems2_Utilities_Plot_Records.html#Modelica_LinearSystems2.Utilities.Plot.Records.Diagram"
>Plot.Records.Diagram</A> diagram2[<font color="red">size</font>(ss.C, 1)];

      Real y[:,<font color="red">size</font>(ss.C, 1),<font color="blue">if </font>response == TimeResponse.Initial<font color="blue"> then </font>1<font color="blue"> else </font><font color="red">size</font>(ss.B,2)] <font color="darkgreen">
        &quot;Output response: (number of samples) x (number of outputs) x (number of inputs)&quot;</font>;
      Real t[:] <font color="darkgreen">&quot;Time vector: (number of samples)&quot;</font>;
      Real x[:,<font color="red">size</font>(ss.A, 1),<font color="blue">if </font>response == TimeResponse.Initial<font color="blue"> then </font>1<font color="blue"> else </font><font color="red">size</font>(ss.B,2)] <font color="darkgreen">
        &quot;State trajectories: (number of samples) x (number of states) x (number of inputs)&quot;</font>;
      String yNames[<font color="red">size</font>(ss.C, 1)];
      String uNames[<font color="red">size</font>(ss.B, 2)];
      Integer loops=<font color="blue">if </font>response == TimeResponse.Initial<font color="blue"> then </font>1<font color="blue"> else </font><font color="red">size</font>(ss.B,2);

    <font color="blue">algorithm </font>
      (y,t,x) := <font color="red">Modelica_LinearSystems2.StateSpace.Analysis.timeResponse</font>(
        sc=ss,
        dt=dt,
        tSpan=tSpan,
        response=response,
        x0=x0);

    <font color="darkgreen">// generate headings</font>
      <font color="blue">for </font>i1<font color="blue"> in </font>1:<font color="red">size</font>(ss.B, 2)<font color="blue"> loop</font>
        uNames[i1] := <font color="blue">if </font>ss.uNames[i1] == &quot;&quot;<font color="blue"> then </font>&quot;u&quot; + <font color="red">String</font>(i1)<font color="blue"> else </font>ss.uNames[
          i1];
      <font color="blue">end for</font>;
      <font color="blue">for </font>i1<font color="blue"> in </font>1:<font color="red">size</font>(ss.C, 1)<font color="blue"> loop</font>
        yNames[i1] := <font color="blue">if </font>ss.yNames[i1] == &quot;&quot;<font color="blue"> then </font>&quot;y&quot; + <font color="red">String</font>(i1)<font color="blue"> else </font>ss.yNames[
          i1];
      <font color="blue">end for</font>;

      <font color="blue">for </font>i2<font color="blue"> in </font>1:loops<font color="blue"> loop</font>
        <font color="blue">for </font>i1<font color="blue"> in </font>1:<font color="red">size</font>(ss.C, 1)<font color="blue"> loop</font>
          curve := <font color="red">Plot.Records.Curve</font>(
            x=t,
            y=y[:, i1, i2],
            autoLine=true);

          diagram2[i1] := defaultDiagram;
          diagram2[i1].curve := {curve};
          diagram2[i1].heading := <font color="blue">if </font>response == TimeResponse.Initial<font color="blue"> then </font>defaultDiagram.heading +&quot; &quot;+ yNames[i1]<font color="blue"> else </font>defaultDiagram.heading + &quot;  &quot; + uNames[i2] + &quot; -&gt; &quot; + yNames[i1];
          diagram2[i1].yLabel := yNames[i1];

        <font color="blue">end for</font>;

        <font color="blue">if </font>subPlots<font color="blue"> then</font>
          <font color="red">Plot.diagramVector</font>(diagram2, device);
        <font color="blue">else</font>
          <font color="blue">for </font>i1<font color="blue"> in </font>1:<font color="red">size</font>(ss.C, 1)<font color="blue"> loop</font>
            <font color="red">Plot.diagram</font>(diagram2[i1], device);
          <font color="blue">end for</font>;
        <font color="blue">end if</font>;
      <font color="blue">end for</font>;

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>timeResponse</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Plot.impulse"><font color="blue">encapsulated </font><font color="blue">function</font> impulse <font color="darkgreen">&quot;Impulse response plot&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.TimeResponse"
>Modelica_LinearSystems2.Types.TimeResponse</A>;

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Utilities_Plot.html#Modelica_LinearSystems2.Utilities.Plot"
>Modelica_LinearSystems2.Utilities.Plot</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;
      <font color="blue">input </font>Real dt=0 <font color="darkgreen">&quot;Sample time [s]&quot;</font>;
      <font color="blue">input </font>Real tSpan=0 <font color="darkgreen">&quot;Simulation time span [s]&quot;</font>;
      <font color="blue">input </font>Real x0[<font color="red">size</font>(ss.A, 1)]=<font color="red">zeros</font>(<font color="red">size</font>(ss.A, 1)) <font color="darkgreen">&quot;Initial state vector&quot;</font>;

      <font color="blue">input </font>Boolean subPlots=true <font color="darkgreen">
        &quot;true if all subsystem time responses are plotted in one window with subplots&quot;</font>;

      <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.PartialPlotFunctionMIMO"
>Modelica_LinearSystems2.Internal.PartialPlotFunctionMIMO</A>(defaultDiagram=<font color="red">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</font>(heading=&quot;Impulse response&quot;));

    <font color="blue">protected </font>
      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.TimeResponse"
>Modelica_LinearSystems2.Types.TimeResponse</A> response=Modelica_LinearSystems2.Types.TimeResponse.Impulse <font color="darkgreen">
        &quot;type of time response&quot;</font>;
    <font color="blue">algorithm </font>

      <font color="red">Modelica_LinearSystems2.StateSpace.Plot.timeResponse</font>(
        ss=ss,
        dt=dt,
        tSpan=tSpan,
        response=response,
        x0=x0,
        defaultDiagram=defaultDiagram,
        device=device);

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>impulse</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Plot.step"><font color="blue">encapsulated </font><font color="blue">function</font> step <font color="darkgreen">&quot;Step response plot&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.TimeResponse"
>Modelica_LinearSystems2.Types.TimeResponse</A>;

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Utilities_Plot.html#Modelica_LinearSystems2.Utilities.Plot"
>Modelica_LinearSystems2.Utilities.Plot</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;
      <font color="blue">input </font>Real dt=0 <font color="darkgreen">&quot;Sample time [s]&quot;</font>;
      <font color="blue">input </font>Real tSpan=0 <font color="darkgreen">&quot;Simulation time span [s]&quot;</font>;
      <font color="blue">input </font>Real x0[<font color="red">size</font>(ss.A, 1)]=<font color="red">zeros</font>(<font color="red">size</font>(ss.A, 1)) <font color="darkgreen">&quot;Initial state vector&quot;</font>;

      <font color="blue">input </font>Boolean subPlots=true <font color="darkgreen">
        &quot;true if all subsystem time responses are plotted in one window with subplots&quot;</font>;

      <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.PartialPlotFunctionMIMO"
>Modelica_LinearSystems2.Internal.PartialPlotFunctionMIMO</A>(defaultDiagram=<font color="red">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</font>(heading=&quot;Step response&quot;));

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.TimeResponse"
>Modelica_LinearSystems2.Types.TimeResponse</A> response=
          Modelica_LinearSystems2.Types.TimeResponse.Step <font color="darkgreen">
        &quot;type of time response&quot;</font>;

    <font color="blue">algorithm </font>
      <font color="red">Modelica_LinearSystems2.StateSpace.Plot.timeResponse</font>(
        ss=ss,
        dt=dt,
        tSpan=tSpan,
        response=response,
        x0=x0,
        defaultDiagram=defaultDiagram,
        device=device);

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>step</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Plot.ramp"><font color="blue">encapsulated </font><font color="blue">function</font> ramp <font color="darkgreen">&quot;Ramp response plot&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.TimeResponse"
>Modelica_LinearSystems2.Types.TimeResponse</A>;

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Utilities_Plot.html#Modelica_LinearSystems2.Utilities.Plot"
>Modelica_LinearSystems2.Utilities.Plot</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;
    <font color="blue">input </font>Real dt=0 <font color="darkgreen">&quot;Sample time [s]&quot;</font>;
    <font color="blue">input </font>Real tSpan=0 <font color="darkgreen">&quot;Simulation time span [s]&quot;</font>;
    <font color="blue">input </font>Real x0[<font color="red">size</font>(ss.A, 1)]=<font color="red">zeros</font>(<font color="red">size</font>(ss.A, 1)) <font color="darkgreen">&quot;Initial state vector&quot;</font>;

    <font color="blue">input </font>Boolean subPlots=true <font color="darkgreen">
        &quot;true if all subsystem time responses are plotted in one window with subplots&quot;</font>;

    <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.PartialPlotFunctionMIMO"
>Modelica_LinearSystems2.Internal.PartialPlotFunctionMIMO</A>(defaultDiagram=<font color="red">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</font>(
          heading=&quot;Ramp response&quot;));

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.TimeResponse"
>Modelica_LinearSystems2.Types.TimeResponse</A> response=
        Modelica_LinearSystems2.Types.TimeResponse.Ramp <font color="darkgreen">&quot;type of time response&quot;</font>;

    <font color="blue">algorithm </font>
    <font color="red">Modelica_LinearSystems2.StateSpace.Plot.timeResponse</font>(
          ss=ss,
          dt=dt,
          tSpan=tSpan,
          response=response,
          x0=x0,
          defaultDiagram=defaultDiagram,
          device=device);

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>ramp</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Plot.initialResponse"><font color="blue">encapsulated </font><font color="blue">function</font> initialResponse <font color="darkgreen">
      &quot;Initial condition response plot&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.TimeResponse"
>Modelica_LinearSystems2.Types.TimeResponse</A>;

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Utilities_Plot.html#Modelica_LinearSystems2.Utilities.Plot"
>Modelica_LinearSystems2.Utilities.Plot</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;
      <font color="blue">input </font>Real dt=0 <font color="darkgreen">&quot;Sample time [s]&quot;</font>;
      <font color="blue">input </font>Real tSpan=0 <font color="darkgreen">&quot;Simulation time span [s]&quot;</font>;
      <font color="blue">input </font>Real x0[<font color="red">size</font>(ss.A, 1)]=<font color="red">zeros</font>(<font color="red">size</font>(ss.A, 1)) <font color="darkgreen">&quot;Initial state vector&quot;</font>;

      <font color="blue">input </font>Boolean subPlots=true <font color="darkgreen">
        &quot;true if all subsystem time responses are plotted in one window with subplots&quot;</font>;

      <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.PartialPlotFunctionMIMO"
>Modelica_LinearSystems2.Internal.PartialPlotFunctionMIMO</A>(defaultDiagram=<font color="red">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</font>(
            heading=&quot;Initial response&quot;));

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.TimeResponse"
>Modelica_LinearSystems2.Types.TimeResponse</A> response=
          Modelica_LinearSystems2.Types.TimeResponse.Initial <font color="darkgreen">
        &quot;type of time response&quot;</font>;
    <font color="blue">algorithm </font>

      <font color="red">Modelica_LinearSystems2.StateSpace.Plot.timeResponse</font>(
        ss=ss,
        dt=dt,
        tSpan=tSpan,
        response=response,
        x0=x0,
        defaultDiagram=defaultDiagram,
        device=device);

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>initialResponse</textblock>;

<font color="blue">end </font>Plot</textblock>;

<textblock type="packagesmall" expanded="false" path="Modelica_LinearSystems2.StateSpace.Conversion"><font color="blue">encapsulated </font><font color="blue">package</font> Conversion <font color="darkgreen">
    &quot;Conversion functions from StateSpace into TransferFunction or ZerosAndPoles representations&quot;</font>

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Conversion.toZerosAndPoles"><font color="blue">encapsulated </font><font color="blue">function</font> toZerosAndPoles <font color="darkgreen">
      &quot;Generate a zeros-and-poles representation from a SISO state space representation&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;StateSpace object&quot;</font>;
    <font color="blue">protected </font>
    <font color="blue">input </font>Boolean cancel=true <font color="darkgreen">&quot;false to hinder cancellation&quot;</font>;
    <font color="blue">public </font>
    <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp;

    <font color="blue">protected </font>
    <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ssm=<font color="red">StateSpace.Transformation.toIrreducibleForm</font>(ss);
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> poles[:];
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> zeros[:];

    Real gain;
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> frequency;
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> Gs;
    Real As[:,:];
    Real pk;
    Integer i;
    Integer k;
    Boolean h;

  <font color="blue">algorithm </font>
    <font color="blue">if </font><font color="red">Modelica.Math.Vectors.length</font>(ssm.B[:, 1]) &gt; 0<font color="blue"> and </font>
        <font color="red">Modelica.Math.Vectors.length</font>(ssm.C[1, :]) &gt; 0<font color="blue"> then</font>

      poles := <font color="red">Complex.Internal.eigenValues_dhseqr</font>(ssm.A);<font color="darkgreen">//ssm.A is of upper Hessenberg form</font>
      zeros := <font color="blue">if </font>cancel<font color="blue"> then </font><font color="red">StateSpace.Internal.invariantZeros2</font>(ssm)<font color="blue"> else </font>
        <font color="red">StateSpace.Analysis.zerosAndPoles</font>(ss);

      <font color="blue">if </font><font color="red">size</font>(ss.C, 1) &lt;&gt; 1<font color="blue"> or </font><font color="red">size</font>(ss.B, 2) &lt;&gt; 1<font color="blue"> then</font>
        <font color="red">assert</font>(<font color="red">size</font>(ss.B, 2) == 1, &quot; function fromStateSpaceSISO expects a SISO-system as input\n but the number of inputs is &quot;
           + <font color="red">String</font>(<font color="red">size</font>(ss.B, 2)) + &quot; instead of 1&quot;);
        <font color="red">assert</font>(<font color="red">size</font>(ss.C, 1) == 1, &quot; function fromStateSpaceSISO expects a SISO-system as input\n but the number of outputs is &quot;
           + <font color="red">String</font>(<font color="red">size</font>(ss.C, 1)) + &quot; instead of 1&quot;);
      <font color="blue">end if</font>;

      zp := <font color="red">ZerosAndPoles</font>(
          z=zeros,
          p=poles,
          k=1);
  <font color="darkgreen">// set frequency to a complex value which is whether pole nor zero</font>
      frequency := <font color="red">Complex</font>(2*<font color="red">abs</font>(<font color="red">max</font>(<font color="red">cat</font>(
          1,
          zeros[:].re,
          poles[:].re)) + 1));
      Gs := <font color="red">ZerosAndPoles.Analysis.evaluate</font>(zp, frequency);

      As := -ssm.A;
      <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(As, 1)<font color="blue"> loop</font>
        As[i, i] := As[i, i] + frequency.re;
      <font color="blue">end for</font>;

      pk := <font color="red">StateSpace.Internal.partialGain</font>(As, ssm.B[:, 1]);
      gain := (ssm.C[1, <font color="red">size</font>(As, 1)]*pk + ss.D[1, 1])/Gs.re;

      zp := <font color="red">ZerosAndPoles</font>(
          z=zeros,
          p=poles,
          k=gain);

    <font color="blue">else</font>
      zp := <font color="red">ZerosAndPoles</font>(
          z=<font color="red">fill</font>(<font color="red">Complex</font>(0), 0),
          p=<font color="red">fill</font>(<font color="red">Complex</font>(0), 0),
          k=0);

    <font color="blue">end if</font>;
    zp.uName := ss.uNames[1];
    zp.yName := ss.yNames[1];

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>toZerosAndPoles</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Conversion.toTransferFunction"><font color="blue">function</font> toTransferFunction <font color="darkgreen">
      &quot;Generate a transfer function from a SISO state space representation&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;StateSpace object&quot;</font>;

    <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf;

    <font color="blue">protected </font>
    <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp;

  <font color="blue">algorithm </font>
    zp := <font color="red">toZerosAndPoles</font>(ss);
    tf := <font color="red">ZerosAndPoles.Conversion.toTransferFunction</font>(zp);

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>toTransferFunction</textblock>;

<textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Conversion.toZerosAndPolesMIMO"><font color="blue">encapsulated </font><font color="blue">function</font> toZerosAndPolesMIMO <font color="darkgreen">
      &quot;Generate a zeros-and-poles representation from a MIMO state space representation&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;StateSpace object&quot;</font>;

  <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp[<font color="red">size</font>(ss.C, 1),<font color="red">size</font>(ss.B, 2)];

    <font color="blue">protected </font>
  <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss_siso(
    <font color="blue">redeclare </font>Real A[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)],
    <font color="blue">redeclare </font>Real B[<font color="red">size</font>(ss.B, 1),1],
    <font color="blue">redeclare </font>Real C[1,<font color="red">size</font>(ss.C, 2)],
    <font color="blue">redeclare </font>Real D[1,1]);

  Integer ny=<font color="red">size</font>(ss.C, 1);
  Integer nu=<font color="red">size</font>(ss.B, 2);

<font color="blue">algorithm </font>
  <font color="blue">for </font>ic<font color="blue"> in </font>1:ny<font color="blue"> loop</font>
    <font color="blue">for </font>ib<font color="blue"> in </font>1:nu<font color="blue"> loop</font>
      ss_siso :=<font color="red"> StateSpace</font>(
          A=ss.A,
          B=<font color="red">matrix</font>(ss.B[:, ib]),
          C=<font color="red">transpose</font>(<font color="red">matrix</font>(ss.C[ic, :])),
          D=<font color="red">matrix</font>(ss.D[ic, ib]));
          zp[ic, ib] :=<font color="red"> StateSpace.Conversion.toZerosAndPoles</font>(ss_siso);
     <font color="blue">end for</font>;
  <font color="blue">end for</font>;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>toZerosAndPolesMIMO</textblock>;

<textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Conversion.toTransferFunctionMIMO"><font color="blue">function</font> toTransferFunctionMIMO <font color="darkgreen">
      &quot;Generate a transfer function of a MIMO system from state space representation&quot;</font>
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;StateSpace object&quot;</font>;

  <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf[<font color="red">size</font>(ss.C, 1),<font color="red">size</font>(ss.B, 2)] <font color="darkgreen">
        &quot;Matrix of transfer function objects&quot;</font>;

    <font color="blue">protected </font>
  <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp[:,:];
  <font color="blue">parameter </font>Integer m=<font color="red">size</font>(ss.B, 2);
  <font color="blue">parameter </font>Integer p=<font color="red">size</font>(ss.C, 1);

<font color="blue">algorithm </font>
  zp :=<font color="red"> Modelica_LinearSystems2.StateSpace.Conversion.toZerosAndPolesMIMO</font>(ss);
  <font color="blue">for </font>i1<font color="blue"> in </font>1:m<font color="blue"> loop</font>
    <font color="blue">for </font>i2<font color="blue"> in </font>1:p<font color="blue"> loop</font>
      tf[i2, i1] :=<font color="red"> ZerosAndPoles.Conversion.toTransferFunction</font>(zp[i2, i1]);
    <font color="blue">end for</font>;
  <font color="blue">end for</font>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>toTransferFunctionMIMO</textblock>;

<font color="blue">end </font>Conversion</textblock>;

  <textblock type="packagesmall" expanded="false" path="Modelica_LinearSystems2.StateSpace.Transformation"><font color="blue">encapsulated </font><font color="blue">package</font> Transformation <font color="darkgreen">
    &quot;State Space similarity transformations&quot;</font>

      <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Transformation.toSimilarForm"><font color="blue">encapsulated </font><font color="blue">function</font> toSimilarForm <font color="darkgreen">
      &quot;Perform the similarity transformation z = Tx (or x = inv(T)z) which leads to Az=T*A*inv(T), Bz=T*B, Cz=C*inv(T), Dz=D (or Az=inv(T)*A*T, Bz=inv(T)B, Cz=C*T, Dz=D)&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>;

        <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;state space system&quot;</font>;
        <font color="blue">input </font>Real T[<font color="red">size</font>(ss.A, 2),<font color="red">size</font>(ss.A, 1)] = <font color="red">identity</font>(<font color="red">size</font>(ss.A,1)) <font color="darkgreen">
        &quot;Transformation matrix&quot;</font>;
        <font color="blue">input </font>Boolean inverted=false <font color="darkgreen">
        &quot;false (default) for transformation z = Tx, true for x = Tz&quot;</font>;

        <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> tss(
          <font color="blue">redeclare </font>Real A[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)],
          <font color="blue">redeclare </font>Real B[<font color="red">size</font>(ss.B, 1),<font color="red">size</font>(ss.B, 2)],
          <font color="blue">redeclare </font>Real C[<font color="red">size</font>(ss.C, 1),<font color="red">size</font>(ss.C, 2)],
          <font color="blue">redeclare </font>Real D[<font color="red">size</font>(ss.D, 1),<font color="red">size</font>(ss.D, 2)]);

      <font color="blue">algorithm </font>
        <font color="blue">if </font>inverted<font color="blue"> then</font>
          tss.A := <font color="red">Matrices.solve2</font>(T, ss.A*T);
          tss.B := <font color="red">Matrices.solve2</font>(T, ss.B);
          tss.C := ss.C*T;
          tss.D := ss.D;
        <font color="blue">else</font>
          tss.A := <font color="red">transpose</font>(<font color="red">LAPACK.dgesvx</font>(T, <font color="red">transpose</font>(T*ss.A)));
          tss.B := T*ss.B;
          tss.C := <font color="red">transpose</font>(<font color="red">LAPACK.dgesvx</font>(T, <font color="red">transpose</font>(ss.C)));
          tss.D := ss.D;
        <font color="blue">end if</font>;
<textblock type="annotcomp" expanded="false">      <font color="blue">end </font>toSimilarForm</textblock>;

      <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Transformation.toObservabilityForm"><font color="blue">encapsulated </font><font color="blue">function</font> toObservabilityForm <font color="darkgreen">
      &quot;Perform the similarity transformation to the obervabillity canonical form&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal_Streams.html#Modelica_LinearSystems2.Internal.Streams"
>Modelica_LinearSystems2.Internal.Streams</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>;

        <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;state space system&quot;</font>;
        <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> tss(
          <font color="blue">redeclare </font>Real A[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)],
          <font color="blue">redeclare </font>Real B[<font color="red">size</font>(ss.B, 1),<font color="red">size</font>(ss.B, 2)],
          <font color="blue">redeclare </font>Real C[<font color="red">size</font>(ss.C, 1),<font color="red">size</font>(ss.C, 2)],
          <font color="blue">redeclare </font>Real D[<font color="red">size</font>(ss.D, 1),<font color="red">size</font>(ss.D, 2)]);

    <font color="blue">protected </font>
        Real V[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 1)] <font color="darkgreen">
        &quot;Matrix of the right eigenvectors of the matrix ss.A&quot;</font>;

        Integer nx=<font color="red">size</font>(ss.A, 1);

      <font color="blue">algorithm </font>
        <font color="red">assert</font>(<font color="red">size</font>(ss.C, 1) == 1<font color="blue"> and </font><font color="red">size</font>(ss.B, 2) == 1,
          &quot;Calculation of controllable form fails for systems with more than 1 inputs or outputs&quot;);
        <font color="red">assert</font>(<font color="red">Modelica_LinearSystems2.StateSpace.Analysis.isObservable</font>(ss),
          &quot;transformation ist not realizable since the system ist not obersvable&quot;);

        V[:, 1] := <font color="red">Modelica.Math.Matrices.solve</font>(<font color="red">StateSpace.Analysis.observabilityMatrix</font>(ss), <font color="red">vector</font>([
          <font color="red">fill</font>(
            0,
            1,
            nx - 1),1]));

        <font color="blue">for </font>i<font color="blue"> in </font>2:nx<font color="blue"> loop</font>
          V[:, i] := ss.A*V[:, i - 1];
        <font color="blue">end for</font>;

        tss := <font color="red">StateSpace.Transformation.toSimilarForm</font>(ss, V,inverted=true);

<textblock type="annotcomp" expanded="false">      <font color="blue">end </font>toObservabilityForm</textblock>;

      <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Transformation.toControllabilityForm"><font color="blue">encapsulated </font><font color="blue">function</font> toControllabilityForm <font color="darkgreen">
      &quot;Perform the similarity transformation to the controllability canonical form&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal_Streams.html#Modelica_LinearSystems2.Internal.Streams"
>Modelica_LinearSystems2.Internal.Streams</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>;

        <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;state space system&quot;</font>;
        <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> tss(
          <font color="blue">redeclare </font>Real A[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)],
          <font color="blue">redeclare </font>Real B[<font color="red">size</font>(ss.B, 1),<font color="red">size</font>(ss.B, 2)],
          <font color="blue">redeclare </font>Real C[<font color="red">size</font>(ss.C, 1),<font color="red">size</font>(ss.C, 2)],
          <font color="blue">redeclare </font>Real D[<font color="red">size</font>(ss.D, 1),<font color="red">size</font>(ss.D, 2)]);

    <font color="blue">protected </font>
        Real V[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 1)] <font color="darkgreen">
        &quot;Matrix of the right eigenvectors of the matrix ss.A&quot;</font>;

        Integer nx=<font color="red">size</font>(ss.A, 1);

      <font color="blue">algorithm </font>
        <font color="red">assert</font>(<font color="red">size</font>(ss.C, 1) == 1<font color="blue"> and </font><font color="red">size</font>(ss.B, 2) == 1,
          &quot;Calculation of controllable form fails for systems with more than 1 inputs or outputs&quot;);
        <font color="red">assert</font>(<font color="red">Modelica_LinearSystems2.StateSpace.Analysis.isControllable</font>(ss),
          &quot;transformation ist not realizable since the system ist not controllable&quot;);

        V[1, :] := <font color="red">Modelica.Math.Matrices.solve</font>(<font color="red">transpose</font>(<font color="red">StateSpace.Analysis.controllabilityMatrix</font>(ss)),
          <font color="red">vector</font>([<font color="red">fill</font>(
            0,
            nx - 1,
            1); 1]));

        <font color="blue">for </font>i<font color="blue"> in </font>2:nx<font color="blue"> loop</font>
          V[i, :] := V[i - 1, :]*ss.A;
        <font color="blue">end for</font>;

        tss := <font color="red">StateSpace.Transformation.toSimilarForm</font>(
                                ss, V);

<textblock type="annotcomp" expanded="false">      <font color="blue">end </font>toControllabilityForm</textblock>;

      <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Transformation.toDiagonalForm"><font color="blue">encapsulated </font><font color="blue">function</font> toDiagonalForm <font color="darkgreen">
      &quot;Perform the similarity transformation with the (real) inverse right eigenvector matrix of the system, that lead to the Jordan canonical form for single eigenvalues&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>;

        <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;state space system&quot;</font>;
        <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> tss(
          <font color="blue">redeclare </font>Real A[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)],
          <font color="blue">redeclare </font>Real B[<font color="red">size</font>(ss.B, 1),<font color="red">size</font>(ss.B, 2)],
          <font color="blue">redeclare </font>Real C[<font color="red">size</font>(ss.C, 1),<font color="red">size</font>(ss.C, 2)],
          <font color="blue">redeclare </font>Real D[<font color="red">size</font>(ss.D, 1),<font color="red">size</font>(ss.D, 2)]);

    <font color="blue">protected </font>
        Real V[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 1)] <font color="darkgreen">
        &quot;Matrix of the right eigenvectors of the matrix ss.A&quot;</font>;

      <font color="blue">algorithm </font>
        (,,,V,) := <font color="red">LAPACK.dgeev</font>(ss.A);

        tss := <font color="red">StateSpace.Transformation.toSimilarForm</font>(ss, V, inverted=true);

<textblock type="annotcomp" expanded="false">      <font color="blue">end </font>toDiagonalForm</textblock>;

      <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Transformation.toIrreducibleForm"><font color="blue">encapsulated </font><font color="blue">function</font> toIrreducibleForm <font color="darkgreen">
      &quot;Calculate a minimal controllable and observable block Hessenberg realization of a given SISO state-space representation &quot;</font>

       <font color="darkgreen">// test of SISO has to be added</font>
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;

        <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;State space system&quot;</font>;

    <font color="blue">protected </font>
        <A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.StateSpaceR"
>Modelica_LinearSystems2.Internal.StateSpaceR</A> ssm1=
            <font color="red">StateSpace.Internal.reducedCtrSystem</font>(ss);
        Integer nx=<font color="red">size</font>(ss.A, 1);
        Integer rankQ=ssm1.r;
        <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss2=<font color="red">StateSpace</font>(
              A=<font color="red">transpose</font>(ssm1.A[nx - rankQ + 1:nx, nx - rankQ + 1:nx]),
              B=<font color="red">transpose</font>(ssm1.C[:, nx - rankQ + 1:nx]),
              C=<font color="red">transpose</font>(ssm1.B[nx - rankQ + 1:nx, :]),
              D=ssm1.D);
        Integer nx2=ssm1.r;
        <A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.StateSpaceR"
>Modelica_LinearSystems2.Internal.StateSpaceR</A> ssm2=
            <font color="red">StateSpace.Internal.reducedCtrSystem</font>(ss2);
        Integer rankQ2=ssm2.r;
    <font color="blue">public </font>
        <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ssm3(
          <font color="blue">redeclare </font>Real A[rankQ2,rankQ2],
          <font color="blue">redeclare </font>Real B[rankQ2,<font color="red">size</font>(ss.B, 2)],
          <font color="blue">redeclare </font>Real C[<font color="red">size</font>(ss.C, 1),rankQ2],
          <font color="blue">redeclare </font>Real D[<font color="red">size</font>(ss.D, 1),<font color="red">size</font>(ss.D, 2)]);
      <font color="blue">algorithm </font>
        ssm3 := <font color="red">StateSpace</font>(
            A=<font color="red">transpose</font>(ssm2.A[nx2 - rankQ2 + 1:nx2, nx2 - rankQ2 + 1:nx2]),
            B=<font color="red">transpose</font>(ssm2.C[:, nx2 - rankQ2 + 1:nx2]),
            C=<font color="red">transpose</font>(ssm2.B[nx2 - rankQ2 + 1:nx2, :]),
            D=(ssm2.D));

<textblock type="annotcomp" expanded="false">      <font color="blue">end </font>toIrreducibleForm</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Transformation.extract"><font color="blue">encapsulated </font><font color="blue">function</font> extract <font color="darkgreen">
      &quot;Extract input/output related subsystems from state space system record&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;State space system&quot;</font>;
    <font color="blue">input </font>Integer outputIndex[:]={1} <font color="darkgreen">&quot;Vector of subsystem outputs indices&quot;</font>;
    <font color="blue">input </font>Integer inputIndex[:]={1} <font color="darkgreen">&quot;Vector of subsystem inputs indices&quot;</font>;
    <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> subSc(
      <font color="blue">redeclare </font>Real A[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)],
      <font color="blue">redeclare </font>Real B[<font color="red">size</font>(ss.B, 1),<font color="red">size</font>(inputIndex, 1)],
      <font color="blue">redeclare </font>Real C[<font color="red">size</font>(outputIndex, 1),<font color="red">size</font>(ss.C, 2)],
      <font color="blue">redeclare </font>Real D[<font color="red">size</font>(outputIndex, 1),<font color="red">size</font>(inputIndex, 1)]) <font color="darkgreen">
        &quot;Subsystem state space record&quot;</font>;

  <font color="blue">algorithm </font>
    subSc.A := ss.A;
    subSc.B := ss.B[:, inputIndex];
    subSc.C := ss.C[outputIndex, :];
    subSc.D := ss.D[outputIndex, inputIndex];

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>extract</textblock>;

  <font color="blue">end </font>Transformation</textblock>;

<textblock type="packagesmall" expanded="false" path="Modelica_LinearSystems2.StateSpace.Import"><font color="blue">encapsulated </font><font color="blue">package</font> Import <font color="darkgreen">
    &quot;Utilitiy functions to import StaeSpace representations&quot;</font>

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Import.fromFile"><font color="blue">encapsulated </font><font color="blue">function</font> fromFile <font color="darkgreen">
      &quot;Read a StateSpace data record from mat-file&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>;
    <font color="blue">input </font>String fileName=&quot;dslin.mat&quot; <font color="darkgreen">
        &quot;Name of the state space system data file&quot;</font>;
    <font color="blue">input </font>String matrixName=&quot;ABCD&quot; <font color="darkgreen">&quot;Name of the state space system matrix&quot;</font>;
    <font color="blue">protected </font>
    <font color="blue">input </font>Integer xuy[3]=<font color="red">Internal.readSystemDimension</font>(fileName, matrixName);
    <font color="blue">input </font>Integer nx=xuy[1];
    <font color="blue">input </font>Integer nu=xuy[2];
    <font color="blue">input </font>Integer ny=xuy[3];

    <font color="blue">public </font>
    <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> result(
      <font color="blue">redeclare </font>Real A[nx,nx],
      <font color="blue">redeclare </font>Real B[nx,nu],
      <font color="blue">redeclare </font>Real C[ny,nx],
      <font color="blue">redeclare </font>Real D[ny,nu]) <font color="darkgreen">&quot;= model linearized at initial point&quot;</font>;

    <font color="blue">protected </font>
    Real ABCD[nx + ny,nx + nu]=<font color="red">Modelica_LinearSystems2.Internal.Streams.readMatrixInternal</font>(
          fileName,
          matrixName,
          nx + ny,
          nx + nu);

  <font color="blue">algorithm </font>
    result.A := ABCD[1:nx, 1:nx];
    result.B := ABCD[1:nx, nx + 1:nx + nu];
    result.C := ABCD[nx + 1:nx + ny, 1:nx];
    result.D := ABCD[nx + 1:nx + ny, nx + 1:nx + nu];
    <font color="red">Modelica.Utilities.Streams.print</font>(&quot;StateSpace record loaded from file: \&quot;&quot;
       + fileName + &quot;\&quot;&quot;);

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>fromFile</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Import.fromModel"><font color="blue">function</font> fromModel <font color="darkgreen">
      &quot;Generate a StateSpace data record by linearization of a model&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

    <font color="blue">input </font>String modelName <font color="darkgreen">&quot;Name of the Modelica model&quot;</font>;
    <font color="blue">input </font>Real T_linearize=0 <font color="darkgreen">
        &quot;point in time of simulation to linearize the model&quot;</font>;
    <font color="blue">input </font>String fileName=&quot;dslin&quot; <font color="darkgreen">&quot;Name of the result file&quot;</font>;
    <font color="blue">protected </font>
    String fileName2=fileName + &quot;.mat&quot;;
    Boolean OK1 = <font color="red">simulateModel</font>(problem=modelName, startTime=0, stopTime=T_linearize);
    Boolean OK2 = <font color="red">importInitial</font>(&quot;dsfinal.txt&quot;);
    Boolean OK3 = <font color="red">linearizeModel</font>(problem=modelName, resultFile=fileName, startTime=T_linearize, stopTime=T_linearize+1);

    Real nxMat[1,1]=<font color="red">readMatrix</font>(fileName2, &quot;nx&quot;, 1, 1);
    Integer ABCDsizes[2]=<font color="red">readMatrixSize</font>(fileName2, &quot;ABCD&quot;);
    Integer nx=<font color="red">integer</font>(nxMat[1, 1]);
    Integer nu=ABCDsizes[2] - nx;
    Integer ny=ABCDsizes[1] - nx;
    Real ABCD[nx + ny,nx + nu]=<font color="red">readMatrix</font>(fileName2, &quot;ABCD&quot;, nx + ny, nx + nu);
    String xuyName[nx + nu + ny]=<font color="red">readStringMatrix</font>(fileName2, &quot;xuyName&quot;, nx + nu + ny);
    <font color="blue">public </font>
    <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> result(
      <font color="blue">redeclare </font>Real A[nx,nx],
      <font color="blue">redeclare </font>Real B[nx,nu],
      <font color="blue">redeclare </font>Real C[ny,nx],
      <font color="blue">redeclare </font>Real D[ny,nu]) <font color="darkgreen">&quot;= model linearized at initial point&quot;</font>;

  <font color="blue">algorithm </font>
    result.A := ABCD[1:nx, 1:nx];
    result.B := ABCD[1:nx, nx + 1:nx + nu];
    result.C := ABCD[nx + 1:nx + ny, 1:nx];
    result.D := ABCD[nx + 1:nx + ny, nx + 1:nx + nu];
    result.uNames := xuyName[nx + 1:nx + nu];
    result.yNames := xuyName[nx + nu + 1:nx + nu + ny];
    result.xNames := xuyName[1:nx];

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>fromModel</textblock>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>Import</textblock>;

<textblock type="packagesmall" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal"><font color="blue">encapsulated </font><font color="blue">package</font> Internal <font color="darkgreen">
    &quot;Internal library of record StateSpace (should not be directly used by user)&quot;</font>
    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
  <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons_Library.html#Modelica.Icons.Library"
>Modelica.Icons.Library</A>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.isSISO"><font color="blue">encapsulated </font><font color="blue">function</font> isSISO <font color="darkgreen">
      &quot;To check a state space system to be SISO (or not)&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;

    <font color="blue">output </font>Boolean isSISO;
  <font color="blue">algorithm </font>
    isSISO := <font color="red">size</font>(ss.B, 2) == 1<font color="blue"> and </font><font color="red">size</font>(ss.C, 1) == 1;
<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>isSISO</textblock>;

<textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.invariantZeros2"><font color="blue">encapsulated </font><font color="blue">function</font> invariantZeros2 <font color="darkgreen">
      &quot;Compute invariant zeros of linear SISO state space system with a generalized system matrix [A, B, C, D] which is of upper Hessenberg form&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;Linear system in state space form&quot;</font>;
  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> Zeros[:] <font color="darkgreen">
        &quot;Finite, invariant zeros of ss; size(Zeros,1) &lt;= size(ss.A,1)&quot;</font>;

    <font color="blue">protected </font>
  Integer nx=<font color="red">size</font>(ss.A, 1) <font color="darkgreen">&quot;Number of states&quot;</font>;
  Integer nu=<font color="red">size</font>(ss.B, 2) <font color="darkgreen">&quot;Number of inputs&quot;</font>;
  Integer ny=<font color="red">size</font>(ss.C, 1) <font color="darkgreen">&quot;Number of outputs&quot;</font>;
  Integer na=nx + nu;
  Real A[nx + ny,nx + nu]=[ss.A,ss.B; ss.C,ss.D];
  Real B[nx + ny,nx + nu]=[<font color="red">identity</font>(nx),<font color="red">zeros</font>(nx, nu);<font color="red"> zeros</font>(ny, nx + nu)];
  Real alphaReal[na];
  Real alphaImag[na];
  Real beta[na];
  Integer info;
  Real beta_small=100*Modelica.Constants.eps;
  Integer nZeros;
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> z[<font color="red">size</font>(ss.A, 1)];
  Integer j;
  Real normB=<font color="red">max</font>(beta_small,<font color="red">Modelica.Math.Matrices.norm</font>(ss.B, p=1));
<font color="blue">algorithm </font>
  <font color="red">assert</font>(nu == ny, &quot;Function invariantZeros requires currently that the number of
inputs (= &quot;
          +<font color="red"> String</font>(nu) + &quot;) = number of outputs (= &quot; +<font color="red"> String</font>(ny) + &quot;)
This condition is however not fulfilled&quot;);

<font color="darkgreen">// Compute zeros</font>

  (alphaReal,alphaImag,beta,info) :=
    <font color="red">Matrices.generalizedEigenvaluesTriangular</font>(A, B);

  <font color="red">assert</font>(info == 0,
    &quot;Failed to compute invariant zeros with function invariantZeros(..)&quot;);

<font color="darkgreen">// If beta[i] is zero, then zero i is infinite.</font>
  j := 1;
  <font color="blue">for </font>i<font color="blue"> in </font>1:na<font color="blue"> loop</font>

   <font color="blue">if </font>beta[i] &gt;= normB*1e-6<font color="blue"> then</font>
     <font color="darkgreen">// finite eigenvalue</font>
      z[j].re := <font color="blue">if </font><font color="red">abs</font>(alphaReal[i]) &gt;= normB*1e-12<font color="blue"> then </font>alphaReal[i]/beta[i]<font color="blue"> else </font>
              0;
      z[j].im := <font color="blue">if </font><font color="red">abs</font>(alphaImag[i]) &gt;= normB*1e-12<font color="blue"> then </font>alphaImag[i]/beta[i]<font color="blue"> else </font>
              0;
      j := j + 1;
    <font color="blue">end if</font>;
  <font color="blue">end for</font>;
  nZeros := j - 1;
  Zeros := z[1:nZeros];
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>invariantZeros2</textblock>;

<textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.characterizeEigenvalue"><font color="blue">function</font> characterizeEigenvalue <font color="darkgreen">
      &quot;Check stability, stabilizability, controllability, observability nad detectability of the single poles&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Modelica_LinearSystems2.Internal.Eigenvalue</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss=<font color="red">Modelica_LinearSystems2.StateSpace</font>(
      A=<font color="red">fill</font>(
        0,
        0,
        0),
      B=<font color="red">fill</font>(
        0,
        0,
        0),
      C=<font color="red">fill</font>(
        0,
        0,
        0),
      D=<font color="red">fill</font>(
        0,
        0,
        0));
  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Eigenvalue</A> evin[:];
  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Eigenvalue</A> ev[<font color="red">size</font>(ss.A, 1)];

    <font color="blue">protected </font>
  Real cPoles[:,2] <font color="darkgreen">&quot;controllable poles&quot;</font>;
  Real ncPoles[:,2] <font color="darkgreen">&quot;uncontrollable poles&quot;</font>;
  Real poles[<font color="red">size</font>(ss.A, 1),2] <font color="darkgreen">&quot;controllable and uncontrollable poles&quot;</font>;
  Integer n_c;
  Integer nx=<font color="red">size</font>(ss.A, 1);

  <A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Eigenvalue</A> cdummy[<font color="red">size</font>(ss.A, 1)];
  <A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Eigenvalue</A> odummy[<font color="red">size</font>(ss.A, 1)];
  <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> sst=<font color="red">StateSpace</font>(
      A=<font color="red">transpose</font>(ss.A),
      B=<font color="red">transpose</font>(ss.C),
      C=<font color="red">transpose</font>(ss.B),
      D=<font color="red">transpose</font>(ss.D));
  Boolean equal;
  Integer ii;

  Real eps=1e-16*<font color="red">Modelica.Math.Matrices.norm</font>(A=ss.A, p=1);
  Real factor_eps=1;
  Real absVector[nx];
  Integer indices[:];
  Integer indexMin;
  Real indexVector[:];
  Integer vv[:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> j =<font color="red"> Modelica_LinearSystems2.Math.Complex.j</font>();

<font color="blue">algorithm </font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
    ev[i].ev := evin[i].ev;
  <font color="blue">end for</font>;

  (cPoles,ncPoles,poles) :=<font color="red"> StateSpace.Internal.controllablePoles</font>(ss);
  n_c :=<font color="red"> size</font>(cPoles, 1);
  <font color="blue">for </font>i<font color="blue"> in </font>1:n_c<font color="blue"> loop</font>
    cdummy[i].ev := cPoles[i, 1]+cPoles[i, 2]*j;
    cdummy[i].isControllable := true;
  <font color="blue">end for</font>;
  <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(ncPoles, 1)<font color="blue"> loop</font>
    cdummy[n_c + i].ev := ncPoles[i, 1]+ncPoles[i, 2]*j;
    cdummy[n_c + i].isControllable := false;
  <font color="blue">end for</font>;

<font color="darkgreen">// controllable poles of the trnasposed system are the observable poles</font>
  (cPoles,ncPoles,poles) :=<font color="red"> StateSpace.Internal.controllablePoles</font>(sst);
  n_c :=<font color="red"> size</font>(cPoles, 1);
  <font color="blue">for </font>i<font color="blue"> in </font>1:n_c<font color="blue"> loop</font>
    odummy[i].ev := cPoles[i, 1]+cPoles[i, 2]*j;
    odummy[i].isObservable := true;
  <font color="blue">end for</font>;
  <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(ncPoles, 1)<font color="blue"> loop</font>
    odummy[n_c + i].ev := ncPoles[i, 1]+ncPoles[i, 2]*j;
    odummy[n_c + i].isObservable := false;
  <font color="blue">end for</font>;

<font color="darkgreen">// using ev.imag as an flag to mark the eigenvalues</font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
    absVector :=<font color="red"> fill</font>(1e50, nx);
    <font color="blue">for </font>ii<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
      <font color="blue">if </font><font color="blue">not </font>odummy[ii].imag<font color="blue"> then</font>
        absVector[ii] :=<font color="red"> Complex.&#39;abs&#39;</font>(ev[i].ev - odummy[ii].ev);
      <font color="blue">end if</font>;
    <font color="blue">end for</font>;
    (absVector,indices) :=<font color="red"> Modelica.Math.Vectors.sort</font>(absVector);
    indexMin := indices[1];
    ev[i].isObservable := odummy[indexMin].isObservable;
    odummy[indexMin].imag := true;
  <font color="blue">end for</font>;

  <font color="blue">for </font>i<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
    absVector :=<font color="red"> fill</font>(1e50, nx);
    <font color="blue">for </font>ii<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
      <font color="blue">if </font><font color="blue">not </font>cdummy[ii].imag<font color="blue"> then</font>
        absVector[ii] :=<font color="red"> Complex.&#39;abs&#39;</font>(ev[i].ev - cdummy[ii].ev);
      <font color="blue">end if</font>;
    <font color="blue">end for</font>;
    (absVector,indices) :=<font color="red"> Modelica.Math.Vectors.sort</font>(absVector);
    indexMin := indices[1];
    ev[i].isControllable := cdummy[indexMin].isControllable;
    cdummy[indexMin].imag := true;
  <font color="blue">end for</font>;

  <font color="blue">for </font>i<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
    ev[i] :=<font color="red"> Eigenvalue</font>(
      ev[i].ev,
      ev[i].isControllable,
      ev[i].isObservable);
  <font color="blue">end for</font>;

<font color="blue">end </font>characterizeEigenvalue</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.isStabilizableSISO"><font color="blue">encapsulated </font><font color="blue">function</font> isStabilizableSISO <font color="darkgreen">
      &quot;To check wether a SISO system is stabliziable&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;

    <font color="blue">protected </font>
    <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.StateSpaceR"
>Modelica_LinearSystems2.Internal.StateSpaceR</A> ssm=
        <font color="red">StateSpace.Internal.cntrHessenberg</font>(ss);
    <font color="blue">public </font>
    <font color="blue">output </font>Boolean stabilizable;

    <font color="blue">protected </font>
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> evd[:]=<font color="red">fill</font>(<font color="red">Complex</font>(0), <font color="red">size</font>(ss.A, 1) - ssm.r);

  <font color="blue">algorithm </font>
    <font color="blue">if </font><font color="red">size</font>(ss.C, 1) &lt;&gt; 1<font color="blue"> or </font><font color="red">size</font>(ss.B, 2) &lt;&gt; 1<font color="blue"> then</font>
      <font color="red">assert</font>(<font color="red">size</font>(ss.B, 2) == 1,
        &quot;A SISO-system is expected as input\n but the number of inputs is &quot; +
        <font color="red">String</font>(<font color="red">size</font>(ss.B, 2)) + &quot; instead of 1&quot;);
      <font color="red">assert</font>(<font color="red">size</font>(ss.C, 1) == 1,
        &quot; A SISO-system is expected as input\n but the number of outputs is &quot; +
        <font color="red">String</font>(<font color="red">size</font>(ss.C, 1)) + &quot; instead of 1&quot;);
    <font color="blue">end if</font>;
    evd := <font color="red">Complex.eigenValues</font>(ssm.A[ssm.r + 1:<font color="red">size</font>(ss.A, 1), ssm.r + 1:<font color="red">size</font>(ss.A,
      1)]);
    stabilizable := true;

    <font color="blue">if </font><font color="red">size</font>(ss.A, 1) &gt; ssm.r<font color="blue"> then</font>
       <font color="blue">for </font>i1<font color="blue"> in </font>1:<font color="red">size</font>(evd, 1)<font color="blue"> loop</font>
        stabilizable := stabilizable<font color="blue"> and </font>evd[i1].re &lt; 0;
      <font color="blue">end for</font>;
    <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>isStabilizableSISO</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.isStabilizableMIMO"><font color="blue">encapsulated </font><font color="blue">function</font> isStabilizableMIMO <font color="darkgreen">
      &quot;To check wether a MIMO system is stabliziable&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;

      <font color="blue">output </font>Boolean stabilizable;

    <font color="blue">protected </font>
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> evnc[:] <font color="darkgreen">&quot;complex vector of uncontrollable poles&quot;</font>;
      Real cPoles[:,2] <font color="darkgreen">&quot;controllable poles&quot;</font>;
      Real ncPoles[:,2] <font color="darkgreen">&quot;uncontrollable poles&quot;</font>;
      Real poles[<font color="red">size</font>(ss.A, 1),2] <font color="darkgreen">&quot;controllable and uncontrollable poles&quot;</font>;
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> j=<font color="red">Modelica_LinearSystems2.Math.Complex.j</font>();

  <font color="blue">algorithm </font>
      (cPoles,ncPoles,poles) := <font color="red">StateSpace.Internal.controllablePoles</font>(ss);
      evnc := <font color="red">fill</font>(<font color="red">Complex</font>(0), <font color="red">size</font>(ncPoles, 1));
      <font color="blue">for </font>i1<font color="blue"> in </font>1:<font color="red">size</font>(ncPoles, 1)<font color="blue"> loop</font>
        evnc[i1] := ncPoles[i1, 1] + j*ncPoles[i1, 2];
      <font color="blue">end for</font>;

      stabilizable := true;

      <font color="blue">if </font><font color="red">size</font>(ss.A, 1) &gt; <font color="red">size</font>(cPoles, 1)<font color="blue"> then</font>
        <font color="blue">for </font>i1<font color="blue"> in </font>1:<font color="red">size</font>(ncPoles, 1)<font color="blue"> loop</font>
          stabilizable := stabilizable<font color="blue"> and </font>ncPoles[i1, 1] &lt; 0;
        <font color="blue">end for</font>;
      <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>isStabilizableMIMO</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.isDetectableSISO"><font color="blue">encapsulated </font><font color="blue">function</font> isDetectableSISO <font color="darkgreen">
      &quot;To check wether a SISO system is detectable&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;

    <font color="blue">protected </font>
    <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.StateSpaceR"
>Modelica_LinearSystems2.Internal.StateSpaceR</A> ssm=
        <font color="red">StateSpace.Internal.cntrHessenberg</font>(
        <font color="red">StateSpace.Internal.transposeStateSpace</font>(ss));
    <font color="blue">public </font>
    <font color="blue">output </font>Boolean detectable;
    <font color="blue">protected </font>
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> evd[:]=<font color="red">fill</font>(<font color="red">Complex</font>(0), <font color="red">size</font>(ss.A, 1) - ssm.r);

  <font color="blue">algorithm </font>
    <font color="blue">if </font><font color="red">size</font>(ss.C, 1) &lt;&gt; 1<font color="blue"> or </font><font color="red">size</font>(ss.B, 2) &lt;&gt; 1<font color="blue"> then</font>
      <font color="red">assert</font>(<font color="red">size</font>(ss.B, 2) == 1,
        &quot;A SISO-system is expected as input\n but the number of inputs is &quot; +
        <font color="red">String</font>(<font color="red">size</font>(ss.B, 2)) + &quot; instead of 1&quot;);
      <font color="red">assert</font>(<font color="red">size</font>(ss.C, 1) == 1,
        &quot; A SISO-system is expected as input\n but the number of outputs is &quot; +
        <font color="red">String</font>(<font color="red">size</font>(ss.C, 1)) + &quot; instead of 1&quot;);
    <font color="blue">end if</font>;
    evd := <font color="red">Complex.eigenValues</font>(ssm.A[ssm.r + 1:<font color="red">size</font>(ss.A, 1), ssm.r + 1:<font color="red">size</font>(ss.A,1)]);

    <font color="blue">if </font><font color="red">size</font>(ss.A, 1) == ssm.r<font color="blue"> then</font>
      detectable := true;

    <font color="blue">else</font>
      detectable := true;
      <font color="blue">for </font>i1<font color="blue"> in </font>1:<font color="red">size</font>(evd, 1)<font color="blue"> loop</font>
        detectable := detectable<font color="blue"> and </font>evd[i1].re &lt; 0;
      <font color="blue">end for</font>;
    <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>isDetectableSISO</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.isDetectableMIMO"><font color="blue">encapsulated </font><font color="blue">function</font> isDetectableMIMO <font color="darkgreen">
      &quot;To check wether a MIMO system is detectable&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;

      <font color="blue">output </font>Boolean detectable;

    <font color="blue">protected </font>
      <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> sst=<font color="red">StateSpace.Internal.transposeStateSpace</font>(ss);

      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> evnd[:] <font color="darkgreen">&quot;complex vector of uncontrollable poles&quot;</font>;
      Real dPoles[:,2] <font color="darkgreen">&quot;controllable poles&quot;</font>;
      Real ndPoles[:,2] <font color="darkgreen">&quot;uncontrollable poles&quot;</font>;
      Real poles[<font color="red">size</font>(ss.A, 1),2] <font color="darkgreen">&quot;controllable and uncontrollable poles&quot;</font>;
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> j=<font color="red">Modelica_LinearSystems2.Math.Complex.j</font>();

  <font color="blue">algorithm </font>
      (dPoles,ndPoles,poles) := <font color="red">StateSpace.Internal.controllablePoles</font>(sst);
      evnd := <font color="red">fill</font>(<font color="red">Complex</font>(0), <font color="red">size</font>(ndPoles, 1));
      <font color="blue">for </font>i1<font color="blue"> in </font>1:<font color="red">size</font>(ndPoles, 1)<font color="blue"> loop</font>
        evnd[i1] := ndPoles[i1, 1] + j*ndPoles[i1, 2];
      <font color="blue">end for</font>;

      detectable := true;

      <font color="blue">if </font><font color="red">size</font>(sst.A, 1) == <font color="red">size</font>(dPoles, 1)<font color="blue"> then</font>
        detectable := true;
      <font color="blue">else</font>
        <font color="blue">for </font>i1<font color="blue"> in </font>1:<font color="red">size</font>(ndPoles, 1)<font color="blue"> loop</font>
          detectable := detectable<font color="blue"> and </font>ndPoles[i1, 1] &lt; 0;
        <font color="blue">end for</font>;
      <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>isDetectableMIMO</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.isObservableSISO"><font color="blue">encapsulated </font><font color="blue">function</font> isObservableSISO <font color="darkgreen">
      &quot;To check wether a SISO system is observable&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

     <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;

    <font color="blue">protected </font>
     <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss2=<font color="red">StateSpace.Internal.transposeStateSpace</font>(ss);

     <A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.StateSpaceR"
>Modelica_LinearSystems2.Internal.StateSpaceR</A> ssm2=
         <font color="red">StateSpace.Internal.reducedCtrSystem</font>(ss2);
    <font color="blue">public </font>
     <font color="blue">output </font>Boolean observable;
  <font color="blue">algorithm </font>
   <font color="blue">if </font><font color="red">size</font>(ss.C, 1) &lt;&gt; 1<font color="blue"> or </font><font color="red">size</font>(ss.B, 2) &lt;&gt; 1<font color="blue"> then</font>
         <font color="red">assert</font>(<font color="red">size</font>(ss.B, 2) == 1,
           &quot;A SISO-system is expected as input\n but the number of inputs is &quot;
            + <font color="red">String</font>(<font color="red">size</font>(ss.B, 2)) + &quot; instead of 1&quot;);
         <font color="red">assert</font>(<font color="red">size</font>(ss.C, 1) == 1,
           &quot; A SISO-system is expected as input\n but the number of outputs is &quot;
            + <font color="red">String</font>(<font color="red">size</font>(ss.C, 1)) + &quot; instead of 1&quot;);
       <font color="blue">end if</font>;
     observable := <font color="red">size</font>(ss.A, 1) == ssm2.r;

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>isObservableSISO</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.isControllableSISO"><font color="blue">encapsulated </font><font color="blue">function</font> isControllableSISO <font color="darkgreen">
      &quot;To check a SISO system wether it is controllable&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;

    <font color="blue">protected </font>
    <A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.StateSpaceR"
>Modelica_LinearSystems2.Internal.StateSpaceR</A> ssm=
        <font color="red">StateSpace.Internal.reducedCtrSystem</font>(ss);

    <font color="blue">public </font>
    <font color="blue">output </font>Boolean controllable;
  <font color="blue">algorithm </font>
    <font color="blue">if </font><font color="red">size</font>(ss.C, 1) &lt;&gt; 1<font color="blue"> or </font><font color="red">size</font>(ss.B, 2) &lt;&gt; 1<font color="blue"> then</font>
      <font color="red">assert</font>(<font color="red">size</font>(ss.B, 2) == 1,
        &quot;A SISO-system is expected as input\n but the number of inputs is &quot;
         + <font color="red">String</font>(<font color="red">size</font>(ss.B, 2)) + &quot; instead of 1&quot;);
      <font color="red">assert</font>(<font color="red">size</font>(ss.C, 1) == 1,
        &quot; A SISO-system is expected as input\n but the number of outputs is &quot;
         + <font color="red">String</font>(<font color="red">size</font>(ss.C, 1)) + &quot; instead of 1&quot;);
    <font color="blue">end if</font>;
    controllable := <font color="red">size</font>(ss.A, 1) == ssm.r;

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>isControllableSISO</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.isControllableMIMO"><font color="blue">encapsulated </font><font color="blue">function</font> isControllableMIMO <font color="darkgreen">
      &quot;To check a MIMO system wether it is controllable&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;
      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.StaircaseMethod"
>Modelica_LinearSystems2.Types.StaircaseMethod</A> method=
          Modelica_LinearSystems2.Types.StaircaseMethod.SVD;

      <font color="blue">output </font>Boolean controllable;
  <font color="blue">algorithm </font>
      <font color="red">assert</font>(method == Modelica_LinearSystems2.Types.StaircaseMethod.SVD<font color="blue"> or </font>
        method == Modelica_LinearSystems2.Types.StaircaseMethod.QR, &quot;\nMethods for staircase algorithm are QR factorization or singular value decomposition. Therefore, 
the variable \&quot;method\&quot; in \&quot;Modelica_LinearSystems2.StateSpace.Internal.isControllableMIMO\&quot; has to be qr or svd but is method = &quot;
         + <font color="red">String</font>(method));
      <font color="blue">if </font><font color="red">min</font>(<font color="red">size</font>(ss.B)) == 0<font color="blue"> then</font>
        controllable := false;
      <font color="blue">else</font>
        <font color="blue">if </font>method == Modelica_LinearSystems2.Types.StaircaseMethod.QR<font color="blue"> then</font>
          controllable := <font color="red">StateSpace.Internal.staircaseQR</font>(ss);
        <font color="blue">else</font>
          controllable := <font color="red">StateSpace.Internal.staircaseSVD</font>(ss);
        <font color="blue">end if</font>;
      <font color="blue">end if</font>;
<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>isControllableMIMO</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.isObservableMIMO"><font color="blue">encapsulated </font><font color="blue">function</font> isObservableMIMO <font color="darkgreen">
      &quot;To check a MIMO system wether it is observable&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;
      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.StaircaseMethod"
>Modelica_LinearSystems2.Types.StaircaseMethod</A> method=
          Modelica_LinearSystems2.Types.StaircaseMethod.SVD;

    <font color="blue">protected </font>
      <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss2=<font color="red">StateSpace.Internal.transposeStateSpace</font>(ss);

    <font color="blue">public </font>
      <font color="blue">output </font>Boolean observable;
  <font color="blue">algorithm </font>
      <font color="red">assert</font>(method == Modelica_LinearSystems2.Types.StaircaseMethod.SVD<font color="blue"> or </font>
        method == Modelica_LinearSystems2.Types.StaircaseMethod.QR, &quot;\nMethods for staircase algorithm are QR factorization or singular value decomposition. Therefore, 
the variable \&quot;method\&quot; in \&quot;Modelica_LinearSystems2.StateSpace.Internal.isControllableMIMO\&quot; has to be qr or svd but is method = &quot;
         + <font color="red">String</font>(method));
      <font color="blue">if </font><font color="red">min</font>(<font color="red">size</font>(ss.C)) == 0<font color="blue"> then</font>
        observable := false;
      <font color="blue">else</font>
        <font color="blue">if </font>method == Modelica_LinearSystems2.Types.StaircaseMethod.QR<font color="blue"> then</font>
          observable := <font color="red">StateSpace.Internal.staircaseQR</font>(ss2);
        <font color="blue">else</font>
          observable := <font color="red">StateSpace.Internal.staircaseSVD</font>(ss2);
        <font color="blue">end if</font>;

      <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>isObservableMIMO</textblock>;

 <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.isControllableAndObservableSISO"><font color="blue">encapsulated </font><font color="blue">function</font> isControllableAndObservableSISO <font color="darkgreen">
      &quot;To check whether a SISO system is controllable and observable&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;

    <font color="blue">protected </font>
    <A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.StateSpaceR"
>Modelica_LinearSystems2.Internal.StateSpaceR</A> ssm1=
        <font color="red">StateSpace.Internal.reducedCtrSystem</font>(ss);
    Integer nx=<font color="red">size</font>(ss.A, 1);
    Integer rankQ=ssm1.r;
    <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss2=<font color="red">StateSpace</font>(
          A=<font color="red">transpose</font>(ssm1.A[nx - rankQ + 1:nx, nx - rankQ + 1:nx]),
          B=<font color="red">transpose</font>(ssm1.C[:, nx - rankQ + 1:nx]),
          C=<font color="red">transpose</font>(ssm1.B[nx - rankQ + 1:nx, :]),
          D=ssm1.D);
    Integer nx2=ssm1.r;
    <A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.StateSpaceR"
>Modelica_LinearSystems2.Internal.StateSpaceR</A> ssm2=
        <font color="red">StateSpace.Internal.reducedCtrSystem</font>(ss2);
    <font color="blue">public </font>
    <font color="blue">output </font>Boolean controllableAndObservable;
 <font color="blue">algorithm </font>
    <font color="blue">if </font><font color="red">size</font>(ss.C, 1) &lt;&gt; 1<font color="blue"> or </font><font color="red">size</font>(ss.B, 2) &lt;&gt; 1<font color="blue"> then</font>
      <font color="red">assert</font>(<font color="red">size</font>(ss.B, 2) == 1,
        &quot;A SISO-system is expected as input\n but the number of inputs is &quot; +
        <font color="red">String</font>(<font color="red">size</font>(ss.B, 2)) + &quot; instead of 1&quot;);
      <font color="red">assert</font>(<font color="red">size</font>(ss.C, 1) == 1,
        &quot; A SISO-system is expected as input\n but the number of outputs is &quot;
         +<font color="red"> String</font>(<font color="red">size</font>(ss.C, 1)) + &quot; instead of 1&quot;);
    <font color="blue">end if</font>;
    controllableAndObservable :=<font color="red"> size</font>(ss.A, 1) == ssm2.r;
 <font color="blue">equation </font>

 <font color="blue">end </font>isControllableAndObservableSISO</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.readLength_nx"><font color="blue">encapsulated </font><font color="blue">function</font> readLength_nx <font color="darkgreen">
      &quot;Read the order nx of a state space system from a file&quot;</font>

    <font color="blue">input </font>String fileName=&quot;ss_siso.mat&quot; <font color="darkgreen">
        &quot;Name of the state space system data file&quot;</font>;
    <font color="blue">output </font>Integer nx;
    <font color="blue">protected </font>
    Real nxMat[1,1]=<font color="red">readMatrix</font>(
            fileName,
            &quot;nx&quot;,
            1,
            1);
  <font color="blue">algorithm </font>
    nx := <font color="red">integer</font>(nxMat[1, 1]);
  <font color="blue">end </font>readLength_nx</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.staircaseQR"><font color="blue">encapsulated </font><font color="blue">function</font> staircaseQR <font color="darkgreen">
      &quot;Staircase algorithm to put a state space system to controller Hessenberg form&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Vectors.html#Modelica_LinearSystems2.Math.Vectors"
>Modelica_LinearSystems2.Math.Vectors</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;

    <font color="blue">output </font>Boolean isControllable;
    <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.StateSpaceR"
>Modelica_LinearSystems2.Internal.StateSpaceR</A> ssm1(
      <font color="blue">redeclare </font>Real A[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)],
      <font color="blue">redeclare </font>Real B[<font color="red">size</font>(ss.B, 1),<font color="red">size</font>(ss.B, 2)],
      <font color="blue">redeclare </font>Real C[<font color="red">size</font>(ss.C, 1),<font color="red">size</font>(ss.C, 2)],
      <font color="blue">redeclare </font>Real D[<font color="red">size</font>(ss.D, 1),<font color="red">size</font>(ss.D, 2)]) <font color="darkgreen">
        &quot;controllable state space system&quot;</font>;
    <font color="blue">output </font>Real PP[:,:];
    <font color="blue">protected </font>
    Real A[:,:];
    Real B[<font color="red">size</font>(ss.B, 1),<font color="red">size</font>(ss.B, 2)];
    Real C[:,:];
    Real Q[:,:];
    Real Q2[:,:];
    Real R[:,:];

    Real P[:,:];
    Real tau[:];

    Integer nx=<font color="red">size</font>(ss.A, 1);
    Integer nu=<font color="red">size</font>(ss.B, 2);
    Integer n1;
    Boolean stop;
    Real normA=<font color="red">Modelica.Math.Matrices.norm</font>(A=ss.A, p=1);
    Real eps=normA*1e-10;
    Integer stairStepinSys;
    Integer info;
    Integer nn;
    Integer stairStep;
    Integer rankR;

  <font color="blue">algorithm </font>
    <font color="blue">if </font>nu &gt; 0<font color="blue"> then</font>
    <font color="blue">if </font>nx &gt; 1<font color="blue"> then</font>

       <font color="darkgreen">//#####  first step of staircase</font>
         <font color="darkgreen">// transform b-&gt;Q&#39;b = {*,0,...,0} and c-&gt;cQ, A-&gt;Q&#39;AQ</font>

      (Q,R,tau,Q2) := <font color="red">Matrices.QR</font>( ss.B);
      B := [R; <font color="red">zeros</font>(nx - nu, nu)];<font color="darkgreen">  // should be the same as transopse(Q2)*ss.B</font>

      A := <font color="red">transpose</font>(Q2)*ss.A;
      A := A*Q2;
      C := ss.C*Q2;
      PP := <font color="red">transpose</font>(Q2);

      stairStep := 0;
      rankR := 0;
       <font color="darkgreen">// for i in 1:size(R, 1) loop</font>
       <font color="darkgreen">//   if abs(R[i, i]) &gt; eps then</font>
       <font color="darkgreen">//     rankR := rankR + 1;</font>
       <font color="darkgreen">//   end if;</font>
       <font color="darkgreen">// end for;</font>

  <font color="darkgreen">//  !!!! rank has to be determined. In the case of ill conditioned systems svd should be used</font>
      <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">min</font>(<font color="red">size</font>(R, 1), <font color="red">size</font>(R, 2))<font color="blue"> loop</font>
        <font color="blue">if </font><font color="red">abs</font>(R[i, <font color="red">size</font>(R, 2) - <font color="red">min</font>(<font color="red">size</font>(R, 1), <font color="red">size</font>(R, 2)) + i]) &gt; eps<font color="blue"> then</font>
          rankR := rankR + 1;
        <font color="blue">end if</font>;
      <font color="blue">end for</font>;
      stairStep := stairStep + rankR;
      n1 := nx - stairStep;
      stop := false;

       <font color="darkgreen">// #######  buildig rest of staircase</font>
      <font color="blue">while </font><font color="blue">not </font>stop<font color="blue"> loop</font>

        (Q,R,tau,Q2) := <font color="red">Matrices.QR</font>( A[stairStep + 1:nx, stairStep - rankR +
          1:stairStep]);
        P := [<font color="red">identity</font>(nx - n1),<font color="red">zeros</font>(nx - n1, n1); <font color="red">zeros</font>(n1, nx - n1),Q2];
        PP := <font color="red">transpose</font>(P)*PP;
        A := [A[1:stairStep, 1:stairStep],A[1:stairStep, stairStep + 1:nx]*Q2;
          <font color="red">transpose</font>(Q2)*A[stairStep + 1:nx, 1:stairStep],<font color="red">transpose</font>(Q2)*A[
          stairStep + 1:nx, stairStep + 1:nx]*Q2];
         <font color="darkgreen">//=transpose(P)*A*P = [A11, A12*Q2; transpose(Q2)*A21, transpose(Q2)*A22*Q2]</font>
        C[:, nx - n1 + 1:nx] := C[:, nx - n1 + 1:nx]*Q2;

        rankR := 0;
         <font color="darkgreen">// for i in 1:size(R, 1) loop</font>
         <font color="darkgreen">//   if abs(R[i, i]) &gt; eps then</font>
         <font color="darkgreen">//     rankR := rankR + 1;</font>
         <font color="darkgreen">//   end if;</font>
         <font color="darkgreen">// end for;</font>

  <font color="darkgreen">//  !!!! rank has to be determined. In the case of ill conditioned systems svd should be used</font>
        <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">min</font>(<font color="red">size</font>(R, 1), <font color="red">size</font>(R, 2))<font color="blue"> loop</font>
          <font color="blue">if </font><font color="red">abs</font>(R[i, <font color="red">size</font>(R, 2) - <font color="red">min</font>(<font color="red">size</font>(R, 1), <font color="red">size</font>(R, 2)) + i]) &gt; eps<font color="blue"> then</font>
            rankR := rankR + 1;
          <font color="blue">end if</font>;
        <font color="blue">end for</font>;
        stairStep := stairStep + rankR;
        n1 := <font color="blue">if </font>rankR &lt; 1<font color="blue"> then </font>-1<font color="blue"> else </font>n1 - rankR;
        stop := n1 &lt;= 0;

      <font color="blue">end while</font>;
    <font color="blue">else</font>
      stairStep := <font color="blue">if </font><font color="red">Modelica.Math.Matrices.isEqual</font>(ss.B, <font color="red">zeros</font>(<font color="red">size</font>(ss.B, 1), <font color="red">size</font>(ss.B, 2)))<font color="blue"> then </font>0<font color="blue"> else </font>
              1;
      A := ss.A;
      B := ss.B;
      C := ss.C;
    <font color="blue">end if</font>;

    ssm1 := <font color="red">Modelica_LinearSystems2.Internal.StateSpaceR</font>(
          A=A,
          B=B,
          C=C,
          D=ss.D,
          r=stairStep);

    isControllable := stairStep == nx;
    <font color="blue">else</font> <font color="darkgreen">// no inputs, nu==0</font>
    isControllable := false;
    ssm1 :=<font color="red">  Modelica_LinearSystems2.Internal.StateSpaceR</font>(
          A=ss.A,
          B=ss.B,
          C=ss.C,
          D=ss.D,
          r=0);
    P := <font color="red">identity</font>(nu);
    <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>staircaseQR</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.staircaseSVD"><font color="blue">encapsulated </font><font color="blue">function</font> staircaseSVD <font color="darkgreen">
      &quot;Staircase algorithm based on singular value decomposition&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Vectors.html#Modelica_LinearSystems2.Math.Vectors"
>Modelica_LinearSystems2.Math.Vectors</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;

    <font color="blue">output </font>Boolean isControllable;
    <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.StateSpaceR"
>Modelica_LinearSystems2.Internal.StateSpaceR</A> ssm1(
      <font color="blue">redeclare </font>Real A[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)],
      <font color="blue">redeclare </font>Real B[<font color="red">size</font>(ss.B, 1),<font color="red">size</font>(ss.B, 2)],
      <font color="blue">redeclare </font>Real C[<font color="red">size</font>(ss.C, 1),<font color="red">size</font>(ss.C, 2)],
      <font color="blue">redeclare </font>Real D[<font color="red">size</font>(ss.D, 1),<font color="red">size</font>(ss.D, 2)]) <font color="darkgreen">
        &quot;upper block Hessenberg form state space system&quot;</font>;
    <font color="blue">output </font>Real P[:,:];

    <font color="blue">protected </font>
    Real A[:,:];
    Real B[<font color="red">size</font>(ss.B, 1),<font color="red">size</font>(ss.B, 2)];
    Real C[:,:];
    Real U[:,:];
    Real VT[:,:];

    Real Q[:,:];
    Real Pi[:,:];
    Real tau[:];
    Real sigma[:];

    Integer nx=<font color="red">size</font>(ss.A, 1);
    Integer nu=<font color="red">size</font>(ss.B, 2);
    Integer ni;
    Boolean stop;
    Real normA=<font color="red">Modelica.Math.Matrices.norm</font>(A=ss.A, p=1);
    Real eps=normA*1e-10;
    Integer stairStepinSys;
    Integer info;
    Integer nn;
    Integer stairStep;
    Integer rankS;
    Integer maxA=<font color="red">max</font>(<font color="red">size</font>(ss.A));
  <font color="darkgreen">//   Real evc[:,2];</font>
  <font color="darkgreen">//   Real evnc[:,2];</font>

  <font color="blue">algorithm </font>
    <font color="blue">if </font>nu &gt; 0<font color="blue"> then</font>
    <font color="blue">if </font>nx &gt; 1<font color="blue"> then</font>
  <font color="darkgreen">//#####  first step of staircase</font>
          <font color="darkgreen">// transform b-&gt;Q&#39;b = {*,0,...,0} and c-&gt;cQ, A-&gt;Q&#39;AQ</font>
      (sigma,U,VT) := <font color="red">Modelica.Math.Matrices.singularValues</font>(ss.B);

      rankS := 0;
      <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(sigma, 1)<font color="blue"> loop</font>
        <font color="blue">if </font>sigma[i] &gt; maxA*sigma[1]*Modelica.Constants.eps<font color="blue"> then</font>
          rankS := rankS + 1;
        <font color="blue">end if</font>;
      <font color="blue">end for</font>;

      B := [<font color="red">diagonal</font>(sigma[1:rankS]),<font color="red">zeros</font>(rankS, nu - rankS); <font color="red">zeros</font>(nx - rankS, nu)];
      P := <font color="red">transpose</font>(U);
      Q := <font color="red">transpose</font>(VT);
      A := <font color="red">transpose</font>(U)*ss.A*U;
      C := ss.C*U;
      (sigma,U,VT) := <font color="red">Modelica.Math.Matrices.singularValues</font>(A[rankS + 1:nx, 1:rankS]);

      stairStep := rankS;
      rankS := 0;
      <font color="blue">if </font><font color="red">size</font>(sigma, 1) &gt; 1<font color="blue"> then</font>
        <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(sigma, 1)<font color="blue"> loop</font>
          <font color="blue">if </font>sigma[i] &gt; maxA*sigma[1]*Modelica.Constants.eps<font color="blue"> then</font>
            rankS := rankS + 1;
          <font color="blue">end if</font>;
        <font color="blue">end for</font>;
      <font color="blue">else</font>
        rankS := <font color="blue">if </font><font color="red">size</font>(sigma, 1) &gt; 0<font color="blue"> then </font><font color="blue">if </font>sigma[1] &gt; maxA*Modelica.Constants.eps<font color="blue"> then </font>1<font color="blue"> else </font>0<font color="blue"> else </font>0;
      <font color="blue">end if</font>;

      stairStep := stairStep + rankS;
      Pi := [VT,<font color="red">zeros</font>(<font color="red">size</font>(VT, 1), <font color="red">size</font>(U, 1)); <font color="red">zeros</font>(<font color="red">size</font>(U, 2), <font color="red">size</font>(VT, 2)),<font color="red">transpose</font>(U)];
      B := Pi*B;
      P := Pi*P;

   <font color="darkgreen">// P could be ambigious according to the sign</font>
      <font color="blue">if </font><font color="red">transpose</font>(P)*B[:,1]*ss.B[:,1]&lt;0<font color="blue"> then</font>
        Pi:=-Pi;
        P:=-P;
      <font color="blue">end if</font>;

      A := Pi*A*<font color="red">transpose</font>(Pi);

     <font color="darkgreen">// should be made better because of many zeros in B</font>

      <font color="blue">while </font>stairStep &lt; nx<font color="blue"> and </font>rankS &gt; 0<font color="blue"> and </font><font color="blue">not </font>
          <font color="red">Modelica.Math.Matrices.isEqual</font>(
              A[stairStep + 1:nx, stairStep - rankS + 1:stairStep],
              <font color="red">zeros</font>(stairStep - rankS, rankS),
              eps)<font color="blue"> loop</font>

        (sigma,U,VT) := <font color="red">Modelica.Math.Matrices.singularValues</font>(A[stairStep + 1:nx, stairStep
           - rankS + 1:stairStep]);

        Pi := [<font color="red">identity</font>(stairStep - rankS),<font color="red">zeros</font>(stairStep - rankS, nx -
          stairStep + rankS); <font color="red">zeros</font>(nx - stairStep + rankS, stairStep - rankS),
          [VT,<font color="red">zeros</font>(rankS, nx - stairStep); <font color="red">zeros</font>(nx - stairStep, rankS),
          <font color="red">transpose</font>(U)]];
        P := Pi*P;
        A := Pi*A*<font color="red">transpose</font>(Pi);

  <font color="darkgreen">//new implenmentation necessary because of many zeros in Pi</font>
        C := C*<font color="red">transpose</font>(Pi);
        rankS := 0;
        <font color="blue">if </font><font color="red">size</font>(sigma, 1) &gt; 1<font color="blue"> then</font>
          <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(sigma, 1)<font color="blue"> loop</font>
            <font color="blue">if </font>sigma[i] &gt; maxA*sigma[1]*Modelica.Constants.eps<font color="blue"> then</font>
              rankS := rankS + 1;
            <font color="blue">end if</font>;
          <font color="blue">end for</font>;
        <font color="blue">else</font>
          rankS := <font color="blue">if </font><font color="red">size</font>(sigma, 1) &gt; 0<font color="blue"> then </font><font color="blue">if </font>sigma[1] &gt; maxA*Modelica.Constants.eps<font color="blue"> then </font>
                  1<font color="blue"> else </font>0<font color="blue"> else </font>0;
        <font color="blue">end if</font>;
        stairStep := stairStep + rankS;
      <font color="blue">end while</font>;

    <font color="blue">else</font>
      stairStep := <font color="blue">if </font><font color="red">Modelica.Math.Matrices.isEqual</font>(ss.B, <font color="red">zeros</font>(<font color="red">size</font>(ss.B, 1),
        <font color="red">size</font>(ss.B, 2)))<font color="blue"> then </font>0<font color="blue"> else </font>1;
      A := ss.A;
      B := ss.B;
      C := ss.C;
    <font color="blue">end if</font>;

    ssm1 := <font color="red">Modelica_LinearSystems2.Internal.StateSpaceR</font>(
          A=A,
          B=B,
          C=C,
          D=ss.D,
          r=stairStep);

  <font color="darkgreen">//   evc := Modelica.Math.Matrices.eigenValues(A[1:stairStep, 1:stairStep]);</font>
  <font color="darkgreen">//   evnc := Modelica.Math.Matrices.eigenValues(A[stairStep + 1:nx, stairStep + 1:nx]);</font>

    isControllable := stairStep == nx;

    <font color="blue">else</font> <font color="darkgreen">// no inputs, nu==0</font>
    isControllable := false;
    ssm1 :=<font color="red">  Modelica_LinearSystems2.Internal.StateSpaceR</font>(
          A=ss.A,
          B=ss.B,
          C=ss.C,
          D=ss.D,
          r=0);
    P := <font color="red">identity</font>(nu);
    <font color="blue">end if</font>;

  <font color="blue">end </font>staircaseSVD</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.partialGain"><font color="blue">encapsulated </font><font color="blue">function</font> partialGain
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>;

    <font color="blue">input </font>Real H[:,<font color="red">size</font>(H, 1)];
    <font color="blue">input </font>Real b[<font color="red">size</font>(H, 1)];
    <font color="blue">output </font>Real result;
    <font color="blue">protected </font>
    Real Hh[:,:]=H;
    Real bh[:]=b;
    Integer q=<font color="red">size</font>(H, 1);
  <font color="blue">algorithm </font>

    (Hh,bh) := <font color="red">Internal.trianUpperHess</font>(Hh, bh);
    result := bh[q]/Hh[q, q];

  <font color="blue">end </font>partialGain</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.assignOneOrTwoPoles_alpha"><font color="blue">encapsulated </font><font color="blue">function</font> assignOneOrTwoPoles_alpha <font color="darkgreen">
      &quot;Algorithm to assign p (p = 1 or 2) eigenvalues&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Vectors.html#Modelica_LinearSystems2.Math.Vectors"
>Modelica_LinearSystems2.Math.Vectors</A>;

    <font color="blue">input </font>Real F[:,<font color="red">size</font>(F, 1)] <font color="darkgreen">&quot;system matrix of order p=1 or p=2&quot;</font>;
    <font color="blue">input </font>Real G[<font color="red">size</font>(F, 1),:] <font color="darkgreen">&quot;control input matrix p rows&quot;</font>;
    <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> gamma[<font color="red">size</font>(F, 1)];
    <font color="blue">input </font>Real tolerance=Modelica.Constants.eps;
    <font color="blue">output </font>Real K[:,<font color="red">size</font>(F, 1)] <font color="darkgreen">&quot;feedback matrix p columns&quot;</font>;

    <font color="blue">protected </font>
    Real Gamma[:,:];
    Integer rankGs;
    Real Fs[<font color="red">size</font>(F, 1),<font color="red">size</font>(F, 2)];
    Real Gs[<font color="red">size</font>(G, 1),<font color="red">size</font>(G, 2)];
    Real Gst[:,:]=<font color="red">transpose</font>(G);
    Real Ks[:,<font color="red">size</font>(F, 1)];
    Real c;
    Real s;
    Real r;

    Real V1[<font color="red">size</font>(G, 2),<font color="red">size</font>(G, 2)];
    Real V2[<font color="red">size</font>(G, 2),<font color="red">size</font>(G, 2)];
    Real V[<font color="red">size</font>(G, 2),<font color="red">size</font>(G, 2)];
    Real U[<font color="red">size</font>(F, 1),<font color="red">size</font>(F, 2)];

    Real u1[:];
    Real u2[:];

  <font color="blue">algorithm </font>
    <font color="red">assert</font>(<font color="red">size</font>(F, 1) &gt;= <font color="red">size</font>(gamma, 1),
      &quot;\n In function StateSpace.Internal.assignOneOrTwoPoles() matrix F is of size [&quot;
       + <font color="red">String</font>(<font color="red">size</font>(F, 1)) + &quot;,&quot; + <font color="red">String</font>(<font color="red">size</font>(F, 1)) + &quot;] and &quot; + <font color="red">String</font>(
      <font color="red">size</font>(F, 1)) + &quot; demanded assigned poles are expected. However, &quot; +
      <font color="red">String</font>(<font color="red">size</font>(gamma, 1)) + &quot; poles are given&quot;);
  <font color="darkgreen">//assert(not Modelica.Math.Matrices.isEqual(G,zeros(size(G,1),size(G,2)),tolerance),&quot;A subsystem (F, G) in StateSpace.Internal.assignOneOrTwoPoles() is not controllable, since G is equal to zero matrix &quot;);</font>
    <font color="blue">if </font><font color="red">size</font>(gamma, 1) == 1<font color="blue"> then</font>
      <font color="red">assert</font>(gamma[1].im == 0, &quot;\n In function StateSpace.Internal.assignOneOrTwoPoles() matrix F has size [&quot; + <font color="red">String</font>(<font color="red">size</font>(F, 1)) + &quot;,&quot; + <font color="red">String</font>(<font color="red">size</font>(F, 1)) +
        &quot;], therefore, the demanded assigned pole must be real. However, the imaginary part is &quot;
         + <font color="red">String</font>(gamma[1].im));
    <font color="blue">elseif </font><font color="red">abs</font>(gamma[1].im) &gt; 0<font color="blue"> or </font><font color="red">abs</font>(gamma[2].im) &gt; 0<font color="blue"> then</font>
      <font color="red">assert</font>(gamma[1].re == gamma[2].re<font color="blue"> and </font>gamma[1].im == -gamma[2].im,
        &quot;\nThe assigned pole pair given in function StateSpace.Internal.assignOneOrTwoPoles() must be conjungated complex. However, the poles are\npole1 = &quot;
         + <font color="red">String</font>(gamma[1]) + &quot;\npole2 = &quot; + <font color="red">String</font>(gamma[2]) +
        &quot;. \nTry\npole1 = &quot; + <font color="red">String</font>(gamma[1]) + &quot;\npole2 = &quot; + <font color="red">String</font>(
        <font color="red">Complex.conj</font>(gamma[1])) + &quot;\ninstead&quot;);
    <font color="blue">end if</font>;

    <font color="blue">if </font><font color="blue">not </font><font color="red">Modelica.Math.Matrices.isEqual</font>(
            G,
            <font color="red">zeros</font>(<font color="red">size</font>(G, 1), <font color="red">size</font>(G, 2)),
            tolerance)<font color="blue"> then</font>
      <font color="blue">if </font><font color="red">size</font>(G, 2) == 1<font color="blue"> then</font>
        V := [1];
        <font color="blue">if </font><font color="red">size</font>(G, 1) == 1<font color="blue"> then</font>
          U := [1];
        <font color="blue">else</font>
           <font color="darkgreen">// Givens</font>
          r := <font color="red">sqrt</font>(G[1, 1]^2 + G[2, 1]^2);
          c := G[1, 1]/r;
          s := G[2, 1]/r;
          U := [c,s; -s,c];
        <font color="blue">end if</font>;
        Gs := U*G;

        rankGs := <font color="blue">if </font><font color="red">abs</font>(Gs[1, 1]) &gt; tolerance<font color="blue"> then </font>1<font color="blue"> else </font>0;
      <font color="blue">else</font>
       <font color="darkgreen">// size(G, 2)&gt;1</font>

        <font color="blue">if </font><font color="red">size</font>(G, 1) == 1<font color="blue"> then</font> <font color="darkgreen">// U=I, compute V by just one Householder transformation</font>
          U := [1];
          u1 := <font color="red">cat</font>(1, <font color="red">Vectors.householderVector</font>(Gst[:, 1], <font color="red">cat</font>(1, {1}, <font color="red">zeros</font>(<font color="red">size</font>(G, 2) - 1))));
            <font color="darkgreen">                       // Householder vector</font>
          Gst := <font color="red">Modelica_LinearSystems2.Math.Matrices.householderReflexion</font>(
            Gst, u1);

          V := <font color="red">identity</font>(<font color="red">size</font>(G, 2)) - 2*<font color="red">matrix</font>(u1)*<font color="red">transpose</font>(<font color="red">matrix</font>(u1))/(u1*u1);
          Gs := <font color="red">transpose</font>(Gst);
          rankGs := <font color="blue">if </font><font color="red">abs</font>(Gs[1, 1]) &gt; tolerance<font color="blue"> then </font>1<font color="blue"> else </font>0;

        <font color="blue">else</font>
          <font color="darkgreen">//2xHH + Givens</font>
          u1 := <font color="red">cat</font>(1, <font color="red">Vectors.householderVector</font>(Gst[:, 1], <font color="red">cat</font>(
                1,
                {1},
                <font color="red">zeros</font>(<font color="red">size</font>(G, 2) - 1))));
            <font color="darkgreen">                       // Householder vector1</font>
          Gst := <font color="red">Modelica_LinearSystems2.Math.Matrices.householderReflexion</font>(
            Gst, u1);
          V1 := <font color="red">identity</font>(<font color="red">size</font>(G, 2)) - 2*<font color="red">matrix</font>(u1)*<font color="red">transpose</font>(<font color="red">matrix</font>(u1))/(u1
            *u1);

  <font color="darkgreen">// if rank of G of a multi input system is equal to 1</font>
          <font color="blue">if </font><font color="red">Modelica.Math.Vectors.isEqual</font>(Gst[:, 2], <font color="red">zeros</font>(<font color="red">size</font>(G, 2)), tolerance)<font color="blue"> or </font>
            <font color="red">Modelica.Math.Matrices.isEqual</font>(Gst[2:<font color="red">size</font>(Gst, 1), :], <font color="red">zeros</font>(<font color="red">size</font>(Gst, 1) - 1, <font color="red">size</font>(Gst, 2)), tolerance)<font color="blue"> then</font>
            V := V1;
            rankGs := <font color="blue">if </font><font color="red">abs</font>(Gs[1, 1]) &gt; tolerance<font color="blue"> then </font>1<font color="blue"> else </font>0;
          <font color="blue">else</font>

            u2 := <font color="red">cat</font>(
                  1,
                  <font color="red">zeros</font>(1),
                  <font color="red">Vectors.householderVector</font>(Gst[2:<font color="red">size</font>(G, 2), 2], <font color="red">cat</font>(
                    1,
                    {1},
                    <font color="red">zeros</font>(<font color="red">size</font>(G, 2) - 2))));
              <font color="darkgreen">                       // Householder vector2</font>
            Gst := <font color="red">Modelica_LinearSystems2.Math.Matrices.householderReflexion</font>(
              Gst, u2);

            V2 := <font color="red">identity</font>(<font color="red">size</font>(G, 2)) - 2*<font color="red">matrix</font>(u2)*<font color="red">transpose</font>(<font color="red">matrix</font>(u2))/(
              u1*u1);
            V := V2*V1;

          <font color="blue">end if</font>;

          Gs := <font color="red">transpose</font>(Gst);

          rankGs := 0;
          <font color="blue">for </font>i<font color="blue"> in </font>1:2<font color="blue"> loop</font>
            <font color="blue">if </font><font color="red">abs</font>(Gs[i, i]) &gt; tolerance<font color="blue"> then</font>
              rankGs := rankGs + 1;
            <font color="blue">end if</font>;
          <font color="blue">end for</font>;
       <font color="darkgreen">// Givens rotation to transfotm Gs[1:2,1:2] to right upper triangle</font>
          r := <font color="red">sqrt</font>(Gs[1, 1]^2 + Gs[2, 1]^2);
          c := Gs[1, 1]/r;
          s := Gs[2, 1]/r;
          U := [c,s; -s,c];
          Gs := U*Gs;

        <font color="blue">end if</font>;
            <font color="blue">end if</font>;

  <font color="darkgreen">// check controllability</font>
      <font color="red">assert</font>(<font color="blue">not </font><font color="red">Modelica.Math.Matrices.isEqual</font>(
            Gs,
            <font color="red">zeros</font>(<font color="red">size</font>(Gs, 1), <font color="red">size</font>(Gs, 2)),
            tolerance),
        &quot;A subsystem in StateSpace.Internal.assignOneOrTwoPoles() is not controllable&quot;);

      Ks := <font color="red">fill</font>(
            0,
            rankGs,
            <font color="red">size</font>(F, 1));
      Fs := U*F*<font color="red">transpose</font>(U);

      <font color="blue">if </font><font color="red">size</font>(F, 1) == 1<font color="blue"> then</font>
        Ks := <font color="red">matrix</font>((Fs[1, 1] - gamma[1].re)/Gs[1, 1]);
      <font color="blue">else</font>
        <font color="blue">if </font>rankGs == <font color="red">size</font>(F, 1)<font color="blue"> then</font>

          <font color="darkgreen">// Gamma:= if size(F,1)==1 then [gamma[1].re] else [gamma[1].re, -(gamma[1].im)^2;1, gamma[2].re];</font>
          <font color="darkgreen">//  Ks :=  Modelica_LinearSystems2.Math.Matrices.solve2(Gs, Fs - Gamma);</font>
          Ks := [(Fs[1, 1] - gamma[1].re)/Gs[1, 1] - Gs[1, 2]*(Fs[2, 1] - 1)/Gs[1, 1]/Gs[2,
            2],(Fs[1, 2] + (gamma[1].im)^2)/Gs[1, 1] - Gs[1, 2]*(Fs[2, 2] -
            gamma[2].re)/Gs[1, 1]/Gs[2, 2]; (Fs[2, 1] - 1)/Gs[2, 2],(Fs[2, 2]
             - gamma[2].re)/Gs[2, 2]];
        <font color="blue">else</font>

          Ks[1, 1] := (gamma[1].re + gamma[2].re - Fs[1, 1] - Fs[2, 2])/Gs[1,
            1];
          Ks[1, 2] := Ks[1, 1]*Fs[2, 2]/Fs[2, 1] + (Fs[1, 1]*Fs[2, 2] - Fs[1,
            2]*Fs[2, 1] - (gamma[1].re*gamma[2].re - gamma[1].im*gamma[2].im))
            /Fs[2, 1]/Gs[1, 1];
          Ks := -Ks;
        <font color="blue">end if</font>;
      <font color="blue">end if</font>;

  <font color="darkgreen">//    K := transpose(V)*[Ks; zeros(size(G, 2) - rankGs, size(Ks, 2))]*(U);</font>
      K := <font color="red">transpose</font>(V[1:<font color="red">size</font>(Ks, 1), :])*Ks*U;

    <font color="blue">else</font>
      <font color="red">Modelica.Utilities.Streams.print</font>(
        &quot;\n A subsystem (F, G) in StateSpace.Internal.assignOneOrTwoPoles() is not controllable, since G is equal to zero matrix. Therefore, K is set to zero matrix and the eigenvalues are retained&quot;);
      K := <font color="red">zeros</font>(<font color="red">size</font>(G, 2), <font color="red">size</font>(F, 1));
    <font color="blue">end if</font>;

  <font color="blue">end </font>assignOneOrTwoPoles_alpha</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.assignOneOrTwoPoles"><font color="blue">encapsulated </font><font color="blue">function</font> assignOneOrTwoPoles <font color="darkgreen">
      &quot;Algorithm to assign p (p = 1 or 2) eigenvalues&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Vectors.html#Modelica_LinearSystems2.Math.Vectors"
>Modelica_LinearSystems2.Math.Vectors</A>;

    <font color="blue">input </font>Real F[:,<font color="red">size</font>(F, 1)] <font color="darkgreen">&quot;system matrix of order p=1 or p=2&quot;</font>;
    <font color="blue">input </font>Real G[<font color="red">size</font>(F, 1),:] <font color="darkgreen">&quot;control input matrix p rows&quot;</font>;
    <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> gamma[<font color="red">size</font>(F, 1)];
    <font color="blue">input </font>Real tolerance=Modelica.Constants.eps;
    <font color="blue">output </font>Real K[:,<font color="red">size</font>(F, 1)] <font color="darkgreen">&quot;feedback matrix p columns&quot;</font>;

    <font color="blue">protected </font>
    Real Gamma[:,:];
    Integer rankGs;
    Real Fs[<font color="red">size</font>(F, 1),<font color="red">size</font>(F, 2)];
    Real Gs[<font color="red">size</font>(G, 1),<font color="red">size</font>(G, 2)];
    Real Gst[:,:]=<font color="red">transpose</font>(G);
    Real Ks[:,<font color="red">size</font>(F, 1)];
    Real c;
    Real s;
    Real r;
    Integer p=<font color="red">size</font>(F,1);
    Real sigmaG[:];

    Real V[<font color="red">size</font>(G, 2),<font color="red">size</font>(G, 2)];
    Real U[<font color="red">size</font>(F, 1),<font color="red">size</font>(F, 2)];

    Real u1[:];
    Real u2[:];
    Integer i;
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> system_ev[:];

  <font color="blue">algorithm </font>
    <font color="red">assert</font>(<font color="red">size</font>(F, 1) &gt;= <font color="red">size</font>(gamma, 1),
      &quot;\n In function StateSpace.Internal.assignOneOrTwoPoles() matrix F is of size [&quot;
       + <font color="red">String</font>(<font color="red">size</font>(F, 1)) + &quot;,&quot; + <font color="red">String</font>(<font color="red">size</font>(F, 1)) + &quot;] and &quot; + <font color="red">String</font>(
      <font color="red">size</font>(F, 1)) + &quot; demanded assigned poles are expected. However, &quot; +
      <font color="red">String</font>(<font color="red">size</font>(gamma, 1)) + &quot; poles are given&quot;);
  <font color="darkgreen">//assert(not Modelica.Math.Matrices.isEqual(G,zeros(size(G,1),size(G,2)),tolerance),&quot;A subsystem (F, G) in StateSpace.Internal.assignOneOrTwoPoles() is not controllable, since G is equal to zero matrix &quot;);</font>
    <font color="blue">if </font><font color="red">size</font>(gamma, 1) == 1<font color="blue"> then</font>
      <font color="red">assert</font>(gamma[1].im == 0, &quot;\n In function StateSpace.Internal.assignOneOrTwoPoles() matrix F has size [&quot; + <font color="red">String</font>(<font color="red">size</font>(F, 1)) + &quot;,&quot; + <font color="red">String</font>(<font color="red">size</font>(F, 1)) +
        &quot;], therefore, the demanded assigned pole must be real. However, the imaginary part is &quot;
         + <font color="red">String</font>(gamma[1].im));
    <font color="blue">elseif </font><font color="red">abs</font>(gamma[1].im) &gt; 0<font color="blue"> or </font><font color="red">abs</font>(gamma[2].im) &gt; 0<font color="blue"> then</font>
      <font color="red">assert</font>(gamma[1].re == gamma[2].re<font color="blue"> and </font>gamma[1].im == -gamma[2].im,
        &quot;\nThe assigned pole pair given in function StateSpace.Internal.assignOneOrTwoPoles() must be conjungated complex. However, the poles are\npole1 = &quot;
         + <font color="red">String</font>(gamma[1]) + &quot;\npole2 = &quot; + <font color="red">String</font>(gamma[2]) +
        &quot;. \nTry\npole1 = &quot; + <font color="red">String</font>(gamma[1]) + &quot;\npole2 = &quot; + <font color="red">String</font>(
        <font color="red">Complex.conj</font>(gamma[1])) + &quot;\ninstead&quot;);
    <font color="blue">end if</font>;

    <font color="blue">if </font><font color="blue">not </font><font color="red">Modelica.Math.Matrices.isEqual</font>(
        G,
        <font color="red">zeros</font>(<font color="red">size</font>(G, 1), <font color="red">size</font>(G, 2)),
        tolerance)<font color="blue"> then</font>
      <font color="blue">if </font><font color="red">size</font>(G, 2) == 1<font color="blue"> then</font>
        V := [1];
        <font color="blue">if </font><font color="red">size</font>(G, 1) == 1<font color="blue"> then</font>
          U := [1];
        <font color="blue">else</font>
           <font color="darkgreen">// Givens</font>
          r := <font color="red">sqrt</font>(G[1, 1]^2 + G[2, 1]^2);
          c := G[1, 1]/r;
          s := G[2, 1]/r;
          U := [c,s; -s,c];
        <font color="blue">end if</font>;
        Gs := U*G;

        rankGs := <font color="blue">if </font><font color="red">abs</font>(Gs[1, 1]) &gt; tolerance<font color="blue"> then </font>1<font color="blue"> else </font>0;
      <font color="blue">else</font>
       <font color="darkgreen">// size(G, 2)&gt;1</font>

        <font color="blue">if </font><font color="red">size</font>(G, 1) == 1<font color="blue"> then</font> <font color="darkgreen">// U=I, compute V by just one Householder transformation</font>
          U := [1];
          u1 := <font color="red">cat</font>(1, <font color="red">Vectors.householderVector</font>(Gst[:, 1],
                       <font color="red">cat</font>(1, {1}, <font color="red">zeros</font>(<font color="red">size</font>(G, 2) - 1))));<font color="darkgreen">// Householder vector</font>
          Gst := <font color="red">Modelica_LinearSystems2.Math.Matrices.householderReflexion</font>(Gst, u1);

          V := <font color="red">identity</font>(<font color="red">size</font>(G, 2)) - 2*<font color="red">matrix</font>(u1)*<font color="red">transpose</font>(<font color="red">matrix</font>(u1))/(u1*u1);
          Gs := <font color="red">transpose</font>(Gst);
          rankGs := <font color="blue">if </font><font color="red">abs</font>(Gs[1, 1]) &gt; tolerance<font color="blue"> then </font>1<font color="blue"> else </font>0;

        <font color="blue">else</font>
  <font color="darkgreen">// systems with p==2 and m&gt;1 are transformed by svd</font>
          (sigmaG,U,V) := <font color="red">Modelica.Math.Matrices.singularValues</font>(G);
          rankGs := 0;
          i := <font color="red">size</font>(sigmaG, 1);
          <font color="blue">while </font>i &gt; 0<font color="blue"> loop</font>
            <font color="blue">if </font>sigmaG[i] &gt; 1e-10<font color="blue"> then</font>
              rankGs := i;
              i := 0;
            <font color="blue">end if</font>;
            i := i - 1;
          <font color="blue">end while</font>;
          Gs := <font color="red">zeros</font>(p, <font color="red">size</font>(G, 2));
          <font color="blue">for </font>i<font color="blue"> in </font>1:rankGs<font color="blue"> loop</font>
            Gs[i, i] := sigmaG[i];
          <font color="blue">end for</font>;

        <font color="blue">end if</font>;
        V := <font color="red">transpose</font>(V);
      <font color="blue">end if</font>;

  <font color="darkgreen">// check controllability</font>
      <font color="red">assert</font>(<font color="blue">not </font><font color="red">Modelica.Math.Matrices.isEqual</font>(
        Gs,
        <font color="red">zeros</font>(<font color="red">size</font>(Gs, 1), <font color="red">size</font>(Gs, 2)),
        tolerance), &quot;A subsystem in StateSpace.Internal.assignOneOrTwoPoles() is not controllable&quot;);

      Ks := <font color="red">fill</font>(
        0,
        rankGs,
        <font color="red">size</font>(F, 1));
      Fs := U*F*<font color="red">transpose</font>(U);

      <font color="blue">if </font><font color="red">size</font>(F, 1) == 1<font color="blue"> then</font>
        Ks := <font color="red">matrix</font>((Fs[1, 1] - gamma[1].re)/Gs[1, 1]);
      <font color="blue">else</font>
        <font color="blue">if </font>rankGs == <font color="red">size</font>(F, 1)<font color="blue"> then</font>

          <font color="darkgreen">// Gamma:= if size(F,1)==1 then [gamma[1].re] else [gamma[1].re, -(gamma[1].im)^2;1, gamma[2].re];</font>
          <font color="darkgreen">//  Ks :=  Modelica_LinearSystems2.Math.Matrices.solve2(Gs, Fs - Gamma);</font>
          Ks := [(Fs[1, 1] - gamma[1].re)/Gs[1, 1] - Gs[1, 2]*(Fs[2, 1] - 1)/Gs[1, 1]/Gs[2,2],
          (Fs[1, 2] + (gamma[1].im)^2)/Gs[1, 1] - Gs[1, 2]*(Fs[2, 2] - gamma[2].re)/Gs[1, 1]/Gs[2, 2];
          (Fs[2, 1] - 1)/Gs[2, 2],(Fs[2, 2] - gamma[2].re)/Gs[2, 2]];
        <font color="blue">else</font>

          Ks[1, 1] := (gamma[1].re + gamma[2].re - Fs[1, 1] - Fs[2, 2])/Gs[1, 1];
          Ks[1, 2] := Ks[1, 1]*Fs[2, 2]/Fs[2, 1] + (Fs[1, 1]*Fs[2, 2] - Fs[1, 2]*
            Fs[2, 1] - (gamma[1].re*gamma[2].re - gamma[1].im*gamma[2].im))/Fs[2,1]/Gs[1, 1];
          Ks := -Ks;
        <font color="blue">end if</font>;
      <font color="blue">end if</font>;

      K := V[:, 1:<font color="red">size</font>(Ks, 1)]*Ks*U;

    <font color="blue">else</font>
      <font color="blue">if </font>p == 1<font color="blue"> then</font>
        <font color="red">Modelica.Utilities.Streams.print</font>(&quot;\n A subsystem (F, G) in StateSpace.Internal.assignOneOrTwoPoles() is not controllable, since G is equal to zero matrix. Therefore, K is set to zero matrix and the eigenvalues are retained.\n
      That is, &quot;   + <font color="red">String</font>(F[1, 1]) + &quot; remains and &quot; + <font color="red">String</font>(gamma[1].re) + &quot; cannot be realized&quot;);
      <font color="blue">else</font>
        system_ev := <font color="red">Complex.eigenValues</font>(F);
        <font color="red">Modelica.Utilities.Streams.print</font>(&quot;\n A subsystem (F, G) in StateSpace.Internal.assignOneOrTwoPoles() is not controllable, since G is equal to zero matrix. Therefore, K is set to zero matrix and the eigenvalues are retained.\n
      That is, &quot;   + <font color="red">String</font>(system_ev[1].re) + (<font color="blue">if </font><font color="red">abs</font>(system_ev[1].im) &gt; 0<font color="blue"> then </font>&quot; + &quot;<font color="blue"> else </font>
                &quot; - &quot;) + <font color="red">String</font>(system_ev[1].im) + &quot;j and &quot; + <font color="red">String</font>(system_ev[2].re)
           + (<font color="blue">if </font><font color="red">abs</font>(system_ev[2].im) &gt; 0<font color="blue"> then </font>&quot; + &quot;<font color="blue"> else </font>&quot; - &quot;) + <font color="red">String</font>(
          system_ev[2].im) + &quot;j remain and &quot; + <font color="red">String</font>(gamma[1].re) + (<font color="blue">if </font><font color="red">abs</font>(
          gamma[1].im) &gt; 0<font color="blue"> then </font>(<font color="blue">if </font>gamma[1].im &gt; 0<font color="blue"> then </font>&quot; + &quot;<font color="blue"> else </font>&quot; - &quot; +
          <font color="red">String</font>(gamma[1].im) + &quot;j&quot;)<font color="blue"> else </font>&quot;&quot; + &quot; and &quot;) + <font color="red">String</font>(gamma[2].re) + (
          <font color="blue">if </font><font color="red">abs</font>(gamma[2].im) &gt; 0<font color="blue"> then </font>(<font color="blue">if </font>gamma[2].im &gt; 0<font color="blue"> then </font>&quot; + &quot;<font color="blue"> else </font>&quot; - &quot; +
          <font color="red">String</font>(gamma[2].im) + &quot;j&quot;)<font color="blue"> else </font>&quot;&quot;) + &quot; cannot be realized&quot;);
      <font color="blue">end if</font>;
      K := <font color="red">zeros</font>(<font color="red">size</font>(G, 2), <font color="red">size</font>(F, 1));
    <font color="blue">end if</font>;

  <font color="blue">end </font>assignOneOrTwoPoles</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.readSystemDimension"><font color="blue">encapsulated </font><font color="blue">function</font> readSystemDimension <font color="darkgreen">
      &quot;Read the order nx of state matrix and the numbers nu and ny of inputs and outputs&quot;</font>
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
    <font color="blue">input </font>String fileName=&quot;stateSpace.mat&quot;;
    <font color="blue">input </font>String matrixName=&quot;ABCD&quot; <font color="darkgreen">
        &quot;Name of the generalized state space system matrix&quot;</font>;
    <font color="blue">output </font>Integer xuy[3];

    <font color="blue">protected </font>
    Real sizeA[1,1]=<font color="red">readMatrix</font>(
            fileName,
            &quot;nx&quot;,
            1,
            1);

    Integer ABCDsizes[2]=<font color="red">readMatrixSize</font>(fileName, matrixName);

  <font color="blue">algorithm </font>
    xuy[1] := <font color="red">integer</font>(sizeA[1, 1]);
    xuy[2] := ABCDsizes[2] - xuy[1];
    xuy[3] := ABCDsizes[1] - xuy[1];

  <font color="blue">end </font>readSystemDimension</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.readLength_nu"><font color="blue">encapsulated </font><font color="blue">function</font> readLength_nu <font color="darkgreen">
      &quot;Read the number of inputs nu of a state space system from a file&quot;</font>

    <font color="blue">input </font>String fileName=&quot;ss_siso.mat&quot; <font color="darkgreen">
        &quot;Name of the state space system data file&quot;</font>;
    <font color="blue">input </font>String matrixName=&quot;ABCD&quot; <font color="darkgreen">&quot;Name of the state space system matrix&quot;</font>;

    <font color="blue">output </font>Integer nu;
    <font color="blue">protected </font>
    Real nxMat[1,1]=<font color="red">readMatrix</font>(
            fileName,
            &quot;nx&quot;,
            1,
            1);
    Integer ABCDsizes[2]=<font color="red">readMatrixSize</font>(fileName, matrixName);
    Integer nx=<font color="red">integer</font>(nxMat[1, 1]);

  <font color="blue">algorithm </font>
    nu := ABCDsizes[2] - nx;
  <font color="blue">end </font>readLength_nu</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.readLength_ny"><font color="blue">encapsulated </font><font color="blue">function</font> readLength_ny <font color="darkgreen">
      &quot;Read the number of outputs ny of a state space system from a file&quot;</font>

    <font color="blue">input </font>String fileName=&quot;ss_siso.mat&quot; <font color="darkgreen">
        &quot;Name of the state space system data file&quot;</font>;
    <font color="blue">input </font>String matrixName=&quot;ABCD&quot; <font color="darkgreen">&quot;Name of the state space system matrix&quot;</font>;

    <font color="blue">output </font>Integer ny;
    <font color="blue">protected </font>
    Real nxMat[1,1]=<font color="red">readMatrix</font>(
            fileName,
            &quot;nx&quot;,
            1,
            1);
    Integer ABCDsizes[2]=<font color="red">readMatrixSize</font>(fileName, matrixName);
    Integer nx=<font color="red">integer</font>(nxMat[1, 1]);

  <font color="blue">algorithm </font>
    ny := ABCDsizes[1] - nx;
  <font color="blue">end </font>readLength_ny</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.dgreeOfRedSys"><font color="blue">encapsulated </font><font color="blue">function</font> dgreeOfRedSys <font color="darkgreen">
      &quot;Calculate the controllable and observable part of a state space system&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;
    <font color="blue">output </font>Integer degree_rs;

    <font color="blue">protected </font>
    <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ssm1=
        <font color="red">Modelica_LinearSystems2.StateSpace.Internal.reducedCtrSystem</font>(ss);

    <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss2=<font color="red">StateSpace</font>(
            A=<font color="red">transpose</font>(ssm1.A),
            B=<font color="red">transpose</font>(ssm1.C),
            C=<font color="red">transpose</font>(ssm1.B),
            D=ssm1.D);

    <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ssm2=
        <font color="red">Modelica_LinearSystems2.StateSpace.Internal.reducedCtrSystem</font>(ss2);

  <font color="blue">algorithm </font>
    degree_rs := <font color="red">size</font>(ssm2.A, 1);

  <font color="blue">end </font>dgreeOfRedSys</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.householder"><font color="blue">encapsulated </font><font color="blue">function</font> householder
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Vectors.html#Modelica_LinearSystems2.Math.Vectors"
>Modelica_LinearSystems2.Math.Vectors</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;
    <font color="blue">input </font>Real v[<font color="red">size</font>(ss.A, 1)];

    <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ssh;

    <font color="blue">protected </font>
    Real Ah[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)];
    Real Bh[<font color="red">size</font>(ss.B, 1),<font color="red">size</font>(ss.B, 2)];
    Real Ch[<font color="red">size</font>(ss.C, 1),<font color="red">size</font>(ss.C, 2)];
  <font color="blue">algorithm </font>
    Ah := <font color="red">Matrices.householderSimilarityTransformation</font>(ss.A, v);
    Bh := <font color="red">Matrices.householderReflexion</font>(ss.B, v);
    Ch := <font color="red">transpose</font>(<font color="red">Matrices.householderReflexion</font>(<font color="red">transpose</font>(ss.C), v));

    ssh := <font color="red">StateSpace</font>(
          A=Ah,
          B=Bh,
          C=Ch,
          D=ss.D);

  <font color="blue">end </font>householder</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.numberOfZeros"><font color="blue">encapsulated </font><font color="blue">function</font> numberOfZeros <font color="darkgreen">
      &quot;Calculate the number of zeros of the related transfer function&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;StateSpace object&quot;</font>;

    <font color="blue">output </font>Integer numberOfZeros;

    <font color="blue">protected </font>
    Integer nop;
    Integer noz;

  <font color="blue">algorithm </font>
    (nop,noz) := <font color="red">StateSpace.Internal.numberOfPolesAndZeros</font>(ss);
    numberOfZeros := noz;
  <font color="blue">end </font>numberOfZeros</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.complexZeros"><font color="blue">encapsulated </font><font color="blue">function</font> complexZeros <font color="darkgreen">
      &quot;Calculate the zeros of the related transfer function&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;StateSpace object&quot;</font>;
    <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> zeros2[:]=<font color="red">fill</font>(<font color="red">Complex</font>(0, 0),
        <font color="red">StateSpace.Internal.numberOfZeros</font>(ss));

    <font color="blue">protected </font>
    Integer nx=<font color="red">size</font>(ss.A, 2);

    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> zeros[:];
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> poles[:];
    Real eval[nx,2];
    Real evec[nx,nx];

    Integer index[:]=<font color="red">fill</font>(0, nx) <font color="darkgreen">&quot;indices of zeros which are equal to poles&quot;</font>;
    Integer i;
    Integer j;
    Integer k;
    Boolean h;
    Integer nzero;

  <font color="blue">algorithm </font>
    <font color="blue">if </font><font color="red">size</font>(ss.C, 1) &lt;&gt; 1<font color="blue"> or </font><font color="red">size</font>(ss.B, 2) &lt;&gt; 1<font color="blue"> then</font>
      <font color="red">assert</font>(<font color="red">size</font>(ss.B, 2) == 1,
        &quot; function fromStateSpaceSISO expects a SISO-system as input\n but the number of inputs is &quot;
         + <font color="red">String</font>(<font color="red">size</font>(ss.B, 2)) + &quot; instead of 1&quot;);
      <font color="red">assert</font>(<font color="red">size</font>(ss.C, 1) == 1,
        &quot; function fromStateSpaceSISO expects a SISO-system as input\n but the number of outputs is &quot;
         + <font color="red">String</font>(<font color="red">size</font>(ss.C, 1)) + &quot; instead of 1&quot;);
    <font color="blue">end if</font>;

    zeros := <font color="red">StateSpace.Analysis.invariantZeros</font>( ss);

    poles := <font color="red">Modelica_LinearSystems2.Math.Complex.eigenValues</font>(ss.A);

    <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(zeros, 1)<font color="blue"> loop</font>
      <font color="blue">for </font>j<font color="blue"> in </font>1:<font color="red">size</font>(poles, 1)<font color="blue"> loop</font>
         <font color="blue">if </font>zeros[i] == poles[j]<font color="blue"> then</font>
          h := false;
          k := 1;
          <font color="blue">while </font>((k &lt; i)<font color="blue"> and </font>(<font color="blue">not </font>h))<font color="blue"> loop</font>
            h := <font color="blue">if </font>(j == index[k])<font color="blue"> then </font>true<font color="blue"> else </font>false;
            k := k + 1;
          <font color="blue">end while</font>;
          index[i] := <font color="blue">if </font>h<font color="blue"> then </font>0<font color="blue"> else </font>j;
        <font color="blue">end if</font>;
      <font color="blue">end for</font>;
    <font color="blue">end for</font>;

    j := 0;
    <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(zeros, 1)<font color="blue"> loop</font>
      <font color="blue">if </font>index[i] == 0<font color="blue"> then</font>
        j := j + 1;
        zeros2[j] := zeros[i];
      <font color="blue">end if</font>;
    <font color="blue">end for</font>;

  <font color="blue">end </font>complexZeros</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.numberOfPoles"><font color="blue">encapsulated </font><font color="blue">function</font> numberOfPoles <font color="darkgreen">
      &quot;Calculate the number of poles of the related transfer function&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;StateSpace object&quot;</font>;

    <font color="blue">output </font>Integer numberOfPoles=<font color="red">StateSpace.Internal.numberOfPolesAndZeros</font>(ss);

  <font color="blue">algorithm </font>
  <font color="blue">end </font>numberOfPoles</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.numberOfPolesAndZeros"><font color="blue">encapsulated </font><font color="blue">function</font> numberOfPolesAndZeros <font color="darkgreen">
      &quot;Calculate the number poles and of zeros of the related transfer function&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;StateSpace object&quot;</font>;
    <font color="blue">output </font>Integer numberOfPoles;
    <font color="blue">output </font>Integer numberOfZeros;

    <font color="blue">protected </font>
    Integer nx=<font color="red">size</font>(ss.A, 2);
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> zeros[:];
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> zeros2[:] <font color="darkgreen">
        &quot;Finite, invariant zeros of ss; size(Zeros,1) &lt;= size(ss.A,1)&quot;</font>;
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> poles[:];
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> poles2[:] <font color="darkgreen">&quot;eigenvalues of ss&quot;</font>;
    Real eval[nx,2];
    Real evec[nx,nx];

    Integer index[:]=<font color="red">fill</font>(0, nx) <font color="darkgreen">&quot;indices of zeros which are equal to poles&quot;</font>;
    Integer i;
    Integer j;
    Integer k;
    Boolean h;
    Integer nzero;

  <font color="blue">algorithm </font>
    <font color="blue">if </font><font color="red">size</font>(ss.C, 1) &lt;&gt; 1<font color="blue"> or </font><font color="red">size</font>(ss.B, 2) &lt;&gt; 1<font color="blue"> then</font>
      <font color="red">assert</font>(<font color="red">size</font>(ss.B, 2) == 1,
        &quot; function fromStateSpaceSISO expects a SISO-system as input\n but the number of inputs is &quot;
         + <font color="red">String</font>(<font color="red">size</font>(ss.B, 2)) + &quot; instead of 1&quot;);
      <font color="red">assert</font>(<font color="red">size</font>(ss.C, 1) == 1,
        &quot; function fromStateSpaceSISO expects a SISO-system as input\n but the number of outputs is &quot;
         + <font color="red">String</font>(<font color="red">size</font>(ss.C, 1)) + &quot; instead of 1&quot;);
    <font color="blue">end if</font>;

    zeros := <font color="red">StateSpace.Analysis.invariantZeros</font>(ss);
    zeros2 := zeros;

    poles := <font color="red">Modelica_LinearSystems2.Math.Complex.eigenValues</font>(ss.A);
    poles2 := poles;

  <font color="darkgreen">//Reduce terms which are in nominator as well as in denominator</font>
    <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(zeros, 1)<font color="blue"> loop</font>
      <font color="blue">for </font>j<font color="blue"> in </font>1:<font color="red">size</font>(poles, 1)<font color="blue"> loop</font>
        <font color="blue">if </font>zeros[i] == poles[j]<font color="blue"> then</font>
          h := false;
          k := 1;
          <font color="blue">while </font>((k &lt; i)<font color="blue"> and </font>(<font color="blue">not </font>h))<font color="blue"> loop</font>
            h := <font color="blue">if </font>(j == index[k])<font color="blue"> then </font>true<font color="blue"> else </font>false;
            k := k + 1;
          <font color="blue">end while</font>;
          index[i] := <font color="blue">if </font>h<font color="blue"> then </font>0<font color="blue"> else </font>j;
        <font color="blue">end if</font>;
      <font color="blue">end for</font>;
    <font color="blue">end for</font>;

    j := 0;
    <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(zeros, 1)<font color="blue"> loop</font>
      <font color="blue">if </font>index[i] == 0<font color="blue"> then</font>
        j := j + 1;
        zeros2[j] := zeros[i];
      <font color="blue">end if</font>;
    <font color="blue">end for</font>;
    nzero := j;
    j := 0;
    <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(poles, 1)<font color="blue"> loop</font>
      h := false;
      k := 1;
      <font color="blue">while </font>(k &lt;= <font color="red">size</font>(zeros, 1)<font color="blue"> and </font>(<font color="blue">not </font>h))<font color="blue"> loop</font>
        h := <font color="blue">if </font>i == index[k]<font color="blue"> then </font>true<font color="blue"> else </font>false;
        k := k + 1;
      <font color="blue">end while</font>;
      <font color="blue">if </font><font color="blue">not </font>h<font color="blue"> then</font>
        j := j + 1;
        poles2[j] := poles[i];

      <font color="blue">end if</font>;
    <font color="blue">end for</font>;

    numberOfPoles := nx - <font color="red">size</font>(zeros, 1) + nzero;
    numberOfZeros := nzero;

  <font color="blue">end </font>numberOfPolesAndZeros</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.complexPoles"><font color="blue">encapsulated </font><font color="blue">function</font> complexPoles <font color="darkgreen">
      &quot;Generate a zeros-and-poles representation from state space representation&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;StateSpace object&quot;</font>;

    <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> poles2[:]=<font color="red">fill</font>(<font color="red">Complex</font>(0, 0),
        <font color="red">StateSpace.Internal.numberOfPoles</font>(ss));

    <font color="blue">protected </font>
    Integer nx=<font color="red">size</font>(ss.A, 2);

    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> zeros[:] <font color="darkgreen">
        &quot;Finite, invariant zeros of ss; size(Zeros,1) &lt;= size(ss.A,1)&quot;</font>;
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> zeros2[:];
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> poles[:] <font color="darkgreen">&quot;eigenvalues of ss&quot;</font>;
    Real eval[nx,2];
    Real evec[nx,nx];

    Integer index[:]=<font color="red">fill</font>(0, nx) <font color="darkgreen">&quot;indices of zeros which are equal to poles&quot;</font>;
    Integer i;
    Integer j;
    Integer k;
    Boolean h;
    Integer nzero;

  <font color="blue">algorithm </font>
    <font color="blue">if </font><font color="red">size</font>(ss.C, 1) &lt;&gt; 1<font color="blue"> or </font><font color="red">size</font>(ss.B, 2) &lt;&gt; 1<font color="blue"> then</font>
      <font color="red">assert</font>(<font color="red">size</font>(ss.B, 2) == 1,
        &quot; function fromStateSpaceSISO expects a SISO-system as input\n but the number of inputs is &quot;
         + <font color="red">String</font>(<font color="red">size</font>(ss.B, 2)) + &quot; instead of 1&quot;);
      <font color="red">assert</font>(<font color="red">size</font>(ss.C, 1) == 1,
        &quot; function fromStateSpaceSISO expects a SISO-system as input\n but the number of outputs is &quot;
         + <font color="red">String</font>(<font color="red">size</font>(ss.C, 1)) + &quot; instead of 1&quot;);
    <font color="blue">end if</font>;

    h := false;
    zeros := <font color="red">StateSpace.Analysis.invariantZeros</font>( ss);
    zeros2 := zeros;

    poles := <font color="red">Modelica_LinearSystems2.Math.Complex.eigenValues</font>(ss.A);

    <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(zeros, 1)<font color="blue"> loop</font>
      <font color="blue">for </font>j<font color="blue"> in </font>1:<font color="red">size</font>(poles, 1)<font color="blue"> loop</font>
        <font color="blue">if </font>zeros[i] == poles[j]<font color="blue"> then</font>
          h := false;
          k := 1;
          <font color="blue">while </font>((k &lt; i)<font color="blue"> and </font>(<font color="blue">not </font>h))<font color="blue"> loop</font>
            h := <font color="blue">if </font>(j == index[k])<font color="blue"> then </font>true<font color="blue"> else </font>false;
            k := k + 1;
          <font color="blue">end while</font>;
          index[i] := <font color="blue">if </font>h<font color="blue"> then </font>0<font color="blue"> else </font>j;
        <font color="blue">end if</font>;
      <font color="blue">end for</font>;
    <font color="blue">end for</font>;

    j := 0;
    <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(zeros, 1)<font color="blue"> loop</font>
      <font color="blue">if </font>index[i] == 0<font color="blue"> then</font>
        j := j + 1;
        zeros2[j] := zeros[i];
      <font color="blue">end if</font>;
    <font color="blue">end for</font>;
    nzero := j;
    j := 0;
    <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(poles, 1)<font color="blue"> loop</font>
      h := false;
      k := 1;
      <font color="blue">while </font>(k &lt;= <font color="red">size</font>(zeros, 1)<font color="blue"> and </font>(<font color="blue">not </font>h))<font color="blue"> loop</font>
        h := <font color="blue">if </font>i == index[k]<font color="blue"> then </font>true<font color="blue"> else </font>false;
        k := k + 1;
      <font color="blue">end while</font>;
      <font color="blue">if </font><font color="blue">not </font>h<font color="blue"> then</font>
        j := j + 1;
        poles2[j] := poles[i];

      <font color="blue">end if</font>;
    <font color="blue">end for</font>;

  <font color="blue">end </font>complexPoles</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.trianUpperHess"><font color="blue">encapsulated </font><font color="blue">function</font> trianUpperHess <font color="darkgreen">
      &quot;Triangulize an upper Hessenberg matrix by repeatedly applicated householder reflexion&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Vectors.html#Modelica_LinearSystems2.Math.Vectors"
>Modelica_LinearSystems2.Math.Vectors</A>;

    <font color="blue">input </font>Real H[:,:];
    <font color="blue">input </font>Real b[<font color="red">size</font>(H, 1)];

    <font color="blue">output </font>Real Ht[<font color="red">size</font>(H, 1),<font color="red">size</font>(H, 2)];
    <font color="blue">output </font>Real bt[<font color="red">size</font>(b, 1)];

    <font color="blue">protected </font>
    Integer q=<font color="red">size</font>(H, 1);
    Real u[:] <font color="darkgreen">&quot;householder vector&quot;</font>;
    Integer ll;

  <font color="blue">algorithm </font>
    Ht := H;
    bt := b;

    <font color="blue">for </font>ll<font color="blue"> in </font>1:q - 1<font color="blue"> loop</font>
      u := <font color="red">cat</font>(
            1,
            <font color="red">zeros</font>(ll - 1),
            <font color="red">cat</font>(
              1,
              <font color="red">Vectors.householderVector</font>(<font color="red">vector</font>(Ht[ll:ll + 1, ll]), {1,0}),
              <font color="red">zeros</font>(q - ll - 1)));
      Ht := <font color="red">Matrices.householderReflexion</font>(Ht, u);
      bt := <font color="red">Vectors.householderReflexion</font>(bt, u);
    <font color="blue">end for</font>;

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>trianUpperHess</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.reducedCtrSystem2"><font color="blue">encapsulated </font><font color="blue">function</font> reducedCtrSystem2 <font color="darkgreen">
      &quot;calculate the controllable part of a SISO system&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Vectors.html#Modelica_LinearSystems2.Math.Vectors"
>Modelica_LinearSystems2.Math.Vectors</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;
    <font color="blue">input </font>Real eps=0;

    <font color="blue">protected </font>
    <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> sst(
      <font color="blue">redeclare </font>Real A[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)],
      <font color="blue">redeclare </font>Real B[<font color="red">size</font>(ss.B, 1),<font color="red">size</font>(ss.B, 2)],
      <font color="blue">redeclare </font>Real C[<font color="red">size</font>(ss.C, 1),<font color="red">size</font>(ss.C, 2)],
      <font color="blue">redeclare </font>Real D[<font color="red">size</font>(ss.D, 1),<font color="red">size</font>(ss.D, 2)]) <font color="darkgreen">
        &quot;tranformed state space system&quot;</font>;

    Integer nx=<font color="red">size</font>(ss.A, 1);
    Real Ah1[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)];
    Real bh1[<font color="red">size</font>(ss.A, 1)];
    Real ch1[<font color="red">size</font>(ss.A, 1)];

    Real u[:] <font color="darkgreen">&quot;householder vector&quot;</font>;
    Real cpoles[:,2]=<font color="red">Modelica_LinearSystems2.StateSpace.Internal.controllablePoles</font>(ss);
    Integer rankQc=<font color="red">size</font>(cpoles,1);

    Integer rankQc2;
    Real Qc2[nx,nx];
    Real sigma[:];
    Real eps2;

    Real Ah2[rankQc,rankQc];
    Real bh2[rankQc];
    Real ch2[rankQc];

    Integer ll;
    Integer r;

    Boolean h;

    <font color="blue">public </font>
    <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ssm1(
      <font color="blue">redeclare </font>Real A[rankQc,rankQc],
      <font color="blue">redeclare </font>Real B[rankQc,1],
      <font color="blue">redeclare </font>Real C[1,rankQc],
      <font color="blue">redeclare </font>Real D[<font color="red">size</font>(ss.D, 1),<font color="red">size</font>(ss.D, 2)]) <font color="darkgreen">
        &quot;controllable state space system&quot;</font>;

  <font color="blue">algorithm </font>
    <font color="blue">if </font><font color="red">size</font>(ss.C, 1) &lt;&gt; 1<font color="blue"> or </font><font color="red">size</font>(ss.B, 2) &lt;&gt; 1<font color="blue"> then</font>
      <font color="red">assert</font>(<font color="red">size</font>(ss.B, 2) == 1,
        &quot;A SISO-system is expected as input\n but the number of inputs is &quot;
         + <font color="red">String</font>(<font color="red">size</font>(ss.B, 2)) + &quot; instead of 1&quot;);
      <font color="red">assert</font>(<font color="red">size</font>(ss.C, 1) == 1,
        &quot; A SISO-system is expected as input\n but the number of outputs is &quot;
         + <font color="red">String</font>(<font color="red">size</font>(ss.C, 1)) + &quot; instead of 1&quot;);
    <font color="blue">end if</font>;

    Ah1 := ss.A;
    bh1 := ss.B[:, 1];
    ch1 := ss.C[1, :];

    <font color="blue">if </font>nx &gt; 1<font color="blue"> then</font>

      u := <font color="red">Vectors.householderVector</font>(bh1, <font color="red">cat</font>(
            1,
            <font color="red">fill</font>(0, nx - 1),
            {1}));

      Ah1 := <font color="red">Matrices.householderSimilarityTransformation</font>(Ah1, u);

      bh1 := <font color="red">Vectors.householderReflexion</font>(bh1, u);
      ch1 := <font color="red">Vectors.householderReflexion</font>(ch1, u);

      ll := nx;

      h := true;
      r := 1;

      <font color="blue">while </font>r &lt;= nx - 2<font color="blue"> and </font>h<font color="blue"> loop</font>
        <font color="blue">if </font><font color="red">max</font>(Ah1[1:ll - 1, ll]) &lt;= 1e-8<font color="blue"> then</font>

          u := <font color="red">cat</font>(
                1,
                <font color="red">Vectors.householderVector</font>(Ah1[1:ll - 1, ll], <font color="red">cat</font>(
                  1,
                  <font color="red">fill</font>(0, ll - 2),
                  {1})),
                <font color="red">fill</font>(0, nx - ll + 1));
          Ah1 := <font color="red">Matrices.householderSimilarityTransformation</font>(Ah1, u);
          ch1 := <font color="red">Vectors.householderReflexion</font>(ch1, u);

          Ah1[1:ll - 2, ll] := <font color="red">fill</font>(0, ll - 2);

          ll := ll - 1;

        <font color="blue">else</font>
          h := false;

        <font color="blue">end if</font>;
        r := r + 1;
      <font color="blue">end while</font>;
    <font color="blue">end if</font>;

    Qc2 := <font color="red">cat</font>(
          2,
          Ah1[:, 2:nx],
          <font color="red">matrix</font>(bh1));
    sigma := <font color="red">Modelica.Math.Matrices.singularValues</font>(Qc2);
    eps2 := <font color="blue">if </font>eps &gt; 0<font color="blue"> then </font>eps<font color="blue"> else </font>1000*sigma[1]*Modelica.Constants.eps;
    rankQc2 := 0;

    <font color="blue">for </font>i<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
      <font color="red">Modelica.Utilities.Streams.print</font>(&quot; s[&quot; + <font color="red">String</font>(i) + &quot;] = &quot; + <font color="red">String</font>(
        sigma[i]));
      <font color="blue">if </font>sigma[i] &gt; eps2<font color="blue"> then</font>
        rankQc2 := rankQc2 + 1;
      <font color="blue">end if</font>;
    <font color="blue">end for</font>;

    <font color="red">Modelica.Utilities.Streams.print</font>(&quot;rankQc = &quot; + <font color="red">String</font>(rankQc) +
      &quot;     rankQc2 = &quot; + <font color="red">String</font>(rankQc2) + &quot;     eps2 = &quot; + <font color="red">String</font>(eps2));

    sst := <font color="red">StateSpace</font>(
          A=Ah1,
          B=<font color="red">matrix</font>(bh1),
          C=<font color="red">transpose</font>(<font color="red">matrix</font>(ch1)),
          D=ss.D);

    Ah2 := Ah1[nx - rankQc2 + 1:nx, nx - rankQc2 + 1:nx];
    bh2 := bh1[nx - rankQc2 + 1:nx];
    ch2 := ch1[nx - rankQc2 + 1:nx];
    ssm1 := <font color="red">StateSpace</font>(
          A=Ah2,
          B=<font color="red">matrix</font>(bh2),
          C=<font color="red">transpose</font>(<font color="red">matrix</font>(ch2)),
          D=ss.D);

  <font color="blue">end </font>reducedCtrSystem2</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.controllablePoles"><font color="blue">encapsulated </font><font color="blue">function</font> controllablePoles <font color="darkgreen">
      &quot;Compute the controllable and uncontrollable poles of a state space system&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss=<font color="red">StateSpace</font>(
        A=[-1],
        B=[1],
        C=[0],
        D=[0]);

    <font color="blue">output </font>Real cPoles[:,2] <font color="darkgreen">&quot;controllable poles&quot;</font>;
    <font color="blue">output </font>Real ncPoles[:,2] <font color="darkgreen">&quot;uncontrollable poles&quot;</font>;
    <font color="blue">output </font>Real poles[<font color="red">size</font>(ss.A, 1),2] <font color="darkgreen">&quot;controllable and uncontrollable poles&quot;</font>;
    <font color="blue">protected </font>
    <A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.StateSpaceR"
>Modelica_LinearSystems2.Internal.StateSpaceR</A> ssch(
      <font color="blue">redeclare </font>Real A[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)],
      <font color="blue">redeclare </font>Real B[<font color="red">size</font>(ss.B, 1),<font color="red">size</font>(ss.B, 2)],
      <font color="blue">redeclare </font>Real C[<font color="red">size</font>(ss.C, 1),<font color="red">size</font>(ss.C, 2)],
      <font color="blue">redeclare </font>Real D[<font color="red">size</font>(ss.D, 1),<font color="red">size</font>(ss.D, 2)]) <font color="darkgreen">
        &quot;upper block controller Hessenberg form state space system&quot;</font>;
    Boolean isControllable;

  <font color="blue">algorithm </font>
    <font color="blue">if </font><font color="red">size</font>(ss.B, 2) == 0<font color="blue"> then</font>
      poles := <font color="red">Modelica.Math.Matrices.eigenValues</font>(ss.A);
      ncPoles := poles;
      cPoles := <font color="red">fill</font>(0, 0, 2);
    <font color="blue">else</font>
  <font color="darkgreen">// build upper Hessenberg staircase to decomposite controllable/uncontrollable subspaces</font>
  <font color="darkgreen">// The controllable part of A is in A[1:ssch.r, 1:ssch.r]</font>
      (isControllable,ssch) := <font color="red">StateSpace.Internal.staircaseSVD</font>(ss);
      <font color="blue">if </font>isControllable<font color="blue"> then</font>
        poles := <font color="red">Modelica.Math.Matrices.eigenValues</font>(ss.A);
        cPoles := poles;
        ncPoles := <font color="red">fill</font>(0, 0, 2);
      <font color="blue">else</font>
        cPoles := <font color="red">Modelica.Math.Matrices.eigenValues</font>(ssch.A[1:ssch.r, 1:ssch.r]);
        ncPoles := <font color="red">Modelica.Math.Matrices.eigenValues</font>(ssch.A[ssch.r + 1:<font color="red">size</font>(ss.A,
          1), ssch.r + 1:<font color="red">size</font>(ss.A, 1)]);
        poles := [cPoles; ncPoles];
      <font color="blue">end if</font>;
    <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>controllablePoles</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.polesAndZeros"><font color="blue">encapsulated </font><font color="blue">function</font> polesAndZeros <font color="darkgreen">
      &quot;Generate poles and zeros from state space representation&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.PolesAndZeros"
>Modelica_LinearSystems2.Internal.PolesAndZeros</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;StateSpace object&quot;</font>;
    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ssm=<font color="red">Modelica_LinearSystems2.StateSpace.Transformation.toIrreducibleForm</font>(
                                                                         ss);
    <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.PolesAndZeros"
>Internal.PolesAndZeros</A> pz(
      <font color="blue">redeclare </font>Real p_real[<font color="red">size</font>(ssm.A, 1)],
      <font color="blue">redeclare </font>Real p_im[<font color="red">size</font>(ssm.A, 1)],
      <font color="blue">redeclare </font>Real z_real[<font color="red">size</font>(<font color="red">StateSpace.Analysis.invariantZeros</font>(ssm), 1)],
      <font color="blue">redeclare </font>Real z_im[<font color="red">size</font>(<font color="red">StateSpace.Analysis.invariantZeros</font>(ssm), 1)]);
    <font color="blue">protected </font>
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> poles[:]=<font color="red">Complex.eigenValues</font>(ssm.A);
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> zeros[:]=<font color="red">StateSpace.Analysis.invariantZeros</font>( ssm);

  <font color="blue">algorithm </font>
    pz.p_real := poles[:].re;
    pz.p_im := poles[:].im;
    pz.z_real := zeros[:].re;
    pz.z_im := zeros[:].im;
    pz.norz_p := <font color="red">Internal.numberOfRealZeros</font>(poles);
    pz.norz_z := <font color="red">Internal.numberOfRealZeros</font>(zeros);

  <font color="blue">end </font>polesAndZeros</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.scaleFactor1"><font color="blue">encapsulated </font><font color="blue">function</font> scaleFactor1 <font color="darkgreen">
      &quot;Return scale factor for first order block&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">input </font>Real n <font color="darkgreen">&quot;(s+n)/(s+d)&quot;</font>;
    <font color="blue">input </font>Real d <font color="darkgreen">&quot;(s+n)/(s+d)&quot;</font>;
    <font color="blue">input </font>Real small=100*Modelica.Constants.eps;
    <font color="blue">output </font>Real k <font color="darkgreen">&quot;= d/n, if d,n are not zero, otherwise special cases&quot;</font>;
  <font color="blue">algorithm </font>
    k := (<font color="blue">if </font><font color="red">abs</font>(d) &gt; small<font color="blue"> then </font><font color="red">abs</font>(d)<font color="blue"> else </font>1)/(<font color="blue">if </font><font color="red">abs</font>(n) &gt; small<font color="blue"> then </font><font color="red">abs</font>(n)<font color="blue"> else </font>
            1);
  <font color="blue">end </font>scaleFactor1</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.scaleFactor2"><font color="blue">function</font> scaleFactor2 <font color="darkgreen">&quot;Return scale factor for second order block&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">input </font>Real n1 <font color="darkgreen">&quot;(s^2 + n1*s + n2)/(s^2 + d1*s + d2)&quot;</font>;
    <font color="blue">input </font>Real n2 <font color="darkgreen">&quot;(s^2 + n1*s + n2)/(s^2 + d1*s + d2)&quot;</font>;
    <font color="blue">input </font>Real d1 <font color="darkgreen">&quot;(s^2 + n1*s + n2)/(s^2 + d1*s + d2)&quot;</font>;
    <font color="blue">input </font>Real d2 <font color="darkgreen">&quot;(s^2 + n1*s + n2)/(s^2 + d1*s + d2)&quot;</font>;
    <font color="blue">input </font>Real small=100*Modelica.Constants.eps;
    <font color="blue">output </font>Real k <font color="darkgreen">&quot;= d2/n2, if d2,n2 are not zero, otherwise special cases&quot;</font>;
  <font color="blue">algorithm </font>
    k := (<font color="blue">if </font><font color="red">abs</font>(d2) &gt; small<font color="blue"> then </font><font color="red">abs</font>(d2)<font color="blue"> else </font>(<font color="blue">if </font><font color="red">abs</font>(d1) &gt; small<font color="blue"> then </font><font color="red">abs</font>(
      d1)<font color="blue"> else </font>1))/(<font color="blue">if </font><font color="red">abs</font>(n2) &gt; small<font color="blue"> then </font><font color="red">abs</font>(n2)<font color="blue"> else </font>(<font color="blue">if </font><font color="red">abs</font>(n1) &gt; small<font color="blue"> then </font>
            <font color="red">abs</font>(n1)<font color="blue"> else </font>1));
  <font color="blue">end </font>scaleFactor2</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.invariantZerosHessenberg"><font color="blue">encapsulated </font><font color="blue">function</font> invariantZerosHessenberg <font color="darkgreen">
      &quot;Fast version to calculate the system zeros of a SISO system with D=[0] and A has upper Hessenberg form, delivered by StateSpace.reduceSystem&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;Linear system in state space form&quot;</font>;
    <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> Zeros[:] <font color="darkgreen">
        &quot;Finite, invariant zeros of ss; size(Zeros,1) &lt;= size(ss.A,1)&quot;</font>;

    <font color="blue">protected </font>
    Integer nx=<font color="red">size</font>(ss.A, 1) <font color="darkgreen">&quot;Number of states&quot;</font>;
    Integer nu=<font color="red">size</font>(ss.B, 2) <font color="darkgreen">&quot;Number of inputs&quot;</font>;
    Integer ny=<font color="red">size</font>(ss.C, 1) <font color="darkgreen">&quot;Number of outputs&quot;</font>;
    Real Ah[nx,nx]=ss.A;
    Real eps=100*Modelica.Constants.eps;
    Integer k;
    Boolean h;

  <font color="blue">algorithm </font>
    <font color="red">assert</font>(nu == 1, &quot;Function invariantZeros2 requires currently a SISO-input system.\n
This condition is however not fulfilled because the number of inputs is nu = &quot;
       + <font color="red">String</font>(nu));
    <font color="red">assert</font>(ny == 1, &quot;Function invariantZeros2 requires currently a SISO-input system.\n
This condition is however not fulfilled because the number of outputs is ny = &quot;
       + <font color="red">String</font>(ny));

    h := true;
    k := nx + 1;

    <font color="blue">if </font><font color="red">size</font>(ss.B, 2) &gt; 0<font color="blue"> then</font>
      <font color="blue">while </font>k &gt;= 1<font color="blue"> and </font>h<font color="blue"> loop</font>
        k := k - 1;
        <font color="blue">if </font><font color="red">abs</font>(ss.B[k, 1]) &gt;= eps<font color="blue"> then</font>

          h := false;
        <font color="blue">end if</font>;

      <font color="blue">end while</font>;

      Zeros := <font color="red">fill</font>(<font color="red">Complex</font>(0), k - 1);

      <font color="blue">if </font>k &gt; 1<font color="blue"> then</font>
        Ah[:, k - 1] := ss.A[:, k - 1] - ss.A[k, k - 1]/ss.B[k, 1]*ss.B[:, 1];

  <font color="darkgreen">//    Zeros := Complex.eigenValues(Ah[1:k - 1, 1:k - 1]);</font>
        Zeros := <font color="red">Complex.Internal.eigenValues_dhseqr</font>(Ah[1:k - 1, 1:k - 1]);

        <font color="blue">for </font>i<font color="blue"> in </font>1:k - 1<font color="blue"> loop</font>
          <font color="blue">if </font><font color="red">Complex.&#39;abs&#39;</font>(Zeros[i]) &lt; <font color="red">Modelica.Math.Matrices.norm</font>(Ah[1:k - 1, 1:
              k - 1], p=1)*1e-12<font color="blue"> then</font>
            Zeros[i] := <font color="red">Complex</font>(0);
          <font color="blue">end if</font>;

        <font color="blue">end for</font>;

      <font color="blue">end if</font>;
    <font color="blue">else</font>
      Zeros := <font color="red">fill</font>(<font color="red">Complex</font>(0, 0), 0);
    <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>invariantZerosHessenberg</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.cntrHessenberg"><font color="blue">encapsulated </font><font color="blue">function</font> cntrHessenberg <font color="darkgreen">
      &quot;calculate the controllable part of a SISO system&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Vectors.html#Modelica_LinearSystems2.Math.Vectors"
>Modelica_LinearSystems2.Math.Vectors</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;

    <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.StateSpaceR"
>Modelica_LinearSystems2.Internal.StateSpaceR</A> ssm1(
      <font color="blue">redeclare </font>Real A[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)],
      <font color="blue">redeclare </font>Real B[<font color="red">size</font>(ss.B, 1),1],
      <font color="blue">redeclare </font>Real C[1,<font color="red">size</font>(ss.C, 2)],
      <font color="blue">redeclare </font>Real D[<font color="red">size</font>(ss.D, 1),<font color="red">size</font>(ss.D, 2)]) <font color="darkgreen">
        &quot;controllable state space system&quot;</font>;

    <font color="blue">protected </font>
    Integer nx=<font color="red">size</font>(ss.A, 1);
    Real Ah1[nx,nx];
    Real bh1[nx];
    Real ch1[nx];
    Real u[:] <font color="darkgreen">&quot;householder vector&quot;</font>;
    Real Q[nx,nx];
    Real V[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)];
    Real tau[nx - 1];
    Real Qc[:,:];
    Real svd[:];
    Real normA=<font color="red">Modelica.Math.Matrices.norm</font>(A=ss.A, p=1);
    Integer rankMinSys;
    Boolean isZero=false;

  <font color="blue">algorithm </font>
    <font color="blue">if </font><font color="red">size</font>(ss.C, 1) &lt;&gt; 1<font color="blue"> or </font><font color="red">size</font>(ss.B, 2) &lt;&gt; 1<font color="blue"> then</font>
      <font color="red">assert</font>(<font color="red">size</font>(ss.B, 2) == 1,
        &quot;A SISO-system is expected as input\n but the number of inputs is &quot;
         + <font color="red">String</font>(<font color="red">size</font>(ss.B, 2)) + &quot; instead of 1&quot;);
      <font color="red">assert</font>(<font color="red">size</font>(ss.C, 1) == 1,
        &quot; A SISO-system is expected as input\n but the number of outputs is &quot;
         + <font color="red">String</font>(<font color="red">size</font>(ss.C, 1)) + &quot; instead of 1&quot;);
    <font color="blue">end if</font>;

    Ah1 := ss.A;
    bh1 := ss.B[:, 1];
    ch1 := ss.C[1, :];

    <font color="blue">if </font><font color="red">Modelica.Math.Vectors.length</font>(bh1) &gt; 0<font color="blue"> then</font>

      <font color="blue">if </font>nx &gt; 1<font color="blue"> then</font>

          <font color="darkgreen">// transform b-&gt;Qb = {*,0,...,0} and c-&gt;cQ, A-&gt;QAQ</font>
        u := <font color="red">Vectors.householderVector</font>(bh1, <font color="red">cat</font>(
              1,
              {1},
              <font color="red">fill</font>(0, nx - 1)));<font color="darkgreen">  //householder vector to compute a housholder reflector S = I - 2*u*u&#39;/u&#39;*u</font>
        Ah1 := <font color="red">Matrices.householderSimilarityTransformation</font>(Ah1, u);
        bh1 := <font color="red">Vectors.householderReflexion_e1</font>(bh1, u);
        ch1 := <font color="red">Vectors.householderReflexion</font>(ch1, u);

        (Ah1,V,tau) := <font color="red">Matrices.toUpperHessenberg</font>(
              Ah1,
              1,
              nx);
        Q := <font color="red">Matrices.orthogonalQ</font>(
              V,
              tau,
              1,
              nx);
        ch1 := ch1*Q;

      <font color="blue">end if</font>;

      rankMinSys := 1;
      <font color="blue">while </font>rankMinSys &lt; nx<font color="blue"> and </font><font color="blue">not </font>isZero<font color="blue"> loop</font>
        isZero := <font color="red">abs</font>(Ah1[rankMinSys + 1, rankMinSys]) &lt; normA*1e-10;
        rankMinSys := rankMinSys + 1;
      <font color="blue">end while</font>;

      ssm1 := <font color="red">Modelica_LinearSystems2.Internal.StateSpaceR</font>(
            A=Ah1,
            B=<font color="red">matrix</font>(bh1),
            C=<font color="red">transpose</font>(<font color="red">matrix</font>(ch1)),
            D=ss.D,
            r=<font color="blue">if </font>isZero<font color="blue"> then </font>rankMinSys - 1<font color="blue"> else </font>rankMinSys);

    <font color="blue">end if</font>;

  <font color="darkgreen">//equation</font>

  <font color="darkgreen">//algorithm</font>
  <font color="blue">end </font>cntrHessenberg</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.transposeStateSpace"><font color="blue">encapsulated </font><font color="blue">function</font> transposeStateSpace <font color="darkgreen">
      &quot;Return the transposed state space system&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;

    <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> sst=<font color="red">StateSpace</font>(
            A=<font color="red">transpose</font>(ss.A),
            B=<font color="red">transpose</font>(ss.C),
            C=<font color="red">transpose</font>(ss.B),
            D=<font color="red">transpose</font>(ss.D),
            uNames=ss.yNames,
            yNames=ss.uNames);
  <font color="blue">algorithm </font>

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>transposeStateSpace</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.reduceRosenbrock"><font color="blue">encapsulated </font><font color="blue">function</font> reduceRosenbrock <font color="darkgreen">
      &quot;Algorithm to compress the generalized system matrix [A, B; C, D] to calculate the invariant zeros of a system&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Vectors.html#Modelica_LinearSystems2.Math.Vectors"
>Modelica_LinearSystems2.Math.Vectors</A>;

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams.print"
>Modelica.Utilities.Streams.print</A>;

    <font color="blue">input </font>Real A[:,:];
    <font color="blue">input </font>Real B[:,:];
    <font color="blue">input </font>Real C[:,:];
    <font color="blue">input </font>Real D[:,:];

    <font color="blue">output </font>Real Ar[:,:];
    <font color="blue">output </font>Real Br[:,:];
    <font color="blue">output </font>Real Cr[:,:];
    <font color="blue">output </font>Real Dr[:,:];
    <font color="blue">output </font>Integer n;
    <font color="blue">output </font>Integer m;
    <font color="blue">output </font>Integer p;

    <font color="blue">protected </font>
    Real A2[:,:];
    Real B2[:,:];
    Real C2[:,:];
    Real CC[:,:];
    Real Co[:,:];
    Real Cu[:,:];
    Real D2[:,:];
    Real DD[:,:];
    Real Mr[:,:];
    Real Vf[:,:];
    Real V[:,:];
    Real V2[:,:];
    Real R[:,:];
    Real tau[:];

    Integer nx=<font color="red">size</font>(A, 1);
    Integer nu=<font color="red">size</font>(B, 2);
    Integer ny=<font color="red">size</font>(C, 1);

    Integer nue;
    Integer delta;
    Integer rho;
    Integer mue;
    Integer sigma;
    Integer j;
    Boolean stop;
    Boolean stop1 <font color="darkgreen">&quot;reduction finished&quot;</font>;
    Boolean stop2 <font color="darkgreen">&quot;system has no zeros&quot;</font>;
    Integer rankR;
    Real normA=<font color="red">Modelica.Math.Matrices.norm</font>(A=A, p=1);
    Real eps=normA*1e-10;

  <font color="blue">algorithm </font>
    <font color="blue">if </font>nx &gt; 0<font color="blue"> then</font>

      A2 := A;
      B2 := B;
      C2 := C;
      D2 := D;
      stop := false;
      stop1 := false;
      stop2 := false;
      nue := nx;
      delta := 0;
      mue := ny;
      sigma := ny;
      j := 1;

      <font color="blue">while </font><font color="blue">not </font>stop<font color="blue"> loop</font>
        (V,R,tau,V2) := <font color="red">Matrices.QR</font>( D2);

        rankR := 0;
  <font color="darkgreen">//  !!!! rank has to be determined. In the case of ill conditioned systems svd should be used</font>
        <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">min</font>(<font color="red">size</font>(R, 1), <font color="red">size</font>(R, 2))<font color="blue"> loop</font>
          <font color="blue">if </font><font color="red">abs</font>(R[i, <font color="red">size</font>(R, 2) - <font color="red">min</font>(<font color="red">size</font>(R, 1), <font color="red">size</font>(R, 2)) + i]) &gt; eps<font color="blue"> then</font>
            rankR := rankR + 1;
          <font color="blue">end if</font>;
        <font color="blue">end for</font>;

  <font color="darkgreen">//rankR:=Modelica.Math.Matrices.rank(R);</font>

        DD := R[1:rankR, :];

        CC := <font color="red">transpose</font>(V2)*C2;

        sigma := rankR;
        stop1 := <font color="red">size</font>(CC,1) == rankR;

        <font color="blue">if </font><font color="blue">not </font>stop1<font color="blue"> then</font>
          Cu := CC[sigma + 1:<font color="blue">end</font>, :];
          Co := CC[1:sigma, :];

          (V,R,tau,V2) := <font color="red">Matrices.QR</font>( <font color="red">Matrices.fliplr</font>(<font color="red">transpose</font>(Cu)));
           Vf:=<font color="red">Matrices.fliplr</font>(V2);

           rankR := 0;
  <font color="darkgreen">//  !!!! rank determination</font>
          <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">min</font>(<font color="red">size</font>(R, 1), <font color="red">size</font>(R, 2))<font color="blue"> loop</font>
            <font color="blue">if </font><font color="red">abs</font>(R[i, <font color="red">size</font>(R, 2) - <font color="red">min</font>(<font color="red">size</font>(R, 1), <font color="red">size</font>(R, 2)) + i]) &gt; eps<font color="blue"> then</font>
              rankR := rankR + 1;
            <font color="blue">end if</font>;
          <font color="blue">end for</font>;
  <font color="darkgreen">//rankR:=Modelica.Math.Matrices.rank(R);</font>

          rho := rankR;
          stop1 := rho == 0;
          stop2 := <font color="red">size</font>(Cu,2) == rankR;

          <font color="blue">if </font><font color="blue">not </font>stop1<font color="blue"> and </font><font color="blue">not </font>stop2<font color="blue"> then</font>
            nue := <font color="red">size</font>(Cu, 2) - rankR;
            mue := rho + sigma;
            delta := delta + rho;

            <font color="blue">if </font>sigma == 0<font color="blue"> then</font>
              Mr := [<font color="red">transpose</font>(Vf)*A2*Vf,<font color="red">transpose</font>(Vf)*B2];
            <font color="blue">else</font>
              Mr := [<font color="red">transpose</font>(Vf)*A2*Vf,<font color="red">transpose</font>(Vf)*B2; Co*Vf,DD];
            <font color="blue">end if</font>;

            A2 := Mr[1:nue, 1:nue];
            B2 := Mr[1:nue, nue + rho + 1:nue + rho + nu];
            C2 := Mr[nue + 1:nue + mue,1:nue];
            D2 := Mr[nue + 1:nue + mue,nue + rho + 1:nue + rho + nu];

            j := j + 1;
          <font color="blue">end if</font>;
         <font color="darkgreen">//not stop1 or not stop2</font>

        <font color="blue">end if</font>;
         <font color="darkgreen">//if not stop1</font>

        stop := stop1<font color="blue"> or </font>stop2<font color="blue"> or </font>j&gt;3*nx;

      <font color="blue">end while</font>;

      <font color="blue">if </font>stop1<font color="blue"> then</font>
        Ar := A2;
        Br := B2;
        Cr := C2;
        Dr := D2;
        n := nue;
        p := sigma;
        m := nu;
      <font color="blue">else</font>
        n := 0;
        p := 0;
        m := 0;
        Ar := <font color="red">fill</font>(0,0,0);
        Br := <font color="red">fill</font>(0,0,0);
        Cr := <font color="red">fill</font>(0,0,0);
        Dr := <font color="red">fill</font>(0,0,0);
      <font color="blue">end if</font>;

    <font color="blue">else</font>
      n := 0;
      p := 0;
      m := 0;
      A2 := A;
      B2 := B;
      C2 := C;
      D2 := D;
    <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>reduceRosenbrock</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.reducedCtrSystem"><font color="blue">encapsulated </font><font color="blue">function</font> reducedCtrSystem <font color="darkgreen">
      &quot;calculate the controllable part of a SISO system&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Vectors.html#Modelica_LinearSystems2.Math.Vectors"
>Modelica_LinearSystems2.Math.Vectors</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;

    <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.StateSpaceR"
>Modelica_LinearSystems2.Internal.StateSpaceR</A> ssm1(
      <font color="blue">redeclare </font>Real A[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)],
      <font color="blue">redeclare </font>Real B[<font color="red">size</font>(ss.B, 1),1],
      <font color="blue">redeclare </font>Real C[1,<font color="red">size</font>(ss.C, 2)],
      <font color="blue">redeclare </font>Real D[<font color="red">size</font>(ss.D, 1),<font color="red">size</font>(ss.D, 2)]) <font color="darkgreen">
        &quot;controllable state space system&quot;</font>;

    <font color="blue">protected </font>
    Integer nx=<font color="red">size</font>(ss.A, 1);
    Real Ah1[nx,<font color="red">size</font>(ss.A, 2)];
    Real bh1[nx];
    Real ch1[nx];
    Real u[:] <font color="darkgreen">&quot;householder vector&quot;</font>;
    Integer ll;
    Integer r=1;
    Real maxa;
    Real normA=<font color="red">Modelica.Math.Matrices.norm</font>(A=ss.A, p=1);

  <font color="blue">algorithm </font>
    <font color="blue">if </font><font color="red">size</font>(ss.C, 1) &lt;&gt; 1<font color="blue"> or </font><font color="red">size</font>(ss.B, 2) &lt;&gt; 1<font color="blue"> then</font>
      <font color="red">assert</font>(<font color="red">size</font>(ss.B, 2) == 1,
        &quot;A SISO-system is expected as input\n but the number of inputs is &quot;
         + <font color="red">String</font>(<font color="red">size</font>(ss.B, 2)) + &quot; instead of 1&quot;);
      <font color="red">assert</font>(<font color="red">size</font>(ss.C, 1) == 1,
        &quot; A SISO-system is expected as input\n but the number of outputs is &quot;
         + <font color="red">String</font>(<font color="red">size</font>(ss.C, 1)) + &quot; instead of 1&quot;);
    <font color="blue">end if</font>;

    Ah1 := ss.A;
    bh1 := ss.B[:, 1];
    ch1 := ss.C[1, :];

    <font color="blue">if </font><font color="red">Modelica.Math.Vectors.length</font>(bh1) &gt; 0<font color="blue"> then</font>
      r := 1;
      <font color="blue">if </font>nx &gt; 1<font color="blue"> then</font>

        u := <font color="red">Vectors.householderVector</font>(bh1, <font color="red">cat</font>(
              1,
              <font color="red">fill</font>(0, nx - 1),
              {1}));

        Ah1 := <font color="red">Matrices.householderSimilarityTransformation</font>(Ah1, u);
        bh1 := <font color="red">Vectors.householderReflexion_en</font>(bh1, u);
        ch1 := <font color="red">Vectors.householderReflexion</font>(ch1, u);
        bh1[1:nx - 1] := <font color="red">fill</font>(0, nx - 1);

        ll := nx;
        maxa := <font color="red">max</font>(<font color="red">abs</font>(Ah1[1:ll - 1, ll]));

        <font color="blue">while </font>r &lt;= nx - 1<font color="blue"> and </font>maxa &gt; nx*normA*1e-10<font color="blue"> loop</font>
          u := <font color="red">cat</font>(
                1,
                <font color="red">Vectors.householderVector</font>(Ah1[1:ll - 1, ll], <font color="red">cat</font>(
                  1,
                  <font color="red">fill</font>(0, ll - 2),
                  {1})),
                <font color="red">fill</font>(0, nx - ll + 1));

          Ah1 := <font color="red">Matrices.Internal.hohoTrafoLowerHess</font>(
                Ah1,
                u,
                r);

          ch1 := <font color="red">Vectors.householderReflexion</font>(ch1, u);
          ll := ll - 1;
          maxa := <font color="red">max</font>(<font color="red">abs</font>(Ah1[1:ll - 1, ll]));

          r := r + 1;
        <font color="blue">end while</font>;

      <font color="blue">end if</font>;

      ssm1 := <font color="red">Modelica_LinearSystems2.Internal.StateSpaceR</font>(
            A=Ah1,
            B=<font color="red">matrix</font>(bh1),
            C=<font color="red">transpose</font>(<font color="red">matrix</font>(ch1)),
            D=ss.D,
            r=r);
      ssm1.r := r;
    <font color="blue">end if</font>;
  <font color="blue">end </font>reducedCtrSystem</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.reducedCtrSystemX"><font color="blue">encapsulated </font><font color="blue">function</font> reducedCtrSystemX <font color="darkgreen">
      &quot;calculate the controllable part of a SISO system&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Vectors.html#Modelica_LinearSystems2.Math.Vectors"
>Modelica_LinearSystems2.Math.Vectors</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;

    <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.StateSpaceR"
>Modelica_LinearSystems2.Internal.StateSpaceR</A> ssm1(
      <font color="blue">redeclare </font>Real A[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)],
      <font color="blue">redeclare </font>Real B[<font color="red">size</font>(ss.B, 1),1],
      <font color="blue">redeclare </font>Real C[1,<font color="red">size</font>(ss.C, 2)],
      <font color="blue">redeclare </font>Real D[<font color="red">size</font>(ss.D, 1),<font color="red">size</font>(ss.D, 2)]) <font color="darkgreen">
        &quot;controllable state space system&quot;</font>;

    <font color="blue">protected </font>
    Integer nx=<font color="red">size</font>(ss.A, 1);
    Real Ah1[nx,<font color="red">size</font>(ss.A, 2)];
    Real bh1[nx];
    Real ch1[nx];
    Real u[:] <font color="darkgreen">&quot;householder vector&quot;</font>;
    Integer ll;
    Integer r=1;
    Real maxa;
    Real normA=<font color="red">Modelica.Math.Matrices.norm</font>(A=ss.A, p=1);

  <font color="blue">algorithm </font>
    <font color="blue">if </font><font color="red">size</font>(ss.C, 1) &lt;&gt; 1<font color="blue"> or </font><font color="red">size</font>(ss.B, 2) &lt;&gt; 1<font color="blue"> then</font>
      <font color="red">assert</font>(<font color="red">size</font>(ss.B, 2) == 1,
        &quot;A SISO-system is expected as input\n but the number of inputs is &quot;
         + <font color="red">String</font>(<font color="red">size</font>(ss.B, 2)) + &quot; instead of 1&quot;);
      <font color="red">assert</font>(<font color="red">size</font>(ss.C, 1) == 1,
        &quot; A SISO-system is expected as input\n but the number of outputs is &quot;
         + <font color="red">String</font>(<font color="red">size</font>(ss.C, 1)) + &quot; instead of 1&quot;);
    <font color="blue">end if</font>;

    Ah1 := ss.A;
    bh1 := ss.B[:, 1];
    ch1 := ss.C[1, :];

    <font color="blue">if </font><font color="red">Modelica.Math.Vectors.length</font>(bh1) &gt; 0<font color="blue"> then</font>
      r := 1;
      <font color="blue">if </font>nx &gt; 1<font color="blue"> then</font>

        u := <font color="red">Vectors.householderVector</font>(bh1, <font color="red">cat</font>(
              1,
              <font color="red">fill</font>(0, nx - 1),
              {1}));

        Ah1 := <font color="red">Matrices.householderSimilarityTransformation</font>(Ah1, u);
        bh1 := <font color="red">Vectors.householderReflexion_en</font>(bh1, u);
        ch1 := <font color="red">Vectors.householderReflexion</font>(ch1, u);
        bh1[1:nx - 1] := <font color="red">fill</font>(0, nx - 1);

        ll := nx;
        maxa := <font color="red">max</font>(<font color="red">abs</font>(Ah1[1:ll - 1, ll]));

        <font color="blue">while </font>r &lt;= nx - 1<font color="blue"> and </font>maxa &gt; nx*normA*1e-5<font color="blue"> loop</font>
          u := <font color="red">cat</font>(
                1,
                <font color="red">Vectors.householderVector</font>(Ah1[1:ll - 1, ll], <font color="red">cat</font>(
                  1,
                  <font color="red">fill</font>(0, ll - 2),
                  {1})),
                <font color="red">fill</font>(0, nx - ll + 1));

          Ah1 := <font color="red">Matrices.Internal.hohoTrafoLowerHess</font>(
                Ah1,
                u,
                r);

          ch1 := <font color="red">Vectors.householderReflexion</font>(ch1, u);
          ll := ll - 1;
          maxa := <font color="red">max</font>(<font color="red">abs</font>(Ah1[1:ll - 1, ll]));

          r := r + 1;
        <font color="blue">end while</font>;

      <font color="blue">end if</font>;

      ssm1 := <font color="red">Modelica_LinearSystems2.Internal.StateSpaceR</font>(
            A=Ah1,
            B=<font color="red">matrix</font>(bh1),
            C=<font color="red">transpose</font>(<font color="red">matrix</font>(ch1)),
            D=ss.D,
            r=r);
      ssm1.r := r;
    <font color="blue">end if</font>;
  <font color="blue">end </font>reducedCtrSystemX</textblock>;

<textblock type="model" expanded="false" path="Modelica_LinearSystems2.StateSpace.Internal.assignPolesMI2"><font color="blue">encapsulated </font><font color="blue">function</font> assignPolesMI2 <font color="darkgreen">
      &quot;Pole assigment design algorithm for multi input systems&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams.print"
>Modelica.Utilities.Streams.print</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;state space system&quot;</font>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> gamma[:]=<font color="red">fill</font>(<font color="red">Complex</font>(0),<font color="red"> size</font>(ss.A,1)) <font color="darkgreen">&quot;Designed Poles&quot;</font>;
  <font color="blue">input </font>Integer np=<font color="red">size</font>(gamma, 1) <font color="darkgreen">&quot;number of given eigenvalues to assign&quot;</font>;
  <font color="blue">input </font>Boolean giveEigenvalues=false <font color="darkgreen">
        &quot;Boolean parameter to display the order of the eigenvalues&quot;</font>;
  <font color="blue">input </font>Real alpha=-1e10 <font color="darkgreen">
        &quot;maximum admissible value for real parts(continuous) or for moduli (discrete) of the eigenvalues of A which will not be modified by the eigenvalue assignment algorithm&quot;</font>;
  <font color="blue">input </font>Real tolerance=<font color="red">Modelica.Math.Matrices.norm</font>(ss.A, 1)*1e-12 <font color="darkgreen">
        &quot;The tolerance to be used in determining the controllability of (A,B)&quot;</font>;
  <font color="blue">output </font>Real K[<font color="red">size</font>(ss.B, 2),<font color="red">size</font>(ss.A, 1)] <font color="darkgreen">
        &quot;State feedback matrix assigning the desired poles&quot;</font>;
  <font color="blue">output </font>Real S[:,:] <font color="darkgreen">&quot;Closed loop System matrix&quot;</font>;
  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> po[<font color="red">size</font>(ss.A, 1)] <font color="darkgreen">&quot;poles of the closed loop system&quot;</font>;
  <font color="blue">output </font>Integer nfp <font color="darkgreen">
        &quot;number of eigenvalues that are not modified with respect to alpha&quot;</font>;
  <font color="blue">output </font>Integer nap <font color="darkgreen">&quot;number of assigned eigenvalues&quot;</font>;
  <font color="blue">output </font>Integer nup <font color="darkgreen">&quot;number of uncontrollable eigenvalues&quot;</font>;
  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> X[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 1)] <font color="darkgreen">
        &quot;eigenvectors of the closed loop system&quot;</font>;

    <font color="blue">protected </font>
  Real A_rsf[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)];
  Real B_rsf[<font color="red">size</font>(ss.B, 1),<font color="red">size</font>(ss.B, 2)];
  Real Q[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 1)];
  Real Ks1[:,:];
  Real Ks2[:,:];
  Real Q2[:,:];
  Real A_rsf_1[:,:];
  Real Q1[:,:];
  Boolean select[:];
  Boolean rselectA[:];
  Real Z[:,:] <font color="darkgreen">&quot;orthogonal transformation matrix&quot;</font>;
  Real ZT[:,:] <font color="darkgreen">&quot;orthogonal transformation matrix&quot;</font>;
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> pf[:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> gammaReordered[:]=gamma;
  Integer info;
  Real wr[<font color="red">size</font>(gamma, 1)];
  Real wi[<font color="red">size</font>(gamma, 1)];
  Boolean imag=false;
  Integer i;
  Integer ii;
  Integer counter;
  Integer n=<font color="red">size</font>(ss.A, 1);
  Integer ipf;
  Integer nccA <font color="darkgreen">&quot;number of conjugated complex pole pairs of unmodified system&quot;</font>;
  Integer nccg <font color="darkgreen">&quot;number of conjugated complex pole pairs of gamma&quot;</font>;
  Integer ncc;

  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> h;
  Integer h2[2];
  Real alphaReal[<font color="red">size</font>(ss.A, 1)] <font color="darkgreen">&quot;Real part of eigenvalue=alphaReal+i*alphaImag&quot;</font>;
  Real alphaImag[<font color="red">size</font>(ss.A, 1)] <font color="darkgreen">
        &quot;Imaginary part of eigenvalue=(alphaReal+i*alphaImag&quot;</font>;

  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> pi[:]=<font color="red">Complex.eigenValues</font>(ss.A);

  Boolean complex_assignedPoles=false <font color="darkgreen">
        &quot;true if there is at least one conjugated comples pole pair in the set of the assigned poles&quot;</font>;
  Boolean complex_originalPoles=false <font color="darkgreen">
        &quot;true if there is at least one conjugated comples pole pair in the set of unmodified system poles&quot;</font>;
  Boolean consistency;

  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> SS[:,:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> Xj[:,:];

  Integer markA[n]=<font color="red">fill</font>(1,n);
  Integer markg[n]=<font color="red">fill</font>(1,n);

  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> ev[:];

<font color="blue">algorithm </font>
  <font color="blue">if </font>giveEigenvalues<font color="blue"> then</font>
    (,,alphaReal,alphaImag,info) :=
      <font color="red">Modelica_LinearSystems2.Math.Matrices.LAPACK.dgees</font>(ss.A);
    <font color="red">assert</font>(info == 0, &quot;The output info of LAPACK.dgees should be zero, else if\n
     info &lt; 0:  if info = -i, the i-th argument of dgees had an illegal value\n
     info &gt; 0:  if INFO = i, and i is   
               &lt;= N: the QR algorithm failed to compute all the   
                     eigenvalues; elements 1:ILO-1 and i+1:N of WR and WI   
                     contain those eigenvalues which have converged; if   
                     JOBVS = &#39;V&#39;, VS contains the matrix which reduces A   
                     to its partially converged Schur form.\n&quot;);
    <font color="blue">for </font>i<font color="blue"> in </font>1:n<font color="blue"> loop</font>
      po[i].re := alphaReal[i];
      po[i].im := alphaImag[i];
    <font color="blue">end for</font>;
    <font color="red">Complex.Vectors.print</font>(&quot;The eigenvalues of the open loop system are sorted to\n eigenvalues&quot;, pi);
  <font color="blue">else</font>
    <font color="red">assert</font>(<font color="red">size</font>(gamma, 1) &lt;=<font color="red"> size</font>(ss.A, 1), &quot;At most n (order of ss) eigenvalues can be assigned&quot;);

 <font color="darkgreen">/* Extraction of Poles (Variable conversation) and pole sequence check */</font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(gamma, 1)<font color="blue"> loop</font>
    wr[i] := gamma[i].re;
    wi[i] := gamma[i].im;
    <font color="blue">if </font>imag<font color="blue"> then</font>
      <font color="red">assert</font>(wi[i - 1] == -wi[i]<font color="blue"> and </font>wr[i - 1] == wr[i],
        &quot;Poles are in wrong sequence&quot;);
      imag := false;
    <font color="blue">elseif </font>wi[i] &lt;&gt; 0<font color="blue"> then</font>
      imag := true;
    <font color="blue">end if</font>;
  <font color="blue">end for</font>;

  <font color="darkgreen">// put matrix ss.A to real Schur form A &lt;- QAQ&#39; and compute B &lt;- QB</font>
  (A_rsf,Z,alphaReal,alphaImag) :=<font color="red"> Matrices.rsf2</font>(ss.A);
  ZT :=<font color="red"> transpose</font>(Z);

  <font color="darkgreen">// determine number of poles not to be assigned according to alpha</font>
     nfp := 0;
     nccA := 0;
     nccg := 0;
     <font color="blue">for </font>i<font color="blue"> in </font>1:n<font color="blue"> loop</font>
       <font color="blue">if </font>alphaReal[i] &lt; alpha<font color="blue"> then</font>
         nfp := nfp + 1;
         markA[i] := 0;
         markg[i] := 0;
       <font color="blue">end if</font>;
       <font color="blue">if </font><font color="red">abs</font>(alphaImag[i]) &gt; 0<font color="blue"> then</font>
         markA[i] := 2;
         nccA := nccA + 1;
       <font color="blue">end if</font>;
       <font color="blue">if </font><font color="red">abs</font>(gammaReordered[i].im) &gt; 0<font color="blue"> then</font>
         markg[i] := 2;
         nccg := nccg + 1;
       <font color="blue">end if</font>;
     <font color="blue">end for</font>;
     nap := n - nfp;
     nccA :=<font color="red"> div</font>(nccA, 2);
     nccg :=<font color="red"> div</font>(nccg, 2);
     ncc :=<font color="red"> max</font>(nccA, nccg);

   <font color="darkgreen">// reorder real Schur form according to alpha</font>
   (A_rsf,Z,alphaReal,alphaImag) :=<font color="red"> Matrices.Internal.reorderRSF2</font>(
       A_rsf,
       <font color="red">identity</font>(<font color="red">size</font>(A_rsf, 1)),
       alphaReal,
       alphaImag,
       alpha);
   ZT :=<font color="red"> transpose</font>(Z)*ZT;
   B_rsf := ZT*ss.B;

    <font color="red">Modelica_LinearSystems2.Math.Vectors.printVector</font>(alphaReal,6,&quot;alphaReal&quot;);
    <font color="red">Modelica_LinearSystems2.Math.Vectors.printVector</font>(alphaImag,6,&quot;alphaImag&quot;);
   <font color="red">Modelica_LinearSystems2.Math.Complex.Vectors.print</font>(&quot;gammaReordered1&quot;,gammaReordered);

  <font color="darkgreen">// Reorder gammaReordered according to alpha</font>
    ii := 1;
    <font color="blue">for </font>i<font color="blue"> in </font>1:n<font color="blue"> loop</font>
      <font color="blue">if </font>markg[i]==0<font color="blue"> then</font>
        h := gammaReordered[ii];
        gammaReordered[ii] := gammaReordered[i];
        gammaReordered[i] := h;
        ii := ii+1;
      <font color="blue">end if</font>;
    <font color="blue">end for</font>;

   <font color="darkgreen">// check consistency of poles assignment, i.e. complex pole pairs in gammaReordered and alphaReal and alphaImag may not be separated</font>
    consistency:=true;
    i:=1;
    <font color="blue">while </font>i&lt;n<font color="blue"> loop</font>
      <font color="blue">if </font>markA[i]==2<font color="blue"> then</font>
        consistency :=markA[i + 1] == 2<font color="blue"> and </font>((markg[i] == 2<font color="blue"> and </font>markg[i + 1] == 2)<font color="blue">
          or </font>(markg[i] == 1<font color="blue"> and </font>markg[i + 1] == 1));
        i := i+2;
      <font color="blue">elseif </font>markg[i]==2<font color="blue"> then</font>
        consistency :=markg[i + 1] == 2<font color="blue"> and </font>(markA[i] == 1<font color="blue"> and </font>markA[i + 1] == 1);
        i := i+2;
      <font color="blue">else</font>
        i := i+1;
      <font color="blue">end if</font>;
    <font color="blue">end while</font>;
   <font color="red">assert</font>(consistency,&quot;System poles and assigned poles have to be assigned consistently, i.e. complex pole pairs may not be separated&quot;);

  <font color="darkgreen">// main algorithm</font>
  K :=<font color="red"> zeros</font>(<font color="red">size</font>(ss.B, 2),<font color="red"> size</font>(ss.A, 1));
  counter := nfp + 1;
   <font color="blue">while </font>counter&lt;=n<font color="blue"> loop</font>
    <font color="blue">if </font>markA[n + nfp + 1 - counter] == 2<font color="blue"> or </font>markg[n + nfp + 1 - counter] == 2<font color="blue"> then</font>

<font color="darkgreen">//#############################</font>
<font color="red">Modelica_LinearSystems2.Math.Complex.Vectors.print</font>(&quot;g2&quot;,gammaReordered[n + nfp - counter:n + nfp + 1 - counter]);
<font color="red">Modelica_LinearSystems2.Math.Vectors.printVector</font>(alphaReal[n + nfp - counter:n + nfp + 1 - counter],6,&quot;ar2&quot;);
ev:=<font color="red">Modelica_LinearSystems2.Math.Complex.eigenValues</font>( A_rsf[n - 1:n, n - 1:n]);
<font color="red">Modelica_LinearSystems2.Math.Complex.Vectors.print</font>(&quot;ev2&quot;,ev);
<font color="darkgreen">//#############################</font>

      Ks2 :=<font color="red"> StateSpace.Internal.assignOneOrTwoPoles</font>(
        A_rsf[n - 1:n, n - 1:n],
        <font color="red">matrix</font>(B_rsf[n - 1:n, :]),
        gammaReordered[n + nfp - counter:n + nfp +
        1 - counter],
        tolerance);
      K := K + [<font color="red">zeros</font>(<font color="red">size</font>(Ks2, 1),<font color="red"> size</font>(K, 2) - 2),Ks2]*ZT;
      A_rsf := A_rsf - B_rsf*[<font color="red">zeros</font>(<font color="red">size</font>(Ks2, 1),<font color="red"> size</font>(K, 2) - 2),Ks2];
      select :=<font color="red"> fill</font>(false, n - counter + 1);
      select[n - counter:n - counter + 1] := {true,true};

      (A_rsf[counter:n, counter:n],Q2) :=<font color="red"> Matrices.LAPACK.dtrsen</font>(
        &quot;E&quot;,
        &quot;V&quot;,
        select,
        A_rsf[counter:n, counter:n],
        <font color="red">identity</font>(n - counter + 1));<font color="darkgreen">  //The Schur vector matrix is identity, since A_rsf already has Schur form</font>

      A_rsf[1:counter - 1, counter:n] := A_rsf[1:counter - 1, counter:n]*Q2;
      B_rsf[counter:n, :] :=<font color="red"> transpose</font>(Q2)*B_rsf[counter:n, :];
      ZT[counter:n, :] :=<font color="red"> transpose</font>(Q2)*ZT[counter:n, :];
<font color="darkgreen">//       h2 := markA[counter:counter + 1];</font>
<font color="darkgreen">//       markA[counter:counter + 1] := markA[n - 1:n];</font>
<font color="darkgreen">//       markA[n - 1:n] := h2;</font>
<font color="darkgreen">//       h2 := markg[counter:counter + 1];</font>
<font color="darkgreen">//       markg[counter:counter + 1] := markg[n - 1:n];</font>
<font color="darkgreen">//       markg[n - 1:n] := h2;</font>
<font color="darkgreen">//       h := gammaReordered[n - 1];</font>
<font color="darkgreen">//       gammaReordered[n - 1] := gammaReordered[counter];</font>
<font color="darkgreen">//       gammaReordered[counter] := gammaReordered[n - 1];</font>
<font color="darkgreen">//       h := gammaReordered[n];</font>
<font color="darkgreen">//       gammaReordered[n] := gammaReordered[counter + 1];</font>
<font color="darkgreen">//       gammaReordered[counter + 1] := gammaReordered[n];</font>
      counter := counter + 2;
    <font color="blue">else</font>
<font color="darkgreen">//#############################</font>
<font color="red">print</font>(&quot;g1 = &quot;+<font color="red">String</font>(gammaReordered[n + nfp + 1 - counter]));
<font color="red">print</font>(&quot;ar1 = &quot;+<font color="red">String</font>(alphaReal[n + nfp + 1 - counter]));
<font color="red">print</font>(&quot;ev1 = &quot;+<font color="red">String</font>(A_rsf[n,n])+&quot;\n&quot;);
<font color="darkgreen">//#############################</font>

      Ks1 :=<font color="red"> StateSpace.Internal.assignOneOrTwoPoles</font>(
        <font color="red">matrix</font>(A_rsf[n, n]),
        <font color="red">transpose</font>(<font color="red">matrix</font>(B_rsf[n, :])),
        {gammaReordered[n + nfp + 1 - counter]},
        tolerance);

      K := K + [<font color="red">zeros</font>(<font color="red">size</font>(Ks1, 1),<font color="red"> size</font>(K, 2) - 1),Ks1]*ZT;
      A_rsf := A_rsf - B_rsf*[<font color="red">zeros</font>(<font color="red">size</font>(Ks1, 1),<font color="red"> size</font>(K, 2) - 1),Ks1];
      select :=<font color="red"> fill</font>(false, n - counter + 1);
      select[n - counter + 1] := true;

      (A_rsf[counter:n, counter:n],Q1) :=<font color="red"> Matrices.LAPACK.dtrsen</font>(
        &quot;E&quot;,
        &quot;V&quot;,
        select,
        A_rsf[counter:n, counter:n],
        <font color="red">identity</font>(n - counter + 1));<font color="darkgreen"> //The Schur vector matrix is identity, since A_rsf already has Schur form</font>

      A_rsf[1:counter - 1, counter:n] := A_rsf[1:counter - 1, counter:n]*Q1;
      B_rsf[counter:n, :] :=<font color="red"> transpose</font>(Q1)*B_rsf[counter:n, :];
      ZT[counter:n, :] :=<font color="red"> transpose</font>(Q1)*ZT[counter:n, :];
<font color="darkgreen">//       h2[1] := markA[counter];</font>
<font color="darkgreen">//       markA[counter] := markA[n];</font>
<font color="darkgreen">//       markA[n] := h2[1];</font>
<font color="darkgreen">//       h2[1] := markg[counter];</font>
<font color="darkgreen">//       markg[counter] := markg[n];</font>
<font color="darkgreen">//       markg[n] := h2[1];</font>
<font color="darkgreen">//       h := gammaReordered[n];</font>
<font color="darkgreen">//       gammaReordered[n] := gammaReordered[counter];</font>
<font color="darkgreen">//       gammaReordered[counter] := gammaReordered[n];</font>
      counter := counter + 1;
    <font color="blue">end if</font>;

    <font color="blue">end while</font>;

  S := ss.A - ss.B*K;
  po :=<font color="red"> Complex.eigenValues</font>(S);
   X :=<font color="red"> Complex.eigenVectors</font>(S);

<font color="darkgreen">//    X := fill(Complex(0),n,n);</font>
<font color="darkgreen">//    for i in 1:n loop</font>
<font color="darkgreen">//      SS:=Complex(1)*S;</font>
<font color="darkgreen">//      for ii in 1:n loop</font>
<font color="darkgreen">//        SS[ii,ii] := SS[ii,ii]-po[i];</font>
<font color="darkgreen">//      end for;</font>
<font color="darkgreen">//      Xj := Modelica_LinearSystems2.WorkInProgress.Math.Matrices.C_nullspace(</font>
<font color="darkgreen">//                                 SS);</font>
<font color="darkgreen">//      // Matrices.printMatrix(Complex.real(Xj),6,&quot;ReXj&quot;);</font>
<font color="darkgreen">//      // Matrices.printMatrix(Complex.imag(Xj),6,&quot;ImXj&quot;);</font>
<font color="darkgreen">//      for ii in 1:n loop</font>
<font color="darkgreen">//        X[ii,i] := Xj[ii,1];</font>
<font color="darkgreen">//      end for;</font>
<font color="darkgreen">//    end for;</font>

<font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>assignPolesMI2</textblock>;

<font color="blue">end </font>Internal</textblock>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>StateSpace;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE TransferFunction<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.StateSpaceI.png" ALT="Modelica_LinearSystems2.TransferFunction" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.TransferFunction"></A><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>.TransferFunction</H2>
<B>Continuous transfer function description of a single input, single output system (data + operations)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This record defines the transfer function between the input signal u
and the output signal y by the coefficients of the numerator and denominator
polynomials n(s) and d(s) respectively:
</p>
<pre>        n(s)
   y = ------ * u
        d(s)
</pre>
<p>
The order of the numerator 
polynomial can be larger as the order of the denominator polynomial
(in such a case, the transfer function can not be
transformed to a StateSpace system, but other operations are possible).
</p>
<p>
Example: The transfer function
</p>
<pre>             2*s+3
   y = ----------------- * u
        4*s^2 + 5*s + 6
</pre>
<p>
is transformed in the following way in a TransferFunction record:
</p>
<pre>
   <b>import</b> Modelica_LinearSystems2.TransferFunction;
   <b>import</b> Modelica.Utilities.Streams;
   TransferFunction tf(n={2,3}, d={4,5,6});
   print("y = " + TransferFunction.'String'(tf) + " * u");
   // prints the following string to the output window:
   //   y = (2*s + 3) / (4*s^2 + 5*s + 6) * u
</pre>
<pre></PRE><P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Record"
>Modelica.Icons.Record</A> (Icon for a record).
<P><H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>y = n*{s^m, ... , s, 1} / (d*{s^r, ... , s, 1}) * u</TD></TR>
<TR><TD>Real</TD><TD>n[:]</TD><TD>&nbsp;</TD><TD>Coefficients of numerator polynomial (in descending order)</TD></TR>
<TR><TD>Real</TD><TD>d[:]</TD><TD>&nbsp;</TD><TD>Coefficients of denominator polynomial (in descending order)</TD></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>Signal names</TD></TR>
<TR><TD>String</TD><TD>uName</TD><TD>&quot;u&quot;</TD><TD>Name of input signal</TD></TR>
<TR><TD>String</TD><TD>yName</TD><TD>&quot;y&quot;</TD><TD>Name of output signal</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">record</font> TransferFunction <font color="darkgreen">
  &quot;Continuous transfer function description of a single input, single output system (data + operations)&quot;</font>

  <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Record"
>Modelica.Icons.Record</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Modelica_LinearSystems2.Math.Polynomial</A>;

  Real n[:] <font color="darkgreen">&quot;Coefficients of numerator polynomial (in descending order)&quot;</font>;
  Real d[:] <font color="darkgreen">&quot;Coefficients of denominator polynomial (in descending order)&quot;</font>;

  String uName=&quot;u&quot; <font color="darkgreen">&quot;Name of input signal&quot;</font>;
  String yName=&quot;y&quot; <font color="darkgreen">&quot;Name of output signal&quot;</font>;

<font color="darkgreen">/* If the numerator polynomial has no coefficients, the transfer function
   is zero. The denominator polynomial must always have at
   least one coefficient, such as {1}
*/</font>

  <textblock type="packagesmall" expanded="false" path="Modelica_LinearSystems2.TransferFunction.'constructor'"><font color="blue">encapsulated </font><font color="blue">operator</font> &#39;constructor&#39; <font color="darkgreen">
    &quot;Default constructor for a transfer function&quot;</font>
    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.'constructor'.fromReal"><font color="blue">function</font> fromReal <font color="darkgreen">
      &quot;Generate a TransferFunction data record from a Real value&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;

      <font color="blue">input </font>Real r <font color="darkgreen">&quot;Value of Real variable&quot;</font>;
      <font color="blue">input </font>String uName=&quot;&quot; <font color="darkgreen">&quot;input name&quot;</font>;
      <font color="blue">input </font>String yName=&quot;&quot; <font color="darkgreen">&quot;output name&quot;</font>;
      <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf(n={r}, d={1});

    <font color="blue">algorithm </font>
      tf.uName := uName;
      tf.yName := yName;
<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>fromReal</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.'constructor'.fromZerosAndPoles"><font color="blue">encapsulated </font><font color="blue">function</font> fromZerosAndPoles <font color="darkgreen">
      &quot;Generate a transfer function from a set of zeros and poles&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Modelica_LinearSystems2.Math.Polynomial</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> z[:]=<font color="red">fill</font>(<font color="red">Modelica_LinearSystems2.Math.Complex</font>(0), 0) <font color="darkgreen">
        &quot;Zeros (Complex vector of numerator zeros)&quot;</font>;
    <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> p[:]=<font color="red">fill</font>(<font color="red">Modelica_LinearSystems2.Math.Complex</font>(0), 0) <font color="darkgreen">
        &quot;Poles (Complex vector of denominator zeros)&quot;</font>;
    <font color="blue">input </font>Real k=1.0 <font color="darkgreen">&quot;Constant multiplied with transfer function&quot;</font>;
    <font color="blue">input </font>String uName=&quot;&quot; <font color="darkgreen">&quot;input name&quot;</font>;
    <font color="blue">input </font>String yName=&quot;&quot; <font color="darkgreen">&quot;output name&quot;</font>;
    <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf(<font color="blue">redeclare </font>Real n[<font color="red">size</font>(z, 1)+1], <font color="blue">redeclare </font>Real d[<font color="red">size</font>(p, 1)+1]) <font color="darkgreen">
        &quot;TransferFunction built by ZerosAndPoles object&quot;</font>;

    <font color="blue">protected </font>
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Polynomial</A> pn=k*<font color="red">Polynomial</font>(z);
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Polynomial</A> pd=<font color="red">Polynomial</font>(p);
  <font color="blue">algorithm </font>

  tf.n := pn.c;
    tf.d := pd.c;
    tf.uName := uName;
    tf.yName := yName;

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>fromZerosAndPoles</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.'constructor'.fromArrays"><font color="blue">encapsulated </font><font color="blue">function</font> fromArrays <font color="darkgreen">
      &quot;Generate a TransferFunction data record from numerator and denominator array&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;

           <font color="blue">input </font>Real n[:] <font color="darkgreen">&quot;Coefficients of numerator polynomial&quot;</font>;
           <font color="blue">input </font>Real d[:] <font color="darkgreen">&quot;Coefficients of denominator polynomial&quot;</font>;
           <font color="blue">input </font>String uName = &quot;&quot; <font color="darkgreen">&quot;input name&quot;</font>;
           <font color="blue">input </font>String yName = &quot;&quot; <font color="darkgreen">&quot;output name&quot;</font>;

           <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf(<font color="blue">redeclare </font>Real n[<font color="red">size</font>(n, 1)], <font color="blue">redeclare </font>Real
          d[<font color="red">                                                                         size</font>(d, 1)]) <font color="darkgreen">
        &quot;Transfer function&quot;</font>;

    <font color="blue">algorithm </font>
      <font color="darkgreen">           //this is the constructor algorithm</font>
      <font color="red">     assert</font>(<font color="red">size</font>(d, 1) &gt; 0, &quot;Input denominator d must have at least one element, however\n&quot;
              + &quot;d is an empty vector&quot;);
           tf.n := n;
           tf.d := d;
           tf.uName := uName;
           tf.yName := yName;
    <font color="blue">end </font>fromArrays</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.'constructor'.fromPolynomials"><font color="blue">function</font> fromPolynomials <font color="darkgreen">
      &quot;Generate a TransferFunction data record from a numerator and denominator polynomial&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Modelica_LinearSystems2.Math.Polynomial</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Polynomial</A> n <font color="darkgreen">&quot;Numerator polynomial&quot;</font>;
      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Polynomial</A> d <font color="darkgreen">&quot;Denominator polynomial&quot;</font>;
      <font color="blue">input </font>String uName=&quot;&quot; <font color="darkgreen">&quot;input name&quot;</font>;
      <font color="blue">input </font>String yName=&quot;&quot; <font color="darkgreen">&quot;output name&quot;</font>;
      <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf(n=n.c, d=d.c,uName=uName, yName=yName);

    <font color="blue">algorithm </font>

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>fromPolynomials</textblock>;

  <font color="blue">end </font>&#39;constructor&#39;</textblock>;

  <textblock type="packagesmall" expanded="false" path="Modelica_LinearSystems2.TransferFunction.'-'"><font color="blue">encapsulated </font><font color="blue">operator</font> &#39;-&#39;
    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.'-'.subtract"><font color="blue">function</font> subtract <font color="darkgreen">&quot;Subtract two TransferFunctions (tf1 - tf2)&quot;</font>
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Modelica_LinearSystems2.Math.Polynomial</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf1;
      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf2;

      <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> result = (<font color="red">Polynomial</font>(tf1.n)*<font color="red">Polynomial</font>(tf2.d) - <font color="red">Polynomial</font>(tf2.n)*<font color="red">Polynomial</font>(tf1.d))/(<font color="red">Polynomial</font>(tf1.d)*<font color="red">Polynomial</font>(tf2.d));

    <font color="blue">algorithm </font>
    <font color="blue">end </font>subtract</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.'-'.negate"><font color="blue">function</font> negate <font color="darkgreen">&quot;Unary minus (multiply transfer function by -1)&quot;</font>
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf;
      <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> result(n=-tf.n, d=tf.d) <font color="darkgreen">&quot;= -tf&quot;</font>;
    <font color="blue">algorithm </font>
    <font color="blue">end </font>negate</textblock>;
  <font color="blue">end </font>&#39;-&#39;</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.'+'"><font color="blue">encapsulated </font><font color="blue">operator function</font> &#39;+&#39; <font color="darkgreen">
    &quot;Parallel connection of two transfer functions (= inputs are the same, outputs of the two systems are added)&quot;</font>
     <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Modelica_LinearSystems2.Math.Polynomial</A>;
     <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;

     <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf1 <font color="darkgreen">&quot;Transfer function system 1&quot;</font>;
     <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf2 <font color="darkgreen">&quot;Transfer function system 2&quot;</font>;
     <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> result;
  <font color="blue">algorithm </font>
      result := (<font color="red">Polynomial</font>(tf1.n)*<font color="red">Polynomial</font>(tf2.d) + <font color="red">Polynomial</font>(tf2.n)*<font color="red">Polynomial</font>(tf1.d))/(<font color="red">Polynomial</font>(tf1.d)*<font color="red">Polynomial</font>(tf2.d));
  <font color="blue">end </font>&#39;+&#39;</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.'*'"><font color="blue">encapsulated </font><font color="blue">operator function</font> &#39;*&#39; <font color="darkgreen">
    &quot;Multiply two TransferFunctions (tf1 * tf2)&quot;</font>
     <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Modelica_LinearSystems2.Math.Polynomial</A>;
     <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;

     <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf1 <font color="darkgreen">&quot;Transfer function system 1&quot;</font>;
     <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf2 <font color="darkgreen">&quot;Transfer function system 1&quot;</font>;
     <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> result;
  <font color="blue">algorithm </font>
     result := (<font color="red">Polynomial</font>(tf1.n)*<font color="red">Polynomial</font>(tf2.n))/(<font color="red">Polynomial</font>(tf1.d)*<font color="red">Polynomial</font>(tf2.d));
  <font color="blue">end </font>&#39;*&#39;</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.'/'"><font color="blue">encapsulated </font><font color="blue">operator function</font> &#39;/&#39; <font color="darkgreen">
    &quot;Divide two transfer functions (tf1 / tf2)&quot;</font>
     <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Modelica_LinearSystems2.Math.Polynomial</A>;
     <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;

     <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf1 <font color="darkgreen">&quot;Transfer function system 1&quot;</font>;
     <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf2 <font color="darkgreen">&quot;Transfer function system 1&quot;</font>;
     <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> result;
  <font color="blue">algorithm </font>
    result := (<font color="red">Polynomial</font>(tf1.n)*<font color="red">Polynomial</font>(tf2.d))/(<font color="red">Polynomial</font>(tf1.d)*
      <font color="red">Polynomial</font>(tf2.n));
  <font color="blue">end </font>&#39;/&#39;</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.'^'"><font color="blue">encapsulated </font><font color="blue">operator function</font> &#39;^&#39; <font color="darkgreen">
    &quot;Integer power of TransferFunction (tf1^k)&quot;</font>
     <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Modelica_LinearSystems2.Math.Polynomial</A>;
     <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;

     <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf <font color="darkgreen">&quot;Transfer function&quot;</font>;
     <font color="blue">input </font>Integer k(min=0) = 1 <font color="darkgreen">&quot;Integer exponent&quot;</font>;
     <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> result;
  <font color="blue">algorithm </font>
    result := (<font color="red">Polynomial</font>(tf.n)^k)/(<font color="red">Polynomial</font>(tf.d)^k);
  <font color="blue">end </font>&#39;^&#39;</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.'=='"><font color="blue">encapsulated </font><font color="blue">operator function</font> &#39;==&#39; <font color="darkgreen">
    &quot;Check whether two transfer functions are identical&quot;</font>
     <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Modelica_LinearSystems2.Math.Polynomial</A>;
     <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;

     <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf1 <font color="darkgreen">&quot;Transfer function system 1&quot;</font>;
     <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf2 <font color="darkgreen">&quot;Transfer function system 1&quot;</font>;
     <font color="blue">input </font>Real eps(min=0) = 0 <font color="darkgreen">
      &quot;Two coefficients c1 and c2 of the two transfer functions are identical if abs(c1-c2) &lt;= eps&quot;</font>;

     <font color="blue">output </font>Boolean result <font color="darkgreen">&quot;= tf1 == tf2&quot;</font>;
  <font color="blue">algorithm </font>
    result := (<font color="red">Polynomial</font>(tf1.n) == <font color="red">Polynomial</font>(tf2.n))<font color="blue"> and </font>(<font color="red">Polynomial</font>(tf1.d) == <font color="red">Polynomial</font>(tf2.d));
  <font color="blue">end </font>&#39;==&#39;</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.'String'"><font color="blue">encapsulated </font><font color="blue">operator function</font> &#39;String&#39; <font color="darkgreen">
    &quot;Transform TransferFunction into a String representation&quot;</font>
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Modelica_LinearSystems2.Math.Polynomial</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf <font color="darkgreen">
      &quot;Transfer function to be transformed in a String representation&quot;</font>;
      <font color="blue">input </font>Integer significantDigits=6 <font color="darkgreen">
      &quot;Number of significant digits that are shown&quot;</font>;
      <font color="blue">input </font>String name=&quot;s&quot; <font color="darkgreen">&quot;Independent variable name used for printing&quot;</font>;
      <font color="blue">output </font>String s=&quot;&quot;;
  <font color="blue">protected </font>
      Integer n_num=<font color="red">size</font>(tf.n, 1) - 1;
      Integer n_den=<font color="red">size</font>(tf.d, 1) - 1;
      Boolean numParenthesis;
  <font color="blue">algorithm </font>
      <font color="blue">if </font>n_num == -1<font color="blue"> then</font>
        s := &quot;0&quot;;
      <font color="blue">else</font>
        numParenthesis := n_num &gt; 0<font color="blue"> and </font><font color="blue">not </font>(n_den == 0<font color="blue"> and </font>tf.d[1] == 1);
        <font color="blue">if </font>numParenthesis<font color="blue"> then</font>
          s := &quot;(&quot;;
        <font color="blue">end if</font>;
         s := s + <font color="red">String</font>(
              <font color="red">Polynomial</font>(tf.n),
              significantDigits,
              name);

        <font color="blue">if </font>numParenthesis<font color="blue"> then</font>
          s := s + &quot;)&quot;;
        <font color="blue">end if</font>;
      <font color="blue">if </font>n_den &gt; 0<font color="blue"> or </font>tf.d[1] &lt;&gt; 1<font color="blue"> then</font>
          <font color="blue">if </font>n_den &gt; 0<font color="blue"> then</font>
            s := s + &quot;/(&quot;;
          <font color="blue">else</font>
            s := s + &quot;/&quot;;
          <font color="blue">end if</font>;

          s := s + <font color="red">String</font>(
                <font color="red">Polynomial</font>(tf.d),
                significantDigits,
                name);

          <font color="blue">if </font>n_den &gt; 0<font color="blue"> then</font>
            s := s + &quot;)&quot;;
          <font color="blue">end if</font>;
        <font color="blue">end if</font>;
      <font color="blue">end if</font>;
  <font color="blue">end </font>&#39;String&#39;</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.s"><font color="blue">encapsulated </font><font color="blue">function</font> s <font color="darkgreen">&quot;Generate the transfer function s&quot;</font>
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Modelica_LinearSystems2.Math.Polynomial</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;

    <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf(n={1,0}, d={1}) <font color="darkgreen">&quot;s&quot;</font>;
  <font color="blue">algorithm </font>

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>s</textblock>;

  <textblock type="packagesmall" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Analysis"><font color="blue">encapsulated </font><font color="blue">package</font> Analysis
    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Analysis.analysis"><font color="blue">function</font> analysis <font color="darkgreen">
      &quot;Make a system analysis based on the poles and zeros of the system&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.AnalyseOptions"
>Modelica_LinearSystems2.Internal.AnalyseOptions</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.AnalyseOptions2"
>Modelica_LinearSystems2.Internal.AnalyseOptions2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Modelica_LinearSystems2.Internal.Eigenvalue</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf(uName=&quot;u&quot;, yName=&quot;y&quot;) <font color="darkgreen">
        &quot;transfer function of a system&quot;</font>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.AnalyseOptions2"
>AnalyseOptions2</A> analyseOptions2=
          <font color="red">Modelica_LinearSystems2.Internal.AnalyseOptions2</font>(printControllability=
           false, printObservability=false);

      <font color="blue">input </font>String fileName=&quot;eigenvalues.html&quot; <font color="darkgreen">
        &quot;Name of html-file that contains eigenvalue table&quot;</font>;

      <font color="blue">input </font>String systemName=&quot;tf&quot; <font color="darkgreen">
        &quot;Name of system (used as heading in html file)&quot;</font>;
      <font color="blue">input </font>String description=&quot;&quot; <font color="darkgreen">&quot;Description of system (used in html file)&quot;</font>;

    <font color="blue">protected </font>
      <font color="blue">input </font>Boolean printStateSpaceSystem=true;
      String dummyFileName = &quot;dummy&quot; + fileName;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss=<font color="red">StateSpace</font>(tf);

      <A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.AnalyseOptions"
>Modelica_LinearSystems2.Internal.AnalyseOptions</A> analyseOptions=
          <font color="red">AnalyseOptions</font>(
              plotEigenValues=analyseOptions2.plotEigenValues,
              plotInvariantZeros=analyseOptions2.plotInvariantZeros,
              plotStepResponse=analyseOptions2.plotStepResponse,
              plotFrequencyResponse=analyseOptions2.plotFrequencyResponse,
              printEigenValues=analyseOptions2.printEigenValues,
              printEigenValueProperties=analyseOptions2.printEigenValueProperties,
              printInvariantZeros=analyseOptions2.printInvariantZeros,
              printControllability=analyseOptions2.printControllability,
              printObservability=analyseOptions2.printObservability,
              headingEigenValues=analyseOptions2.headingEigenValues,
              headingInvariantzeros=analyseOptions2.headingInvariantzeros,
              headingStepResponse=analyseOptions2.headingStepResponse,
              headingFrequencyResponse=analyseOptions2.headingFrequencyResponse);

    <font color="blue">algorithm </font>
      <font color="red">assert</font>(<font color="red">TransferFunction.Analysis.denominatorDegree</font>(tf) &gt;
        <font color="red">TransferFunction.Analysis.numeratorDegree</font>(tf),
        &quot; Denominator polynominal of transfer function in function\&quot;TransferFunction.Analysis.analysis\&quot;has to be of higher order than numerator polynomial&quot;);

     <font color="red">Modelica.Utilities.Files.removeFile</font>(fileName);
     <font color="red">Modelica.Utilities.Files.removeFile</font>(dummyFileName);
    <font color="blue">if </font>printStateSpaceSystem<font color="blue"> then</font>
    <font color="red">Modelica_LinearSystems2.TransferFunction.Analysis.analysis.printSystem</font>(
            tf,
            fileName,
            systemName,
            description);
    <font color="red">Modelica_LinearSystems2.TransferFunction.Analysis.analysis.printSystem</font>(
            tf,
            dummyFileName,
            systemName,
            description);
    <font color="blue">end if</font>;
      <font color="red">Modelica.Utilities.Streams.readFile</font>(dummyFileName);

      <font color="red">StateSpace.Analysis.analysis</font>(
            ss=ss,
            analyseOptions=analyseOptions,
            fileName=fileName,
            systemName=systemName,
            description=description,
            printStateSpaceSystem=false);
    <font color="blue">equation </font>

    <font color="blue">public </font>
      <font color="blue">encapsulated </font><font color="blue">function</font> printSystem <font color="darkgreen">
        &quot;Print the state space system in html format on file&quot;</font>
        <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
        <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams.print"
>Modelica.Utilities.Streams.print</A>;
        <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
        <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;

        <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf <font color="darkgreen">&quot;transfer function to analyze&quot;</font>;
        <font color="blue">input </font>String fileName=&quot;systemAnalysis.html&quot; <font color="darkgreen">
          &quot;File on which the transfer fucntion is written in html format&quot;</font>;
        <font color="blue">input </font>String systemName=&quot;Transfer Function&quot; <font color="darkgreen">&quot;name of the system&quot;</font>;
        <font color="blue">input </font>String description=&quot;&quot; <font color="darkgreen">&quot;Description of system (used in html file)&quot;</font>;
        <font color="blue">input </font>String format=&quot;.3g&quot; <font color="darkgreen">&quot;Format of numbers (e.g. \&quot;20.8e\&quot;)&quot;</font>;
      <font color="blue">protected </font>
        String st=<font color="red">String</font>(tf);

      <font color="blue">algorithm </font>
        <font color="red">Modelica.Utilities.Files.removeFile</font>(fileName);
        <font color="red">print</font>(&quot;</pre><body><br><br><p><b>System report</b></p>"<em>Error:Found no end-tag in HTML-documentation</em><pre>, fileName);
        <font color="red">print</font>(&quot;&lt;p&gt; The system &quot; + systemName + &quot; is defined by&lt;/p&gt;&quot;, fileName);
        <font color="red">print</font>(&quot;G(s) = &quot; + st, fileName);
         <font color="blue">if </font>description == &quot;&quot;<font color="blue"> then</font>
          <font color="red">print</font>(&quot;&lt;/table&gt; &quot;, fileName);
        <font color="blue">else</font>
          <font color="red">print</font>(&quot;&lt;/table&gt;&quot;, fileName);
          <font color="red">print</font>(&quot;&lt;p&gt;&lt;b&gt;Description&lt;/b&gt;&lt;/p&gt;&quot;, fileName);
          <font color="red">print</font>(description, fileName);
        <font color="blue">end if</font>;
        <font color="red">print</font>(&quot;&lt;br&gt;&lt;/body&gt;&lt;/html&gt;&quot;,fileName);

      <font color="blue">end </font>printSystem;

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>analysis</textblock>;
    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.TimeResponse"
>Modelica_LinearSystems2.Types.TimeResponse</A>;

   <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Analysis.timeResponse"><font color="blue">encapsulated </font><font color="blue">function</font> timeResponse <font color="darkgreen">
      &quot;Calculate the time response of a transfer function&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;

    <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.timeResponseMask2_tf"
>Modelica_LinearSystems2.Internal.timeResponseMask2_tf</A>;<font color="darkgreen">     // Input/Output declarations of time response functions</font>
    <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.TimeResponse"
>Modelica_LinearSystems2.Types.TimeResponse</A> response=Modelica_LinearSystems2.Types.TimeResponse.Step;

    <font color="blue">input </font>Real x0[<font color="red">TransferFunction.Analysis.denominatorDegree</font>(tf)]=<font color="red">zeros</font>(<font color="red">TransferFunction.Analysis.denominatorDegree</font>(tf)) <font color="darkgreen">
        &quot;Initial state vector&quot;</font>;

    <font color="blue">protected </font>
     <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss=<font color="red">StateSpace</font>(tf);

   <font color="blue">algorithm </font>
     (y,t,x_continuous) := <font color="red">StateSpace.Analysis.timeResponse</font>(sc=ss, dt=dt, tSpan=tSpan, response=response, x0=x0);

<textblock type="annotcomp" expanded="false">   <font color="blue">end </font>timeResponse</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Analysis.impulseResponse"><font color="blue">encapsulated </font><font color="blue">function</font> impulseResponse <font color="darkgreen">
      &quot;Calculate the impulse time response&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;

      <font color="darkgreen">// Input/Output declarations of time response functions:</font>
    <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.timeResponseMask2_tf"
>Modelica_LinearSystems2.Internal.timeResponseMask2_tf</A>;

  <font color="blue">algorithm </font>
    (y,t,x_continuous) := <font color="red">Modelica_LinearSystems2.TransferFunction.Analysis.timeResponse</font>(
        tf=tf,
        dt=dt,
        tSpan=tSpan,
        response=Modelica_LinearSystems2.Types.TimeResponse.Impulse,
        x0=<font color="red">zeros</font>(<font color="red">Modelica_LinearSystems2.TransferFunction.Analysis.denominatorDegree</font>(tf)));

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>impulseResponse</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Analysis.stepResponse"><font color="blue">encapsulated </font><font color="blue">function</font> stepResponse <font color="darkgreen">
      &quot;Calculate the step time response&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
      <font color="darkgreen">// Input/Output declarations of time response functions:</font>
    <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.timeResponseMask2_tf"
>Modelica_LinearSystems2.Internal.timeResponseMask2_tf</A>;

  <font color="blue">algorithm </font>
    (y,t,x_continuous) := <font color="red">Modelica_LinearSystems2.TransferFunction.Analysis.timeResponse</font>(
        tf=tf,
        dt=dt,
        tSpan=tSpan,
        response=Modelica_LinearSystems2.Types.TimeResponse.Step,
        x0=<font color="red">zeros</font>(<font color="red">Modelica_LinearSystems2.TransferFunction.Analysis.denominatorDegree</font>(tf)));

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>stepResponse</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Analysis.rampResponse"><font color="blue">encapsulated </font><font color="blue">function</font> rampResponse <font color="darkgreen">
      &quot;Calculate the ramp time response&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;

      <font color="darkgreen">// Input/Output declarations of time response functions:</font>
    <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.timeResponseMask2_tf"
>Modelica_LinearSystems2.Internal.timeResponseMask2_tf</A>;

  <font color="blue">algorithm </font>
    (y,t,x_continuous) := <font color="red">Modelica_LinearSystems2.TransferFunction.Analysis.timeResponse</font>(
        tf=tf,
        dt=dt,
        tSpan=tSpan,
        response=Modelica_LinearSystems2.Types.TimeResponse.Ramp,
        x0=<font color="red">zeros</font>(<font color="red">Modelica_LinearSystems2.TransferFunction.Analysis.denominatorDegree</font>(tf)));

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>rampResponse</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Analysis.initialResponse"><font color="blue">encapsulated </font><font color="blue">function</font> initialResponse <font color="darkgreen">
      &quot;Calculate the time response for given initial condition and zero inputs&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;

    <font color="blue">input </font>Real x0[:]=<font color="red">fill</font>(0,0) <font color="darkgreen">&quot;Initial state vector&quot;</font>;

      <font color="darkgreen">// Input/Output declarations of time response functions:</font>
    <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.timeResponseMask2_tf"
>Modelica_LinearSystems2.Internal.timeResponseMask2_tf</A>;

  <font color="blue">algorithm </font>
    (y,t,x_continuous) := <font color="red">Modelica_LinearSystems2.TransferFunction.Analysis.timeResponse</font>(
        tf=tf,
        dt=dt,
        tSpan=tSpan,
        response=Modelica_LinearSystems2.Types.TimeResponse.Initial,
        x0=x0);

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>initialResponse</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Analysis.numeratorDegree"><font color="blue">encapsulated </font><font color="blue">function</font> numeratorDegree <font color="darkgreen">&quot;Return numerator degree&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Modelica_LinearSystems2.Math.Polynomial</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf <font color="darkgreen">&quot;transfer function of a system&quot;</font>;
      <font color="blue">output </font>Integer result;

    <font color="blue">algorithm </font>
      result := <font color="red">size</font>(tf.n,1)-1;
<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>numeratorDegree</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Analysis.denominatorDegree"><font color="blue">encapsulated </font><font color="blue">function</font> denominatorDegree <font color="darkgreen">
      &quot;Return denominator degree&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Modelica_LinearSystems2.Math.Polynomial</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf <font color="darkgreen">&quot;transfer function of a system&quot;</font>;
      <font color="blue">output </font>Integer result;

    <font color="blue">algorithm </font>
      result := <font color="red">size</font>(tf.d,1)-1;
<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>denominatorDegree</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Analysis.evaluate"><font color="blue">encapsulated </font><font color="blue">function</font> evaluate <font color="darkgreen">
      &quot;Evaluate a transfer function for a given (Complex) value of s&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Modelica_LinearSystems2.Math.Polynomial</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf <font color="darkgreen">&quot;transfer function of a system&quot;</font>;
      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> s <font color="darkgreen">&quot;Value of s where tf shall be evaluated&quot;</font>;
      <font color="blue">input </font>Real den_min=0 <font color="darkgreen">&quot;|denominator(s)| is limited by den_min&quot;</font>;
      <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> result <font color="darkgreen">&quot;= tf(s)&quot;</font>;

    <font color="blue">protected </font>
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> j = <font color="red">Modelica_LinearSystems2.Math.Complex.j</font>();
     <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> den=<font color="red">Polynomial.evaluateComplex</font>(<font color="red">Polynomial</font>(tf.d), s);
      Real abs_den=<font color="red">Complex.&#39;abs&#39;</font>(den);
    <font color="blue">algorithm </font>
      den := <font color="blue">if </font>abs_den &gt;= den_min<font color="blue"> then </font>den<font color="blue"> else </font>-abs_den+0*j;
      result := <font color="red">Polynomial.evaluateComplex</font>(<font color="red">Polynomial</font>(tf.n), s)/den;
<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>evaluate</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Analysis.zerosAndPoles"><font color="blue">encapsulated </font><font color="blue">function</font> zerosAndPoles <font color="darkgreen">
      &quot;Calculate zeros and poles of a transfer function&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Modelica_LinearSystems2.Math.Polynomial</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf <font color="darkgreen">&quot;transfer function of a system&quot;</font>;

      <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> z[:]=<font color="red">Polynomial.roots</font>(<font color="red">Polynomial</font>(tf.n)) <font color="darkgreen">
        &quot;Zeros (Complex vector of numerator zeros)&quot;</font>;
      <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> p[:]=<font color="red">Polynomial.roots</font>(<font color="red">Polynomial</font>(tf.d)) <font color="darkgreen">
        &quot;Poles (Complex vector of denominator zeros)&quot;</font>;
      <font color="blue">output </font>Real k <font color="darkgreen">
        &quot;Constant multiplied with transfer function that is factorized with zeros and poles&quot;</font>;

    <font color="blue">protected </font>
      <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf2=<font color="red">TransferFunction</font>(z, p);
      Real r;
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> s;
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> y1;
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> y2;
    <font color="blue">algorithm </font>
      <font color="darkgreen">// Determine an s-value that is neither a zero nor a pole</font>
      r := 1.0;
      <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(z, 1)<font color="blue"> loop</font>
        r := <font color="red">max</font>(r, <font color="red">abs</font>(z[i].re));
      <font color="blue">end for</font>;
      <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(p, 1)<font color="blue"> loop</font>
        r := <font color="red">max</font>(r, <font color="red">abs</font>(p[i].re));
      <font color="blue">end for</font>;
      r := 2*r;
      s := <font color="red">Complex</font>(r, 0);

      <font color="darkgreen">// Evaluate both tf and tf2 and determine k from the quotient</font>
      y1 := <font color="red">TransferFunction.Analysis.evaluate</font>(tf, s);
      y2 := <font color="red">TransferFunction.Analysis.evaluate</font>(tf2, s);
      k := y1.re/y2.re;
<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>zerosAndPoles</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Analysis.eigenValues"><font color="blue">function</font> eigenValues <font color="darkgreen">
      &quot;Calculate the eigenvalues of a linear transfer function system and write them in a complex vector&quot;</font>
    <font color="darkgreen">//encapsulated function eigenValues</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Modelica_LinearSystems2.Math.Polynomial</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf <font color="darkgreen">&quot;transfer function of a system&quot;</font>;
      <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> eigval[:] <font color="darkgreen">&quot;eigen values of the system&quot;</font>;

    <font color="blue">protected </font>
      <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss=<font color="red">StateSpace</font>(tf);

    <font color="blue">algorithm </font>
      <font color="red">assert</font>(<font color="red">TransferFunction.Analysis.denominatorDegree</font>(tf) &gt;
        <font color="red">TransferFunction.Analysis.numeratorDegree</font>(tf),
        &quot; Denominator polynominal of transfer function in function\&quot;TransferFunction.Analysis.eigenValues\&quot;has to be of higher order than numerator polynomial&quot;);

      eigval := <font color="red">StateSpace.Analysis.eigenValues</font>(ss);

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>eigenValues</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Analysis.eigenVectors"><font color="blue">encapsulated </font><font color="blue">function</font> eigenVectors <font color="darkgreen">
      &quot;Calculate the right eigenvectors of the state space system corresponding to a transfer function and write them columnwise in a matrix. Optionally, the eigenvalues are computed&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>Modelica.Math.Matrices.LAPACK</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf <font color="darkgreen">&quot;transfer function of a system&quot;</font>;
      <font color="blue">input </font>Boolean onlyEigenvectors=true;
      <font color="blue">output </font>Real eigvec[:,:] <font color="darkgreen">&quot;eigen values of the system&quot;</font>;
      <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> eigval[:] <font color="darkgreen">&quot;eigen values of the system&quot;</font>;
    <font color="blue">protected </font>
      <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss=<font color="red">StateSpace</font>(tf);

    <font color="blue">algorithm </font>
      <font color="red">assert</font>(<font color="red">TransferFunction.Analysis.denominatorDegree</font>(tf) &gt;
        <font color="red">TransferFunction.Analysis.numeratorDegree</font>(tf),
        &quot; Denominator polynominal of transfer function in function\&quot;TransferFunction.Analysis.eigenVectors\&quot;has to be of higher order than numerator polynomial&quot;);
      (eigvec,eigval) := <font color="red">StateSpace.Analysis.eigenVectors</font>(ss=ss,
        onlyEigenvectors=onlyEigenvectors);

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>eigenVectors</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Analysis.invariantZeros"><font color="blue">encapsulated </font><font color="blue">function</font> invariantZeros <font color="darkgreen">
      &quot;Compute invariant zeros of linear transfer function&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf <font color="darkgreen">&quot;transfer function of a system&quot;</font>;

      <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> Zeros[:] <font color="darkgreen">&quot;invariant zeros&quot;</font>;

    <font color="blue">protected </font>
      <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss=<font color="red">StateSpace</font>(tf);

    <font color="blue">algorithm </font>
      Zeros := <font color="red">StateSpace.Analysis.invariantZeros</font>(ss);

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>invariantZeros</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Analysis.observabilityMatrix"><font color="blue">encapsulated </font><font color="blue">function</font> observabilityMatrix <font color="darkgreen">
      &quot;Calculate the observability matrix of a transfer function&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf <font color="darkgreen">&quot;transfer function of a system&quot;</font>;
      <font color="blue">output </font>Real om[:,:];

    <font color="blue">protected </font>
      <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss=<font color="red">StateSpace</font>(tf);

    <font color="blue">algorithm </font>
      om := <font color="red">StateSpace.Analysis.observabilityMatrix</font>(ss=ss);

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>observabilityMatrix</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Analysis.controllabilityMatrix"><font color="blue">encapsulated </font><font color="blue">function</font> controllabilityMatrix <font color="darkgreen">
      &quot;Calculate the controllability matrix [B, A*B, ..., A^(n-1)*B] of a transfer function&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf <font color="darkgreen">&quot;transfer function of a system&quot;</font>;
      <font color="blue">output </font>Real om[:,:];

    <font color="blue">protected </font>
      <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss=<font color="red">StateSpace</font>(tf);

    <font color="blue">algorithm </font>
      om := <font color="red">StateSpace.Analysis.controllabilityMatrix</font>(ss=ss);

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>controllabilityMatrix</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Analysis.isObservable"><font color="blue">encapsulated </font><font color="blue">function</font> isObservable <font color="darkgreen">
      &quot;Check oberservability of a transfer function&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;

        <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf <font color="darkgreen">&quot;transfer function of a system&quot;</font>;
        <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.StaircaseMethod"
>Modelica_LinearSystems2.Types.StaircaseMethod</A> method=
            Modelica_LinearSystems2.Types.StaircaseMethod.SVD;
        <font color="blue">output </font>Boolean observable;
    <font color="blue">protected </font>
        <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss=<font color="red">StateSpace</font>(tf);

    <font color="blue">algorithm </font>
        observable := <font color="red">StateSpace.Analysis.isObservable</font>(ss=ss, method=method);

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>isObservable</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Analysis.isControllable"><font color="blue">encapsulated </font><font color="blue">function</font> isControllable <font color="darkgreen">
      &quot;Check controllability of a transfer function&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;

        <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf <font color="darkgreen">&quot;transfer function of a system&quot;</font>;
        <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.Method"
>Modelica_LinearSystems2.Types.Method</A> method=Modelica_LinearSystems2.Types.StaircaseMethod.SVD;

        <font color="blue">output </font>Boolean controllable;
    <font color="blue">protected </font>
        <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss=<font color="red">StateSpace</font>(tf);

    <font color="blue">algorithm </font>
        controllable := <font color="red">StateSpace.Analysis.isControllable</font>(ss=ss, method=method);

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>isControllable</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Analysis.isStabilizable"><font color="blue">encapsulated </font><font color="blue">function</font> isStabilizable <font color="darkgreen">
      &quot;Check stabilizability of a transfer function&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf <font color="darkgreen">&quot;transfer function of a system&quot;</font>;

      <font color="blue">output </font>Boolean stabilizable;
    <font color="blue">protected </font>
      <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss=<font color="red">StateSpace</font>(tf);

    <font color="blue">algorithm </font>
      stabilizable := <font color="red">StateSpace.Analysis.isStabilizable</font>(ss=ss);

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>isStabilizable</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Analysis.isDetectable"><font color="blue">encapsulated </font><font color="blue">function</font> isDetectable <font color="darkgreen">
      &quot;Check detectability of a transfer function&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf <font color="darkgreen">&quot;transfer function of a system&quot;</font>;

      <font color="blue">output </font>Boolean detectable;

    <font color="blue">protected </font>
      <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss=<font color="red">StateSpace</font>(tf);

    <font color="blue">algorithm </font>
      detectable := <font color="red">StateSpace.Analysis.isDetectable</font>(ss=ss);

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>isDetectable</textblock>;

  <font color="blue">end </font>Analysis</textblock>;

  <textblock type="packagesmall" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Design"><font color="blue">encapsulated </font><font color="blue">package</font> Design
    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Design.filter"><font color="blue">encapsulated </font><font color="blue">function</font> filter <font color="darkgreen">
      &quot;Generate the data record of a ZerosAndPoles transfer function from a filter description&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.AnalogFilter"
>Modelica_LinearSystems2.Types.AnalogFilter</A> analogFilter=Modelica_LinearSystems2.Types.AnalogFilter.CriticalDamping <font color="darkgreen">
        &quot;Analog filter characteristics (CriticalDamping/Bessel/Butterworth/Chebyshev)&quot;</font>;
      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.FilterType"
>Modelica_LinearSystems2.Types.FilterType</A> filterType=Modelica_LinearSystems2.Types.FilterType.LowPass <font color="darkgreen">
        &quot;Type of filter (LowPass/HighPass)&quot;</font>;
      <font color="blue">input </font>Integer order(min=1) = 2 <font color="darkgreen">&quot;Order of filter&quot;</font>;
      <font color="blue">input </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Modelica.SIunits.Frequency</A> f_cut=1/(2*Modelica.Constants.pi) <font color="darkgreen">
        &quot;Cut-off frequency (default is w_cut = 1 rad/s)&quot;</font>;
      <font color="blue">input </font>Real gain=1.0 <font color="darkgreen">
        &quot;Gain (= amplitude of frequency response at zero frequency)&quot;</font>;
      <font color="blue">input </font>Real A_ripple(unit=&quot;dB&quot;) = 0.5 <font color="darkgreen">
        &quot;Pass band ripple for Chebyshev filter (otherwise not used)&quot;</font>;
      <font color="blue">input </font>Boolean normalized=true <font color="darkgreen">
        &quot;= true, if amplitude of low pass filter at f_cut where the magnitude of the filter sagged for 3dB, otherwise unmodified filter&quot;</font>;

      <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> filter <font color="darkgreen">&quot;Filter transfer function&quot;</font>;

    <font color="blue">protected </font>
      <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zpFilter;
    <font color="blue">algorithm </font>
      zpFilter := <font color="red">ZerosAndPoles.Design.filter</font>(analogFilter, filterType, order, f_cut, gain, A_ripple, normalized);
      filter := <font color="red">ZerosAndPoles.Conversion.toTransferFunction</font>(zpFilter);

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>filter</textblock>;

  <font color="blue">end </font>Design</textblock>;

  <textblock type="packagesmall" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Plot"><font color="blue">encapsulated </font><font color="blue">package</font> Plot
    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Plot.polesAndZeros"><font color="blue">encapsulated </font><font color="blue">function</font> polesAndZeros <font color="darkgreen">
      &quot;Plot poles and/or the zeros of a transfer function&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Utilities_Plot.html#Modelica_LinearSystems2.Utilities.Plot"
>Modelica_LinearSystems2.Utilities.Plot</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf <font color="darkgreen">&quot;Linear system in transfer function form&quot;</font>;
    <font color="blue">input </font>Boolean poles=true <font color="darkgreen">&quot;= true, to plot the poles of tf&quot;</font>;
    <font color="blue">input </font>Boolean zeros=true <font color="darkgreen">&quot;= true, to plot the zeros of tf&quot;</font>;

    <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.PartialPlotFunction"
>Modelica_LinearSystems2.Internal.PartialPlotFunction</A>(
       defaultDiagram = <font color="red">Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros</font>());

  <font color="blue">algorithm </font>
     <font color="red">StateSpace.Plot.polesAndZeros</font>(<font color="red">StateSpace</font>(tf), poles, zeros, defaultDiagram, device);
<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>polesAndZeros</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Plot.bode"><font color="blue">encapsulated </font><font color="blue">function</font> bode <font color="darkgreen">&quot;Plot transfer function as bode plot&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Strings.html#Modelica.Utilities.Strings"
>Modelica.Utilities.Strings</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Utilities_Plot.html#Modelica_LinearSystems2.Utilities.Plot"
>Modelica_LinearSystems2.Utilities.Plot</A>;

      <font color="blue">import </font>SI = <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits"
>Modelica.SIunits</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf <font color="darkgreen">&quot;Transfer function to be plotted&quot;</font>;
      <font color="blue">input </font>Integer nPoints(min=2) = 200 <font color="darkgreen">&quot;Number of points&quot;</font>;
      <font color="blue">input </font>Boolean autoRange=true <font color="darkgreen">
        &quot;= true, if abszissa range is automatically determined&quot;</font>;
      <font color="blue">input </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Modelica.SIunits.Frequency</A> f_min(min=0) = 0.1 <font color="darkgreen">
        &quot;Minimum frequency value, if autoRange = false&quot;</font>;
      <font color="blue">input </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Modelica.SIunits.Frequency</A> f_max(min=0) = 10 <font color="darkgreen">
        &quot;Maximum frequency value, if autoRange = false&quot;</font>;

      <font color="blue">input </font>Boolean magnitude=true <font color="darkgreen">&quot;= true, to plot the magnitude of tf&quot;</font>;
      <font color="blue">input </font>Boolean phase=true <font color="darkgreen">&quot;= true, to plot the pase of tf&quot;</font>;

      <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.PartialPlotFunction"
>Modelica_LinearSystems2.Internal.PartialPlotFunction</A>(defaultDiagram=
            <font color="red">Modelica_LinearSystems2.Internal.DefaultDiagramBodePlot</font>(heading=&quot;Bode plot of  tf = &quot;
             + <font color="red">String</font>(tf)));

    <font color="blue">protected </font>
      <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>SI.AngularVelocity</A> w[nPoints];
      <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.Frequency"
>SI.Frequency</A> f[nPoints];
      <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits_Conversions_NonSIunits.html#Modelica.SIunits.Conversions.NonSIunits.Angle_deg"
>Modelica.SIunits.Conversions.NonSIunits.Angle_deg</A> phi[nPoints];
      Real A[nPoints];
      Boolean OK;
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> c;
      <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.Angle"
>Modelica.SIunits.Angle</A> phi_old;
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> numZeros[:];
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> denZeros[:];

      <A HREF="Modelica_LinearSystems2_Utilities_Plot_Records.html#Modelica_LinearSystems2.Utilities.Plot.Records.Curve"
>Plot.Records.Curve</A> curves[2];
      Integer i;
      <A HREF="Modelica_LinearSystems2_Utilities_Plot_Records.html#Modelica_LinearSystems2.Utilities.Plot.Records.Diagram"
>Plot.Records.Diagram</A> diagram2[2];

    <font color="blue">algorithm </font>
      <font color="darkgreen">      // Determine frequency vector f</font>
      <font color="blue">if </font>autoRange<font color="blue"> then</font>
        (numZeros,denZeros) := <font color="red">TransferFunction.Analysis.zerosAndPoles</font>(tf);
      <font color="blue">else</font>
        numZeros := <font color="red">fill</font>(<font color="red">Complex</font>(0), 0);
        denZeros := <font color="red">fill</font>(<font color="red">Complex</font>(0), 0);
      <font color="blue">end if</font>;
      f := <font color="red">Internal.frequencyVector</font>(
            nPoints,
            autoRange,
            f_min,
            f_max,
            numZeros,
            denZeros);

      <font color="darkgreen">// Compute magnitude/phase at the frequency points</font>
      phi_old := 0.0;
      <font color="blue">for </font>i<font color="blue"> in </font>1:nPoints<font color="blue"> loop</font>
        w[i] := <font color="red">Modelica.SIunits.Conversions.from_Hz</font>(f[i]);
        c := <font color="red">TransferFunction.Analysis.evaluate</font>(
              tf,
              <font color="red">Complex</font>(0, w[i]),
              1e-10);
        A[i] := <font color="red">Complex.&#39;abs&#39;</font>(c);
        phi_old := <font color="red">Complex.arg</font>(c, phi_old);
        phi[i] := <font color="red">Modelica.SIunits.Conversions.to_deg</font>(phi_old);

      <font color="blue">end for</font>;

     <font color="darkgreen">// Plot computed frequency response</font>
     diagram2 := <font color="red">fill</font>(defaultDiagram, 2);
      i := 0;
      <font color="blue">if </font>magnitude<font color="blue"> then</font>
        i := i + 1;
        curves[i] := <font color="red">Plot.Records.Curve</font>(
              x=f,
              y=A,
              autoLine=true);
        diagram2[i].curve := {curves[i]};
        diagram2[i].yLabel := &quot;magnitude&quot;;
        <font color="blue">if </font>phase<font color="blue"> then</font>
           diagram2[i].xLabel:=&quot;&quot;;
        <font color="blue">end if</font>;
      <font color="blue">end if</font>;

      <font color="blue">if </font>phase<font color="blue"> then</font>
        i := i + 1;
        curves[i] := <font color="red">Plot.Records.Curve</font>(
              x=f,
              y=phi,
              autoLine=true);
        diagram2[i].curve := {curves[i]};
        diagram2[i].yLabel := &quot;phase [deg]&quot;;
        diagram2[i].logY := false;
        <font color="blue">if </font>magnitude<font color="blue"> then</font>
          diagram2[i].heading:=&quot;&quot;;
       <font color="blue">end if</font>;
      <font color="blue">end if</font>;

        <font color="blue">if </font>magnitude<font color="blue"> and </font>phase<font color="blue"> then</font>
          <font color="red">Plot.diagramVector</font>(diagram2, device);
        <font color="blue">else</font>
          <font color="red">Plot.diagram</font>(diagram2[1], device);
        <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>bode</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Plot.timeResponse"><font color="blue">encapsulated </font><font color="blue">function</font> timeResponse <font color="darkgreen">
      &quot;Plot the time response of a system represented by a transfer function. The response type is selectable&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.TimeResponse"
>Modelica_LinearSystems2.Types.TimeResponse</A>;

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Utilities_Plot.html#Modelica_LinearSystems2.Utilities.Plot"
>Modelica_LinearSystems2.Utilities.Plot</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A> tf;
      <font color="blue">input </font>Real dt=0 <font color="darkgreen">&quot;Sample time [s]&quot;</font>;
      <font color="blue">input </font>Real tSpan=0 <font color="darkgreen">&quot;Simulation time span [s]&quot;</font>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.TimeResponse"
>Modelica_LinearSystems2.Types.TimeResponse</A> response=
          Modelica_LinearSystems2.Types.TimeResponse.Step <font color="darkgreen">
        &quot;type of time response&quot;</font>;
      <font color="blue">input </font>Real x0[<font color="red">TransferFunction.Analysis.denominatorDegree</font>(tf)]=<font color="red">zeros</font>(
          <font color="red">TransferFunction.Analysis.denominatorDegree</font>(tf)) <font color="darkgreen">
        &quot;Initial state vector&quot;</font>;

      <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.PartialPlotFunction"
>Modelica_LinearSystems2.Internal.PartialPlotFunction</A>(
          defaultDiagram=
            <font color="red">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</font>(heading=
             &quot;time response of  tf = &quot; + <font color="red">String</font>(tf)));

    <font color="blue">protected </font>
      <A HREF="Modelica_LinearSystems2_Utilities_Plot_Records.html#Modelica_LinearSystems2.Utilities.Plot.Records.Curve"
>Plot.Records.Curve</A> curve;
      <A HREF="Modelica_LinearSystems2_Utilities_Plot_Records.html#Modelica_LinearSystems2.Utilities.Plot.Records.Diagram"
>Plot.Records.Diagram</A> diagram2;
      Real y[:,1,1] <font color="darkgreen">&quot;Output response&quot;</font>;
      Real t[:] <font color="darkgreen">&quot;Time vector: (number of samples)&quot;</font>;

  <font color="blue">algorithm </font>
      (y,t) := <font color="red">TransferFunction.Analysis.timeResponse</font>(
          tf,
          dt,
          tSpan,
          response,
          x0);

      curve := <font color="red">Plot.Records.Curve</font>(
          x=t,
          y=y[:, 1, 1],
          legend=&quot;y&quot;,
          autoLine=true);
      diagram2 := defaultDiagram;
      diagram2.curve := {curve};

      <font color="red">Plot.diagram</font>(diagram2, device);

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>timeResponse</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Plot.impulse"><font color="blue">encapsulated </font><font color="blue">function</font> impulse <font color="darkgreen">&quot;Impulse response plot&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.TimeResponse"
>Modelica_LinearSystems2.Types.TimeResponse</A>;

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Utilities_Plot.html#Modelica_LinearSystems2.Utilities.Plot"
>Modelica_LinearSystems2.Utilities.Plot</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A> tf <font color="darkgreen">&quot;transfer function&quot;</font>;
      <font color="blue">input </font>Real dt=0 <font color="darkgreen">&quot;Sample time [s]&quot;</font>;
      <font color="blue">input </font>Real tSpan=0 <font color="darkgreen">&quot;Simulation time span [s]&quot;</font>;

      <font color="blue">input </font>Real x0[<font color="red">TransferFunction.Analysis.denominatorDegree</font>(tf)]=<font color="red">zeros</font>(
          <font color="red">TransferFunction.Analysis.denominatorDegree</font>(tf)) <font color="darkgreen">
        &quot;Initial state vector&quot;</font>;

      <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.PartialPlotFunction"
>Modelica_LinearSystems2.Internal.PartialPlotFunction</A>(
          defaultDiagram=
            <font color="red">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</font>(heading=&quot;Impulse response of  tf = &quot;
             + <font color="red">String</font>(tf)));

    <font color="blue">protected </font>
      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.TimeResponse"
>Modelica_LinearSystems2.Types.TimeResponse</A> response=
          Modelica_LinearSystems2.Types.TimeResponse.Impulse <font color="darkgreen">
        &quot;type of time response&quot;</font>;
  <font color="blue">algorithm </font>
      <font color="red">Modelica_LinearSystems2.TransferFunction.Plot.timeResponse</font>(
          tf=tf,
          dt=dt,
          tSpan=tSpan,
          response=response,
          x0=x0,
          defaultDiagram=defaultDiagram,
          device=device);

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>impulse</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Plot.step"><font color="blue">encapsulated </font><font color="blue">function</font> step <font color="darkgreen">&quot;Step response plot&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.TimeResponse"
>Modelica_LinearSystems2.Types.TimeResponse</A>;

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Utilities_Plot.html#Modelica_LinearSystems2.Utilities.Plot"
>Modelica_LinearSystems2.Utilities.Plot</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A> tf;
    <font color="blue">input </font>Real dt=0 <font color="darkgreen">&quot;Sample time [s]&quot;</font>;
    <font color="blue">input </font>Real tSpan=0 <font color="darkgreen">&quot;Simulation time span [s]&quot;</font>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.TimeResponse"
>Modelica_LinearSystems2.Types.TimeResponse</A> response=
        Modelica_LinearSystems2.Types.TimeResponse.Step <font color="darkgreen">&quot;type of time response&quot;</font>;
    <font color="blue">input </font>Real x0[<font color="red">TransferFunction.Analysis.denominatorDegree</font>(tf)]=<font color="red">zeros</font>(
        <font color="red">TransferFunction.Analysis.denominatorDegree</font>(tf)) <font color="darkgreen">&quot;Initial state vector&quot;</font>;

    <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.PartialPlotFunction"
>Modelica_LinearSystems2.Internal.PartialPlotFunction</A>(defaultDiagram=
          <font color="red">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</font>(heading=&quot;Step response of  tf = &quot;
           + <font color="red">String</font>(tf)));

  <font color="blue">algorithm </font>
   <font color="red">Modelica_LinearSystems2.TransferFunction.Plot.timeResponse</font>(
      tf=tf,
      dt=dt,
      tSpan=tSpan,
      response=response,
      x0=x0,
      defaultDiagram=defaultDiagram,
      device=device);

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>step</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Plot.ramp"><font color="blue">encapsulated </font><font color="blue">function</font> ramp <font color="darkgreen">&quot;Ramp response plot&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.TimeResponse"
>Modelica_LinearSystems2.Types.TimeResponse</A>;

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Utilities_Plot.html#Modelica_LinearSystems2.Utilities.Plot"
>Modelica_LinearSystems2.Utilities.Plot</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A> tf;
    <font color="blue">input </font>Real dt=0 <font color="darkgreen">&quot;Sample time [s]&quot;</font>;
    <font color="blue">input </font>Real tSpan=0 <font color="darkgreen">&quot;Simulation time span [s]&quot;</font>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.TimeResponse"
>Modelica_LinearSystems2.Types.TimeResponse</A> response=
        Modelica_LinearSystems2.Types.TimeResponse.Ramp <font color="darkgreen">&quot;type of time response&quot;</font>;
    <font color="blue">input </font>Real x0[<font color="red">TransferFunction.Analysis.denominatorDegree</font>(tf)]=<font color="red">zeros</font>(
        <font color="red">TransferFunction.Analysis.denominatorDegree</font>(tf)) <font color="darkgreen">&quot;Initial state vector&quot;</font>;

    <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.PartialPlotFunction"
>Modelica_LinearSystems2.Internal.PartialPlotFunction</A>(defaultDiagram=
          <font color="red">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</font>(heading=&quot;Ramp response of  tf = &quot;
           + <font color="red">String</font>(tf)));

  <font color="blue">algorithm </font>
   <font color="red">Modelica_LinearSystems2.TransferFunction.Plot.timeResponse</font>(
      tf=tf,
      dt=dt,
      tSpan=tSpan,
      response=response,
      x0=x0,
      defaultDiagram=defaultDiagram,
      device=device);

  <font color="blue">equation </font>

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>ramp</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Plot.initialResponse"><font color="blue">encapsulated </font><font color="blue">function</font> initialResponse <font color="darkgreen">
      &quot;Initial condition response plot&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.TimeResponse"
>Modelica_LinearSystems2.Types.TimeResponse</A>;

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Utilities_Plot.html#Modelica_LinearSystems2.Utilities.Plot"
>Modelica_LinearSystems2.Utilities.Plot</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A> tf;
      <font color="blue">input </font>Real dt=0 <font color="darkgreen">&quot;Sample time [s]&quot;</font>;
      <font color="blue">input </font>Real tSpan=0 <font color="darkgreen">&quot;Simulation time span [s]&quot;</font>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.TimeResponse"
>Modelica_LinearSystems2.Types.TimeResponse</A> response=
          Modelica_LinearSystems2.Types.TimeResponse.Initial <font color="darkgreen">
        &quot;type of time response&quot;</font>;
      <font color="blue">input </font>Real y0 <font color="darkgreen">&quot;Initial output (for initial condition plot)&quot;</font>;

      <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.PartialPlotFunction"
>Modelica_LinearSystems2.Internal.PartialPlotFunction</A>(
          defaultDiagram=
            <font color="red">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</font>(heading=
             &quot;Initial response of  tf = &quot; + <font color="red">String</font>(tf) + &quot;  with y0 = &quot; + <font color="red">String</font>(
            y0)));

    <font color="blue">protected </font>
      <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A> ss=<font color="red">Modelica_LinearSystems2.StateSpace</font>(
          tf);
      Integer nx=<font color="red">TransferFunction.Analysis.denominatorDegree</font>(tf);
      Real x0[nx]=<font color="red">Modelica.Math.Matrices.equalityLeastSquares</font>(
            ss.A,
            <font color="red">fill</font>(0, nx),
            ss.C,
            <font color="red">vector</font>(y0)) <font color="darkgreen">&quot;Initial state vector (for initial condition plot)&quot;</font>;
  <font color="blue">algorithm </font>

      <font color="red">Modelica_LinearSystems2.TransferFunction.Plot.timeResponse</font>(
          tf=tf,
          dt=dt,
          tSpan=tSpan,
          response=response,
          x0=x0,
          defaultDiagram=defaultDiagram,
          device=device);

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>initialResponse</textblock>;

  <font color="blue">end </font>Plot</textblock>;

  <textblock type="packagesmall" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Conversion"><font color="blue">encapsulated </font><font color="blue">package</font> Conversion
    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Conversion.toZerosAndPoles"><font color="blue">encapsulated </font><font color="blue">function</font> toZerosAndPoles <font color="darkgreen">
      &quot;Generate a ZerosAndPoles object from a TransferFunction object&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal"
>Modelica_LinearSystems2.ZerosAndPoles.Internal</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf <font color="darkgreen">&quot;transfer function of a system&quot;</font>;
      <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp(
        <font color="blue">redeclare </font>Real n1[<font color="red">Internal.numberOfRealZeros2</font>(tf)],
        <font color="blue">redeclare </font>Real n2[<font color="red">integer</font>((<font color="red">size</font>(tf.n, 1) - 1 -
          <font color="red">Internal.numberOfRealZeros2</font>(tf))/2),2],
        <font color="blue">redeclare </font>Real d1[<font color="red">Internal.numberOfRealPoles</font>(tf)],
        <font color="blue">redeclare </font>Real d2[<font color="red">integer</font>((<font color="red">size</font>(tf.d, 1) - 1 -
          <font color="red">Internal.numberOfRealPoles</font>(tf))/2),2]);
    <font color="blue">protected </font>
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> z[:];
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> p[:];
      Real k;
    <font color="blue">algorithm </font>
      (z,p,k) := <font color="red">TransferFunction.Analysis.zerosAndPoles</font>(tf);
      zp := <font color="red">ZerosAndPoles</font>(
          z,
          p,
          k);
<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>toZerosAndPoles</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Conversion.toStateSpace"><font color="blue">function</font> toStateSpace <font color="darkgreen">
      &quot;Convert a TransferFunction into a StateSpace representation&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Math_Vectors.html#Modelica.Math.Vectors"
>Modelica.Math.Vectors</A>;

     <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A> tf <font color="darkgreen">
        &quot;transfer function of a system&quot;</font>;
          <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A> ss(
            <font color="blue">redeclare </font>Real A[<font color="red">TransferFunction.Analysis.denominatorDegree</font>(tf),<font color="red">TransferFunction.Analysis.denominatorDegree</font>(tf)],
            <font color="blue">redeclare </font>Real B[<font color="red">TransferFunction.Analysis.denominatorDegree</font>(tf),1],
            <font color="blue">redeclare </font>Real C[1,<font color="red">TransferFunction.Analysis.denominatorDegree</font>(tf)],
            <font color="blue">redeclare </font>Real D[1,1]) <font color="darkgreen">&quot;Transfer function in StateSpace form&quot;</font>;

    <font color="blue">protected </font>
     Integer na=<font color="red">TransferFunction.Analysis.denominatorDegree</font>(tf) + 1;
     Integer nb=<font color="red">TransferFunction.Analysis.numeratorDegree</font>(tf) + 1;
     Integer nx=na - 1;
     Real a[na]=<font color="red">Vectors.reverse</font>(tf.d) <font color="darkgreen">&quot;Reverse element order of tf.a&quot;</font>;
     Real b[na]=<font color="red">vector</font>([<font color="red">Vectors.reverse</font>(tf.n); <font color="red">zeros</font>(na - nb, 1)]);
     Real d=b[na]/a[na];
    <font color="blue">algorithm </font>
     <font color="blue">if </font>nx == 0<font color="blue"> then</font>
       ss.A := <font color="red">fill</font>(
           0,
           0,
           nx);
       ss.B := <font color="red">fill</font>(
           0,
           0,
           1);
       ss.C := <font color="red">fill</font>(
           0,
           1,
           0);
     <font color="blue">else</font>
       ss.A[1:nx - 1, 1:nx] := [<font color="red">zeros</font>(nx - 1, 1),<font color="red">identity</font>(nx - 1)];
       ss.A[nx, 1:nx] := -a[1:na - 1]/a[na];
       ss.B := [<font color="red">zeros</font>(nx - 1, 1); 1/a[na]];
       ss.C := {b[1:nx] - d*a[1:nx]};

    <font color="blue">end if</font>;

      ss.D := [d];
<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>toStateSpace</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Conversion.toZerosAndPolesMIMO"><font color="blue">encapsulated </font><font color="blue">function</font> toZerosAndPolesMIMO <font color="darkgreen">
      &quot;Generate a zeros-and-poles transfer function matrix from a numerator-denominator-polynomial transfer function matrix representation&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf[:,:] <font color="darkgreen">&quot;transfer function of a system&quot;</font>;

    <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp[<font color="red">size</font>(tf, 1),<font color="red">size</font>(tf, 2)];

    <font color="blue">protected </font>
    Integer ny=<font color="red">size</font>(tf, 1);
    Integer nu=<font color="red">size</font>(tf, 2);

  <font color="blue">algorithm </font>
    <font color="blue">for </font>iy<font color="blue"> in </font>1:ny<font color="blue"> loop</font>
      <font color="blue">for </font>iu<font color="blue"> in </font>1:nu<font color="blue"> loop</font>
        zp[iy, iu] := <font color="red">ZerosAndPoles</font>(tf[iy, iu]);
      <font color="blue">end for</font>;
    <font color="blue">end for</font>;
<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>toZerosAndPolesMIMO</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Conversion.toMatrices"><font color="blue">function</font> toMatrices <font color="darkgreen">
      &quot;Convert a TransferFunction into the matrices A, B, C of a StateSpace&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Math_Vectors.html#Modelica.Math.Vectors"
>Modelica.Math.Vectors</A>;

     <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A> tf <font color="darkgreen">
        &quot;transfer function of a system&quot;</font>;

          <font color="blue">output </font>Real ABCD[<font color="red">size</font>(tf.d,1),<font color="red">size</font>(tf.d,1)];

    <font color="blue">protected </font>
     Integer na=<font color="red">TransferFunction.Analysis.denominatorDegree</font>(tf) + 1;
     Integer nb=<font color="red">TransferFunction.Analysis.numeratorDegree</font>(tf) + 1;
     Integer nx=na - 1;
     <font color="blue">output </font>Real A[nx,nx];
     <font color="blue">output </font>Real B[nx,1];
     <font color="blue">output </font>Real C[1,nx];
     <font color="blue">output </font>Real D[1,1];
     Real a[na]=<font color="red">Vectors.reverse</font>(tf.d) <font color="darkgreen">&quot;Reverse element order of tf.a&quot;</font>;
     Real b[na]=<font color="red">vector</font>([<font color="red">Vectors.reverse</font>(tf.n); <font color="red">zeros</font>(na - nb, 1)]);
     Real d=b[na]/a[na];
    <font color="blue">algorithm </font>
     <font color="blue">if </font>nx == 0<font color="blue"> then</font>
       A := <font color="red">fill</font>(
           0,
           0,
           nx);
       B := <font color="red">fill</font>(
           0,
           0,
           1);
       C := <font color="red">fill</font>(
           0,
           1,
           0);
     <font color="blue">else</font>
       A[1:nx - 1, 1:nx] := [<font color="red">zeros</font>(nx - 1, 1),<font color="red">identity</font>(nx - 1)];
       A[nx, 1:nx] := -a[1:na - 1]/a[na];
       B := [<font color="red">zeros</font>(nx - 1, 1); 1/a[na]];
       C := {b[1:nx] - d*a[1:nx]};
    <font color="blue">end if</font>;
      D := [d];
      ABCD := [A,B;C,D];
<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>toMatrices</textblock>;
  <font color="blue">end </font>Conversion</textblock>;

  <textblock type="packagesmall" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Import"><font color="blue">encapsulated </font><font color="blue">package</font> Import

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Import.fromModel"><font color="blue">function</font> fromModel <font color="darkgreen">
      &quot;Generate a TransferFunction record array from a state space representation resulted from linearization of a model&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;

    <font color="blue">input </font>String modelName <font color="darkgreen">&quot;Name of the Modelica model&quot;</font>;
    <font color="blue">input </font>Real T_linearize=0 <font color="darkgreen">
        &quot;point in time of simulation to linearize the model&quot;</font>;
    <font color="blue">input </font>String fileName=&quot;dslin&quot; <font color="darkgreen">&quot;Name of the result file&quot;</font>;

    <font color="blue">protected </font>
    String fileName2=fileName + &quot;.mat&quot;;
    Boolean OK1 = <font color="red">simulateModel</font>(problem=modelName, startTime=0, stopTime=T_linearize);
    Boolean OK2 = <font color="red">importInitial</font>(&quot;dsfinal.txt&quot;);
    Boolean OK3 = <font color="red">linearizeModel</font>(problem=modelName, resultFile=fileName, startTime=T_linearize, stopTime=T_linearize+1);
    Real nxMat[1,1]=<font color="red">readMatrix</font>(fileName2, &quot;nx&quot;, 1, 1);
    Integer ABCDsizes[2]=<font color="red">readMatrixSize</font>(fileName2, &quot;ABCD&quot;);
    Integer nx=<font color="red">integer</font>(nxMat[1, 1]);
    Integer nu=ABCDsizes[2] - nx;
    Integer ny=ABCDsizes[1] - nx;
    Real ABCD[nx + ny,nx + nu]=<font color="red">readMatrix</font>(fileName2, &quot;ABCD&quot;, nx + ny, nx + nu);
    String xuyName[nx + nu + ny]=<font color="red">readStringMatrix</font>(fileName2, &quot;xuyName&quot;, nx + nu + ny);

  <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> result(
      <font color="blue">redeclare </font>Real A[nx,nx],
      <font color="blue">redeclare </font>Real B[nx,nu],
      <font color="blue">redeclare </font>Real C[ny,nx],
      <font color="blue">redeclare </font>Real D[ny,nu]) <font color="darkgreen">&quot;= model linearized at initial point&quot;</font>;
    <font color="blue">public </font>
    <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf[:,:];

  <font color="blue">algorithm </font>
    result.A := ABCD[1:nx, 1:nx];
    result.B := ABCD[1:nx, nx + 1:nx + nu];
    result.C := ABCD[nx + 1:nx + ny, 1:nx];
    result.D := ABCD[nx + 1:nx + ny, nx + 1:nx + nu];
    result.uNames := xuyName[nx + 1:nx + nu];
    result.yNames := xuyName[nx + nu + 1:nx + nu + ny];
    result.xNames := xuyName[1:nx];

    tf := <font color="red">Modelica_LinearSystems2.StateSpace.Conversion.toTransferFunctionMIMO</font>(result);

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>fromModel</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Import.fromFile"><font color="blue">encapsulated </font><font color="blue">function</font> fromFile <font color="darkgreen">
      &quot;Generate a transfer function data record by reading numenator coefficients and denominator coefficients from a file (default file name is tf.mat)&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Modelica_LinearSystems2.Math.Polynomial</A>;
    <font color="blue">input </font>String fileName=&quot;tf.mat&quot; <font color="darkgreen">&quot;Name of the transfer function data file&quot;</font>;
    <font color="blue">input </font>String numName=&quot;n&quot; <font color="darkgreen">&quot;Name of the numenator of the transfer function&quot;</font>;
    <font color="blue">input </font>String denName=&quot;d&quot; <font color="darkgreen">&quot;Name of the denominator of the transfer function&quot;</font>;

    <font color="blue">protected </font>
    <font color="blue">input </font>Integer numSize[2]=<font color="red">readMatrixSize</font>(fileName, numName);
    <font color="blue">input </font>Integer denSize[2]=<font color="red">readMatrixSize</font>(fileName, denName);

    Real num[numSize[1],numSize[2]]=<font color="red">readMatrix</font>(
          fileName,
          numName,
          numSize[1],
          numSize[2]) <font color="darkgreen">&quot;numenator coefficients&quot;</font>;
    Real den[denSize[1],denSize[2]]=<font color="red">readMatrix</font>(
          fileName,
          denName,
          denSize[1],
          denSize[2]) <font color="darkgreen">&quot;denominator coefficients&quot;</font>;
    <font color="blue">input </font>Integer ns2=numSize[2];
    <font color="blue">input </font>Integer ds2=denSize[2];
    <font color="blue">public </font>
   <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf(n=<font color="red">fill</font>(0,ns2),d=<font color="red">fill</font>(0,ds2)) <font color="darkgreen">&quot;tranfer function&quot;</font>;

  <font color="blue">algorithm </font>
    tf.n := <font color="red">vector</font>(num);
    tf.d := <font color="red">vector</font>(den);
    tf.uName := numName;
    tf.yName := denName;

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>fromFile</textblock>;

  <font color="blue">end </font>Import</textblock>;

  <textblock type="packagesmall" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Internal"><font color="blue">encapsulated </font><font color="blue">package</font> Internal <font color="darkgreen">
    &quot;Internal library of record transferFunction (should not be directly used by user)&quot;</font>
    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons_Library.html#Modelica.Icons.Library"
>Modelica.Icons.Library</A>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Internal.readLength"><font color="blue">encapsulated </font><font color="blue">function</font> readLength <font color="darkgreen">
      &quot;Read the number n of coefficients written in a [n,1]-matrix&quot;</font>
      <font color="blue">input </font>String fileName=&quot;tf.mat&quot; <font color="darkgreen">&quot;Name of the transfer function data file&quot;</font>;
      <font color="blue">input </font>String polyName=&quot;n&quot; <font color="darkgreen">
        &quot;Name of the polynominal (numenator or denominator) coefficients of the transfer function&quot;</font>;
      <font color="blue">output </font>Integer result;
    <font color="blue">protected </font>
      Integer polySize[2]=<font color="red">readMatrixSize</font>(fileName, polyName);

    <font color="blue">algorithm </font>
      result := polySize[2];
    <font color="blue">end </font>readLength</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.TransferFunction.Internal.isControllableAndObservableSISO"><font color="blue">encapsulated </font><font color="blue">function</font> isControllableAndObservableSISO <font color="darkgreen">
      &quot;To check whether a SISO system is controllable and observable&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf;

      <font color="blue">output </font>Boolean controllableAndObservable;
    <font color="blue">protected </font>
      <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss=<font color="red">StateSpace</font>(tf);

    <font color="blue">algorithm </font>
      controllableAndObservable := <font color="red">StateSpace.Internal.isControllableAndObservableSISO</font>(ss=ss);

    <font color="blue">end </font>isControllableAndObservableSISO</textblock>;

  <font color="blue">end </font>Internal</textblock>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>TransferFunction;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE ZerosAndPoles<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.StateSpaceI.png" ALT="Modelica_LinearSystems2.ZerosAndPoles" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.ZerosAndPoles"></A><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>.ZerosAndPoles</H2>
<B>Continuous zeros and poles description of a single input, single output system (data + operations)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This record defines a transfer function by its zeros, poles and a gain:
</p>
<pre>         product(p - z[i])
  y = k*------------------- * u
         product(p - n[i])
</pre>
<p>
where z[:] is a Complex vector of zeros, n[:] is a Complex
vector of poles and k is an additional multiplicative factor.
The elements of the two Complex vectors must either be real
numbers or conjugate complex pairs (in order that their product
results in a polynomial with Real coefficients).
</p>
<p>
In the record, the zeros and poles are transformed
into a product of first and second order polynomials.
The data structure is especially useful in applications where first and 
second order polynomials are naturally occuring, e.g., as 
for <b>filters</b>. In fact, via function 
<A HREF="Modelica_LinearSystems2_Design.html#Modelica_LinearSystems2.ZerosAndPoles.Design.filter"
>ZerosAndPoles.Design.filter</a>, a 
ZeroAndPole transfer function is generated from
<b>low</b> and <b>high pass</b> analog filters 
(<b>CriticalDamping</b>, <b>Bessel</b>, <b>Butterworth</b>, <b>Chebyshev</b>). 
The filters are available in <b>normalized</b> (default) and non-normalized form.
In the normalized form, the amplitude of the filter transfer function
at the cutoff frequency is 3 dB.
</p>
<p>
A ZeroAndPole transfer function is internally stored by the coefficients
of first and second order polynomials, and by an additional
multiplicative factor k:
</p>
<pre>         product(s + n1[i]) * product(p^2 + n2[i,1]*p + n2[i,2])
  y = k*---------------------------------------------------------
         product(p + d1[i]) * product(p^2 + d2[i,1]*p + d2[i,2])
</pre>
<p>
Note, the degrees of the numerator and denominator
polynomials are given as:
</p>
<pre>
   degree of numerator   = size(n1,1) + 2*size(n2,1);
   degree of denominator = size(d1,1) + 2*size(d2,1);
</pre>
<p>
Example:
</p>
<pre>                          (p+1)
  zp = 4* -------------------------------------
           (p - 1)*(p - (2+j*3))*(p - (2-j*3))
</pre>
<p>
with j=sqrt(-1), is defined as
</p>
<pre> 
   <b>import</b> Modelica_LinearSystems2.Math.Complex; 
   <b>import</b> Modelica_LinearSystems2.ZerosAndPoles;
   
   zp = ZerosAndPoles(z = {Complex(-1,0)},
                      p = {Complex(1,0),
                           Complex(2,3),
                           Complex(2,-3)}, 
                           k=4);
</pre>
<pre></PRE><P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Record"
>Modelica.Icons.Record</A> (Icon for a record).
<P><H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>y = k*(product(p+n1[i]) * product(p^2+n2[i,1]*p+n2[i,2])) / (product(p+d1[i])*product(p^2+d2[i,1]*p+d2[i,2])) *u</TD></TR>
<TR><TD>Real</TD><TD>k</TD><TD>1.0</TD><TD>Multiplicative factor of transfer function</TD></TR>
<TR><TD>Real</TD><TD>n1[:]</TD><TD>&nbsp;</TD><TD>[p^0] coefficients of 1st order numerator polynomials</TD></TR>
<TR><TD>Real</TD><TD>n2[:, 2]</TD><TD>&nbsp;</TD><TD>[p,p^0] coefficients of 2nd order numerator polynomials</TD></TR>
<TR><TD>Real</TD><TD>d1[:]</TD><TD>&nbsp;</TD><TD>[p^0] coefficients of 1st order denominator polynomials</TD></TR>
<TR><TD>Real</TD><TD>d2[:, 2]</TD><TD>&nbsp;</TD><TD>[p,p^0] coefficients of 2nd order denominator polynomials</TD></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>Signal names</TD></TR>
<TR><TD>String</TD><TD>uName</TD><TD>&quot;u&quot;</TD><TD>Name of input signal</TD></TR>
<TR><TD>String</TD><TD>yName</TD><TD>&quot;y&quot;</TD><TD>Name of output signal</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">record</font> ZerosAndPoles <font color="darkgreen">
  &quot;Continuous zeros and poles description of a single input, single output system (data + operations)&quot;</font>
  <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Record"
>Modelica.Icons.Record</A>;

  Real k=1.0 <font color="darkgreen">&quot;Multiplicative factor of transfer function&quot;</font>;
  Real n1[:] <font color="darkgreen">&quot;[p^0] coefficients of 1st order numerator polynomials&quot;</font>;
  Real n2[:,2] <font color="darkgreen">&quot;[p,p^0] coefficients of 2nd order numerator polynomials&quot;</font>;
  Real d1[:] <font color="darkgreen">&quot;[p^0] coefficients of 1st order denominator polynomials&quot;</font>;
  Real d2[:,2] <font color="darkgreen">&quot;[p,p^0] coefficients of 2nd order denominator polynomials&quot;</font>;
  String uName=&quot;u&quot; <font color="darkgreen">&quot;Name of input signal&quot;</font>;
  String yName=&quot;y&quot; <font color="darkgreen">&quot;Name of output signal&quot;</font>;

  <textblock type="packagesmall" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.'constructor'"><font color="blue">encapsulated </font><font color="blue">operator</font> &#39;constructor&#39; <font color="darkgreen">
    &quot;Generate a ZerosAndPoles object&quot;</font>
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.'constructor'.fromReal"><font color="blue">encapsulated </font><font color="blue">function</font> fromReal <font color="darkgreen">
      &quot;Generate a ZerosAndPoles transfer function from a Real value&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;

      <font color="blue">input </font>Real r <font color="darkgreen">&quot;Value of Real variable&quot;</font>;
      <font color="blue">input </font>String uName=&quot;&quot; <font color="darkgreen">&quot;input name&quot;</font>;
      <font color="blue">input </font>String yName=&quot;&quot; <font color="darkgreen">&quot;output name&quot;</font>;
      <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp(
        <font color="blue">redeclare </font>Real n1[0],
        <font color="blue">redeclare </font>Real n2[0,2],
        <font color="blue">redeclare </font>Real d1[0],
        <font color="blue">redeclare </font>Real d2[0,2]) <font color="darkgreen">&quot;= r&quot;</font>;

    <font color="blue">algorithm </font>
      zp.k := r;
      zp.uName := uName;
      zp.yName := yName;

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>fromReal</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.'constructor'.fromZerosAndPoles"><font color="blue">encapsulated </font><font color="blue">function</font> fromZerosAndPoles <font color="darkgreen">
      &quot;Generate a ZerosAndPoles transfer function from a set of zeros and poles&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams.print"
>Modelica.Utilities.Streams.print</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> z[:]=<font color="red">fill</font>(<font color="red">Modelica_LinearSystems2.Math.Complex</font>(0), 0) <font color="darkgreen">
        &quot;Zeros (Complex vector of numerator zeros)&quot;</font>;
    <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> p[:]=<font color="red">fill</font>(<font color="red">Modelica_LinearSystems2.Math.Complex</font>(0), 0) <font color="darkgreen">
        &quot;Poles (Complex vector of denominator zeros)&quot;</font>;
    <font color="blue">input </font>Real k=1.0 <font color="darkgreen">&quot;Constant multiplied with transfer function&quot;</font>;
    <font color="blue">input </font>String uName=&quot;&quot; <font color="darkgreen">&quot;input name&quot;</font>;
    <font color="blue">input </font>String yName=&quot;&quot; <font color="darkgreen">&quot;output name&quot;</font>;
    <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp(
      <font color="blue">redeclare </font>Real n1[<font color="red">Internal.numberOfRealZeros</font>(z)],
      <font color="blue">redeclare </font>Real n2[<font color="red">integer</font>((<font color="red">size</font>(z, 1) - <font color="red">Internal.numberOfRealZeros</font>(z))/2),
        2],
      <font color="blue">redeclare </font>Real d1[<font color="red">Internal.numberOfRealZeros</font>(p)],
      <font color="blue">redeclare </font>Real d2[<font color="red">integer</font>((<font color="red">size</font>(p, 1) - <font color="red">Internal.numberOfRealZeros</font>(p))/2),
        2]) <font color="darkgreen">&quot;ZerosAndPoles transfer functions of the zeros, poles and k&quot;</font>;

    <font color="blue">protected </font>
    Integer n_n1=<font color="red">size</font>(zp.n1, 1);
    Integer n_d1=<font color="red">size</font>(zp.d1, 1);
    Integer n_n2=<font color="red">size</font>(zp.n2, 1);
    Integer n_d2=<font color="red">size</font>(zp.d2, 1);
    Integer i;
    Integer j;
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> z_reordered[<font color="red">size</font>(z, 1)] <font color="darkgreen">&quot;Reordered zeros&quot;</font>;
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> p_reordered[<font color="red">size</font>(p, 1)] <font color="darkgreen">&quot;Reordered poles&quot;</font>;
    Integer nz_real <font color="darkgreen">&quot;Number of real zeros&quot;</font>;
    Integer np_real <font color="darkgreen">&quot;Number of real poles&quot;</font>;
  <font color="blue">algorithm </font>
    <font color="darkgreen">//Extra input (string) added</font>
    (z_reordered,nz_real) := <font color="red">Internal.reorderZeros</font>(z, &quot;&quot;);
    (p_reordered,np_real) := <font color="red">Internal.reorderZeros</font>(p, &quot;&quot;);

    <font color="darkgreen">// Numerator</font>
    <font color="blue">for </font>i<font color="blue"> in </font>1:n_n1<font color="blue"> loop</font>
      zp.n1[i] := -z_reordered[i].re;
    <font color="blue">end for</font>;

    j := 1;
    <font color="blue">for </font>i<font color="blue"> in </font>n_n1 + 1:2:<font color="red">size</font>(z, 1)<font color="blue"> loop</font>
      zp.n2[j, :] := {-2*z_reordered[i].re,z_reordered[i].re^2 + z_reordered[i].im
        ^2};
      j := j + 1;
    <font color="blue">end for</font>;

    <font color="darkgreen">// Denominator</font>
    <font color="blue">for </font>i<font color="blue"> in </font>1:n_d1<font color="blue"> loop</font>
      zp.d1[i] := -p_reordered[i].re;
    <font color="blue">end for</font>;

    j := 1;
    <font color="blue">for </font>i<font color="blue"> in </font>n_d1 + 1:2:<font color="red">size</font>(p, 1)<font color="blue"> loop</font>
      zp.d2[j, :] := {-2*p_reordered[i].re,p_reordered[i].re^2 + p_reordered[i].im
        ^2};
      j := j + 1;
    <font color="blue">end for</font>;

    zp.k := k;
    zp.uName := uName;
    zp.yName := yName;

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>fromZerosAndPoles</textblock>;

    <font color="blue">function</font> fromTransferFunction = 
        <A HREF="Modelica_LinearSystems2_Conversion.html#Modelica_LinearSystems2.TransferFunction.Conversion.toZerosAndPoles"
>Modelica_LinearSystems2.TransferFunction.Conversion.toZerosAndPoles</A>;
    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.'constructor'.fromFactorization"><font color="blue">encapsulated </font><font color="blue">function</font> fromFactorization <font color="darkgreen">
      &quot;Generate a ZerosAndPoles object from first and second order polynomials&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;

      <font color="blue">input </font>Real n1[:]=<font color="red">fill</font>(0, 0) <font color="darkgreen">
        &quot;[p^0] coefficients of 1st order numerator polynomials&quot;</font>;
      <font color="blue">input </font>Real n2[:,2]=<font color="red">fill</font>(
              0,
              0,
              2) <font color="darkgreen">&quot;[p,p^0] coefficients of 2nd order numerator polynomials&quot;</font>;
      <font color="blue">input </font>Real d1[:]=<font color="red">fill</font>(0, 0) <font color="darkgreen">
        &quot;[p^0] coefficients of 1st order denominator polynomials&quot;</font>;
      <font color="blue">input </font>Real d2[:,2]=<font color="red">fill</font>(
              0,
              0,
              2) <font color="darkgreen">&quot;[p,p^0] coefficients of 2nd order denominator polynomials&quot;</font>;
      <font color="blue">input </font>Real k=1.0 <font color="darkgreen">&quot;Multiplicative factor of transfer function&quot;</font>;
      <font color="blue">input </font>String uName=&quot;&quot; <font color="darkgreen">&quot;input name&quot;</font>;
      <font color="blue">input </font>String yName=&quot;&quot; <font color="darkgreen">&quot;output name&quot;</font>;
      <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp(
        <font color="blue">redeclare </font>Real n1[<font color="red">size</font>(n1, 1)],
        <font color="blue">redeclare </font>Real n2[<font color="red">size</font>(n2, 1),2],
        <font color="blue">redeclare </font>Real d1[<font color="red">size</font>(d1, 1)],
        <font color="blue">redeclare </font>Real d2[<font color="red">size</font>(d2, 1),2]) <font color="darkgreen">&quot;ZerosAndPoles transfer function&quot;</font>;
    <font color="blue">algorithm </font>
      zp.n1 := n1;
      zp.n2 := n2;
      zp.d1 := d1;
      zp.d2 := d2;
      zp.k := k;
      zp.uName := uName;
      zp.yName := yName;
    <font color="blue">end </font>fromFactorization</textblock>;

  <font color="blue">end </font>&#39;constructor&#39;</textblock>;

<textblock type="packagesmall" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.'-'"><font color="blue">encapsulated </font><font color="blue">operator</font> &#39;-&#39;
  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.'-'.subtract"><font color="blue">function</font> subtract <font color="darkgreen">&quot;Subtract two TransferFunctions (zp1 - zp2)&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Modelica_LinearSystems2.Math.Polynomial</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp1;
    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp2;

    <font color="blue">protected </font>
    Integer size_z1n1=<font color="red">size</font>(zp1.n1, 1);
    Integer size_z1d1=<font color="red">size</font>(zp1.d1, 1);
    Integer size_z1n2=<font color="red">size</font>(zp1.n2, 1);
    Integer size_z1d2=<font color="red">size</font>(zp1.d2, 1);
    Integer size_z2n1=<font color="red">size</font>(zp2.n1, 1);
    Integer size_z2d1=<font color="red">size</font>(zp2.d1, 1);
    Integer size_z2n2=<font color="red">size</font>(zp2.n2, 1);
    Integer size_z2d2=<font color="red">size</font>(zp2.d2, 1);
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Polynomial</A> p1;
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Polynomial</A> p2;
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Polynomial</A> p3;
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> numZeros[:];
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> dummy[:]=<font color="red">fill</font>(<font color="red">Complex</font>(1), size_z1d1 + size_z2d1 + 2*(size_z1d2 +
        size_z2d2));
    Real k;

    <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> result <font color="darkgreen">&quot;= zp1/zp2&quot;</font>;

  <font color="blue">algorithm </font>
    <font color="blue">if </font>zp1 == zp2<font color="blue"> then</font>
      result := <font color="red">ZerosAndPoles</font>(0);
    <font color="blue">else</font>
      p1 := <font color="red">Polynomial</font>(1);
      p2 := <font color="red">Polynomial</font>(1);

      <font color="blue">for </font>i<font color="blue"> in </font>1:size_z1n1<font color="blue"> loop</font>
        p1 := p1*<font color="red">Polynomial</font>({1,zp1.n1[i]});
      <font color="blue">end for</font>;
      <font color="blue">for </font>i<font color="blue"> in </font>1:size_z1n2<font color="blue"> loop</font>
        p1 := p1*<font color="red">Polynomial</font>(<font color="red">cat</font>(
          1,
          {1},
          zp1.n2[i, :]));
      <font color="blue">end for</font>;
      <font color="blue">for </font>i<font color="blue"> in </font>1:size_z2d1<font color="blue"> loop</font>
        p1 := p1*<font color="red">Polynomial</font>({1,zp2.d1[i]});
      <font color="blue">end for</font>;
      <font color="blue">for </font>i<font color="blue"> in </font>1:size_z2d2<font color="blue"> loop</font>
        p1 := p1*<font color="red">Polynomial</font>(<font color="red">cat</font>(
          1,
          {1},
          zp2.d2[i, :]));
      <font color="blue">end for</font>;

      <font color="blue">for </font>i<font color="blue"> in </font>1:size_z2n1<font color="blue"> loop</font>
        p2 := p2*<font color="red">Polynomial</font>({1,zp2.n1[i]});
      <font color="blue">end for</font>;
      <font color="blue">for </font>i<font color="blue"> in </font>1:size_z2n2<font color="blue"> loop</font>
        p2 := p2*<font color="red">Polynomial</font>(<font color="red">cat</font>(
          1,
          {1},
          zp2.n2[i, :]));
      <font color="blue">end for</font>;
      <font color="blue">for </font>i<font color="blue"> in </font>1:size_z1d1<font color="blue"> loop</font>
        p2 := p2*<font color="red">Polynomial</font>({1,zp1.d1[i]});
      <font color="blue">end for</font>;
      <font color="blue">for </font>i<font color="blue"> in </font>1:size_z1d2<font color="blue"> loop</font>
        p2 := p2*<font color="red">Polynomial</font>(<font color="red">cat</font>(
          1,
          {1},
          zp1.d2[i, :]));
      <font color="blue">end for</font>;

      p3 := zp1.k*p1 - zp2.k*p2;
      k := 0;
      <font color="blue">for </font>i<font color="blue"> in </font><font color="red">size</font>(p3.c, 1):-1:1<font color="blue"> loop</font>
        <font color="blue">if </font><font color="red">abs</font>(p3.c[i]) &gt; Modelica.Constants.eps<font color="blue"> then</font>
          k := p3.c[i];
        <font color="blue">end if</font>;
      <font color="blue">end for</font>;
      numZeros := <font color="red">Polynomial.roots</font>(p3);
      result := <font color="red">ZerosAndPoles</font>(
        numZeros,
        dummy,
        k);

      result.d1 := <font color="red">cat</font>(
        1,
        zp1.d1,
        zp2.d1);
      result.d2 := <font color="red">cat</font>(
        1,
        zp1.d2,
        zp2.d2);

    <font color="blue">end if</font>;
  <font color="blue">end </font>subtract</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.'-'.negate"><font color="blue">function</font> negate <font color="darkgreen">&quot;Unary minus (multiply transfer function by -1)&quot;</font>
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;

     <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp;
     <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> result(n1=zp.n1, n2=zp.n2, d1=zp.d1, d2=zp.d2, k=-zp.k) <font color="darkgreen">&quot;= -zp&quot;</font>;
  <font color="blue">algorithm </font>
  <font color="blue">end </font>negate</textblock>;
<font color="blue">end </font>&#39;-&#39;</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.'+'"><font color="blue">encapsulated </font><font color="blue">operator function</font> &#39;+&#39; <font color="darkgreen">
    &quot;Addition of to tarnsfwer functions zp1 + zp2, i.e. parallel connection of two transfer functions (= inputs are the same, outputs of the two systems are added)&quot;</font>

    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Modelica_LinearSystems2.Math.Polynomial</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp1;
    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp2;

  <font color="blue">protected </font>
    Integer size_z1n1=<font color="red">size</font>(zp1.n1, 1);
    Integer size_z1d1=<font color="red">size</font>(zp1.d1, 1);
    Integer size_z1n2=<font color="red">size</font>(zp1.n2, 1);
    Integer size_z1d2=<font color="red">size</font>(zp1.d2, 1);
    Integer size_z2n1=<font color="red">size</font>(zp2.n1, 1);
    Integer size_z2d1=<font color="red">size</font>(zp2.d1, 1);
    Integer size_z2n2=<font color="red">size</font>(zp2.n2, 1);
    Integer size_z2d2=<font color="red">size</font>(zp2.d2, 1);
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Polynomial</A> p1;
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Polynomial</A> p2;
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Polynomial</A> p3;
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> numZeros[:];
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> dummy[:]=<font color="red">fill</font>(<font color="red">Complex</font>(1), size_z1d1 + size_z2d1 + 2*(size_z1d2 +
        size_z2d2));
    Real k;

    <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> result <font color="darkgreen">&quot;= zp1+zp2&quot;</font>;

  <font color="blue">algorithm </font>
    <font color="blue">if </font>zp1 == -zp2<font color="blue"> then</font>
      result := <font color="red">ZerosAndPoles</font>(0);
    <font color="blue">else</font>

      p1 := <font color="red">Polynomial</font>(1);
      p2 := <font color="red">Polynomial</font>(1);

      <font color="blue">for </font>i<font color="blue"> in </font>1:size_z1n1<font color="blue"> loop</font>
        p1 := p1*<font color="red">Polynomial</font>({1,zp1.n1[i]});
      <font color="blue">end for</font>;
      <font color="blue">for </font>i<font color="blue"> in </font>1:size_z1n2<font color="blue"> loop</font>
        p1 := p1*<font color="red">Polynomial</font>(<font color="red">cat</font>(
          1,
          {1},
          zp1.n2[i, :]));
      <font color="blue">end for</font>;
      <font color="blue">for </font>i<font color="blue"> in </font>1:size_z2d1<font color="blue"> loop</font>
        p1 := p1*<font color="red">Polynomial</font>({1,zp2.d1[i]});
      <font color="blue">end for</font>;
      <font color="blue">for </font>i<font color="blue"> in </font>1:size_z2d2<font color="blue"> loop</font>
        p1 := p1*<font color="red">Polynomial</font>(<font color="red">cat</font>(
          1,
          {1},
          zp2.d2[i, :]));
      <font color="blue">end for</font>;

      <font color="blue">for </font>i<font color="blue"> in </font>1:size_z2n1<font color="blue"> loop</font>
        p2 := p2*<font color="red">Polynomial</font>({1,zp2.n1[i]});
      <font color="blue">end for</font>;
      <font color="blue">for </font>i<font color="blue"> in </font>1:size_z2n2<font color="blue"> loop</font>
        p2 := p2*<font color="red">Polynomial</font>(<font color="red">cat</font>(
          1,
          {1},
          zp2.n2[i, :]));
      <font color="blue">end for</font>;
      <font color="blue">for </font>i<font color="blue"> in </font>1:size_z1d1<font color="blue"> loop</font>
        p2 := p2*<font color="red">Polynomial</font>({1,zp1.d1[i]});
      <font color="blue">end for</font>;
      <font color="blue">for </font>i<font color="blue"> in </font>1:size_z1d2<font color="blue"> loop</font>
        p2 := p2*<font color="red">Polynomial</font>(<font color="red">cat</font>(
          1,
          {1},
          zp1.d2[i, :]));
      <font color="blue">end for</font>;

      p3 := zp1.k*p1 + zp2.k*p2;
      k := p3.c[1];
      numZeros := <font color="red">Polynomial.roots</font>(p3);
      result := <font color="red">ZerosAndPoles</font>(
        numZeros,
        dummy,
        k);

      result.d1 := <font color="red">cat</font>(
        1,
        zp1.d1,
        zp2.d1);
      result.d2 := <font color="red">cat</font>(
        1,
        zp1.d2,
        zp2.d2);
    <font color="blue">end if</font>;

  <font color="blue">end </font>&#39;+&#39;</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.'*'"><font color="blue">encapsulated </font><font color="blue">operator function</font> &#39;*&#39; <font color="darkgreen">
    &quot;Multiply two ZerosAndPoles transfer functions (zp1 * zp2)&quot;</font>

    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp1;
    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp2;

    <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> result <font color="darkgreen">&quot;= zp1 * zp2&quot;</font>;
  <font color="blue">algorithm </font>
    <font color="blue">if </font>zp1 == <font color="red">ZerosAndPoles</font>(0)<font color="blue"> or </font>zp2 == <font color="red">ZerosAndPoles</font>(0)<font color="blue"> then</font>
      result := <font color="red">ZerosAndPoles</font>(0);
    <font color="blue">else</font>
      result.n1 := <font color="red">cat</font>(
        1,
        zp1.n1,
        zp2.n1);
      result.n2 := <font color="red">cat</font>(
        1,
        zp1.n2,
        zp2.n2);
      result.d1 := <font color="red">cat</font>(
        1,
        zp1.d1,
        zp2.d1);
      result.d2 := <font color="red">cat</font>(
        1,
        zp1.d2,
        zp2.d2);
      result.k := zp1.k*zp2.k;
    <font color="blue">end if</font>;

  <font color="blue">end </font>&#39;*&#39;</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.'/'"><font color="blue">encapsulated </font><font color="blue">operator function</font> &#39;/&#39; <font color="darkgreen">
    &quot;Divide two transfer functions (zp1 / zp2)&quot;</font>

    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp1;
    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp2;

    <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> result <font color="darkgreen">&quot;= zp1/zp2&quot;</font>;

  <font color="blue">algorithm </font>
    <font color="red">assert</font>(<font color="red">abs</font>(zp2.k)&gt;100*Modelica.Constants.small,&quot;zp2 in operator \&quot;Modelica_LinearSystems2.TransferFunction.&#39;/&#39;()\&quot; may not be zero&quot;);
    <font color="blue">if </font>zp1==<font color="red">ZerosAndPoles</font>(0)<font color="blue"> then</font>
      result := <font color="red">ZerosAndPoles</font>(0);
    <font color="blue">else</font>
      result.n1 := <font color="red">cat</font>(1,zp1.n1, zp2.d1);
      result.n2 := <font color="red">cat</font>(1,zp1.n2, zp2.d2);
      result.d1 := <font color="red">cat</font>(1,zp1.d1, zp2.n1);
      result.d2 := <font color="red">cat</font>(1,zp1.d2, zp2.n2);
      result.k := zp1.k/zp2.k;
  <font color="blue">end if</font>;

  <font color="blue">end </font>&#39;/&#39;</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.'^'"><font color="blue">encapsulated </font><font color="blue">operator function</font> &#39;^&#39; <font color="darkgreen">
    &quot;Integer power of TransferFunction (zp^k)&quot;</font>

    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp;
    <font color="blue">input </font>Integer k;

    <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> result(
      <font color="blue">redeclare </font>Real n1[k*<font color="red">size</font>(zp.n1, 1)],
      <font color="blue">redeclare </font>Real n2[k*<font color="red">size</font>(zp.n2, 1),2],
      <font color="blue">redeclare </font>Real d1[k*<font color="red">size</font>(zp.d1, 1)],
      <font color="blue">redeclare </font>Real d2[k*<font color="red">size</font>(zp.d2, 1),2]) <font color="darkgreen">&quot;= zp^k&quot;</font>;
  <font color="blue">protected </font>
    Integer size_n1=<font color="red">size</font>(zp.n1, 1);
    Integer size_d1=<font color="red">size</font>(zp.d1, 1);
    Integer size_n2=<font color="red">size</font>(zp.n2, 1);
    Integer size_d2=<font color="red">size</font>(zp.d2, 1);
  <font color="blue">algorithm </font>
    <font color="blue">for </font>i<font color="blue"> in </font>1:k<font color="blue"> loop</font>
      result.n1[(i - 1)*size_n1 + 1:i*size_n1] := zp.n1;
      result.d1[(i - 1)*size_d1 + 1:i*size_d1] := zp.d1;
      result.n2[(i - 1)*size_n2 + 1:i*size_n2, :] := zp.n2;
      result.d2[(i - 1)*size_d2 + 1:i*size_d2, :] := zp.d2;
    <font color="blue">end for</font>;
    result.k := zp.k^k;

  <font color="blue">end </font>&#39;^&#39;</textblock>;

<textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.'=='"><font color="blue">encapsulated </font><font color="blue">operator function</font> &#39;==&#39; <font color="darkgreen">
    &quot;Check whether two transfer functions are identical&quot;</font>
        <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
        <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Math.html#Modelica.Math"
>Modelica.Math</A>;
        <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Modelica_LinearSystems2.Math.Polynomial</A>;
        <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp1;
    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp2;
    <font color="blue">input </font>Real eps(min=0) = 0 <font color="darkgreen">
      &quot;Two numbers n1 and n2 are identical if abs(n1-n2) &lt;= eps&quot;</font>;

    <font color="blue">output </font>Boolean result <font color="darkgreen">&quot;= zp1 == zp2&quot;</font>;
<font color="blue">algorithm </font>
    result :=<font color="red"> Math.Vectors.isEqual</font>(zp1.n1,zp2.n1,eps)<font color="blue"> and </font><font color="red">Math.Vectors.isEqual</font>(zp1.d1,zp2.d1,eps)<font color="blue"> and </font><font color="red">Math.Matrices.isEqual</font>(zp1.n2,zp2.n2,eps)<font color="blue"> and </font><font color="red">Math.Matrices.isEqual</font>(zp1.d2,zp2.d2,eps)<font color="blue"> and </font>(zp1.k==zp2.k);

<font color="blue">end </font>&#39;==&#39;</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.'String'"><font color="blue">encapsulated </font><font color="blue">operator function</font> &#39;String&#39; <font color="darkgreen">
    &quot;Transform ZerosAndPoles transfer function into a String representation&quot;</font>
          <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
          <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
          <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal"
>Modelica_LinearSystems2.ZerosAndPoles.Internal</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp <font color="darkgreen">
      &quot;ZerosAndPoles transfer function to be transformed in a String representation&quot;</font>;
      <font color="blue">input </font>Integer significantDigits=6 <font color="darkgreen">
      &quot;Number of significant digits that are shown&quot;</font>;
      <font color="blue">input </font>String name=&quot;p&quot; <font color="darkgreen">&quot;Independent variable name used for printing&quot;</font>;
      <font color="blue">output </font>String s=&quot;&quot;;
  <font color="blue">protected </font>
      Integer num_order=<font color="red">size</font>(zp.n1, 1) + 2*<font color="red">size</font>(zp.n2, 1);
      Integer den_order=<font color="red">size</font>(zp.d1, 1) + 2*<font color="red">size</font>(zp.d2, 1);
  <font color="blue">algorithm </font>
      <font color="blue">if </font>num_order == 0<font color="blue"> and </font>den_order == 0<font color="blue"> then</font>
        s := <font color="red">String</font>(zp.k);

      <font color="blue">else</font>
      <font color="darkgreen">   // construct string for multiplicative factor</font>
        <font color="blue">if </font>zp.k &lt;&gt; 1.0<font color="blue"> or </font>zp.k == 1.0<font color="blue"> and </font>num_order == 0<font color="blue"> then</font>
          s := <font color="red">String</font>(zp.k);
          <font color="blue">if </font>num_order &lt;&gt; 0<font color="blue"> then</font>
            s := s + &quot;*&quot;;
          <font color="blue">end if</font>;
        <font color="blue">end if</font>;

        <font color="blue">if </font>num_order &lt;&gt; 0<font color="blue"> then</font>
        <font color="darkgreen">    // construct numerator string</font>
          s := s + <font color="red">Internal.firstOrderToString</font>(
                zp.n1,
                significantDigits,
                name);
          <font color="blue">if </font><font color="red">size</font>(zp.n2, 1) &lt;&gt; 0<font color="blue"> then</font>
            s := <font color="blue">if </font><font color="red">size</font>(zp.n1, 1) &gt; 0<font color="blue"> then </font>s + &quot;*&quot; +
              <font color="red">Internal.secondOrderToString</font>(
                  zp.n2,
                  significantDigits,
                  name)<font color="blue"> else </font>s + <font color="red">Internal.secondOrderToString</font>(
                  zp.n2,
                  significantDigits,
                  name);
          <font color="blue">end if</font>;
        <font color="blue">end if</font>;

        <font color="blue">if </font>den_order &lt;&gt; 0<font color="blue"> then</font>
        <font color="darkgreen">    // construct denominator string</font>
          s := s + &quot;/&quot;;
          <font color="blue">if </font>den_order &gt; 1<font color="blue"> then</font>
            s := s + &quot;( &quot;;
          <font color="blue">end if</font>;
          s := s + <font color="red">Internal.firstOrderToString</font>(
                zp.d1,
                significantDigits,
                name);
          <font color="blue">if </font><font color="red">size</font>(zp.d2, 1) &lt;&gt; 0<font color="blue"> then</font>
            <font color="blue">if </font><font color="red">size</font>(zp.d1, 1) &gt; 0<font color="blue"> then</font>
              s := s + &quot;*&quot;;
            <font color="blue">end if</font>;
            s := s + <font color="red">Internal.secondOrderToString</font>(
                  zp.d2,
                  significantDigits,
                  name);
          <font color="blue">end if</font>;
          <font color="blue">if </font>den_order &gt; 1<font color="blue"> then</font>
            s := s + &quot; )&quot;;
          <font color="blue">end if</font>;
        <font color="blue">end if</font>;
      <font color="blue">end if</font>;
    <font color="darkgreen">//    end toString;</font>
  <font color="blue">end </font>&#39;String&#39;</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.p"><font color="blue">encapsulated </font><font color="blue">function</font> p <font color="darkgreen">&quot;Generate the transfer function p&quot;</font>
    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Modelica_LinearSystems2.Math.Polynomial</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;

    <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp(
      <font color="blue">redeclare </font>Real n1[1],
      <font color="blue">redeclare </font>Real n2[0,2],
      <font color="blue">redeclare </font>Real d1[0],
      <font color="blue">redeclare </font>Real d2[0,2]) <font color="darkgreen">&quot;= tf1 * tf2&quot;</font>;
  <font color="blue">algorithm </font>
    zp.n1[1] := 0;
<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>p</textblock>;

  <textblock type="packagesmall" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Analysis"><font color="blue">encapsulated </font><font color="blue">package</font> Analysis
    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Analysis.analysis"><font color="blue">function</font> analysis <font color="darkgreen">
      &quot;Make a system analysis based on the poles and zeros of the system&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.AnalyseOptions"
>Modelica_LinearSystems2.Internal.AnalyseOptions</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.AnalyseOptions2"
>Modelica_LinearSystems2.Internal.AnalyseOptions2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Modelica_LinearSystems2.Internal.Eigenvalue</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp(uName=&quot;u&quot;, yName=&quot;y&quot;) <font color="darkgreen">
        &quot;transfer function of a system&quot;</font>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.AnalyseOptions2"
>AnalyseOptions2</A> analyseOptions2 = <font color="red">Modelica_LinearSystems2.Internal.AnalyseOptions2</font>(
               printControllability=false,
               printObservability=false);

      <font color="blue">input </font>String fileName=&quot;eigenvalues.html&quot; <font color="darkgreen">
        &quot;Name of html-file that contains eigenvalue table&quot;</font>;

      <font color="blue">input </font>String systemName = &quot;&quot; <font color="darkgreen">
        &quot;Name of system (used as heading in html file)&quot;</font>;
      <font color="blue">input </font>String description = &quot;&quot; <font color="darkgreen">&quot;Description of system (used in html file)&quot;</font>;

    <font color="blue">protected </font>
    <font color="blue">input </font>Boolean printStateSpaceSystem=true;
      String dummyFileName = &quot;dummy&quot; + fileName;
      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss=<font color="red">StateSpace</font>(zp);

    <A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.AnalyseOptions"
>AnalyseOptions</A> analyseOptions=<font color="red">AnalyseOptions</font>(
               plotEigenValues=analyseOptions2.plotEigenValues,
               plotInvariantZeros=analyseOptions2.plotInvariantZeros,
               plotStepResponse=analyseOptions2.plotStepResponse,
               plotFrequencyResponse=analyseOptions2.plotFrequencyResponse,
               printEigenValues=analyseOptions2.printEigenValues,
               printEigenValueProperties=analyseOptions2.printEigenValueProperties,
               printInvariantZeros=analyseOptions2.printInvariantZeros,
               printControllability=analyseOptions2.printControllability,
               printObservability=analyseOptions2.printObservability,
               headingEigenValues=analyseOptions2.headingEigenValues,
               headingInvariantzeros=analyseOptions2.headingInvariantzeros,
               headingStepResponse=analyseOptions2.headingStepResponse,
               headingFrequencyResponse=analyseOptions2.headingFrequencyResponse);

    <font color="blue">algorithm </font>
      <font color="red">assert</font>(<font color="red">ZerosAndPoles.Analysis.denominatorDegree</font>(zp) &gt;
        <font color="red">ZerosAndPoles.Analysis.numeratorDegree</font>(zp),
        &quot; Denominator polynominal of transfer function in function\&quot;TransferFunction.Analysis.analysis\&quot;has to be of higher order than numerator polynomial&quot;);
    <font color="red">Modelica.Utilities.Files.removeFile</font>(fileName);
     <font color="red">Modelica.Utilities.Files.removeFile</font>(dummyFileName);
    <font color="blue">if </font>printStateSpaceSystem<font color="blue"> then</font>
    <font color="red">printSystem</font>(
            zp,
            fileName,
            systemName,
            description);
    <font color="red">printSystem</font>(
            zp,
            dummyFileName,
            systemName,
            description);
    <font color="blue">end if</font>;
      <font color="red">Modelica.Utilities.Streams.readFile</font>(dummyFileName);
      <font color="red">StateSpace.Analysis.analysis</font>(
            ss=ss,
            analyseOptions=analyseOptions,
            fileName=fileName,
            systemName=systemName,
            description=description,
            printStateSpaceSystem=false);
    <font color="blue">equation </font>

    <font color="blue">public </font>
     <font color="blue">encapsulated </font><font color="blue">function</font> printSystem <font color="darkgreen">
        &quot;Print the state space system in html format on file&quot;</font>
        <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
        <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams.print"
>Modelica.Utilities.Streams.print</A>;
        <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
        <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp <font color="darkgreen">&quot;transfer function to analyze&quot;</font>;
      <font color="blue">input </font>String fileName=&quot;systemAnalysis.html&quot; <font color="darkgreen">
          &quot;File on which the zeros-and-poles transfer function is written in html format&quot;</font>;
      <font color="blue">input </font>String systemName=&quot;ZerosAndPoles Transfer Function&quot; <font color="darkgreen">
          &quot;name of the system&quot;</font>;
      <font color="blue">input </font>String description = &quot;&quot; <font color="darkgreen">&quot;Description of system (used in html file)&quot;</font>;
      <font color="blue">input </font>String format=&quot;.3g&quot; <font color="darkgreen">&quot;Format of numbers (e.g. \&quot;20.8e\&quot;)&quot;</font>;
      <font color="blue">protected </font>
      String st=<font color="red">String</font>(zp);

     <font color="blue">algorithm </font>
      <font color="red">Modelica.Utilities.Files.removeFile</font>(fileName);
      <font color="red">print</font>(&quot;</pre><body><br><br><p>\n<b>System report</b>\n</p>"<em>Error:Found no end-tag in HTML-documentation</em><pre>,fileName);
      <font color="red">print</font>(&quot;&lt;body&gt;&lt;p&gt;&lt;br&gt; The system &lt;b&gt;&quot; + systemName + &quot;&lt;/b&gt; is defined by&lt;/p&gt;&quot;,fileName);
       <font color="red">print</font>(&quot;G(p) = &quot;+st, fileName);

         <font color="blue">if </font>description==&quot;&quot;<font color="blue"> then</font>
       <font color="red">print</font>(&quot;&lt;/table&gt;&quot;, fileName);
      <font color="blue">else</font>
       <font color="red">print</font>(&quot;&lt;/table&gt;&quot;, fileName);
       <font color="red">print</font>(&quot;&lt;body&gt;&lt;p&gt;&lt;b&gt;Description&lt;/b&gt;&lt;/p&gt;&quot;,fileName);
       <font color="red">print</font>(description, fileName);
       <font color="blue">end if</font>;

     <font color="blue">end </font>printSystem;
<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>analysis</textblock>;

   <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Analysis.timeResponse"><font color="blue">encapsulated </font><font color="blue">function</font> timeResponse <font color="darkgreen">
      &quot;Calculate the time response of a zeros-and-poles transfer function&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.TimeResponse"
>Modelica_LinearSystems2.Types.TimeResponse</A>;

    <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.timeResponseMask2_zp"
>Modelica_LinearSystems2.Internal.timeResponseMask2_zp</A>;<font color="darkgreen">     // Input/Output declarations of time response functions</font>
    <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.TimeResponse"
>Modelica_LinearSystems2.Types.TimeResponse</A> response=Modelica_LinearSystems2.Types.TimeResponse.Step;

    <font color="blue">input </font>Real x0[<font color="red">Modelica_LinearSystems2.ZerosAndPoles.Analysis.denominatorDegree</font>(zp)]=<font color="red">zeros</font>(<font color="red">Modelica_LinearSystems2.ZerosAndPoles.Analysis.denominatorDegree</font>(zp)) <font color="darkgreen">
        &quot;Initial state vector&quot;</font>;

    <font color="blue">protected </font>
     <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss=<font color="red">StateSpace</font>(zp);

   <font color="blue">algorithm </font>
     (y,t,x_continuous) := <font color="red">StateSpace.Analysis.timeResponse</font>(sc=ss, dt=dt, tSpan=tSpan, response=response, x0=x0);

<textblock type="annotcomp" expanded="false">   <font color="blue">end </font>timeResponse</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Analysis.impulseResponse"><font color="blue">encapsulated </font><font color="blue">function</font> impulseResponse <font color="darkgreen">
      &quot;Calculate the impulse time response&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;

      <font color="darkgreen">// Input/Output declarations of time response functions:</font>
    <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.timeResponseMask2_zp"
>Modelica_LinearSystems2.Internal.timeResponseMask2_zp</A>;

  <font color="blue">algorithm </font>
    (y,t,x_continuous) := <font color="red">Modelica_LinearSystems2.ZerosAndPoles.Analysis.timeResponse</font>(
        zp=zp,
        dt=dt,
        tSpan=tSpan,
        response=Modelica_LinearSystems2.Types.TimeResponse.Impulse,
        x0=<font color="red">zeros</font>(<font color="red">Modelica_LinearSystems2.ZerosAndPoles.Analysis.denominatorDegree</font>(zp)));

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>impulseResponse</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Analysis.stepResponse"><font color="blue">encapsulated </font><font color="blue">function</font> stepResponse <font color="darkgreen">
      &quot;Calculate the step time response&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
      <font color="darkgreen">// Input/Output declarations of time response functions:</font>
    <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.timeResponseMask2_zp"
>Modelica_LinearSystems2.Internal.timeResponseMask2_zp</A>;

  <font color="blue">algorithm </font>
    (y,t,x_continuous) := <font color="red">Modelica_LinearSystems2.ZerosAndPoles.Analysis.timeResponse</font>(
        zp=zp,
        dt=dt,
        tSpan=tSpan,
        response=Modelica_LinearSystems2.Types.TimeResponse.Step,
        x0=<font color="red">zeros</font>(<font color="red">Modelica_LinearSystems2.ZerosAndPoles.Analysis.denominatorDegree</font>(zp)));

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>stepResponse</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Analysis.rampResponse"><font color="blue">encapsulated </font><font color="blue">function</font> rampResponse <font color="darkgreen">
      &quot;Calculate the ramp time response&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;

      <font color="darkgreen">// Input/Output declarations of time response functions:</font>
    <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.timeResponseMask2_zp"
>Modelica_LinearSystems2.Internal.timeResponseMask2_zp</A>;

  <font color="blue">algorithm </font>
    (y,t,x_continuous) := <font color="red">Modelica_LinearSystems2.ZerosAndPoles.Analysis.timeResponse</font>(
        zp=zp,
        dt=dt,
        tSpan=tSpan,
        response=Modelica_LinearSystems2.Types.TimeResponse.Ramp,
        x0=<font color="red">zeros</font>(<font color="red">Modelica_LinearSystems2.ZerosAndPoles.Analysis.denominatorDegree</font>(zp)));

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>rampResponse</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Analysis.initialResponse"><font color="blue">encapsulated </font><font color="blue">function</font> initialResponse <font color="darkgreen">
      &quot;Calculate the time response for given initial condition and zero inputs&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;

    <font color="blue">input </font>Real x0[:]=<font color="red">fill</font>(0,0) <font color="darkgreen">&quot;Initial state vector&quot;</font>;

      <font color="darkgreen">// Input/Output declarations of time response functions:</font>
    <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.timeResponseMask2_zp"
>Modelica_LinearSystems2.Internal.timeResponseMask2_zp</A>;

  <font color="blue">algorithm </font>
    (y,t,x_continuous) := <font color="red">Modelica_LinearSystems2.ZerosAndPoles.Analysis.timeResponse</font>(
        zp=zp,
        dt=dt,
        tSpan=tSpan,
        response=Modelica_LinearSystems2.Types.TimeResponse.Initial,
        x0=x0);

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>initialResponse</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Analysis.numeratorDegree"><font color="blue">encapsulated </font><font color="blue">function</font> numeratorDegree <font color="darkgreen">&quot;Return numerator degree&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp <font color="darkgreen">&quot;ZerosAndPoles transfer function of a system&quot;</font>;
      <font color="blue">output </font>Integer result;
    <font color="blue">algorithm </font>
      result := <font color="red">size</font>(zp.n1, 1) + 2*<font color="red">size</font>(zp.n2, 1);
<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>numeratorDegree</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Analysis.denominatorDegree"><font color="blue">encapsulated </font><font color="blue">function</font> denominatorDegree <font color="darkgreen">
      &quot;Return denominator degree&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp <font color="darkgreen">&quot;ZerosAndPoles transfer function of a system&quot;</font>;
      <font color="blue">output </font>Integer result;
    <font color="blue">algorithm </font>
      result := <font color="red">size</font>(zp.d1, 1) + 2*<font color="red">size</font>(zp.d2, 1);
<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>denominatorDegree</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Analysis.evaluate"><font color="blue">encapsulated </font><font color="blue">function</font> evaluate <font color="darkgreen">
      &quot;Evaluate a ZerosAndPoles transfer function at a given value of p&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal"
>Modelica_LinearSystems2.ZerosAndPoles.Internal</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp <font color="darkgreen">&quot;ZerosAndPoles transfer function of a system&quot;</font>;
      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> p=<font color="red">Complex</font>(0) <font color="darkgreen">&quot;Complex value p where zp is evaluated&quot;</font>;
      <font color="blue">input </font>Real den_min=0 <font color="darkgreen">&quot;|denominator(p)| is limited by den_min&quot;</font>;
      <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> y <font color="darkgreen">&quot;= zp(p)&quot;</font>;
    <font color="blue">protected </font>
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> j = <font color="red">Modelica_LinearSystems2.Math.Complex.j</font>();
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> num;
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> den;
      Real abs_den;
    <font color="blue">algorithm </font>
      <font color="darkgreen">// Build numerator</font>
      num := zp.k+0*j;
      <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(zp.n1, 1)<font color="blue"> loop</font>
         num := num*<font color="red">Internal.&#39;p+a&#39;</font>(p, zp.n1[i]);
      <font color="blue">end for</font>;
      <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(zp.n2, 1)<font color="blue"> loop</font>
         num := num*<font color="red">Internal.&#39;p^2+k[1]*p+k[2]&#39;</font>(p, zp.n2[i, :]);
      <font color="blue">end for</font>;

      <font color="darkgreen">// Build denominator</font>
      den := 1+0*j;
      <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(zp.d1, 1)<font color="blue"> loop</font>
        den := den*<font color="red">Internal.&#39;p+a&#39;</font>(p, zp.d1[i]);
      <font color="blue">end for</font>;
      <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(zp.d2, 1)<font color="blue"> loop</font>
        den := den*<font color="red">Internal.&#39;p^2+k[1]*p+k[2]&#39;</font>(p, zp.d2[i, :]);
      <font color="blue">end for</font>;

      <font color="darkgreen">// Build value of transfer function</font>
      abs_den := <font color="red">Complex.&#39;abs&#39;</font>(den);
      den := <font color="blue">if </font>abs_den &gt;= den_min<font color="blue"> then </font>den<font color="blue"> else </font>-abs_den+0*j;
      y := num/den;
<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>evaluate</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Analysis.zerosAndPoles"><font color="blue">encapsulated </font><font color="blue">function</font> zerosAndPoles <font color="darkgreen">
      &quot;Calculate zeros and poles of a ZerosAndPoles transfer function&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal"
>Modelica_LinearSystems2.ZerosAndPoles.Internal</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp <font color="darkgreen">&quot;ZerosAndPoles transfer function of a system&quot;</font>;
      <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> z[:]=<font color="red">fill</font>(<font color="red">Complex</font>(0, 0), <font color="red">size</font>(zp.n1, 1) + 2*<font color="red">size</font>(zp.n2, 1)) <font color="darkgreen">
        &quot;Zeros (Complex vector of numerator zeros)&quot;</font>;
      <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> p[:]=<font color="red">fill</font>(<font color="red">Complex</font>(0, 0), <font color="red">size</font>(zp.d1, 1) + 2*<font color="red">size</font>(zp.d2, 1)) <font color="darkgreen">
        &quot;Poles (Complex vector of denominator zeros)&quot;</font>;
      <font color="blue">output </font>Real k <font color="darkgreen">&quot;Constant multiplied with transfer function&quot;</font>;

    <font color="blue">protected </font>
      Integer n_num1=<font color="red">size</font>(zp.n1, 1);
      Integer n_num2=<font color="red">size</font>(zp.n2, 1);
      Integer n_den1=<font color="red">size</font>(zp.d1, 1);
      Integer n_den2=<font color="red">size</font>(zp.d2, 1);
      Integer n_num=n_num1 + 2*n_num2;
      Integer n_den=n_den1 + 2*n_den2;
      Real re;
      Real im;
      Integer nz_real=<font color="red">Internal.numberOfRealZeros</font>(zp.n1, zp.n2) <font color="darkgreen">
        &quot;z[1:nz_real] are the real zeros&quot;</font>;
      Integer np_real=<font color="red">Internal.numberOfRealZeros</font>(zp.d1, zp.d2) <font color="darkgreen">
        &quot;p[1:np_real] are the real poles&quot;</font>;
      Real num_zeros1[nz_real];
      Real den_zeros1[np_real];
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> num_zeros2[:]=<font color="red">fill</font>(<font color="red">Complex</font>(0, 0), <font color="red">integer</font>((n_num - nz_real)/2));
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> den_zeros2[:]=<font color="red">fill</font>(<font color="red">Complex</font>(0, 0), <font color="red">integer</font>((n_den - np_real)/2));
      Integer n;
      Integer jj;
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> j=<font color="red">Modelica_LinearSystems2.Math.Complex.j</font>();

    <font color="blue">algorithm </font>
      (num_zeros1,num_zeros2) := <font color="red">Internal.roots</font>(
          zp.n1,
          zp.n2,
          nz_real);
      (den_zeros1,den_zeros2) := <font color="red">Internal.roots</font>(
          zp.d1,
          zp.d2,
          np_real);

      n := <font color="red">size</font>(num_zeros1, 1);
      <font color="blue">for </font>i<font color="blue"> in </font>1:n<font color="blue"> loop</font>
        z[i] := <font color="red">Complex</font>(num_zeros1[i], 0);
      <font color="blue">end for</font>;

      jj := 1;
      <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(num_zeros2, 1)<font color="blue"> loop</font>
        z[n + jj] := num_zeros2[i];
        z[n + jj + 1] := num_zeros2[i].re-num_zeros2[i].im*j;
        jj := jj + 2;
      <font color="blue">end for</font>;

      n := <font color="red">size</font>(den_zeros1, 1);
      <font color="blue">for </font>i<font color="blue"> in </font>1:n<font color="blue"> loop</font>
        p[i] := den_zeros1[i]+0*j;
      <font color="blue">end for</font>;

      jj := 1;
      <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(den_zeros2, 1)<font color="blue"> loop</font>
        p[n + jj] := den_zeros2[i];
        p[n + jj + 1] := den_zeros2[i].re-den_zeros2[i].im*j;
        jj := jj + 2;
      <font color="blue">end for</font>;

      k := zp.k;
<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>zerosAndPoles</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Analysis.eigenValues"><font color="blue">function</font> eigenValues <font color="darkgreen">
      &quot;Calculate the eigen values of a linear zeros-and-poles transfer function and write them in a complex vector&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp <font color="darkgreen">&quot;ZerosAndPoles transfer function of a system&quot;</font>;
      <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> eigval[:] <font color="darkgreen">&quot;eigen values of the system&quot;</font>;
    <font color="blue">protected </font>
      <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss=<font color="red">StateSpace</font>(zp);

    <font color="blue">algorithm </font>
      <font color="red">assert</font>(<font color="red">ZerosAndPoles.Analysis.denominatorDegree</font>(zp) &gt;
        <font color="red">ZerosAndPoles.Analysis.numeratorDegree</font>(zp),
        &quot; Denominator polynominal of transfer function in function\&quot;ZerosAndPoles.Analysis.eigenValues\&quot;has to be of higher order than numerator polynomial&quot;);
      eigval := <font color="red">Complex.eigenValues</font>(ss.A);
<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>eigenValues</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Analysis.eigenVectors"><font color="blue">encapsulated </font><font color="blue">function</font> eigenVectors <font color="darkgreen">
      &quot;Calculate the rigth eigenvectors of the corresponding state space system of a zeros-and-poles transfer function and write them columnwise in a matrix&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp <font color="darkgreen">&quot;ZerosAndPoles transfer function of a system&quot;</font>;
      <font color="blue">input </font>Boolean onlyEigenvectors=true;
      <font color="blue">output </font>Real eigvec[:,:] <font color="darkgreen">&quot;eigen values of the system&quot;</font>;
      <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> eigval[:] <font color="darkgreen">&quot;eigen values of the system&quot;</font>;
    <font color="blue">protected </font>
      <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss=<font color="red">StateSpace</font>(zp);

    <font color="blue">algorithm </font>
      <font color="red">assert</font>(<font color="red">ZerosAndPoles.Analysis.denominatorDegree</font>(zp) &gt;
        <font color="red">ZerosAndPoles.Analysis.numeratorDegree</font>(zp),
        &quot; Denominator polynominal of transfer function in function\&quot;ZerosAndPoles.Analysis.eigenVectors\&quot;has to be of higher order than numerator polynomial&quot;);
      (eigvec,eigval) := <font color="red">StateSpace.Analysis.eigenVectors</font>(ss=ss,
        onlyEigenvectors=onlyEigenvectors);

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>eigenVectors</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Analysis.invariantZeros"><font color="blue">encapsulated </font><font color="blue">function</font> invariantZeros <font color="darkgreen">
      &quot;Compute invariant zeros of zeros-and-poles transfer function&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp <font color="darkgreen">&quot;ZerosAndPoles transfer function of a system&quot;</font>;

      <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> Zeros[:]= <font color="red">ZerosAndPoles.Analysis.zerosAndPoles</font>(zp);

    <font color="blue">algorithm </font>

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>invariantZeros</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Analysis.observabilityMatrix"><font color="blue">encapsulated </font><font color="blue">function</font> observabilityMatrix <font color="darkgreen">
      &quot;Calculate the observability matrix of zp-transfer-function&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp <font color="darkgreen">&quot;ZerosAndPoles transfer function of a system&quot;</font>;
      <font color="blue">output </font>Real om[:,:];

    <font color="blue">protected </font>
      <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss=<font color="red">StateSpace</font>(zp);

    <font color="blue">algorithm </font>
      om := <font color="red">StateSpace.Analysis.observabilityMatrix</font>(ss=ss);

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>observabilityMatrix</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Analysis.controllabilityMatrix"><font color="blue">encapsulated </font><font color="blue">function</font> controllabilityMatrix <font color="darkgreen">
      &quot;Calculate the controllability matrix [B, A*B, ..., A^(n-1)*B] of a zp-transfer-function&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp <font color="darkgreen">&quot;ZerosAndPoles transfer function of a system&quot;</font>;
      <font color="blue">output </font>Real om[:,:];

    <font color="blue">protected </font>
      <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss=<font color="red">StateSpace</font>(zp);

    <font color="blue">algorithm </font>
      om := <font color="red">StateSpace.Analysis.controllabilityMatrix</font>(ss=ss);

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>controllabilityMatrix</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Analysis.isObservable"><font color="blue">encapsulated </font><font color="blue">function</font> isObservable <font color="darkgreen">
      &quot;Check observability of a zp-transfer-function&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;

        <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp <font color="darkgreen">&quot;ZerosAndPoles transfer function of a system&quot;</font>;
        <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.StaircaseMethod"
>Modelica_LinearSystems2.Types.StaircaseMethod</A> method=
            Modelica_LinearSystems2.Types.StaircaseMethod.SVD;

        <font color="blue">output </font>Boolean observable;
    <font color="blue">protected </font>
        <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss=<font color="red">StateSpace</font>(zp);

    <font color="blue">algorithm </font>
        observable := <font color="red">StateSpace.Analysis.isObservable</font>(ss=ss, method=method);

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>isObservable</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Analysis.isControllable"><font color="blue">encapsulated </font><font color="blue">function</font> isControllable <font color="darkgreen">
      &quot;Check controllability of a zp-transfer-function&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp <font color="darkgreen">&quot;ZerosAndPoles transfer function of a system&quot;</font>;
      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.Method"
>Modelica_LinearSystems2.Types.Method</A> method=Modelica_LinearSystems2.Types.StaircaseMethod.SVD;

      <font color="blue">output </font>Boolean controllable;
    <font color="blue">protected </font>
      <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss=<font color="red">StateSpace</font>(zp);

    <font color="blue">algorithm </font>
      controllable := <font color="red">StateSpace.Analysis.isControllable</font>(ss=ss, method=method);

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>isControllable</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Analysis.isStabilizable"><font color="blue">encapsulated </font><font color="blue">function</font> isStabilizable <font color="darkgreen">
      &quot;Check stabilizability of a zp-transfer-function&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp <font color="darkgreen">&quot;ZerosAndPoles transfer function of a system&quot;</font>;

      <font color="blue">output </font>Boolean stabilizable;
    <font color="blue">protected </font>
      <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss=<font color="red">StateSpace</font>(zp);

    <font color="blue">algorithm </font>
      stabilizable := <font color="red">StateSpace.Analysis.isStabilizable</font>(ss=ss);

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>isStabilizable</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Analysis.isDetectable"><font color="blue">encapsulated </font><font color="blue">function</font> isDetectable <font color="darkgreen">
      &quot;Check detectability of a zp-transfer-function&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp <font color="darkgreen">&quot;ZerosAndPoles transfer function of a system&quot;</font>;

      <font color="blue">output </font>Boolean detectable;

    <font color="blue">protected </font>
      <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss=<font color="red">StateSpace</font>(zp);

    <font color="blue">algorithm </font>
      detectable := <font color="red">StateSpace.Analysis.isDetectable</font>(ss=ss);

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>isDetectable</textblock>;

  <font color="blue">end </font>Analysis</textblock>;

  <textblock type="packagesmall" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Design"><font color="blue">encapsulated </font><font color="blue">package</font> Design

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Design.filter"><font color="blue">encapsulated </font><font color="blue">function</font> filter <font color="darkgreen">
      &quot;Generate the data record of a ZerosAndPoles transfer function from a filter description&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams"
>Modelica.Utilities.Streams</A>;
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams.print"
>Modelica.Utilities.Streams.print</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types"
>Modelica_LinearSystems2.Types</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal"
>Modelica_LinearSystems2.ZerosAndPoles.Internal</A>;
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Math.html#Modelica.Math"
>Modelica.Math</A>.*;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math"
>Modelica_LinearSystems2.Math</A>.*;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.AnalogFilter"
>Modelica_LinearSystems2.Types.AnalogFilter</A> analogFilter=Types.AnalogFilter.CriticalDamping <font color="darkgreen">
        &quot;Analog filter characteristics (CriticalDamping/Bessel/Butterworth/Chebyshev)&quot;</font>;
    <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.FilterType"
>Modelica_LinearSystems2.Types.FilterType</A> filterType=Types.FilterType.LowPass <font color="darkgreen">
        &quot;Type of filter (LowPass/HighPass)&quot;</font>;
    <font color="blue">input </font>Integer order(min=1) = 2 <font color="darkgreen">&quot;Order of filter&quot;</font>;
    <font color="blue">input </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Modelica.SIunits.Frequency</A> f_cut=1/(2*Modelica.Constants.pi) <font color="darkgreen">
        &quot;Cut-off frequency (default is w_cut = 1 rad/s)&quot;</font>;
    <font color="blue">input </font>Real gain=1.0 <font color="darkgreen">
        &quot;Gain (= amplitude of frequency response at zero frequency)&quot;</font>;
    <font color="blue">input </font>Real A_ripple(unit=&quot;dB&quot;) = 0.5 <font color="darkgreen">
        &quot;Pass band ripple for Chebyshev filter (otherwise not used)&quot;</font>;
    <font color="blue">input </font>Boolean normalized=true <font color="darkgreen">
        &quot;= true, if amplitude of low pass filter at f_cut where the magnitude of the filter sagged for 3dB, otherwise unmodified filter&quot;</font>;
    <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> filter(
      <font color="blue">redeclare </font>Real n1[<font color="blue">if </font>filterType == Types.FilterType.LowPass<font color="blue"> then </font>0<font color="blue"> else </font>(
        <font color="blue">if </font>analogFilter == Types.AnalogFilter.CriticalDamping<font color="blue"> then </font>order<font color="blue"> else </font>
        <font color="red">mod</font>(order, 2))],
      <font color="blue">redeclare </font>Real n2[<font color="blue">if </font>filterType == Types.FilterType.LowPass<font color="blue"> then </font>0<font color="blue"> else </font>(
        <font color="blue">if </font>analogFilter == Types.AnalogFilter.CriticalDamping<font color="blue"> then </font>0<font color="blue"> else </font>
        <font color="red">integer</font>((order + 1)/2)),2],
      <font color="blue">redeclare </font>Real d1[<font color="blue">if </font>analogFilter == Types.AnalogFilter.CriticalDamping<font color="blue"> then </font>
              order<font color="blue"> else </font><font color="red">mod</font>(order, 2)],
      <font color="blue">redeclare </font>Real d2[<font color="blue">if </font>analogFilter == Types.AnalogFilter.CriticalDamping<font color="blue"> then </font>
              0<font color="blue"> else </font><font color="red">integer</font>(order/2),2]) <font color="darkgreen">&quot;Filter transfer function&quot;</font>;

    <font color="blue">protected </font>
    Integer n_num1=<font color="red">size</font>(filter.n1, 1);
    Integer n_num2=<font color="red">size</font>(filter.n2, 1);
    Integer n_den1=<font color="red">size</font>(filter.d1, 1);
    Integer n_den2=<font color="red">size</font>(filter.d2, 1);
    Integer n_num=n_num1 + 2*n_num2;
    Integer n_den=n_den1 + 2*n_den2;
    Real pi=Modelica.Constants.pi;
    Boolean evenOrder=<font color="red">mod</font>(order, 2) == 0 <font color="darkgreen">
        &quot;= true, if even filter order (otherwise uneven)&quot;</font>;
    <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>Modelica.SIunits.AngularVelocity</A> w_cut=2*pi*f_cut <font color="darkgreen">
        &quot;Cut-off angular frequency&quot;</font>;
    Real w_cut2 <font color="darkgreen">&quot;= w_cut*w_cut&quot;</font>;
    Real alpha=1.0 <font color="darkgreen">&quot;Frequency correction factor&quot;</font>;
    Real alpha2 <font color="darkgreen">&quot;= alpha*alpha&quot;</font>;

    Real alphax;

    Real poleReal <font color="darkgreen">&quot;Real part of pole&quot;</font>;
    Real poleImag <font color="darkgreen">&quot;Imaginary part of pole&quot;</font>;
    Real epsilon <font color="darkgreen">&quot;Ripple size&quot;</font>;
    Real fac <font color="darkgreen">&quot;arsinh(epsilon)&quot;</font>;
    Real A2 <font color="darkgreen">&quot;poleReal^2 + poleImag^2&quot;</font>;
    Real A <font color="darkgreen">&quot;Amplitude at w_cut&quot;</font>;
    Real num1[n_num1] <font color="darkgreen">
        &quot;[p] coefficients of numerator first order polynomials (a*p + 1)&quot;</font>;
    Real num2[n_num2,2] <font color="darkgreen">
        &quot;[p^2, p] coefficients of numerator second order polynomials (b*p^2 + a*p + 1I)&quot;</font>;
    Real den1[n_den1] <font color="darkgreen">
        &quot;[p] coefficients of denominator first order polynomials (a*p + 1)&quot;</font>;
    Real den2[n_den2,2] <font color="darkgreen">
        &quot;[p^2, p] coefficients of denominator second order polynomials (b*p^2 + a*p + 1I)&quot;</font>;
    Real aux;
    Real k;
  <font color="blue">algorithm </font>
    <font color="darkgreen">// Set properties that are common for all filters</font>
    filter.k := gain;

    <font color="darkgreen">/* Compute filter coefficients of prototype low pass filter. If another filter
     characteristics is desired (e.g. high pass filter), it is derived
     from the low pass filter coefficients below
  */</font>
    <font color="blue">if </font>analogFilter == Types.AnalogFilter.CriticalDamping<font color="blue"> then</font>
      <font color="blue">if </font>normalized<font color="blue"> then</font>
        alpha := <font color="red">sqrt</font>(2^(1/order) - 1);
  <font color="darkgreen">//alpha := sqrt(10^(3/10/order)-1)</font>
      <font color="blue">else</font>
        alpha := 1;
      <font color="blue">end if</font>;
      <font color="blue">for </font>i<font color="blue"> in </font>1:n_den1<font color="blue"> loop</font>
        den1[i] := alpha;
      <font color="blue">end for</font>;

    <font color="blue">elseif </font>analogFilter == Types.AnalogFilter.Bessel<font color="blue"> then</font>
      (den1,den2,alpha) := <font color="red">Internal.BesselCoefficients</font>(order);
      <font color="blue">if </font><font color="blue">not </font>normalized<font color="blue"> then</font>
        alpha2 := alpha*alpha;
        <font color="blue">for </font>i<font color="blue"> in </font>1:n_den2<font color="blue"> loop</font>
          den2[i, 1] := den2[i, 1]*alpha2;
          den2[i, 2] := den2[i, 2]*alpha;
        <font color="blue">end for</font>;
        <font color="blue">if </font><font color="blue">not </font>evenOrder<font color="blue"> then</font>
          den1[1] := den1[1]*alpha;
        <font color="blue">end if</font>;
      <font color="blue">end if</font>;

    <font color="blue">elseif </font>analogFilter == Types.AnalogFilter.Butterworth<font color="blue"> then</font>
       <font color="darkgreen">// Original filter is already normalized</font>
      <font color="blue">for </font>i<font color="blue"> in </font>1:n_den2<font color="blue"> loop</font>
        den2[i, 1] := 1.0;
        den2[i, 2] := -2*<font color="red">cos</font>(pi*(0.5 + (i - 0.5)/order));
      <font color="blue">end for</font>;
      <font color="blue">if </font><font color="blue">not </font>evenOrder<font color="blue"> then</font>
        den1[1] := 1.0;
      <font color="blue">end if</font>;

    <font color="blue">elseif </font>analogFilter == Types.AnalogFilter.Chebyshev<font color="blue"> then</font>
      epsilon := <font color="red">sqrt</font>(10^(A_ripple/10) - 1);
      fac := <font color="red">asinh</font>(1/epsilon)/order;

      <font color="blue">for </font>i<font color="blue"> in </font>1:n_den2<font color="blue"> loop</font>
         <font color="darkgreen">// poles of prototype lowpass</font>
        poleReal := <font color="red">cos</font>(pi/2 + pi*(2*i - 1)/(2*order))*<font color="red">sinh</font>(fac);
        poleImag := -<font color="red">sin</font>(pi/2 + pi*(2*i - 1)/(2*order))*<font color="red">cosh</font>(fac);

         <font color="darkgreen">// second order filter coefficients</font>
        A2 := poleReal^2 + poleImag^2;
        den2[i, 1] := 1/A2;
        den2[i, 2] := -2*poleReal/A2;
      <font color="blue">end for</font>;
      <font color="blue">if </font><font color="blue">not </font>evenOrder<font color="blue"> then</font>
        den1[1] := -1.0/(<font color="red">cos</font>(pi/2 + pi*(2*n_den - 1)/(2*order))*<font color="red">sinh</font>(fac));
      <font color="blue">end if</font>;

       <font color="darkgreen">/* Transformation of filter transfer function with &quot;new(p) = alpha*p&quot;
        in order that the filter transfer function has an amplitude of
        3 db at the cutoff frequency
     */</font>
      <font color="blue">if </font>normalized<font color="blue"> then</font>
        alpha := <font color="red">Internal.normalizationFactor</font>(den1, den2);
        alpha2 := alpha*alpha;
        <font color="blue">for </font>i<font color="blue"> in </font>1:n_den2<font color="blue"> loop</font>
          den2[i, 1] := den2[i, 1]*alpha2;
          den2[i, 2] := den2[i, 2]*alpha;
        <font color="blue">end for</font>;
        <font color="blue">if </font><font color="blue">not </font>evenOrder<font color="blue"> then</font>
          den1[1] := den1[1]*alpha;
        <font color="blue">end if</font>;
      <font color="blue">end if</font>;

    <font color="blue">else</font>
      <font color="red">Streams.error</font>(&quot;analogFilter (= &quot; + <font color="red">String</font>(analogFilter) +
        &quot;) is not supported&quot;);
    <font color="blue">end if</font>;

    <font color="darkgreen">// Determine normalized denominator polynomials with highest power of p equal to one</font>
    filter.n1 := <font color="red">zeros</font>(n_num1);
    filter.n2 := <font color="red">zeros</font>(n_num2, 2);
    (filter.d1,filter.d2,k) := <font color="red">Internal.filterToNormalized</font>(den1, den2);
    filter.k := filter.k/k;

    <font color="darkgreen">// Compute desired filter characteristics from low pass filter coefficients</font>
    <font color="blue">if </font>filterType == Types.FilterType.HighPass<font color="blue"> then</font>
       <font color="darkgreen">/* The high pass filter is derived from the low pass filter by
        the transformation new(p) = 1/p
        1/(p^2 + a*p + b) -&gt; 1/((1/p)^2 + a*(1/p) + b) = (1/b)*p^2 / (p^2 + (a/b)*p + 1/b)
        1/(p + a)         -&gt; 1/((1/p) + a) = (1/a)*p / (p + (1/a))
     */</font>
      <font color="red">assert</font>(n_num1 == n_den1<font color="blue"> and </font>n_num2 == n_den2,
        &quot;Internal error 1, should not occur&quot;);
      filter.n1 := <font color="red">zeros</font>(n_num1);
      filter.n2 := <font color="red">zeros</font>(n_num2, 2);
      <font color="blue">for </font>i<font color="blue"> in </font>1:n_num1<font color="blue"> loop</font>
        filter.k := filter.k/filter.d1[i];
        filter.d1[i] := 1/filter.d1[i];
      <font color="blue">end for</font>;
      <font color="blue">for </font>i<font color="blue"> in </font>1:n_num2<font color="blue"> loop</font>
        filter.k := filter.k/filter.d2[i, 2];
        filter.d2[i, 1] := filter.d2[i, 1]/filter.d2[i, 2];
        filter.d2[i, 2] := 1/filter.d2[i, 2];
      <font color="blue">end for</font>;
    <font color="blue">end if</font>;

    <font color="darkgreen">/* Change filter coefficients according to transformation new(p) = p/w_cut
     Numerator  :     (p/w)^2 + a*(p/w) + b = (1/w^2)*(p^2 + (a*w)*p + b*w^2)
                                  (p/w) + a = (1/w)*(p + w*a)
     Denominator: 1/((p/w)^2 + a*(p/w) + b) = w^2/(p^2 + (a*w)*p + w^2/b)
                              1/((p/w) + a) = w/(p + w*a)
  */</font>
    w_cut2 := w_cut*w_cut;
    filter.k := filter.k*w_cut^(n_den1 + 2*n_den2 - n_num1 - 2*n_num2);
    filter.n1 := w_cut*filter.n1;
    filter.d1 := w_cut*filter.d1;
    filter.n2 := [w_cut*filter.n2[:, 1],w_cut2*filter.n2[:, 2]];
    filter.d2 := [w_cut*filter.d2[:, 1],w_cut2*filter.d2[:, 2]];

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>filter</textblock>;
  <font color="blue">end </font>Design</textblock>;

  <textblock type="packagesmall" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Plot"><font color="blue">encapsulated </font><font color="blue">package</font> Plot

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Plot.polesAndZeros"><font color="blue">encapsulated </font><font color="blue">function</font> polesAndZeros <font color="darkgreen">
      &quot;Plot eigenvalues and or the zeros of a zeros-and-poles transfer function&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Utilities_Plot.html#Modelica_LinearSystems2.Utilities.Plot"
>Modelica_LinearSystems2.Utilities.Plot</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp <font color="darkgreen">&quot;Linear system in ZerosAndPoles form&quot;</font>;
    <font color="blue">input </font>Boolean poles=true <font color="darkgreen">&quot;= true, to plot the poles of zp&quot;</font>;
    <font color="blue">input </font>Boolean zeros=true <font color="darkgreen">&quot;= true, to plot the zeros of zp&quot;</font>;

    <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.PartialPlotFunction"
>Modelica_LinearSystems2.Internal.PartialPlotFunction</A>(
       defaultDiagram = <font color="red">Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros</font>());

    <font color="blue">protected </font>
    Real eval[<font color="red">ZerosAndPoles.Analysis.denominatorDegree</font>(zp),2];
    Real invZerosRe[<font color="red">ZerosAndPoles.Analysis.numeratorDegree</font>(zp)];
    Real invZerosIm[<font color="red">ZerosAndPoles.Analysis.numeratorDegree</font>(zp)];

    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> invZeros[:];
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> poles2[:];

    <A HREF="Modelica_LinearSystems2_Utilities_Plot_Records.html#Modelica_LinearSystems2.Utilities.Plot.Records.Curve"
>Plot.Records.Curve</A> curves[2];
    Integer i;
    <A HREF="Modelica_LinearSystems2_Utilities_Plot_Records.html#Modelica_LinearSystems2.Utilities.Plot.Records.Diagram"
>Plot.Records.Diagram</A> diagram2;
  <font color="blue">algorithm </font>
    (invZeros, poles2) := <font color="red">ZerosAndPoles.Analysis.zerosAndPoles</font>(zp);

    <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(invZeros, 1)<font color="blue"> loop</font>
       invZerosRe[i] := invZeros[i].re;
       invZerosIm[i] := invZeros[i].im;
    <font color="blue">end for</font>;

    <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(poles2, 1)<font color="blue"> loop</font>
       eval[i,1] := poles2[i].re;
       eval[i,2] := poles2[i].im;
    <font color="blue">end for</font>;

    i :=0;
    <font color="blue">if </font>poles<font color="blue"> then</font>
       i :=i + 1;
       curves[i] :=<font color="red">Plot.Records.Curve</font>(
                          x=eval[:, 1],
                          y=eval[:, 2],
                          legend=&quot;poles&quot;,
                          autoLine=false,
                          linePattern=Plot.Types.LinePattern.None,
                          lineSymbol=Plot.Types.PointSymbol.Cross);
    <font color="blue">end if</font>;

    <font color="blue">if </font>zeros<font color="blue"> then</font>
       i :=i + 1;
       curves[i] :=<font color="red">Plot.Records.Curve</font>(
                          x=invZerosRe,
                          y=invZerosIm,
                          legend=&quot;zeros&quot;,
                          autoLine=false,
                          linePattern=Plot.Types.LinePattern.None,
                          lineSymbol=Plot.Types.PointSymbol.Circle);
    <font color="blue">end if</font>;

       diagram2 :=defaultDiagram;
       diagram2.curve :=curves[1:i];
       <font color="red">Plot.diagram</font>(diagram2,device);

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>polesAndZeros</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Plot.bode"><font color="blue">encapsulated </font><font color="blue">function</font> bode <font color="darkgreen">
      &quot;Plot ZerosAndPoles transfer function as bode plot&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams.print"
>Modelica.Utilities.Streams.print</A>;
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Strings.html#Modelica.Utilities.Strings"
>Modelica.Utilities.Strings</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>;
      <font color="blue">import </font>SI = <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits"
>Modelica.SIunits</A>;

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Utilities_Plot.html#Modelica_LinearSystems2.Utilities.Plot"
>Modelica_LinearSystems2.Utilities.Plot</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp <font color="darkgreen">&quot;ZerosAndPoles transfer function to be plotted&quot;</font>;
    <font color="blue">input </font>Integer nPoints(min=2) = 200 <font color="darkgreen">&quot;Number of points&quot;</font>;
    <font color="blue">input </font>Boolean autoRange=true <font color="darkgreen">
        &quot;= true, if abszissa range is automatically determined&quot;</font>;
    <font color="blue">input </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Modelica.SIunits.Frequency</A> f_min(min=0) = 0.1 <font color="darkgreen">
        &quot;Minimum frequency value, if autoRange = false&quot;</font>;
    <font color="blue">input </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Modelica.SIunits.Frequency</A> f_max(min=0) = 10 <font color="darkgreen">
        &quot;Maximum frequency value, if autoRange = false&quot;</font>;

    <font color="blue">input </font>Boolean magnitude=true <font color="darkgreen">&quot;= true, to plot the magnitude of tf&quot;</font>;
    <font color="blue">input </font>Boolean phase=true <font color="darkgreen">&quot;= true, to plot the pase of tf&quot;</font>;

    <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.PartialPlotFunction"
>Modelica_LinearSystems2.Internal.PartialPlotFunction</A>(defaultDiagram=
          <font color="red">Modelica_LinearSystems2.Internal.DefaultDiagramBodePlot</font>(heading=&quot;Bode plot of  zp = &quot;
           + <font color="red">String</font>(zp)));

    <font color="blue">protected </font>
    <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>SI.AngularVelocity</A> w[nPoints];
    <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.Frequency"
>SI.Frequency</A> f[nPoints];
    <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits_Conversions_NonSIunits.html#Modelica.SIunits.Conversions.NonSIunits.Angle_deg"
>Modelica.SIunits.Conversions.NonSIunits.Angle_deg</A> phi[nPoints];
    Real A[nPoints];
    Boolean OK;
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> c;
    Integer window=0;
    <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.Angle"
>Modelica.SIunits.Angle</A> phi_old;
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> numZeros[:];
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> denZeros[:];
    <A HREF="Modelica_LinearSystems2_Utilities_Plot_Records.html#Modelica_LinearSystems2.Utilities.Plot.Records.Curve"
>Plot.Records.Curve</A> curves[2];
    Integer i;
    <A HREF="Modelica_LinearSystems2_Utilities_Plot_Records.html#Modelica_LinearSystems2.Utilities.Plot.Records.Diagram"
>Plot.Records.Diagram</A> diagram2[2];
  <font color="blue">algorithm </font>
      <font color="darkgreen">   // Determine frequency vector f</font>
    <font color="blue">if </font>autoRange<font color="blue"> then</font>
      (numZeros,denZeros) := <font color="red">ZerosAndPoles.Analysis.zerosAndPoles</font>(zp);
    <font color="blue">else</font>
      numZeros := <font color="red">fill</font>(<font color="red">Complex</font>(0), 0);
      denZeros := <font color="red">fill</font>(<font color="red">Complex</font>(0), 0);
    <font color="blue">end if</font>;
    f := <font color="red">Internal.frequencyVector</font>(
      nPoints,
      autoRange,
      f_min,
      f_max,
      numZeros,
      denZeros);

      <font color="darkgreen">   // Compute magnitude/phase at the frequency points</font>

    phi_old := 0.0;
    <font color="blue">for </font>i<font color="blue"> in </font>1:nPoints<font color="blue"> loop</font>
      w[i] := <font color="red">Modelica.SIunits.Conversions.from_Hz</font>(f[i]);
      c := <font color="red">ZerosAndPoles.Analysis.evaluate</font>(
        zp,
        <font color="red">Complex</font>(0, w[i]),
        1e-10);
      A[i] := <font color="red">Complex.&#39;abs&#39;</font>(c);
      phi_old := <font color="red">Complex.arg</font>(c, phi_old);
      phi[i] := <font color="red">Modelica.SIunits.Conversions.to_deg</font>(phi_old);

    <font color="blue">end for</font>;

    <font color="darkgreen">// Plot computed frequency response</font>
    diagram2 := <font color="red">fill</font>(defaultDiagram, 2);
    i := 0;
    <font color="blue">if </font>magnitude<font color="blue"> then</font>
      i := i + 1;
      curves[i] := <font color="red">Plot.Records.Curve</font>(
        x=f,
        y=A,
        autoLine=true);
      diagram2[i].curve := {curves[i]};
      diagram2[i].yLabel := &quot;magnitude&quot;;
      <font color="blue">if </font>phase<font color="blue"> then</font>
         diagram2[i].xLabel:=&quot;&quot;;
      <font color="blue">end if</font>;
    <font color="blue">end if</font>;

    <font color="blue">if </font>phase<font color="blue"> then</font>
      i := i + 1;
      curves[i] := <font color="red">Plot.Records.Curve</font>(
        x=f,
        y=phi,
        autoLine=true);
      diagram2[i].curve := {curves[i]};
      diagram2[i].yLabel := &quot;phase [deg]&quot;;
      diagram2[i].logY := false;
      <font color="blue">if </font>magnitude<font color="blue"> then</font>
        diagram2[i].heading:=&quot;&quot;;
     <font color="blue">end if</font>;
    <font color="blue">end if</font>;

    <font color="blue">if </font>magnitude<font color="blue"> and </font>phase<font color="blue"> then</font>
      <font color="red">Plot.diagramVector</font>(diagram2, device);
    <font color="blue">else</font>
      <font color="red">Plot.diagram</font>(diagram2[1], device);
    <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>bode</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Plot.timeResponse"><font color="blue">encapsulated </font><font color="blue">function</font> timeResponse <font color="darkgreen">
      &quot;Plot the time response of a system represented by a transfer function. The response type is selectable&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.TimeResponse"
>Modelica_LinearSystems2.Types.TimeResponse</A>;

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Utilities_Plot.html#Modelica_LinearSystems2.Utilities.Plot"
>Modelica_LinearSystems2.Utilities.Plot</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A> zp;
    <font color="blue">input </font>Real dt=0 <font color="darkgreen">&quot;Sample time [s]&quot;</font>;
    <font color="blue">input </font>Real tSpan=0 <font color="darkgreen">&quot;Simulation time span [s]&quot;</font>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.TimeResponse"
>Modelica_LinearSystems2.Types.TimeResponse</A> response=
        Modelica_LinearSystems2.Types.TimeResponse.Step <font color="darkgreen">&quot;type of time response&quot;</font>;
    <font color="blue">input </font>Real x0[<font color="red">ZerosAndPoles.Analysis.denominatorDegree</font>(zp)]=<font color="red">zeros</font>(
        <font color="red">ZerosAndPoles.Analysis.denominatorDegree</font>(zp)) <font color="darkgreen">&quot;Initial state vector&quot;</font>;

    <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.PartialPlotFunction"
>Modelica_LinearSystems2.Internal.PartialPlotFunction</A>(defaultDiagram=
          <font color="red">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</font>(heading=&quot;time response of  zp = &quot;
           + <font color="red">String</font>(zp)));

    <font color="blue">protected </font>
    <A HREF="Modelica_LinearSystems2_Utilities_Plot_Records.html#Modelica_LinearSystems2.Utilities.Plot.Records.Curve"
>Plot.Records.Curve</A> curve;
    <A HREF="Modelica_LinearSystems2_Utilities_Plot_Records.html#Modelica_LinearSystems2.Utilities.Plot.Records.Diagram"
>Plot.Records.Diagram</A> diagram2;
    Real y[:,1,1] <font color="darkgreen">&quot;Output response&quot;</font>;
    Real t[:] <font color="darkgreen">&quot;Time vector: (number of samples)&quot;</font>;

  <font color="blue">algorithm </font>
    (y,t) := <font color="red">ZerosAndPoles.Analysis.timeResponse</font>(
      zp,
      dt,
      tSpan,
      response,
      x0);

    curve := <font color="red">Plot.Records.Curve</font>(
      x=t,
      y=y[:, 1, 1],
      legend=&quot;y&quot;,
      autoLine=true);
    diagram2 := defaultDiagram;
    diagram2.curve := {curve};

    <font color="red">Plot.diagram</font>(diagram2, device);
<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>timeResponse</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Plot.impulse"><font color="blue">encapsulated </font><font color="blue">function</font> impulse <font color="darkgreen">&quot;Impulse response plot&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Utilities_Plot.html#Modelica_LinearSystems2.Utilities.Plot"
>Modelica_LinearSystems2.Utilities.Plot</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A> zp <font color="darkgreen">
        &quot;zeros-and-poles transfer function&quot;</font>;
    <font color="blue">input </font>Real dt=0 <font color="darkgreen">&quot;Sample time [s]&quot;</font>;
    <font color="blue">input </font>Real tSpan=0 <font color="darkgreen">&quot;Simulation time span [s]&quot;</font>;

    <font color="blue">input </font>Real x0[<font color="red">ZerosAndPoles.Analysis.denominatorDegree</font>(zp)]=<font color="red">zeros</font>(<font color="red">ZerosAndPoles.Analysis.denominatorDegree</font>(zp)) <font color="darkgreen">
        &quot;Initial state vector&quot;</font>;

    <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.PartialPlotFunction"
>Modelica_LinearSystems2.Internal.PartialPlotFunction</A>(defaultDiagram=
          <font color="red">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</font>(heading=&quot;Impulse response of  zp = &quot;
           + <font color="red">String</font>(zp)));

    <font color="blue">protected </font>
    <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.TimeResponse"
>Modelica_LinearSystems2.Types.TimeResponse</A> response=
        Modelica_LinearSystems2.Types.TimeResponse.Impulse <font color="darkgreen">
        &quot;type of time response&quot;</font>;
  <font color="blue">algorithm </font>
    <font color="red">Modelica_LinearSystems2.ZerosAndPoles.Plot.timeResponse</font>(
      zp=zp,
      dt=dt,
      tSpan=tSpan,
      response=response,
      x0=x0,
      defaultDiagram=defaultDiagram,
      device=device);

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>impulse</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Plot.step"><font color="blue">encapsulated </font><font color="blue">function</font> step <font color="darkgreen">&quot;Step response plot&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.TimeResponse"
>Modelica_LinearSystems2.Types.TimeResponse</A>;

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Utilities_Plot.html#Modelica_LinearSystems2.Utilities.Plot"
>Modelica_LinearSystems2.Utilities.Plot</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A> zp;
    <font color="blue">input </font>Real dt=0 <font color="darkgreen">&quot;Sample time [s]&quot;</font>;
    <font color="blue">input </font>Real tSpan=0 <font color="darkgreen">&quot;Simulation time span [s]&quot;</font>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.TimeResponse"
>Modelica_LinearSystems2.Types.TimeResponse</A> response=
        Modelica_LinearSystems2.Types.TimeResponse.Step <font color="darkgreen">&quot;type of time response&quot;</font>;
    <font color="blue">input </font>Real x0[<font color="red">ZerosAndPoles.Analysis.denominatorDegree</font>(zp)]=<font color="red">zeros</font>(
        <font color="red">ZerosAndPoles.Analysis.denominatorDegree</font>(zp)) <font color="darkgreen">&quot;Initial state vector&quot;</font>;

    <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.PartialPlotFunction"
>Modelica_LinearSystems2.Internal.PartialPlotFunction</A>(defaultDiagram=
          <font color="red">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</font>(heading=&quot;Step response of  zp = &quot;
           + <font color="red">String</font>(zp)));

  <font color="blue">algorithm </font>
   <font color="red">Modelica_LinearSystems2.ZerosAndPoles.Plot.timeResponse</font>(
      zp=zp,
      dt=dt,
      tSpan=tSpan,
      response=response,
      x0=x0,
      defaultDiagram=defaultDiagram,
      device=device);

  <font color="blue">equation </font>

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>step</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Plot.ramp"><font color="blue">encapsulated </font><font color="blue">function</font> ramp <font color="darkgreen">&quot;Ramp response plot&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.TimeResponse"
>Modelica_LinearSystems2.Types.TimeResponse</A>;

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Utilities_Plot.html#Modelica_LinearSystems2.Utilities.Plot"
>Modelica_LinearSystems2.Utilities.Plot</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A> zp;
    <font color="blue">input </font>Real dt=0 <font color="darkgreen">&quot;Sample time [s]&quot;</font>;
    <font color="blue">input </font>Real tSpan=0 <font color="darkgreen">&quot;Simulation time span [s]&quot;</font>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.TimeResponse"
>Modelica_LinearSystems2.Types.TimeResponse</A> response=
        Modelica_LinearSystems2.Types.TimeResponse.Ramp <font color="darkgreen">&quot;type of time response&quot;</font>;
    <font color="blue">input </font>Real x0[<font color="red">ZerosAndPoles.Analysis.denominatorDegree</font>(zp)]=<font color="red">zeros</font>(
        <font color="red">ZerosAndPoles.Analysis.denominatorDegree</font>(zp)) <font color="darkgreen">&quot;Initial state vector&quot;</font>;

    <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.PartialPlotFunction"
>Modelica_LinearSystems2.Internal.PartialPlotFunction</A>(defaultDiagram=
          <font color="red">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</font>(heading=&quot;Ramp response of  zp = &quot;
           + <font color="red">String</font>(zp)));

  <font color="blue">algorithm </font>
   <font color="red">Modelica_LinearSystems2.ZerosAndPoles.Plot.timeResponse</font>(
      zp=zp,
      dt=dt,
      tSpan=tSpan,
      response=response,
      x0=x0,
      defaultDiagram=defaultDiagram,
      device=device);

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>ramp</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Plot.initialResponse"><font color="blue">encapsulated </font><font color="blue">function</font> initialResponse <font color="darkgreen">
      &quot;Initial condition response plot&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.TimeResponse"
>Modelica_LinearSystems2.Types.TimeResponse</A>;

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Utilities_Plot.html#Modelica_LinearSystems2.Utilities.Plot"
>Modelica_LinearSystems2.Utilities.Plot</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A> zp;
    <font color="blue">input </font>Real dt=0 <font color="darkgreen">&quot;Sample time [s]&quot;</font>;
    <font color="blue">input </font>Real tSpan=0 <font color="darkgreen">&quot;Simulation time span [s]&quot;</font>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.TimeResponse"
>Modelica_LinearSystems2.Types.TimeResponse</A> response=
        Modelica_LinearSystems2.Types.TimeResponse.Initial <font color="darkgreen">
        &quot;type of time response&quot;</font>;
    <font color="blue">input </font>Real y0 <font color="darkgreen">&quot;Initial output (for initial condition plot)&quot;</font>;

    <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.PartialPlotFunction"
>Modelica_LinearSystems2.Internal.PartialPlotFunction</A>(defaultDiagram=
          <font color="red">Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse</font>(heading=&quot;Initial response of  zp = &quot;
           + <font color="red">String</font>(zp) + &quot;  with y0 = &quot; + <font color="red">String</font>(y0)));

    <font color="blue">protected </font>
    <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A> ss=<font color="red">Modelica_LinearSystems2.StateSpace</font>(zp);
    Real x0[<font color="red">ZerosAndPoles.Analysis.denominatorDegree</font>(zp)]=
        <font color="red">Modelica.Math.Matrices.equalityLeastSquares</font>(
        ss.A,
        <font color="red">fill</font>(0, <font color="red">size</font>(ss.B, 1)),
        ss.C,
        <font color="red">vector</font>(y0)) <font color="darkgreen">&quot;Initial state vector (for initial condition plot)&quot;</font>;
  <font color="blue">algorithm </font>

    <font color="red">Modelica_LinearSystems2.ZerosAndPoles.Plot.timeResponse</font>(
          zp=zp,
          dt=dt,
          tSpan=tSpan,
          response=response,
          x0=x0,
          defaultDiagram=defaultDiagram,
          device=device);

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>initialResponse</textblock>;

  <font color="blue">end </font>Plot</textblock>;

  <textblock type="packagesmall" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Conversion"><font color="blue">encapsulated </font><font color="blue">package</font> Conversion

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Conversion.toTransferFunction"><font color="blue">function</font> toTransferFunction <font color="darkgreen">
      &quot;Generate a TransferFunction object from a ZerosAndPoles object&quot;</font>
      <font color="darkgreen">//encapsulated function fromZerosAndPoles</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Modelica_LinearSystems2.Math.Polynomial</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp <font color="darkgreen">&quot;ZerosAndPoles transfer function of a system&quot;</font>;
      <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf;

    <font color="blue">protected </font>
      Real k;
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> z[:];
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> p[:];
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Polynomial</A> pn;
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Polynomial</A> pd;
    <font color="blue">algorithm </font>
      (z,p,k) := <font color="red">ZerosAndPoles.Analysis.zerosAndPoles</font>(zp);
      pn := <font color="red">Polynomial</font>(z)*<font color="red">Polynomial</font>(k);
      pd := <font color="red">Polynomial</font>(p);
      tf.n := pn.c;
      tf.d := pd.c;
      tf.uName := zp.uName;
      tf.yName := zp.yName;
<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>toTransferFunction</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Conversion.toTransferFunctionMIMO"><font color="blue">encapsulated </font><font color="blue">function</font> toTransferFunctionMIMO <font color="darkgreen">
      &quot;Generate a transfer function matrix  from zeros-and-poles transfer function matrix&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp[:,:] <font color="darkgreen">&quot;ZerosAndPoles transfer function of a system&quot;</font>;

    <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf[<font color="red">size</font>(zp, 1),<font color="red">size</font>(zp, 2)];

    <font color="blue">protected </font>
    Integer ny=<font color="red">size</font>(zp, 1);
    Integer nu=<font color="red">size</font>(zp, 2);

  <font color="blue">algorithm </font>
    <font color="blue">for </font>iy<font color="blue"> in </font>1:ny<font color="blue"> loop</font>
      <font color="blue">for </font>iu<font color="blue"> in </font>1:nu<font color="blue"> loop</font>
        tf[iy, iu] := <font color="red">ZerosAndPoles.Conversion.toTransferFunction</font>(zp[iy, iu]);
      <font color="blue">end for</font>;
    <font color="blue">end for</font>;
<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>toTransferFunctionMIMO</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Conversion.toStateSpace"><font color="blue">function</font> toStateSpace <font color="darkgreen">
      &quot;Transform a ZerosAndPoles object into a StateSpace object&quot;</font>
     <font color="darkgreen">//encapsulated function fromZerosAndPoles</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Vectors.html#Modelica_LinearSystems2.Math.Vectors"
>Modelica_LinearSystems2.Math.Vectors</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp <font color="darkgreen">&quot;ZerosAndPoles transfer function of a system&quot;</font>;
      <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss(
        <font color="blue">redeclare </font>Real A[<font color="red">ZerosAndPoles.Analysis.denominatorDegree</font>(zp),
          <font color="red">ZerosAndPoles.Analysis.denominatorDegree</font>(zp)],
        <font color="blue">redeclare </font>Real B[<font color="red">ZerosAndPoles.Analysis.denominatorDegree</font>(zp),1],
        <font color="blue">redeclare </font>Real C[1,<font color="red">ZerosAndPoles.Analysis.denominatorDegree</font>(zp)],
        <font color="blue">redeclare </font>Real D[1,1]) <font color="darkgreen">&quot;Transfer function in StateSpace SISO form&quot;</font>;

    <font color="blue">protected </font>
      Real A[2,2] <font color="darkgreen">&quot;system matrix of partial 2nd order system&quot;</font>;
      Real B[2,1] <font color="darkgreen">&quot;input matrix of partial 2nd order system&quot;</font>;
      Real C[1,2] <font color="darkgreen">&quot;output matrix of partial 2nd order system&quot;</font>;
      Real D[1,1] <font color="darkgreen">&quot;feedthrough matrix of partial 2nd order system&quot;</font>;
      Real a <font color="darkgreen">&quot;system &#39;matrix&#39; of partial 1st order system&quot;</font>;
      Real b <font color="darkgreen">&quot;input &#39;matrix&#39; of partial 1st order system&quot;</font>;
      Real c <font color="darkgreen">&quot;output &#39;matrix&#39; of partial 1st order system&quot;</font>;
      Real d <font color="darkgreen">&quot;feedthrough &#39;matrix&#39; of partial 1st order system&quot;</font>;
      Integer nx=<font color="red">ZerosAndPoles.Analysis.denominatorDegree</font>(zp);
      Integer n_num1=<font color="red">size</font>(zp.n1, 1);
      Integer n_num2=<font color="red">size</font>(zp.n2, 1);
      Integer n_den1=<font color="red">size</font>(zp.d1, 1);
      Integer n_den2=<font color="red">size</font>(zp.d2, 1);
      Integer n_num=n_num1 + 2*n_num2;
      Integer n_den=n_den1 + 2*n_den2;

      Integer i_d=<font color="blue">if </font>n_num2 &gt; n_den2<font color="blue"> then </font>2*(n_num2 - n_den2) + 1<font color="blue"> else </font>1;
      Integer i_k=<font color="blue">if </font>n_num2 &gt; n_den2<font color="blue"> then </font>n_den2 - (n_num2 - n_den2)<font color="blue"> else </font>n_den2;
      Integer i;
      Integer ili;
      Real num[nx,2]=[zp.n2; [zp.n1,<font color="red">zeros</font>(n_num1)]; <font color="red">zeros</font>(nx - n_num2 - n_num1, 2)] <font color="darkgreen">
        &quot;Numerator matrix, in order that indices are defined in all situations in all if clauses&quot;</font>;
      Real den[nx,2]=[zp.d2; [zp.d1,<font color="red">zeros</font>(n_den1)]; <font color="red">zeros</font>(nx - n_den2 - n_den1, 2)] <font color="darkgreen">
        &quot;Denominator matrix, in order that indices are defined in all situations in all if clauses&quot;</font>;
      Real k[i_k + n_den1](<font color="blue">each </font>fixed=false) <font color="darkgreen">
        &quot;Additional factors of the first and second order blocks, in order that the gain of the blocks is 1&quot;</font>;
      Real k_total;

      Boolean dZero=true;

     <font color="darkgreen">//ZerosAndPoles zp2;</font>

    <font color="blue">algorithm </font>
      <font color="red">assert</font>(n_num &lt;= n_den,
        &quot;ZerosAndPoles transfer function is not proper as required from StateSpace system:\n&quot;
         + &quot;  numerator degree (= &quot; + <font color="red">String</font>(n_num) +
        &quot;) &lt;= denominator degree (= &quot; + <font color="red">String</font>(n_den) + &quot;) required.&quot;);

      <font color="blue">if </font>n_den &gt; 0<font color="blue"> then</font>

        <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">max</font>(n_den2, n_num2)<font color="blue"> loop</font>
          <font color="darkgreen">// State space systems of order 2</font>
          <font color="blue">if </font>i &lt;= n_den2<font color="blue"> then</font>
            <font color="blue">if </font>i &lt;= n_num2<font color="blue"> then</font>
                <font color="darkgreen">// State space system in form (1)</font>
              k[i] := <font color="red">Internal.scaleFactor2</font>(
                  num[i, 1],
                  num[i, 2],
                  den[i, 1],
                  den[i, 2]);
            <font color="blue">elseif </font>i - n_num2 + 1 &lt;= n_num1<font color="blue"> then</font>
                <font color="darkgreen">// State space system in form (1) with 2 first order numerator polynomials</font>
              k[i] := <font color="red">Internal.scaleFactor2</font>(
                  num[i, 1] + num[i + 1, 1],
                  num[i, 1]*num[i + 1, 1],
                  den[i, 1],
                  den[i, 2]);
            <font color="blue">elseif </font>i - n_num2 == n_num1<font color="blue"> then</font>
                <font color="darkgreen">// State space system in form (2) with 1 first order numerator polynomial</font>
              k[i] := <font color="red">Internal.scaleFactor2</font>(
                  0,
                  num[i, 1],
                  den[i, 1],
                  den[i, 2]);
            <font color="blue">else</font>
                <font color="darkgreen">// State space system in form (3)</font>
              k[i] := <font color="red">Internal.scaleFactor2</font>(
                  0,
                  0,
                  den[i, 1],
                  den[i, 2]);
            <font color="blue">end if</font>;
          <font color="blue">else</font>
             <font color="darkgreen">// State space system in form (1) with 2 first order denominator polynomials</font>
            k[i] := <font color="red">Internal.scaleFactor2</font>(
                num[i, 1],
                num[i, 2],
                den[i, 1] + den[i + 1, 1],
                den[i, 1]*den[i + 1, 1]);
          <font color="blue">end if</font>;
        <font color="blue">end for</font>;

        <font color="blue">for </font>i<font color="blue"> in </font>i_d:n_den1<font color="blue"> loop</font>
          <font color="darkgreen">// State space systems of order 1</font>
          <font color="blue">if </font>n_num2 &lt;= n_den2<font color="blue"> and </font>2*(n_den2 - n_num2) + i &lt;= n_num1<font color="blue"> then</font>
             <font color="darkgreen">// State space system in form (4)</font>
            k[i_k + i] := <font color="red">Internal.scaleFactor1</font>(num[<font color="red">max</font>(1, n_num2 + 2*(n_den2 -
              n_num2) + i), 1], den[n_den2 + i, 1]);
          <font color="blue">elseif </font>n_num2 &gt; n_den2<font color="blue"> and </font>i - i_d + 1 &lt;= n_num1<font color="blue"> then</font>
             <font color="darkgreen">// State space system in form (4)</font>
            k[i_k + i] := <font color="red">Internal.scaleFactor1</font>(num[<font color="red">max</font>(1, n_num2 + i - i_d + 1),
              1], den[n_den2 + i, 1]);
          <font color="blue">else</font>
             <font color="darkgreen">// State space system in form (5)</font>
            k[i_k + i] := <font color="red">Internal.scaleFactor1</font>(0, den[n_den2 + i, 1]);
          <font color="blue">end if</font>;
        <font color="blue">end for</font>;

        k_total := zp.k/<font color="red">product</font>(k);

        ss.A := <font color="red">zeros</font>(nx, nx);
        ss.B := <font color="red">zeros</font>(nx, 1);
        ss.C := <font color="red">zeros</font>(1, nx);
        ss.D := <font color="red">zeros</font>(1, 1);

     <font color="darkgreen">// Calculation of matrices A, B, C, D</font>
     <font color="darkgreen">//first elements of A, B, C and D</font>

        <font color="blue">if </font><font color="red">max</font>(n_den2, n_num2) &gt; 0<font color="blue"> then</font>
          ili := i_d;
          A[1, :] := {0,1};
          B[1, 1] := 0;
          <font color="darkgreen">    // Construct state space systems of order 2</font>
          <font color="blue">if </font>1 &lt;= n_den2<font color="blue"> then</font>
            A[2, :] := {-den[1, 2],-den[1, 1]};
            B[2, 1] := den[1, 2];
            <font color="blue">if </font>1 &lt;= n_num2<font color="blue"> then</font>
              <font color="darkgreen">     // State space system in form (1)</font>
              C := k[1]*[num[1, 2] - den[1, 2],num[1, 1] - den[1, 1]]/den[1, 2];
              D := [k[1]];
              dZero := false;

            <font color="blue">elseif </font>1 - n_num2 + 1 &lt;= n_num1<font color="blue"> then</font>
              <font color="darkgreen">     // State space system in form (1) with 2 first order numerator polynomials</font>

              C := k[1]*[num[1, 1]*num[2, 1] - den[1, 2],num[1, 1] + num[2, 1] - den[1, 1]]/den[1, 2];
              D := [k[1]];
              dZero := false;
            <font color="blue">elseif </font>1 - n_num2 == n_num1<font color="blue"> then</font>
              <font color="darkgreen">     // State space system in form (2) with 1 first order numerator polynomial</font>

              C := k[1]*[num[1, 1],1]/den[1, 2];
              D := [0];
              dZero := dZero<font color="blue"> and </font>true;
            <font color="blue">else</font>
              <font color="darkgreen">     // State space system in form (3)</font>

              C := k[1]*[1,0]/den[1, 2];
              D := [0];
              dZero := dZero<font color="blue"> and </font>true;
            <font color="blue">end if</font>;
          <font color="blue">else</font>
            <font color="darkgreen">    // State space system in form (1) with 2 first order denominator polynomials</font>

            A[2, :] := {-(den[1, 1]*den[2, 1]),-(den[1, 1] + den[2, 1])};
            B[2, 1] := den[1, 1]*den[1, 1];

            C := k[1]*[num[1, 2] - (den[1, 1]*den[2, 1]),num[1, 1] - (den[1, 1] + den[2, 1])]/den[1, 1]
              /den[1, 1];
            D := [k[1]];
            dZero := false;
          <font color="blue">end if</font>;
          ss.A[1:2, 1:2] := A;
          ss.B[1:2, 1] := <font color="red">vector</font>(B);
          ss.C[1, 1:2] := <font color="red">vector</font>(C);
          ss.D := D;

        <font color="blue">else</font>
          ili := <font color="red">max</font>(2, i_d);
       <font color="darkgreen">// Construct state space systems of order 1</font>
          a := -den[1, 1];
          b := den[1, 1];

          <font color="blue">if </font>1 &lt;= n_num1<font color="blue"> then</font>
            <font color="darkgreen">    // State space system in form (4)</font>
            c := k[1]*(num[1, 1] - den[1, 1])/den[1, 1];
            d := k[1];
            dZero := false;
          <font color="blue">else</font>
            <font color="darkgreen">    // State space system in form (5)</font>
            c := k[1]/den[1, 1];
            d := 0;
            dZero := dZero<font color="blue"> and </font>true;
          <font color="blue">end if</font>;
          ss.A[1, 1] := a;
          ss.B[1, 1] := b;
          ss.C[1, 1] := c;
          ss.D[1, 1] := d;

        <font color="blue">end if</font>;

     <font color="darkgreen">/// for i=2 to degree(system)</font>
        A[1, :] := {0,1};
        B[1, 1] := 0;

        <font color="blue">for </font>i<font color="blue"> in </font>2:<font color="red">max</font>(n_den2, n_num2)<font color="blue"> loop</font>
             <font color="darkgreen">// Construct state space systems of order 2</font>
          <font color="blue">if </font>i &lt;= n_den2<font color="blue"> then</font>
            A[2, :] := {-den[i, 2],-den[i, 1]};
            B[2, 1] := den[i, 2];

            <font color="blue">if </font>i &lt;= n_num2<font color="blue"> then</font>
              <font color="darkgreen">     // State space system in form (1)</font>

              C := k[i]*[num[i, 2] - den[i, 2],num[i, 1] - den[i, 1]]/den[i, 2];
              D := [k[i]];
              dZero := false;

            <font color="blue">elseif </font>i - n_num2 + 1 &lt;= n_num1<font color="blue"> then</font>
              <font color="darkgreen">     // State space system in form (1) with 2 first order numerator polynomials</font>
              C := k[i]*[num[i, 1]*num[i + 1, 1] - den[i, 2],num[i, 1] + num[i + 1, 1] - den[i, 1]]/den[
                i, 2];
              D := [k[i]];
              dZero := false;

            <font color="blue">elseif </font>i - n_num2 == n_num1<font color="blue"> then</font>
              <font color="darkgreen">     // State space system in form (2) with 1 first order numerator polynomial</font>
              C := k[i]*[num[i, 1],1]/den[i, 2];
              D := [0];
              dZero := dZero<font color="blue"> and </font>true;

            <font color="blue">else</font>
              <font color="darkgreen">     // State space system in form (3)</font>
              C := k[i]*[1,0]/den[i, 2];
              D := [0];
              dZero := dZero<font color="blue"> and </font>true;

            <font color="blue">end if</font>;

          <font color="blue">else</font>
            <font color="darkgreen">    // State space system in form (1) with 2 first order denominator polynomials</font>
            A[2, :] := {-(den[i, 1]*den[i + 1, 1]),-(den[i, 1] + den[i + 1, 1])};
            B[2, 1] := den[i, 1]*den[i, 1];

            C := k[i]*[num[i, 2] - (den[i, 1]*den[i + 1, 1]),num[i, 1] - (den[i, 1] + den[i + 1, 1])]/
              den[i, 1]/den[i, 1];
            D := [k[i]];
            dZero := false;
          <font color="blue">end if</font>;

          ss.A[2*i, 1:2*i - 2] := B[2, 1]*ss.C[1, 1:2*i - 2];
          ss.A[2*i - 1:2*i, 2*i - 1:2*i] := A;
          ss.B[2*i, 1] := <font color="blue">if </font>dZero<font color="blue"> then </font>0<font color="blue"> else </font>B[2, 1]*ss.D[1, 1];
          ss.C[1, 1:2*i - 2] := <font color="blue">if </font>dZero<font color="blue"> then </font><font color="red">fill</font>(0, 2*i - 2)<font color="blue"> else </font>D[1, 1]*ss.C[
            1, 1:2*i - 2];
          ss.C[1, 2*i - 1:2*i] := <font color="red">vector</font>(C);
          ss.D := D*ss.D;
        <font color="blue">end for</font>;

     <font color="darkgreen">//  for i in max(2,i_d):n_den1 loop</font>

        <font color="blue">for </font>i<font color="blue"> in </font>ili:n_den1<font color="blue"> loop</font>
             <font color="darkgreen">// Construct state space systems of order 1</font>
          a := <font color="blue">if </font><font color="red">abs</font>(den[n_den2 + i, 1])&gt;Modelica.Constants.eps<font color="blue"> then </font>-den[n_den2 + i, 1]<font color="blue"> else </font>0.0;
          b := <font color="blue">if </font><font color="red">abs</font>(den[n_den2 + i, 1])&gt;Modelica.Constants.eps<font color="blue"> then </font>den[n_den2 + i, 1]<font color="blue"> else </font>1.0;
          <font color="blue">if </font>n_num2 &lt;= n_den2<font color="blue"> and </font>2*(n_den2 - n_num2) + i &lt;= n_num1<font color="blue"> then</font>
            <font color="darkgreen">    // State space system in form (4)</font>

            c := <font color="blue">if </font><font color="red">abs</font>(den[n_den2 + i, 1])&gt;Modelica.Constants.eps<font color="blue"> then </font>k[i_k + i]*(num[<font color="red">max</font>(1, n_num2 + 2*(n_den2 - n_num2) + i), 1] -  den[n_den2 + i, 1])/den[n_den2 + i, 1]<font color="blue"> else </font>1.0;

            d := k[i_k + i];

            dZero := false;
          <font color="blue">elseif </font>n_num2 &gt; n_den2<font color="blue"> and </font>i - i_d + 1 &lt;= n_num1<font color="blue"> then</font>
            <font color="darkgreen">    // State space system in form (4)</font>

            c := <font color="blue">if </font><font color="red">abs</font>(den[n_den2 + i, 1])&gt;Modelica.Constants.eps<font color="blue"> then </font>k[i_k + i]*(num[<font color="red">max</font>(1, n_num2 + i - i_d + 1), 1] - den[n_den2 + i, 1])/den[n_den2 + i, 1]<font color="blue"> else </font>1.0;
            d := k[i_k + i];
            dZero := false;
          <font color="blue">else</font>

            <font color="darkgreen">    // State space system in form (5)</font>

            c := k[i_k + i]/den[n_den2 + i, 1];
            d := 0;
            dZero := dZero<font color="blue"> and </font>true;
          <font color="blue">end if</font>;

          ss.A[2*n_den2 + i, 1:2*n_den2 + i - 1] := b*ss.C[1, 1:2*n_den2 + i - 1];
          ss.A[2*n_den2 + i, 2*n_den2 + i] := a;
          ss.B[2*n_den2 + i, 1] := <font color="blue">if </font>dZero<font color="blue"> then </font>0<font color="blue"> else </font>b*ss.D[1, 1];
          ss.C[1, 1:2*n_den2 + i - 1] := <font color="blue">if </font>dZero<font color="blue"> then </font><font color="red">fill</font>(0, 2*n_den2 + i - 1)<font color="blue"> else </font>
                  d*ss.C[1, 1:2*n_den2 + i - 1];
          ss.C[1, 2*n_den2 + i] := c;
          ss.D := <font color="blue">if </font>dZero<font color="blue"> then </font>[0]<font color="blue"> else </font>d*ss.D;

        <font color="blue">end for</font>;
        ss.C := k_total*ss.C;
        ss.D := k_total*ss.D;
      <font color="blue">else</font>
        ss := <font color="red">Modelica_LinearSystems2.StateSpace</font>(zp.k);
      <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>toStateSpace</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Conversion.toMatrices"><font color="blue">function</font> toMatrices <font color="darkgreen">
      &quot;Convert a ZerosAndPoles object into the matrices A, B, C of a StateSpace&quot;</font>
     <font color="darkgreen">//encapsulated function fromZerosAndPoles</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Vectors.html#Modelica_LinearSystems2.Math.Vectors"
>Modelica_LinearSystems2.Math.Vectors</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp <font color="darkgreen">&quot;ZerosAndPoles transfer function of a system&quot;</font>;
      <font color="blue">output </font>Real ABCD[<font color="red">ZerosAndPoles.Analysis.denominatorDegree</font>(zp)+1,
          <font color="red">ZerosAndPoles.Analysis.denominatorDegree</font>(zp)+1];

    <font color="blue">protected </font>
      Real ssA[<font color="red">ZerosAndPoles.Analysis.denominatorDegree</font>(zp),<font color="red">ZerosAndPoles.Analysis.denominatorDegree</font>(zp)] <font color="darkgreen">
        &quot;system matrix of partial 2nd order system&quot;</font>;
      Real ssB[<font color="red">ZerosAndPoles.Analysis.denominatorDegree</font>(zp),1] <font color="darkgreen">
        &quot;input matrix of partial 2nd order system&quot;</font>;
      Real ssC[1,<font color="red">ZerosAndPoles.Analysis.denominatorDegree</font>(zp)] <font color="darkgreen">
        &quot;output matrix of partial 2nd order system&quot;</font>;
      Real ssD[1,1] <font color="darkgreen">&quot;feedthrough matrix of partial 2nd order system&quot;</font>;

      Real A[2,2] <font color="darkgreen">&quot;system matrix of partial 2nd order system&quot;</font>;
      Real B[2,1] <font color="darkgreen">&quot;input matrix of partial 2nd order system&quot;</font>;
      Real C[1,2] <font color="darkgreen">&quot;output matrix of partial 2nd order system&quot;</font>;
      Real D[1,1] <font color="darkgreen">&quot;feedthrough matrix of partial 2nd order system&quot;</font>;
      Real a <font color="darkgreen">&quot;system &#39;matrix&#39; of partial 1st order system&quot;</font>;
      Real b <font color="darkgreen">&quot;input &#39;matrix&#39; of partial 1st order system&quot;</font>;
      Real c <font color="darkgreen">&quot;output &#39;matrix&#39; of partial 1st order system&quot;</font>;
      Real d <font color="darkgreen">&quot;feedthrough &#39;matrix&#39; of partial 1st order system&quot;</font>;
      Integer nx=<font color="red">ZerosAndPoles.Analysis.denominatorDegree</font>(zp);
      Integer n_num1=<font color="red">size</font>(zp.n1, 1);
      Integer n_num2=<font color="red">size</font>(zp.n2, 1);
      Integer n_den1=<font color="red">size</font>(zp.d1, 1);
      Integer n_den2=<font color="red">size</font>(zp.d2, 1);
      Integer n_num=n_num1 + 2*n_num2;
      Integer n_den=n_den1 + 2*n_den2;

      Integer i_d=<font color="blue">if </font>n_num2 &gt; n_den2<font color="blue"> then </font>2*(n_num2 - n_den2) + 1<font color="blue"> else </font>1;
      Integer i_k=<font color="blue">if </font>n_num2 &gt; n_den2<font color="blue"> then </font>n_den2 - (n_num2 - n_den2)<font color="blue"> else </font>n_den2;
      Integer i;
      Integer ili;
      Real num[nx,2]=[zp.n2; [zp.n1,<font color="red">zeros</font>(n_num1)]; <font color="red">zeros</font>(nx - n_num2 - n_num1, 2)] <font color="darkgreen">
        &quot;Numerator matrix, in order that indices are defined in all situations in all if clauses&quot;</font>;
      Real den[nx,2]=[zp.d2; [zp.d1,<font color="red">zeros</font>(n_den1)]; <font color="red">zeros</font>(nx - n_den2 - n_den1, 2)] <font color="darkgreen">
        &quot;Denominator matrix, in order that indices are defined in all situations in all if clauses&quot;</font>;
      Real k[i_k + n_den1](<font color="blue">each </font>fixed=false) <font color="darkgreen">
        &quot;Additional factors of the first and second order blocks, in order that the gain of the blocks is 1&quot;</font>;
      Real k_total;

      Boolean dZero=true;

     <font color="darkgreen">//ZerosAndPoles zp2;</font>

    <font color="blue">algorithm </font>
      <font color="red">assert</font>(n_num &lt;= n_den,
        &quot;ZerosAndPoles transfer function is not proper as required from StateSpace system:\n&quot;
         + &quot;  numerator degree (= &quot; + <font color="red">String</font>(n_num) +
        &quot;) &lt;= denominator degree (= &quot; + <font color="red">String</font>(n_den) + &quot;) required.&quot;);

      <font color="blue">if </font>n_den &gt; 0<font color="blue"> then</font>

        <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">max</font>(n_den2, n_num2)<font color="blue"> loop</font>
          <font color="darkgreen">// State space systems of order 2</font>
          <font color="blue">if </font>i &lt;= n_den2<font color="blue"> then</font>
            <font color="blue">if </font>i &lt;= n_num2<font color="blue"> then</font>
                <font color="darkgreen">// State space system in form (1)</font>
              k[i] := <font color="red">Internal.scaleFactor2</font>(
                  num[i, 1],
                  num[i, 2],
                  den[i, 1],
                  den[i, 2]);
            <font color="blue">elseif </font>i - n_num2 + 1 &lt;= n_num1<font color="blue"> then</font>
                <font color="darkgreen">// State space system in form (1) with 2 first order numerator polynomials</font>
              k[i] := <font color="red">Internal.scaleFactor2</font>(
                  num[i, 1] + num[i + 1, 1],
                  num[i, 1]*num[i + 1, 1],
                  den[i, 1],
                  den[i, 2]);
            <font color="blue">elseif </font>i - n_num2 == n_num1<font color="blue"> then</font>
                <font color="darkgreen">// State space system in form (2) with 1 first order numerator polynomial</font>
              k[i] := <font color="red">Internal.scaleFactor2</font>(
                  0,
                  num[i, 1],
                  den[i, 1],
                  den[i, 2]);
            <font color="blue">else</font>
                <font color="darkgreen">// State space system in form (3)</font>
              k[i] := <font color="red">Internal.scaleFactor2</font>(
                  0,
                  0,
                  den[i, 1],
                  den[i, 2]);
            <font color="blue">end if</font>;
          <font color="blue">else</font>
             <font color="darkgreen">// State space system in form (1) with 2 first order denominator polynomials</font>
            k[i] := <font color="red">Internal.scaleFactor2</font>(
                num[i, 1],
                num[i, 2],
                den[i, 1] + den[i + 1, 1],
                den[i, 1]*den[i + 1, 1]);
          <font color="blue">end if</font>;
        <font color="blue">end for</font>;

        <font color="blue">for </font>i<font color="blue"> in </font>i_d:n_den1<font color="blue"> loop</font>
          <font color="darkgreen">// State space systems of order 1</font>
          <font color="blue">if </font>n_num2 &lt;= n_den2<font color="blue"> and </font>2*(n_den2 - n_num2) + i &lt;= n_num1<font color="blue"> then</font>
             <font color="darkgreen">// State space system in form (4)</font>
            k[i_k + i] := <font color="red">Internal.scaleFactor1</font>(num[<font color="red">max</font>(1, n_num2 + 2*(n_den2 -
              n_num2) + i), 1], den[n_den2 + i, 1]);
          <font color="blue">elseif </font>n_num2 &gt; n_den2<font color="blue"> and </font>i - i_d + 1 &lt;= n_num1<font color="blue"> then</font>
             <font color="darkgreen">// State space system in form (4)</font>
            k[i_k + i] := <font color="red">Internal.scaleFactor1</font>(num[<font color="red">max</font>(1, n_num2 + i - i_d + 1),
              1], den[n_den2 + i, 1]);
          <font color="blue">else</font>
             <font color="darkgreen">// State space system in form (5)</font>
            k[i_k + i] := <font color="red">Internal.scaleFactor1</font>(0, den[n_den2 + i, 1]);
          <font color="blue">end if</font>;
        <font color="blue">end for</font>;

        k_total := zp.k/<font color="red">product</font>(k);

        ssA := <font color="red">zeros</font>(nx, nx);
        ssB := <font color="red">zeros</font>(nx, 1);
        ssC := <font color="red">zeros</font>(1, nx);
        ssD := <font color="red">zeros</font>(1, 1);

     <font color="darkgreen">// Calculation of matrices A, B, C, D</font>
     <font color="darkgreen">//first elements of A, B, C and D</font>

        <font color="blue">if </font><font color="red">max</font>(n_den2, n_num2) &gt; 0<font color="blue"> then</font>
          ili := i_d;
          A[1, :] := {0,1};
          B[1, 1] := 0;
          <font color="darkgreen">    // Construct state space systems of order 2</font>
          <font color="blue">if </font>1 &lt;= n_den2<font color="blue"> then</font>
            A[2, :] := {-den[1, 2],-den[1, 1]};
            B[2, 1] := den[1, 2];
            <font color="blue">if </font>1 &lt;= n_num2<font color="blue"> then</font>
              <font color="darkgreen">     // State space system in form (1)</font>
              C := k[1]*[num[1, 2] - den[1, 2],num[1, 1] - den[1, 1]]/den[1, 2];
              D := [k[1]];
              dZero := false;

            <font color="blue">elseif </font>1 - n_num2 + 1 &lt;= n_num1<font color="blue"> then</font>
              <font color="darkgreen">     // State space system in form (1) with 2 first order numerator polynomials</font>

              C := k[1]*[num[1, 1]*num[2, 1] - den[1, 2],num[1, 1] + num[2, 1] - den[1, 1]]/den[1, 2];
              D := [k[1]];
              dZero := false;
            <font color="blue">elseif </font>1 - n_num2 == n_num1<font color="blue"> then</font>
              <font color="darkgreen">     // State space system in form (2) with 1 first order numerator polynomial</font>

              C := k[1]*[num[1, 1],1]/den[1, 2];
              D := [0];
              dZero := dZero<font color="blue"> and </font>true;
            <font color="blue">else</font>
              <font color="darkgreen">     // State space system in form (3)</font>

              C := k[1]*[1,0]/den[1, 2];
              D := [0];
              dZero := dZero<font color="blue"> and </font>true;
            <font color="blue">end if</font>;
          <font color="blue">else</font>
            <font color="darkgreen">    // State space system in form (1) with 2 first order denominator polynomials</font>

            A[2, :] := {-(den[1, 1]*den[2, 1]),-(den[1, 1] + den[2, 1])};
            B[2, 1] := den[1, 1]*den[1, 1];

            C := k[1]*[num[1, 2] - (den[1, 1]*den[2, 1]),num[1, 1] - (den[1, 1] + den[2, 1])]/den[1, 1]
              /den[1, 1];
            D := [k[1]];
            dZero := false;
          <font color="blue">end if</font>;
          ssA[1:2, 1:2] := A;
          ssB[1:2, 1] := <font color="red">vector</font>(B);
          ssC[1, 1:2] := <font color="red">vector</font>(C);
          ssD := D;

        <font color="blue">else</font>
          ili := <font color="red">max</font>(2, i_d);
       <font color="darkgreen">// Construct state space systems of order 1</font>
          a := -den[1, 1];
          b := den[1, 1];

          <font color="blue">if </font>1 &lt;= n_num1<font color="blue"> then</font>
            <font color="darkgreen">    // State space system in form (4)</font>
            c := k[1]*(num[1, 1] - den[1, 1])/den[1, 1];
            d := k[1];
            dZero := false;
          <font color="blue">else</font>
            <font color="darkgreen">    // State space system in form (5)</font>
            c := k[1]/den[1, 1];
            d := 0;
            dZero := dZero<font color="blue"> and </font>true;
          <font color="blue">end if</font>;
          ssA[1, 1] := a;
          ssB[1, 1] := b;
          ssC[1, 1] := c;
          ssD[1, 1] := d;

        <font color="blue">end if</font>;

     <font color="darkgreen">/// for i=2 to degree(system)</font>
        A[1, :] := {0,1};
        B[1, 1] := 0;

        <font color="blue">for </font>i<font color="blue"> in </font>2:<font color="red">max</font>(n_den2, n_num2)<font color="blue"> loop</font>
             <font color="darkgreen">// Construct state space systems of order 2</font>
          <font color="blue">if </font>i &lt;= n_den2<font color="blue"> then</font>
            A[2, :] := {-den[i, 2],-den[i, 1]};
            B[2, 1] := den[i, 2];

            <font color="blue">if </font>i &lt;= n_num2<font color="blue"> then</font>
              <font color="darkgreen">     // State space system in form (1)</font>

              C := k[i]*[num[i, 2] - den[i, 2],num[i, 1] - den[i, 1]]/den[i, 2];
              D := [k[i]];
              dZero := false;

            <font color="blue">elseif </font>i - n_num2 + 1 &lt;= n_num1<font color="blue"> then</font>
              <font color="darkgreen">     // State space system in form (1) with 2 first order numerator polynomials</font>
              C := k[i]*[num[i, 1]*num[i + 1, 1] - den[i, 2],num[i, 1] + num[i + 1, 1] - den[i, 1]]/den[
                i, 2];
              D := [k[i]];
              dZero := false;

            <font color="blue">elseif </font>i - n_num2 == n_num1<font color="blue"> then</font>
              <font color="darkgreen">     // State space system in form (2) with 1 first order numerator polynomial</font>
              C := k[i]*[num[i, 1],1]/den[i, 2];
              D := [0];
              dZero := dZero<font color="blue"> and </font>true;

            <font color="blue">else</font>
              <font color="darkgreen">     // State space system in form (3)</font>
              C := k[i]*[1,0]/den[i, 2];
              D := [0];
              dZero := dZero<font color="blue"> and </font>true;

            <font color="blue">end if</font>;

          <font color="blue">else</font>
            <font color="darkgreen">    // State space system in form (1) with 2 first order denominator polynomials</font>
            A[2, :] := {-(den[i, 1]*den[i + 1, 1]),-(den[i, 1] + den[i + 1, 1])};
            B[2, 1] := den[i, 1]*den[i, 1];

            C := k[i]*[num[i, 2] - (den[i, 1]*den[i + 1, 1]),num[i, 1] - (den[i, 1] + den[i + 1, 1])]/
              den[i, 1]/den[i, 1];
            D := [k[i]];
            dZero := false;
          <font color="blue">end if</font>;

          ssA[2*i, 1:2*i - 2] := B[2, 1]*ssC[1, 1:2*i - 2];
          ssA[2*i - 1:2*i, 2*i - 1:2*i] := A;
          ssB[2*i, 1] := <font color="blue">if </font>dZero<font color="blue"> then </font>0<font color="blue"> else </font>B[2, 1]*ssD[1, 1];
          ssC[1, 1:2*i - 2] := <font color="blue">if </font>dZero<font color="blue"> then </font><font color="red">fill</font>(0, 2*i - 2)<font color="blue"> else </font>D[1, 1]*ssC[
            1, 1:2*i - 2];
          ssC[1, 2*i - 1:2*i] := <font color="red">vector</font>(C);
          ssD := D*ssD;
        <font color="blue">end for</font>;

     <font color="darkgreen">//  for i in max(2,i_d):n_den1 loop</font>

        <font color="blue">for </font>i<font color="blue"> in </font>ili:n_den1<font color="blue"> loop</font>
             <font color="darkgreen">// Construct state space systems of order 1</font>
          a := <font color="blue">if </font><font color="red">abs</font>(den[n_den2 + i, 1])&gt;Modelica.Constants.eps<font color="blue"> then </font>-den[n_den2 + i, 1]<font color="blue"> else </font>0.0;
          b := <font color="blue">if </font><font color="red">abs</font>(den[n_den2 + i, 1])&gt;Modelica.Constants.eps<font color="blue"> then </font>den[n_den2 + i, 1]<font color="blue"> else </font>1.0;
          <font color="blue">if </font>n_num2 &lt;= n_den2<font color="blue"> and </font>2*(n_den2 - n_num2) + i &lt;= n_num1<font color="blue"> then</font>
            <font color="darkgreen">    // State space system in form (4)</font>

            c := <font color="blue">if </font><font color="red">abs</font>(den[n_den2 + i, 1])&gt;Modelica.Constants.eps<font color="blue"> then </font>k[i_k + i]*(num[<font color="red">max</font>(1, n_num2 + 2*(n_den2 - n_num2) + i), 1] -  den[n_den2 + i, 1])/den[n_den2 + i, 1]<font color="blue"> else </font>1.0;

            d := k[i_k + i];

            dZero := false;
          <font color="blue">elseif </font>n_num2 &gt; n_den2<font color="blue"> and </font>i - i_d + 1 &lt;= n_num1<font color="blue"> then</font>
            <font color="darkgreen">    // State space system in form (4)</font>

            c := <font color="blue">if </font><font color="red">abs</font>(den[n_den2 + i, 1])&gt;Modelica.Constants.eps<font color="blue"> then </font>k[i_k + i]*(num[<font color="red">max</font>(1, n_num2 + i - i_d + 1), 1] - den[n_den2 + i, 1])/den[n_den2 + i, 1]<font color="blue"> else </font>1.0;
            d := k[i_k + i];
            dZero := false;
          <font color="blue">else</font>

            <font color="darkgreen">    // State space system in form (5)</font>

            c := k[i_k + i]/den[n_den2 + i, 1];
            d := 0;
            dZero := dZero<font color="blue"> and </font>true;
          <font color="blue">end if</font>;

          ssA[2*n_den2 + i, 1:2*n_den2 + i - 1] := b*ssC[1, 1:2*n_den2 + i - 1];
          ssA[2*n_den2 + i, 2*n_den2 + i] := a;
          ssB[2*n_den2 + i, 1] := <font color="blue">if </font>dZero<font color="blue"> then </font>0<font color="blue"> else </font>b*ssD[1, 1];
          ssC[1, 1:2*n_den2 + i - 1] := <font color="blue">if </font>dZero<font color="blue"> then </font><font color="red">fill</font>(0, 2*n_den2 + i - 1)<font color="blue"> else </font>
                  d*ssC[1, 1:2*n_den2 + i - 1];
          ssC[1, 2*n_den2 + i] := c;
          ssD := <font color="blue">if </font>dZero<font color="blue"> then </font>[0]<font color="blue"> else </font>d*ssD;

        <font color="blue">end for</font>;
        ssC := k_total*ssC;
        ssD := k_total*ssD;
      <font color="blue">else</font>
        ABCD := [zp.k];
      <font color="blue">end if</font>;

      ABCD := [ssA,ssB; ssC,ssD];

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>toMatrices</textblock>;
  <font color="blue">end </font>Conversion</textblock>;

  <textblock type="packagesmall" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Import"><font color="blue">encapsulated </font><font color="blue">package</font> Import

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Import.fromModel"><font color="blue">function</font> fromModel <font color="darkgreen">
      &quot;Generate a ZerosAndPoles record array from a state space representation resulted from linearization of a model&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;

      <font color="blue">input </font>String modelName <font color="darkgreen">&quot;Name of the Modelica model&quot;</font>;
      <font color="blue">input </font>Real T_linearize=0 <font color="darkgreen">
        &quot;point in time of simulation to linearize the model&quot;</font>;
      <font color="blue">input </font>String fileName=&quot;dslin&quot; <font color="darkgreen">&quot;Name of the result file&quot;</font>;

    <font color="blue">protected </font>
      String fileName2=fileName + &quot;.mat&quot;;
      Boolean OK1=<font color="red">simulateModel</font>(
            problem=modelName,
            startTime=0,
            stopTime=T_linearize);
      Boolean OK2=<font color="red">importInitial</font>(&quot;dsfinal.txt&quot;);
      Boolean OK3=<font color="red">linearizeModel</font>(
            problem=modelName,
            resultFile=fileName,
            startTime=T_linearize,
            stopTime=T_linearize + 1);
      Real nxMat[1,1]=<font color="red">readMatrix</font>(
            fileName2,
            &quot;nx&quot;,
            1,
            1);
      Integer ABCDsizes[2]=<font color="red">readMatrixSize</font>(fileName2, &quot;ABCD&quot;);
      Integer nx=<font color="red">integer</font>(nxMat[1, 1]);
      Integer nu=ABCDsizes[2] - nx;
      Integer ny=ABCDsizes[1] - nx;
      Real ABCD[nx + ny,nx + nu]=<font color="red">readMatrix</font>(
            fileName2,
            &quot;ABCD&quot;,
            nx + ny,
            nx + nu);
      String xuyName[nx + nu + ny]=<font color="red">readStringMatrix</font>(
            fileName2,
            &quot;xuyName&quot;,
            nx + nu + ny);

      <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> result(
        <font color="blue">redeclare </font>Real A[nx,nx],
        <font color="blue">redeclare </font>Real B[nx,nu],
        <font color="blue">redeclare </font>Real C[ny,nx],
        <font color="blue">redeclare </font>Real D[ny,nu]) <font color="darkgreen">&quot;= model linearized at initial point&quot;</font>;
    <font color="blue">public </font>
      <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp[:,:];
  <font color="blue">algorithm </font>
      result.A := ABCD[1:nx, 1:nx];
      result.B := ABCD[1:nx, nx + 1:nx + nu];
      result.C := ABCD[nx + 1:nx + ny, 1:nx];
      result.D := ABCD[nx + 1:nx + ny, nx + 1:nx + nu];
      result.uNames := xuyName[nx + 1:nx + nu];
      result.yNames := xuyName[nx + nu + 1:nx + nu + ny];
      result.xNames := xuyName[1:nx];

      zp := <font color="red">StateSpace.Conversion.toZerosAndPolesMIMO</font>(result);

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>fromModel</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Import.fromFile"><font color="blue">encapsulated </font><font color="blue">function</font> fromFile <font color="darkgreen">
      &quot;Generate a ZerosAndPoles record by reading the polynomial coefficients or zeros and poles from a file&quot;</font>
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font>Modelica_LinearSystems2.DataDir;

      <font color="blue">input </font>String fileName=DataDir + &quot;/zp.mat&quot; <font color="darkgreen">
        &quot;Name of the zeros and poles data file&quot;</font>;

    <font color="blue">protected </font>
      <font color="blue">input </font>Integer n1n2d1d2[4]=<font color="blue">if </font><font color="red">ZerosAndPoles.Internal.checkRepresentation</font>(
          fileName)<font color="blue"> then </font><font color="red">ZerosAndPoles.Internal.numberOfRealZerosAndPoles_zp</font>(
          fileName)<font color="blue"> else </font><font color="red">ZerosAndPoles.Internal.numberOfRealZerosAndPoles_pc</font>(
          fileName);
      <font color="blue">input </font>Integer n1=n1n2d1d2[1];
      <font color="blue">input </font>Integer n2=n1n2d1d2[2];
      <font color="blue">input </font>Integer d1=n1n2d1d2[3];
      <font color="blue">input </font>Integer d2=n1n2d1d2[4];
      <font color="blue">input </font>Integer zSize=n1n2d1d2[1] + 2*n1n2d1d2[2];
      <font color="blue">input </font>Integer pSize=n1n2d1d2[3] + 2*n1n2d1d2[4];
    <font color="blue">public </font>
      <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp(
        n1=<font color="red">fill</font>(0, n1),
        n2=<font color="red">fill</font>(
              0,
              n2,
              2),
        d1=<font color="red">fill</font>(0, d1),
        d2=<font color="red">fill</font>(
              0,
              d2,
              2));
    <font color="blue">algorithm </font>
    <font color="darkgreen">//Whenever this function becomes operational the code must be rewritten if fromFile_pc2 and fromFile_zp2 are in the &#39;constructor&#39;</font>

      zp := <font color="blue">if </font><font color="red">ZerosAndPoles.Internal.checkRepresentation</font>(fileName)<font color="blue"> then </font><font color="red">ZerosAndPoles.Internal.fromFile_zp</font>( fileName)<font color="blue"> else </font><font color="red">ZerosAndPoles.Internal.fromFile_pc</font>(
        fileName);

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>fromFile</textblock>;

  <font color="blue">end </font>Import</textblock>;

  <textblock type="packagesmall" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Internal"><font color="blue">encapsulated </font><font color="blue">package</font> Internal <font color="darkgreen">
    &quot;Internal library of record Filter (should not be directly used by user)&quot;</font>

    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
    <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons_Library.html#Modelica.Icons.Library"
>Modelica.Icons.Library</A>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Internal.ZerosAndPoles"><font color="blue">record</font> ZerosAndPoles <font color="darkgreen">
      &quot;Continuous zeros and poles description of a single input, single output system (data + operations)&quot;</font>
    <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Record"
>Modelica.Icons.Record</A>;

    Real k=1.0 <font color="darkgreen">&quot;Multiplicative factor of transfer function&quot;</font>;
    Real n1[:] <font color="darkgreen">&quot;[p^0] coefficients of 1st order numerator polynomials&quot;</font>;
    Real n2[:,2] <font color="darkgreen">&quot;[p,p^0] coefficients of 2nd order numerator polynomials&quot;</font>;
    Real d1[:] <font color="darkgreen">&quot;[p^0] coefficients of 1st order denominator polynomials&quot;</font>;
    Real d2[:,2] <font color="darkgreen">&quot;[p,p^0] coefficients of 2nd order denominator polynomials&quot;</font>;

  <font color="blue">end </font>ZerosAndPoles</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Internal.filter"><font color="blue">encapsulated </font><font color="blue">function</font> filter <font color="darkgreen">
      &quot;Generate the data record of a ZerosAndPoles transfer function from a filter description&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams"
>Modelica.Utilities.Streams</A>;
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams.print"
>Modelica.Utilities.Streams.print</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types"
>Modelica_LinearSystems2.Types</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal"
>Modelica_LinearSystems2.ZerosAndPoles.Internal</A>;
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Math.html#Modelica.Math"
>Modelica.Math</A>.*;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math"
>Modelica_LinearSystems2.Math</A>.*;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.AnalogFilter"
>Modelica_LinearSystems2.Types.AnalogFilter</A> analogFilter=Types.AnalogFilter.CriticalDamping <font color="darkgreen">
        &quot;Analog filter characteristics (CriticalDamping/Bessel/Butterworth/Chebyshev)&quot;</font>;
    <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.FilterType"
>Modelica_LinearSystems2.Types.FilterType</A> filterType=Types.FilterType.LowPass <font color="darkgreen">
        &quot;Type of filter (LowPass/HighPass)&quot;</font>;
    <font color="blue">input </font>Integer order(min=1) = 2 <font color="darkgreen">&quot;Order of filter&quot;</font>;
    <font color="blue">input </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Modelica.SIunits.Frequency</A> f_cut=1/(2*Modelica.Constants.pi) <font color="darkgreen">
        &quot;Cut-off frequency (default is w_cut = 1 rad/s)&quot;</font>;
    <font color="blue">input </font>Real gain=1.0 <font color="darkgreen">
        &quot;Gain (= amplitude of frequency response at zero frequency)&quot;</font>;
    <font color="blue">input </font>Real A_ripple(unit=&quot;dB&quot;) = 0.5 <font color="darkgreen">
        &quot;Pass band ripple for Chebyshev filter (otherwise not used)&quot;</font>;
    <font color="blue">input </font>Boolean normalized=true <font color="darkgreen">
        &quot;= true, if amplitude of low pass filter at f_cut where the magnitude of the filter sagged for 3dB, otherwise unmodified filter&quot;</font>;
    <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal.ZerosAndPoles"
>Internal.ZerosAndPoles</A> filter(
      <font color="blue">redeclare </font>Real n1[<font color="blue">if </font>filterType == Types.FilterType.LowPass<font color="blue"> then </font>0<font color="blue"> else </font>(
        <font color="blue">if </font>analogFilter == Types.AnalogFilter.CriticalDamping<font color="blue"> then </font>order<font color="blue"> else </font>
        <font color="red">mod</font>(order, 2))],
      <font color="blue">redeclare </font>Real n2[<font color="blue">if </font>filterType == Types.FilterType.LowPass<font color="blue"> then </font>0<font color="blue"> else </font>(
        <font color="blue">if </font>analogFilter == Types.AnalogFilter.CriticalDamping<font color="blue"> then </font>0<font color="blue"> else </font>
        <font color="red">integer</font>((order + 1)/2)),2],
      <font color="blue">redeclare </font>Real d1[<font color="blue">if </font>analogFilter == Types.AnalogFilter.CriticalDamping<font color="blue"> then </font>
              order<font color="blue"> else </font><font color="red">mod</font>(order, 2)],
      <font color="blue">redeclare </font>Real d2[<font color="blue">if </font>analogFilter == Types.AnalogFilter.CriticalDamping<font color="blue"> then </font>
              0<font color="blue"> else </font><font color="red">integer</font>(order/2),2]) <font color="darkgreen">&quot;Filter transfer function&quot;</font>;

    <font color="blue">protected </font>
    Integer n_num1=<font color="red">size</font>(filter.n1, 1);
    Integer n_num2=<font color="red">size</font>(filter.n2, 1);
    Integer n_den1=<font color="red">size</font>(filter.d1, 1);
    Integer n_den2=<font color="red">size</font>(filter.d2, 1);
    Integer n_num=n_num1 + 2*n_num2;
    Integer n_den=n_den1 + 2*n_den2;
    Real pi=Modelica.Constants.pi;
    Boolean evenOrder=<font color="red">mod</font>(order, 2) == 0 <font color="darkgreen">
        &quot;= true, if even filter order (otherwise uneven)&quot;</font>;
    <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>Modelica.SIunits.AngularVelocity</A> w_cut=2*pi*f_cut <font color="darkgreen">
        &quot;Cut-off angular frequency&quot;</font>;
    Real w_cut2 <font color="darkgreen">&quot;= w_cut*w_cut&quot;</font>;
    Real alpha=1.0 <font color="darkgreen">&quot;Frequency correction factor&quot;</font>;
    Real alpha2 <font color="darkgreen">&quot;= alpha*alpha&quot;</font>;

    Real alphax;

    Real poleReal <font color="darkgreen">&quot;Real part of pole&quot;</font>;
    Real poleImag <font color="darkgreen">&quot;Imaginary part of pole&quot;</font>;
    Real epsilon <font color="darkgreen">&quot;Ripple size&quot;</font>;
    Real fac <font color="darkgreen">&quot;arsinh(epsilon)&quot;</font>;
    Real A2 <font color="darkgreen">&quot;poleReal^2 + poleImag^2&quot;</font>;
    Real A <font color="darkgreen">&quot;Amplitude at w_cut&quot;</font>;
    Real num1[n_num1] <font color="darkgreen">
        &quot;[p] coefficients of numerator first order polynomials (a*p + 1)&quot;</font>;
    Real num2[n_num2,2] <font color="darkgreen">
        &quot;[p^2, p] coefficients of numerator second order polynomials (b*p^2 + a*p + 1I)&quot;</font>;
    Real den1[n_den1] <font color="darkgreen">
        &quot;[p] coefficients of denominator first order polynomials (a*p + 1)&quot;</font>;
    Real den2[n_den2,2] <font color="darkgreen">
        &quot;[p^2, p] coefficients of denominator second order polynomials (b*p^2 + a*p + 1I)&quot;</font>;
    Real aux;
    Real k;
  <font color="blue">algorithm </font>
    <font color="darkgreen">// Set properties that are common for all filters</font>
    filter.k := gain;

    <font color="darkgreen">/* Compute filter coefficients of prototype low pass filter. If another filter
     characteristics is desired (e.g. high pass filter), it is derived
     from the low pass filter coefficients below
  */</font>
    <font color="blue">if </font>analogFilter == Types.AnalogFilter.CriticalDamping<font color="blue"> then</font>
      <font color="blue">if </font>normalized<font color="blue"> then</font>
        alpha := <font color="red">sqrt</font>(2^(1/order) - 1);
  <font color="darkgreen">//alpha := sqrt(10^(3/10/order)-1)</font>
      <font color="blue">else</font>
        alpha := 1;
      <font color="blue">end if</font>;
      <font color="blue">for </font>i<font color="blue"> in </font>1:n_den1<font color="blue"> loop</font>
        den1[i] := alpha;
      <font color="blue">end for</font>;

    <font color="blue">elseif </font>analogFilter == Types.AnalogFilter.Bessel<font color="blue"> then</font>
      (den1,den2,alpha) := <font color="red">Internal.BesselCoefficients</font>(order);
      <font color="blue">if </font><font color="blue">not </font>normalized<font color="blue"> then</font>
        alpha2 := alpha*alpha;
        <font color="blue">for </font>i<font color="blue"> in </font>1:n_den2<font color="blue"> loop</font>
          den2[i, 1] := den2[i, 1]*alpha2;
          den2[i, 2] := den2[i, 2]*alpha;
        <font color="blue">end for</font>;
        <font color="blue">if </font><font color="blue">not </font>evenOrder<font color="blue"> then</font>
          den1[1] := den1[1]*alpha;
        <font color="blue">end if</font>;
      <font color="blue">end if</font>;

    <font color="blue">elseif </font>analogFilter == Types.AnalogFilter.Butterworth<font color="blue"> then</font>
       <font color="darkgreen">// Original filter is already normalized</font>
      <font color="blue">for </font>i<font color="blue"> in </font>1:n_den2<font color="blue"> loop</font>
        den2[i, 1] := 1.0;
        den2[i, 2] := -2*<font color="red">cos</font>(pi*(0.5 + (i - 0.5)/order));
      <font color="blue">end for</font>;
      <font color="blue">if </font><font color="blue">not </font>evenOrder<font color="blue"> then</font>
        den1[1] := 1.0;
      <font color="blue">end if</font>;

    <font color="blue">elseif </font>analogFilter == Types.AnalogFilter.Chebyshev<font color="blue"> then</font>
      epsilon := <font color="red">sqrt</font>(10^(A_ripple/10) - 1);
      fac := <font color="red">asinh</font>(1/epsilon)/order;

      <font color="blue">for </font>i<font color="blue"> in </font>1:n_den2<font color="blue"> loop</font>
         <font color="darkgreen">// poles of prototype lowpass</font>
        poleReal := <font color="red">cos</font>(pi/2 + pi*(2*i - 1)/(2*order))*<font color="red">sinh</font>(fac);
        poleImag := -<font color="red">sin</font>(pi/2 + pi*(2*i - 1)/(2*order))*<font color="red">cosh</font>(fac);

         <font color="darkgreen">// second order filter coefficients</font>
        A2 := poleReal^2 + poleImag^2;
        den2[i, 1] := 1/A2;
        den2[i, 2] := -2*poleReal/A2;
      <font color="blue">end for</font>;
      <font color="blue">if </font><font color="blue">not </font>evenOrder<font color="blue"> then</font>
        den1[1] := -1.0/(<font color="red">cos</font>(pi/2 + pi*(2*n_den - 1)/(2*order))*<font color="red">sinh</font>(fac));
      <font color="blue">end if</font>;

       <font color="darkgreen">/* Transformation of filter transfer function with &quot;new(p) = alpha*p&quot;
        in order that the filter transfer function has an amplitude of
        1/sqrt(2) at the cutoff frequency
     */</font>
      <font color="blue">if </font>normalized<font color="blue"> then</font>
        alpha := <font color="red">Internal.normalizationFactor</font>(den1, den2);
        alpha2 := alpha*alpha;
        <font color="blue">for </font>i<font color="blue"> in </font>1:n_den2<font color="blue"> loop</font>
          den2[i, 1] := den2[i, 1]*alpha2;
          den2[i, 2] := den2[i, 2]*alpha;
        <font color="blue">end for</font>;
        <font color="blue">if </font><font color="blue">not </font>evenOrder<font color="blue"> then</font>
          den1[1] := den1[1]*alpha;
        <font color="blue">end if</font>;
      <font color="blue">end if</font>;

    <font color="blue">else</font>
      <font color="red">Streams.error</font>(&quot;analogFilter (= &quot; + <font color="red">String</font>(analogFilter) +
        &quot;) is not supported&quot;);
    <font color="blue">end if</font>;

    <font color="darkgreen">// Compute amplitude at w=1</font>
  <font color="darkgreen">/*
  A := 1.0;
  for i in 1:n_den2 loop
     A := A*(1 + den2[i,2]^2 - 2*den2[i,1]
               + den2[i,1]^2);
  end for;
  for i in 1:n_den1 loop
     A := A*(1 + den1[i]^2);
  end for;
  A := 1/sqrt(A);
  print(&quot;A = &quot; + String(A));
*/</font>

    <font color="darkgreen">// Determine normalized denominator polynomials with highest power of p equal to one</font>
    filter.n1 := <font color="red">zeros</font>(n_num1);
    filter.n2 := <font color="red">zeros</font>(n_num2, 2);
    (filter.d1,filter.d2,k) := <font color="red">Internal.filterToNormalized</font>(den1, den2);
    filter.k := filter.k/k;

    <font color="darkgreen">// Compute desired filter characteristics from low pass filter coefficients</font>
    <font color="blue">if </font>filterType == Types.FilterType.HighPass<font color="blue"> then</font>
       <font color="darkgreen">/* The high pass filter is derived from the low pass filter by
        the transformation new(p) = 1/p
        1/(p^2 + a*p + b) -&gt; 1/((1/p)^2 + a*(1/p) + b) = (1/b)*p^2 / (p^2 + (a/b)*p + 1/b)
        1/(p + a)         -&gt; 1/((1/p) + a) = (1/a)*p / (p + (1/a))
     */</font>
      <font color="red">assert</font>(n_num1 == n_den1<font color="blue"> and </font>n_num2 == n_den2,
        &quot;Internal error 1, should not occur&quot;);
      filter.n1 := <font color="red">zeros</font>(n_num1);
      filter.n2 := <font color="red">zeros</font>(n_num2, 2);
      <font color="blue">for </font>i<font color="blue"> in </font>1:n_num1<font color="blue"> loop</font>
        filter.k := filter.k/filter.d1[i];
        filter.d1[i] := 1/filter.d1[i];
      <font color="blue">end for</font>;
      <font color="blue">for </font>i<font color="blue"> in </font>1:n_num2<font color="blue"> loop</font>
        filter.k := filter.k/filter.d2[i, 2];
        filter.d2[i, 1] := filter.d2[i, 1]/filter.d2[i, 2];
        filter.d2[i, 2] := 1/filter.d2[i, 2];
      <font color="blue">end for</font>;
    <font color="blue">end if</font>;

    <font color="darkgreen">/* Change filter coefficients according to transformation new(p) = p/w_cut
     Numerator  :     (p/w)^2 + a*(p/w) + b = (1/w^2)*(p^2 + (a*w)*p + b*w^2)
                                  (p/w) + a = (1/w)*(p + w*a)
     Denominator: 1/((p/w)^2 + a*(p/w) + b) = w^2/(p^2 + (a*w)*p + w^2/b)
                              1/((p/w) + a) = w/(p + w*a)
  */</font>
    w_cut2 := w_cut*w_cut;
    filter.k := filter.k*w_cut^(n_den1 + 2*n_den2 - n_num1 - 2*n_num2);
    filter.n1 := w_cut*filter.n1;
    filter.d1 := w_cut*filter.d1;
    filter.n2 := [w_cut*filter.n2[:, 1],w_cut2*filter.n2[:, 2]];
    filter.d2 := [w_cut*filter.d2[:, 1],w_cut2*filter.d2[:, 2]];

<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>filter</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Internal.findMatrixName"><font color="blue">function</font> findMatrixName
      <font color="blue">input </font>String filename;
      <font color="blue">input </font>String matName=&quot;z&quot;;

      <font color="blue">output </font>Integer m;

    <font color="blue">external</font> &quot;C&quot; m = <font color="red">findMatrixName</font>(
            filename,
            matName,
            &quot;NoClass&quot;);

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>findMatrixName</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Internal.fromFile_pc"><font color="blue">encapsulated </font><font color="blue">function</font> fromFile_pc <font color="darkgreen">
      &quot;Generate a zeros and poles data record by reading the polynomial coefficients from a file (default file name is pc.mat)&quot;</font>
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;

    <font color="blue">input </font>String fileName=&quot;pc.mat&quot; <font color="darkgreen">&quot;Name of the zeros and poles data file&quot;</font>;

    <font color="blue">protected </font>
    <font color="blue">input </font>Integer n1n2d1d2[4]=
        <font color="red">ZerosAndPoles.Internal.numberOfRealZerosAndPoles_pc</font>(fileName);
    <font color="blue">input </font>Integer n1=n1n2d1d2[1];
    <font color="blue">input </font>Integer n2=n1n2d1d2[2];
    <font color="blue">input </font>Integer d1=n1n2d1d2[3];
    <font color="blue">input </font>Integer d2=n1n2d1d2[4];
    <font color="blue">input </font>Integer zSize=n1n2d1d2[1] + 2*n1n2d1d2[2];
    <font color="blue">input </font>Integer pSize=n1n2d1d2[3] + 2*n1n2d1d2[4];
    <font color="blue">public </font>
    <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp(
      n1=<font color="red">fill</font>(0, n1),
      n2=<font color="red">fill</font>(
            0,
            n2,
            2),
      d1=<font color="red">fill</font>(0, d1),
      d2=<font color="red">fill</font>(
            0,
            d2,
            2));

    <font color="blue">protected </font>
    Integer n1_2=<font color="blue">if </font>n1 &gt; 0<font color="blue"> then </font>1<font color="blue"> else </font>0 <font color="darkgreen">&quot;second dimension of n1-matrix&quot;</font>;
    Integer n2_2=<font color="blue">if </font>n2 &gt; 0<font color="blue"> then </font>2<font color="blue"> else </font>0 <font color="darkgreen">&quot;second dimension of n2-matrix&quot;</font>;
    Integer d1_2=<font color="blue">if </font>d1 &gt; 0<font color="blue"> then </font>1<font color="blue"> else </font>0 <font color="darkgreen">&quot;second dimension of d1-matrix&quot;</font>;
    Integer d2_2=<font color="blue">if </font>d2 &gt; 0<font color="blue"> then </font>2<font color="blue"> else </font>0 <font color="darkgreen">&quot;second dimension of d2-matrix&quot;</font>;

    Real k=<font color="red">scalar</font>(<font color="red">readMatrix</font>(
          fileName,
          &quot;k&quot;,
          1,
          1));
    Real n1Vector[n1]=<font color="red">vector</font>(<font color="red">readMatrix</font>(
          fileName,
          &quot;n1&quot;,
          n1,
          n1_2)) <font color="darkgreen">&quot;coefficients of first order numenator polynomials&quot;</font>;
    Real n2Matrix[n2,n2_2]=<font color="red">readMatrix</font>(
          fileName,
          &quot;n2&quot;,
          n2,
          n2_2) <font color="darkgreen">&quot;coefficients of second order denominator polynomials&quot;</font>;
    Real d1Vector[d1]=<font color="red">vector</font>(<font color="red">readMatrix</font>(
          fileName,
          &quot;d1&quot;,
          d2,
          d1_2)) <font color="darkgreen">&quot;coefficients of first order denominator polynomials&quot;</font>;
    Real d2Matrix[d2,d2_2]=<font color="red">readMatrix</font>(
          fileName,
          &quot;d2&quot;,
          d2,
          d2_2) <font color="darkgreen">&quot;coefficients of second order numenator polynomials&quot;</font>;

  <font color="blue">algorithm </font>
    zp.k := k;
    zp.n1 := <font color="blue">if </font>n1 &gt; 0<font color="blue"> then </font>n1Vector<font color="blue"> else </font><font color="red">fill</font>(0, 0);
    zp.n2 := <font color="blue">if </font>n2 &gt; 0<font color="blue"> then </font>n2Matrix<font color="blue"> else </font><font color="red">fill</font>(
        0,
        0,
        2);
    zp.d1 := <font color="blue">if </font>d1 &gt; 0<font color="blue"> then </font>d1Vector<font color="blue"> else </font><font color="red">fill</font>(0, 0);
    zp.d2 := <font color="blue">if </font>d2 &gt; 0<font color="blue"> then </font>d2Matrix<font color="blue"> else </font><font color="red">fill</font>(
        0,
        0,
        2);

  <font color="blue">end </font>fromFile_pc</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Internal.fromFile_zp"><font color="blue">encapsulated </font><font color="blue">function</font> fromFile_zp <font color="darkgreen">
      &quot;Generate a zeros and poles data record by reading poles and zeros from a file (default file name is zp.mat)&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

    <font color="blue">input </font>String fileName=&quot;zp.mat&quot; <font color="darkgreen">&quot;Name of the zeros and poles data file&quot;</font>;
    <font color="blue">protected </font>
    <font color="blue">input </font>Integer n1n2d1d2[4]=
        <font color="red">ZerosAndPoles.Internal.numberOfRealZerosAndPoles_zp</font>(fileName);
    <font color="blue">input </font>Integer n1=n1n2d1d2[1];
    <font color="blue">input </font>Integer n2=n1n2d1d2[2];
    <font color="blue">input </font>Integer d1=n1n2d1d2[3];
    <font color="blue">input </font>Integer d2=n1n2d1d2[4];
    <font color="blue">input </font>Integer zSize=n1n2d1d2[1] + 2*n1n2d1d2[2];
    <font color="blue">input </font>Integer pSize=n1n2d1d2[3] + 2*n1n2d1d2[4];
    <font color="blue">public </font>
    <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp(
      n1=<font color="red">fill</font>(0, n1),
      n2=<font color="red">fill</font>(
            0,
            n2,
            2),
      d1=<font color="red">fill</font>(0, d1),
      d2=<font color="red">fill</font>(
            0,
            d2,
            2));

    <font color="blue">protected </font>
    Integer z_2=<font color="blue">if </font>zSize &gt; 0<font color="blue"> then </font>2<font color="blue"> else </font>0 <font color="darkgreen">&quot;second dimension of zeros-matrix&quot;</font>;
    Integer p_2=<font color="blue">if </font>pSize &gt; 0<font color="blue"> then </font>2<font color="blue"> else </font>0 <font color="darkgreen">&quot;second dimension of poles-matrix&quot;</font>;

    Real k=<font color="red">scalar</font>(<font color="red">readMatrix</font>(
          fileName,
          &quot;k&quot;,
          1,
          1));
    Real zerosMatrix[zSize,z_2]=<font color="red">readMatrix</font>(
          fileName,
          &quot;z&quot;,
          zSize,
          z_2) <font color="darkgreen">&quot;zeros in rows of real parts and imaginary parts&quot;</font>;
    Real polesMatrix[pSize,p_2]=<font color="red">readMatrix</font>(
          fileName,
          &quot;p&quot;,
          pSize,
          p_2) <font color="darkgreen">&quot;poles in rows of real parts and imaginary parts&quot;</font>;
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> zeros[:]=<font color="blue">if </font>zSize &gt; 0<font color="blue"> then </font><font color="red">ZerosAndPoles.Internal.fromRealAndImag</font>(
        zerosMatrix[:, 1], zerosMatrix[:, z_2])<font color="blue"> else </font><font color="red">fill</font>(<font color="red">Complex</font>(0), 0);
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> poles[:]=<font color="blue">if </font>pSize &gt; 0<font color="blue"> then </font><font color="red">ZerosAndPoles.Internal.fromRealAndImag</font>(
        polesMatrix[:, 1], polesMatrix[:, p_2])<font color="blue"> else </font><font color="red">fill</font>(<font color="red">Complex</font>(0), 0);

  <font color="blue">algorithm </font>
    zp := <font color="red">ZerosAndPoles</font>(
        k=k,
        z=zeros,
        p=poles);
  <font color="blue">end </font>fromFile_zp</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Internal.checkRepresentation"><font color="blue">function</font> checkRepresentation <font color="darkgreen">
      &quot;checks whether the system on file is represented by zeros and poles (z, p) or first and second order polynomials (n1, n2, d1, d2)&quot;</font>
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal"
>Modelica_LinearSystems2.ZerosAndPoles.Internal</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">input </font>String fileName=&quot;zp.mat&quot; <font color="darkgreen">&quot;Name of the zeros and poles data file&quot;</font>;
      <font color="blue">output </font>Boolean iszp=true;
    <font color="blue">protected </font>
      Integer m=0;

    <font color="blue">algorithm </font>
      m := <font color="red">Internal.findMatrixName</font>(fileName, &quot;z&quot;);
      m := m + <font color="red">Internal.findMatrixName</font>(fileName, &quot;p&quot;);
      iszp := m == 2;

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>checkRepresentation</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Internal.sameVectorElements"><font color="blue">function</font> sameVectorElements <font color="darkgreen">
      &quot;Determine identical elements of a vector&quot;</font>

      <font color="blue">input </font>Real v[:] <font color="darkgreen">&quot;Vector&quot;</font>;
      <font color="blue">input </font>Integer startIndex=1 <font color="darkgreen">&quot;Start index&quot;</font>;
      <font color="blue">output </font>Integer endIndex=startIndex <font color="darkgreen">
        &quot;startIndex:endIndex are identical elements in v&quot;</font>;
    <font color="blue">protected </font>
      Integer nv=<font color="red">size</font>(v, 1);
      Integer i=startIndex + 1;
      Real v0=v[startIndex];
    <font color="blue">algorithm </font>
      <font color="blue">while </font>i &lt;= nv<font color="blue"> loop</font>
        <font color="blue">if </font>v[i] == v0<font color="blue"> then</font>
          endIndex := i;
          i := i + 1;
        <font color="blue">else</font>
          i := nv + 1;
        <font color="blue">end if</font>;
      <font color="blue">end while</font>;
    <font color="blue">end </font>sameVectorElements</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Internal.fromRealAndImag"><font color="blue">function</font> fromRealAndImag <font color="darkgreen">
      &quot;Generate a complex vector from a real part vector and imaginary part vector &quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

      <font color="blue">input </font>Real real[:];
      <font color="blue">input </font>Real imag[<font color="red">size</font>(real, 1)];
      <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> result[<font color="red">size</font>(real, 1)] <font color="darkgreen">&quot;Number of real zeros&quot;</font>;
    <font color="blue">algorithm </font>
      <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(real, 1)<font color="blue"> loop</font>
        result[i].re := real[i];
        result[i].im := imag[i];
      <font color="blue">end for</font>;
    <font color="blue">end </font>fromRealAndImag</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Internal.sameMatrixRows"><font color="blue">function</font> sameMatrixRows <font color="darkgreen">
      &quot;Determine identical rows of a [:,2] matrix&quot;</font>

      <font color="blue">input </font>Real M[:,2] <font color="darkgreen">&quot;Matrix&quot;</font>;
      <font color="blue">input </font>Integer startIndex=1 <font color="darkgreen">&quot;Start index&quot;</font>;
      <font color="blue">output </font>Integer endIndex=startIndex <font color="darkgreen">
        &quot;startIndex:endIndex are identical rows in M&quot;</font>;
    <font color="blue">protected </font>
      Integer n=<font color="red">size</font>(M, 1);
      Integer i=startIndex + 1;
      Real v0[<font color="red">size</font>(M, 2)]=M[startIndex, :];
    <font color="blue">algorithm </font>
      <font color="blue">while </font>i &lt;= n<font color="blue"> loop</font>
        <font color="blue">if </font>M[i, 1] == v0[1]<font color="blue"> and </font>M[i, 2] == v0[2]<font color="blue"> then</font>
          endIndex := i;
          i := i + 1;
        <font color="blue">else</font>
          i := n + 1;
        <font color="blue">end if</font>;
      <font color="blue">end while</font>;
    <font color="blue">end </font>sameMatrixRows</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Internal.firstOrderToString"><font color="blue">function</font> firstOrderToString <font color="darkgreen">
      &quot;Transform vector of coefficients of normalized first order polynomials to a string representation&quot;</font>
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Vectors.html#Modelica_LinearSystems2.Math.Vectors"
>Modelica_LinearSystems2.Math.Vectors</A>;

      <font color="blue">input </font>Real c[:] <font color="darkgreen">&quot;p^0 coefficients of normalized first order polynomials&quot;</font>;
      <font color="blue">input </font>Integer significantDigits=6 <font color="darkgreen">
        &quot;Number of significant digits that are shown&quot;</font>;
      <font color="blue">input </font>String name=&quot;p&quot; <font color="darkgreen">&quot;Independent variable name used for printing&quot;</font>;
      <font color="blue">output </font>String s=&quot;&quot;;
    <font color="blue">protected </font>
      Integer nc=<font color="red">size</font>(c, 1);
      Real cs[nc]=<font color="red">Modelica.Math.Vectors.sort</font>(c);
      Real cc[nc];
      Integer i;
      Integer j;
      Integer nj;
      Integer k;
      Boolean found=false;
    <font color="blue">algorithm </font>
      <font color="darkgreen">// Move coefficients with zero to the beginning</font>
      i := 1;
      <font color="blue">while </font>i &lt;= nc<font color="blue"> loop</font>
        <font color="blue">if </font>cs[i] == 0<font color="blue"> then</font>
          found := true;
          k := i;
          i := nc + 1;
        <font color="blue">else</font>
          i := i + 1;
        <font color="blue">end if</font>;
      <font color="blue">end while</font>;

      <font color="blue">if </font>found<font color="blue"> then</font>
        j := <font color="red">sameVectorElements</font>(cs, k);
        cc := <font color="red">cat</font>(
              1,
              cs[k:j],
              cs[1:k - 1],
              cs[j + 1:<font color="blue">end</font>]);
      <font color="blue">else</font>
        cc := cs;
      <font color="blue">end if</font>;

      <font color="darkgreen">// Transform coefficients to string</font>
      i := 1;
      <font color="blue">while </font>i &lt;= nc<font color="blue"> loop</font>
        <font color="blue">if </font>i &lt;&gt; 1<font color="blue"> then</font>
          s := s + &quot;*&quot;;
        <font color="blue">end if</font>;
        <font color="blue">if </font>cc[i] == 0<font color="blue"> then</font>
          s := s + name;
        <font color="blue">else</font>
          <font color="blue">if </font>cc[i] &gt; 0<font color="blue"> then</font>
            s := s + &quot;(&quot; + name + &quot; + &quot;;
          <font color="blue">else</font>
            s := s + &quot;(&quot; + name;
          <font color="blue">end if</font>;
          s := s + <font color="red">String</font>(cc[i], significantDigits=significantDigits) + &quot;)&quot;;
        <font color="blue">end if</font>;
        j := <font color="red">sameVectorElements</font>(cc, i);
        nj := j - i + 1;
        <font color="blue">if </font>nj &gt; 1<font color="blue"> then</font>
          s := s + &quot;^&quot; + <font color="red">String</font>(nj);
        <font color="blue">end if</font>;
        i := j + 1;
      <font color="blue">end while</font>;
    <font color="blue">end </font>firstOrderToString</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Internal.secondOrderToString"><font color="blue">function</font> secondOrderToString <font color="darkgreen">
      &quot;Transform vector of coefficients of normalized second order polynomials to a string representation&quot;</font>
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;

      <font color="blue">input </font>Real c[:,2] <font color="darkgreen">
        &quot;[p,p^0] coefficients of normalized second order polynomials&quot;</font>;
      <font color="blue">input </font>Integer significantDigits=6 <font color="darkgreen">
        &quot;Number of significant digits that are shown&quot;</font>;
      <font color="blue">input </font>String name=&quot;p&quot; <font color="darkgreen">&quot;Independent variable name used for printing&quot;</font>;
      <font color="blue">output </font>String s=&quot;&quot;;
    <font color="blue">protected </font>
      Integer nc=<font color="red">size</font>(c, 1);
      Real cc[nc,2]=<font color="red">Modelica.Math.Matrices.sort</font>(c);
      Integer i=1;
      Integer j;
      Integer nj;
    <font color="blue">algorithm </font>
      <font color="blue">while </font>i &lt;= nc<font color="blue"> loop</font>
        <font color="blue">if </font>i &lt;&gt; 1<font color="blue"> then</font>
          s := s + &quot;*&quot;;
        <font color="blue">end if</font>;
        j := <font color="red">sameMatrixRows</font>(cc, i);
        nj := j - i + 1;
        <font color="blue">if </font>cc[i, 1] == 0<font color="blue"> and </font>cc[i, 2] == 0<font color="blue"> then</font>
            <font color="darkgreen">// case p^2</font>
          s := s + name + &quot;^&quot; + <font color="red">String</font>(2*nj);
        <font color="blue">else</font>
          s := s + &quot;(&quot; + name + &quot;^2&quot;;

            <font color="darkgreen">// b*p term</font>
          <font color="blue">if </font>cc[i, 1] == 1<font color="blue"> then</font>
            s := s + &quot;+&quot; + name;
          <font color="blue">elseif </font>cc[i, 1] == -1<font color="blue"> then</font>
            s := s + &quot; - &quot; + name;
          <font color="blue">elseif </font>cc[i, 1] &lt;&gt; 0<font color="blue"> then</font>
            <font color="blue">if </font>cc[i, 1] &gt; 0<font color="blue"> then</font>
              s := s + &quot; + &quot;;
            <font color="blue">end if</font>;
            s := s + <font color="red">String</font>(cc[i, 1], significantDigits=significantDigits) +
              &quot;*&quot; + name;
          <font color="blue">end if</font>;

            <font color="darkgreen">// a*p^0 term</font>
          <font color="blue">if </font>cc[i, 2] &gt; 0<font color="blue"> then</font>
            s := s + &quot; + &quot;;
          <font color="blue">end if</font>;
          s := s + <font color="red">String</font>(cc[i, 2], significantDigits=significantDigits) + &quot;)&quot;;
          <font color="blue">if </font>nj &gt; 1<font color="blue"> then</font>
            s := s + &quot;^&quot; + <font color="red">String</font>(nj);
          <font color="blue">end if</font>;
        <font color="blue">end if</font>;
        i := j + 1;
      <font color="blue">end while</font>;
    <font color="blue">end </font>secondOrderToString</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Internal.normalizationFactor"><font color="blue">function</font> normalizationFactor <font color="darkgreen">
      &quot;Compute correction factor of low pass filter such that amplitude at cut-off frequency is 1/sqrt(2) (= 3db)&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams"
>Modelica.Utilities.Streams</A>;

      <font color="blue">input </font>Real c1[:] <font color="darkgreen">&quot;[p] coefficients of denominator polynomials (a*p + 1)&quot;</font>;
      <font color="blue">input </font>Real c2[:,2] <font color="darkgreen">
        &quot;[p^2, p] coefficients of denominator polynomials (b*p^2 + a*p + 1)&quot;</font>;
      <font color="blue">output </font>Real alpha <font color="darkgreen">&quot;Correction factor (replace p by alpha*p)&quot;</font>;
    <font color="blue">protected </font>
      Real oldAlpha=1.0;
      Integer counter=0;
      Integer counterMax=100;
      Boolean iterating=true;
      Real residue;
      Real der_residue;

      <font color="blue">encapsulated </font><font color="blue">function</font> normalizationFactorResidues <font color="darkgreen">
        &quot;Residue and residue derivative for Newton iteration of correction factor computation&quot;</font>
        <font color="blue">input </font>Real c1[:] <font color="darkgreen">
          &quot;[p] coefficients of denominator polynomials (a*p + 1)&quot;</font>;
        <font color="blue">input </font>Real c2[:,2] <font color="darkgreen">
          &quot;[p^2, p] coefficients of denominator polynomials (b*p^2 + a*p + 1)&quot;</font>;
        <font color="blue">input </font>Real alpha;
        <font color="blue">output </font>Real residue;
        <font color="blue">output </font>Real der_residue;
      <font color="blue">protected </font>
        Real beta=2;  <font color="darkgreen">//beta = 10^(3/10);</font>
        Real cc1;
        Real cc2;
        Real p;
        Real pd;
        Real alpha2=alpha*alpha;
        Real alpha4=alpha2*alpha2;
        Real A2=1.0;
        Real fac=0.0;
      <font color="blue">algorithm </font>
        <font color="blue">if </font><font color="red">size</font>(c1, 1) == 1<font color="blue"> then</font>
          cc1 := c1[1]*c1[1];
          p := 1 + cc1*alpha2;
          pd := cc1;
          fac := fac + pd/p;
          A2 := A2*p;
        <font color="blue">end if</font>;
        <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(c2, 1)<font color="blue"> loop</font>
          cc1 := c2[i, 2]*c2[i, 2] - 2*c2[i, 1];
          cc2 := c2[i, 1]*c2[i, 1];
          p := 1 + cc1*alpha2 + cc2*alpha4;
          pd := cc1 + 2*cc2*alpha2;
          fac := fac + pd/p;
          A2 := A2*p;
        <font color="blue">end for</font>;
        residue := A2 - beta;
        der_residue := 2*alpha*A2*fac;
      <font color="blue">end </font>normalizationFactorResidues;
    <font color="blue">algorithm </font>
       <font color="darkgreen">// Simple Newton iteration</font>
      <font color="blue">while </font>iterating<font color="blue"> loop</font>
        counter := counter + 1;
        (residue,der_residue) := <font color="red">normalizationFactorResidues</font>(
              c1,
              c2,
              oldAlpha);
        alpha := oldAlpha - residue/der_residue;
        <font color="blue">if </font><font color="red">abs</font>(alpha - oldAlpha) &lt;= 100*Modelica.Constants.eps<font color="blue"> then</font>
          iterating := false;
        <font color="blue">elseif </font>counter &gt; counterMax<font color="blue"> then</font>
          <font color="red">Streams.error</font>(&quot;Numerical problems when computing cutoff frequency\n&quot;
             + &quot;correction factor of filter (use option normalized=false)&quot;);
        <font color="blue">else</font>
          oldAlpha := alpha;
        <font color="blue">end if</font>;
      <font color="blue">end while</font>;
      <font color="red">assert</font>(alpha &gt; 0.0,
        &quot;Numerical problems when computing cutoff frequency\n&quot; +
        &quot;correction factor of filter (alpha = &quot; + <font color="red">String</font>(alpha) + &quot;)\n&quot; +
        &quot;(use option normalized=false)&quot;);
    <font color="blue">end </font>normalizationFactor</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Internal.BesselCoefficients"><font color="blue">function</font> BesselCoefficients <font color="darkgreen">
      &quot;Return coefficients of normalized low pass Bessel filter (= gain at cut-off frequency 1 rad/s is decreased 3dB&quot;</font>

      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams"
>Modelica.Utilities.Streams</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">input </font>Integer order <font color="darkgreen">&quot;Order of filter in the range 1..41&quot;</font>;
      <font color="blue">output </font>Real c1[<font color="red">mod</font>(order, 2)] <font color="darkgreen">
        &quot;[p] coefficients of Bessel denominator polynomials (a*p + 1)&quot;</font>;
      <font color="blue">output </font>Real c2[<font color="red">integer</font>(order/2),2] <font color="darkgreen">
        &quot;[p^2, p] coefficients of Bessel denominator polynomials (b2*p^2 + b1*p + 1)&quot;</font>;
      <font color="blue">output </font>Real alpha <font color="darkgreen">&quot;Normalization factor&quot;</font>;
    <font color="blue">algorithm </font>
      <font color="blue">if </font>order == 1<font color="blue"> then</font>
        alpha := 1.002377293007601;
        c1[1] := 0.9976283451109835;
      <font color="blue">elseif </font>order == 2<font color="blue"> then</font>
        alpha := 0.7356641785819585;
        c2[1, 1] := 0.6159132201783791;
        c2[1, 2] := 1.359315879600889;
      <font color="blue">elseif </font>order == 3<font color="blue"> then</font>
        alpha := 0.5704770156982642;
        c1[1] := 0.7548574865985343;
        c2[1, 1] := 0.4756958028827457;
        c2[1, 2] := 0.9980615136104388;
      <font color="blue">elseif </font>order == 4<font color="blue"> then</font>
        alpha := 0.4737978580281427;
        c2[1, 1] := 0.4873729247240677;
        c2[1, 2] := 1.337564170455762;
        c2[2, 1] := 0.3877724315741958;
        c2[2, 2] := 0.7730405590839861;
      <font color="blue">elseif </font>order == 5<font color="blue"> then</font>
        alpha := 0.4126226974763408;
        c1[1] := 0.6645723262620757;
        c2[1, 1] := 0.4115231900614016;
        c2[1, 2] := 1.138349926728708;
        c2[2, 1] := 0.3234938702877912;
        c2[2, 2] := 0.6205992985771313;
      <font color="blue">elseif </font>order == 6<font color="blue"> then</font>
        alpha := 0.3705098000736233;
        c2[1, 1] := 0.3874508649098960;
        c2[1, 2] := 1.219740879520741;
        c2[2, 1] := 0.3493298843155746;
        c2[2, 2] := 0.9670265529381365;
        c2[3, 1] := 0.2747419229514599;
        c2[3, 2] := 0.5122165075105700;
      <font color="blue">elseif </font>order == 7<font color="blue"> then</font>
        alpha := 0.3393452623586350;
        c1[1] := 0.5927147125821412;
        c2[1, 1] := 0.3383379423919174;
        c2[1, 2] := 1.092630816438030;
        c2[2, 1] := 0.3001025788696046;
        c2[2, 2] := 0.8289928256598656;
        c2[3, 1] := 0.2372867471539579;
        c2[3, 2] := 0.4325128641920154;
      <font color="blue">elseif </font>order == 8<font color="blue"> then</font>
        alpha := 0.3150267393795002;
        c2[1, 1] := 0.3151115975207653;
        c2[1, 2] := 1.109403015460190;
        c2[2, 1] := 0.2969344839572762;
        c2[2, 2] := 0.9737455812222699;
        c2[3, 1] := 0.2612545921889538;
        c2[3, 2] := 0.7190394712068573;
        c2[4, 1] := 0.2080523342974281;
        c2[4, 2] := 0.3721456473047434;
      <font color="blue">elseif </font>order == 9<font color="blue"> then</font>
        alpha := 0.2953310177184124;
        c1[1] := 0.5377196679501422;
        c2[1, 1] := 0.2824689124281034;
        c2[1, 2] := 1.022646191567475;
        c2[2, 1] := 0.2626824161383468;
        c2[2, 2] := 0.8695626454762596;
        c2[3, 1] := 0.2302781917677917;
        c2[3, 2] := 0.6309047553448520;
        c2[4, 1] := 0.1847991729757028;
        c2[4, 2] := 0.3251978031287202;
      <font color="blue">elseif </font>order == 10<font color="blue"> then</font>
        alpha := 0.2789426890619463;
        c2[1, 1] := 0.2640769908255582;
        c2[1, 2] := 1.019788132875305;
        c2[2, 1] := 0.2540802639216947;
        c2[2, 2] := 0.9377020417760623;
        c2[3, 1] := 0.2343577229427963;
        c2[3, 2] := 0.7802229808216112;
        c2[4, 1] := 0.2052193139338624;
        c2[4, 2] := 0.5594176813008133;
        c2[5, 1] := 0.1659546953748916;
        c2[5, 2] := 0.2878349616233292;
      <font color="blue">elseif </font>order == 11<font color="blue"> then</font>
        alpha := 0.2650227766037203;
        c1[1] := 0.4950265498954191;
        c2[1, 1] := 0.2411858478546218;
        c2[1, 2] := 0.9567800996387417;
        c2[2, 1] := 0.2296849355380925;
        c2[2, 2] := 0.8592523717113126;
        c2[3, 1] := 0.2107851705677406;
        c2[3, 2] := 0.7040216048898129;
        c2[4, 1] := 0.1846461385164021;
        c2[4, 2] := 0.5006729207276717;
        c2[5, 1] := 0.1504217970817433;
        c2[5, 2] := 0.2575070491320295;
      <font color="blue">elseif </font>order == 12<font color="blue"> then</font>
        alpha := 0.2530051198547209;
        c2[1, 1] := 0.2268294941204543;
        c2[1, 2] := 0.9473116570034053;
        c2[2, 1] := 0.2207657387793729;
        c2[2, 2] := 0.8933728946287606;
        c2[3, 1] := 0.2087600700376653;
        c2[3, 2] := 0.7886236252756229;
        c2[4, 1] := 0.1909959101492760;
        c2[4, 2] := 0.6389263649257017;
        c2[5, 1] := 0.1675208146048472;
        c2[5, 2] := 0.4517847275162215;
        c2[6, 1] := 0.1374257286372761;
        c2[6, 2] := 0.2324699157474680;
      <font color="blue">elseif </font>order == 13<font color="blue"> then</font>
        alpha := 0.2424910397561007;
        c1[1] := 0.4608848369928040;
        c2[1, 1] := 0.2099813050274780;
        c2[1, 2] := 0.8992478823790660;
        c2[2, 1] := 0.2027250423101359;
        c2[2, 2] := 0.8328117484224146;
        c2[3, 1] := 0.1907635894058731;
        c2[3, 2] := 0.7257379204691213;
        c2[4, 1] := 0.1742280397887686;
        c2[4, 2] := 0.5830640944868014;
        c2[5, 1] := 0.1530858190490478;
        c2[5, 2] := 0.4106192089751885;
        c2[6, 1] := 0.1264090712880446;
        c2[6, 2] := 0.2114980230156001;
      <font color="blue">elseif </font>order == 14<font color="blue"> then</font>
        alpha := 0.2331902368695848;
        c2[1, 1] := 0.1986162311411235;
        c2[1, 2] := 0.8876961808055535;
        c2[2, 1] := 0.1946683341271615;
        c2[2, 2] := 0.8500754229171967;
        c2[3, 1] := 0.1868331332895056;
        c2[3, 2] := 0.7764629313723603;
        c2[4, 1] := 0.1752118757862992;
        c2[4, 2] := 0.6699720402924552;
        c2[5, 1] := 0.1598906457908402;
        c2[5, 2] := 0.5348446712848934;
        c2[6, 1] := 0.1407810153019944;
        c2[6, 2] := 0.3755841316563539;
        c2[7, 1] := 0.1169627966707339;
        c2[7, 2] := 0.1937088226304455;
      <font color="blue">elseif </font>order == 15<font color="blue"> then</font>
        alpha := 0.2248854870552422;
        c1[1] := 0.4328492272335646;
        c2[1, 1] := 0.1857292591004588;
        c2[1, 2] := 0.8496337061962563;
        c2[2, 1] := 0.1808644178280136;
        c2[2, 2] := 0.8020517898136011;
        c2[3, 1] := 0.1728264404199081;
        c2[3, 2] := 0.7247449729331105;
        c2[4, 1] := 0.1616970125901954;
        c2[4, 2] := 0.6205369315943097;
        c2[5, 1] := 0.1475257264578426;
        c2[5, 2] := 0.4929612162355906;
        c2[6, 1] := 0.1301861023357119;
        c2[6, 2] := 0.3454770708040735;
        c2[7, 1] := 0.1087810777120188;
        c2[7, 2] := 0.1784526655428406;
      <font color="blue">elseif </font>order == 16<font color="blue"> then</font>
        alpha := 0.2174105053474761;
        c2[1, 1] := 0.1765637967473151;
        c2[1, 2] := 0.8377453068635511;
        c2[2, 1] := 0.1738525357503125;
        c2[2, 2] := 0.8102988957433199;
        c2[3, 1] := 0.1684627004613343;
        c2[3, 2] := 0.7563265923413258;
        c2[4, 1] := 0.1604519074815815;
        c2[4, 2] := 0.6776082294687619;
        c2[5, 1] := 0.1498828607802206;
        c2[5, 2] := 0.5766417034027680;
        c2[6, 1] := 0.1367764717792823;
        c2[6, 2] := 0.4563528264410489;
        c2[7, 1] := 0.1209810465419295;
        c2[7, 2] := 0.3193782657322374;
        c2[8, 1] := 0.1016312648007554;
        c2[8, 2] := 0.1652419227369036;
      <font color="blue">elseif </font>order == 17<font color="blue"> then</font>
        alpha := 0.2106355148193306;
        c1[1] := 0.4093223608497299;
        c2[1, 1] := 0.1664014345826274;
        c2[1, 2] := 0.8067173752345952;
        c2[2, 1] := 0.1629839591538256;
        c2[2, 2] := 0.7712924931447541;
        c2[3, 1] := 0.1573277802512491;
        c2[3, 2] := 0.7134213666303411;
        c2[4, 1] := 0.1494828185148637;
        c2[4, 2] := 0.6347841731714884;
        c2[5, 1] := 0.1394948812681826;
        c2[5, 2] := 0.5375594414619047;
        c2[6, 1] := 0.1273627583380806;
        c2[6, 2] := 0.4241608926375478;
        c2[7, 1] := 0.1129187258461290;
        c2[7, 2] := 0.2965752009703245;
        c2[8, 1] := 0.9533357359908857e-1;
        c2[8, 2] := 0.1537041700889585;
      <font color="blue">elseif </font>order == 18<font color="blue"> then</font>
        alpha := 0.2044575288651841;
        c2[1, 1] := 0.1588768571976356;
        c2[1, 2] := 0.7951914263212913;
        c2[2, 1] := 0.1569357024981854;
        c2[2, 2] := 0.7744529690772538;
        c2[3, 1] := 0.1530722206358810;
        c2[3, 2] := 0.7335304425992080;
        c2[4, 1] := 0.1473206710524167;
        c2[4, 2] := 0.6735038935387268;
        c2[5, 1] := 0.1397225420331520;
        c2[5, 2] := 0.5959151542621590;
        c2[6, 1] := 0.1303092459809849;
        c2[6, 2] := 0.5026483447894845;
        c2[7, 1] := 0.1190627367060072;
        c2[7, 2] := 0.3956893824587150;
        c2[8, 1] := 0.1058058030798994;
        c2[8, 2] := 0.2765091830730650;
        c2[9, 1] := 0.8974708108800873e-1;
        c2[9, 2] := 0.1435505288284833;
      <font color="blue">elseif </font>order == 19<font color="blue"> then</font>
        alpha := 0.1987936248083529;
        c1[1] := 0.3892259966869526;
        c2[1, 1] := 0.1506640012172225;
        c2[1, 2] := 0.7693121733774260;
        c2[2, 1] := 0.1481728062796673;
        c2[2, 2] := 0.7421133586741549;
        c2[3, 1] := 0.1440444668388838;
        c2[3, 2] := 0.6975075386214800;
        c2[4, 1] := 0.1383101628540374;
        c2[4, 2] := 0.6365464378910025;
        c2[5, 1] := 0.1310032283190998;
        c2[5, 2] := 0.5606211948462122;
        c2[6, 1] := 0.1221431166405330;
        c2[6, 2] := 0.4713530424221445;
        c2[7, 1] := 0.1116991161103884;
        c2[7, 2] := 0.3703717538617073;
        c2[8, 1] := 0.9948917351196349e-1;
        c2[8, 2] := 0.2587371155559744;
        c2[9, 1] := 0.8475989238107367e-1;
        c2[9, 2] := 0.1345537894555993;
      <font color="blue">elseif </font>order == 20<font color="blue"> then</font>
        alpha := 0.1935761760416219;
        c2[1, 1] := 0.1443871348337404;
        c2[1, 2] := 0.7584165598446141;
        c2[2, 1] := 0.1429501891353184;
        c2[2, 2] := 0.7423000962318863;
        c2[3, 1] := 0.1400877384920004;
        c2[3, 2] := 0.7104185332215555;
        c2[4, 1] := 0.1358210369491446;
        c2[4, 2] := 0.6634599783272630;
        c2[5, 1] := 0.1301773703034290;
        c2[5, 2] := 0.6024175491895959;
        c2[6, 1] := 0.1231826501439148;
        c2[6, 2] := 0.5285332736326852;
        c2[7, 1] := 0.1148465498575254;
        c2[7, 2] := 0.4431977385498628;
        c2[8, 1] := 0.1051289462376788;
        c2[8, 2] := 0.3477444062821162;
        c2[9, 1] := 0.9384622797485121e-1;
        c2[9, 2] := 0.2429038300327729;
        c2[10, 1] := 0.8028211612831444e-1;
        c2[10, 2] := 0.1265329974009533;
      <font color="blue">elseif </font>order == 21<font color="blue"> then</font>
        alpha := 0.1887494014766075;
        c1[1] := 0.3718070668941645;
        c2[1, 1] := 0.1376151928386445;
        c2[1, 2] := 0.7364290859445481;
        c2[2, 1] := 0.1357438914390695;
        c2[2, 2] := 0.7150167318935022;
        c2[3, 1] := 0.1326398453462415;
        c2[3, 2] := 0.6798001808470175;
        c2[4, 1] := 0.1283231214897678;
        c2[4, 2] := 0.6314663440439816;
        c2[5, 1] := 0.1228169159777534;
        c2[5, 2] := 0.5709353626166905;
        c2[6, 1] := 0.1161406100773184;
        c2[6, 2] := 0.4993087153571335;
        c2[7, 1] := 0.1082959649233524;
        c2[7, 2] := 0.4177766148584385;
        c2[8, 1] := 0.9923596957485723e-1;
        c2[8, 2] := 0.3274257287232124;
        c2[9, 1] := 0.8877776108724853e-1;
        c2[9, 2] := 0.2287218166767916;
        c2[10, 1] := 0.7624076527736326e-1;
        c2[10, 2] := 0.1193423971506988;
      <font color="blue">elseif </font>order == 22<font color="blue"> then</font>
        alpha := 0.1842668221199706;
        c2[1, 1] := 0.1323053462701543;
        c2[1, 2] := 0.7262446126765204;
        c2[2, 1] := 0.1312121721769772;
        c2[2, 2] := 0.7134286088450949;
        c2[3, 1] := 0.1290330911166814;
        c2[3, 2] := 0.6880287870435514;
        c2[4, 1] := 0.1257817990372067;
        c2[4, 2] := 0.6505015800059301;
        c2[5, 1] := 0.1214765261983008;
        c2[5, 2] := 0.6015107185211451;
        c2[6, 1] := 0.1161365140967959;
        c2[6, 2] := 0.5418983553698413;
        c2[7, 1] := 0.1097755171533100;
        c2[7, 2] := 0.4726370779831614;
        c2[8, 1] := 0.1023889478519956;
        c2[8, 2] := 0.3947439506537486;
        c2[9, 1] := 0.9392485861253800e-1;
        c2[9, 2] := 0.3090996703083202;
        c2[10, 1] := 0.8420273775456455e-1;
        c2[10, 2] := 0.2159561978556017;
        c2[11, 1] := 0.7257600023938262e-1;
        c2[11, 2] := 0.1128633732721116;
      <font color="blue">elseif </font>order == 23<font color="blue"> then</font>
        alpha := 0.1800893554453722;
        c1[1] := 0.3565232673929280;
        c2[1, 1] := 0.1266275171652706;
        c2[1, 2] := 0.7072778066734162;
        c2[2, 1] := 0.1251865227648538;
        c2[2, 2] := 0.6900676345785905;
        c2[3, 1] := 0.1227944815236645;
        c2[3, 2] := 0.6617011100576023;
        c2[4, 1] := 0.1194647013077667;
        c2[4, 2] := 0.6226432315773119;
        c2[5, 1] := 0.1152132989252356;
        c2[5, 2] := 0.5735222810625359;
        c2[6, 1] := 0.1100558598478487;
        c2[6, 2] := 0.5151027978024605;
        c2[7, 1] := 0.1040013558214886;
        c2[7, 2] := 0.4482410942032739;
        c2[8, 1] := 0.9704014176512626e-1;
        c2[8, 2] := 0.3738049984631116;
        c2[9, 1] := 0.8911683905758054e-1;
        c2[9, 2] := 0.2925028692588410;
        c2[10, 1] := 0.8005438265072295e-1;
        c2[10, 2] := 0.2044134600278901;
        c2[11, 1] := 0.6923832296800832e-1;
        c2[11, 2] := 0.1069984887283394;
      <font color="blue">elseif </font>order == 24<font color="blue"> then</font>
        alpha := 0.1761838665838427;
        c2[1, 1] := 0.1220804912720132;
        c2[1, 2] := 0.6978026874156063;
        c2[2, 1] := 0.1212296762358897;
        c2[2, 2] := 0.6874139794926736;
        c2[3, 1] := 0.1195328372961027;
        c2[3, 2] := 0.6667954259551859;
        c2[4, 1] := 0.1169990987333593;
        c2[4, 2] := 0.6362602049901176;
        c2[5, 1] := 0.1136409040480130;
        c2[5, 2] := 0.5962662188435553;
        c2[6, 1] := 0.1094722001757955;
        c2[6, 2] := 0.5474001634109253;
        c2[7, 1] := 0.1045052832229087;
        c2[7, 2] := 0.4903523180249535;
        c2[8, 1] := 0.9874509806025907e-1;
        c2[8, 2] := 0.4258751523524645;
        c2[9, 1] := 0.9217799943472177e-1;
        c2[9, 2] := 0.3547079765396403;
        c2[10, 1] := 0.8474633796250476e-1;
        c2[10, 2] := 0.2774145482392767;
        c2[11, 1] := 0.7627722381240495e-1;
        c2[11, 2] := 0.1939329108084139;
        c2[12, 1] := 0.6618645465422745e-1;
        c2[12, 2] := 0.1016670147947242;
      <font color="blue">elseif </font>order == 25<font color="blue"> then</font>
        alpha := 0.1725220521949266;
        c1[1] := 0.3429735385896000;
        c2[1, 1] := 0.1172525033170618;
        c2[1, 2] := 0.6812327932576614;
        c2[2, 1] := 0.1161194585333535;
        c2[2, 2] := 0.6671566071153211;
        c2[3, 1] := 0.1142375145794466;
        c2[3, 2] := 0.6439167855053158;
        c2[4, 1] := 0.1116157454252308;
        c2[4, 2] := 0.6118378416180135;
        c2[5, 1] := 0.1082654809459177;
        c2[5, 2] := 0.5713609763370088;
        c2[6, 1] := 0.1041985674230918;
        c2[6, 2] := 0.5230289949762722;
        c2[7, 1] := 0.9942439308123559e-1;
        c2[7, 2] := 0.4674627926041906;
        c2[8, 1] := 0.9394453593830893e-1;
        c2[8, 2] := 0.4053226688298811;
        c2[9, 1] := 0.8774221237222533e-1;
        c2[9, 2] := 0.3372372276379071;
        c2[10, 1] := 0.8075839512216483e-1;
        c2[10, 2] := 0.2636485508005428;
        c2[11, 1] := 0.7282483286646764e-1;
        c2[11, 2] := 0.1843801345273085;
        c2[12, 1] := 0.6338571166846652e-1;
        c2[12, 2] := 0.9680153764737715e-1;
      <font color="blue">elseif </font>order == 26<font color="blue"> then</font>
        alpha := 0.1690795702796737;
        c2[1, 1] := 0.1133168695796030;
        c2[1, 2] := 0.6724297955493932;
        c2[2, 1] := 0.1126417845769961;
        c2[2, 2] := 0.6638709519790540;
        c2[3, 1] := 0.1112948749545606;
        c2[3, 2] := 0.6468652038763624;
        c2[4, 1] := 0.1092823986944244;
        c2[4, 2] := 0.6216337070799265;
        c2[5, 1] := 0.1066130386697976;
        c2[5, 2] := 0.5885011413992190;
        c2[6, 1] := 0.1032969057045413;
        c2[6, 2] := 0.5478864278297548;
        c2[7, 1] := 0.9934388184210715e-1;
        c2[7, 2] := 0.5002885306054287;
        c2[8, 1] := 0.9476081523436283e-1;
        c2[8, 2] := 0.4462644847551711;
        c2[9, 1] := 0.8954648464575577e-1;
        c2[9, 2] := 0.3863930785049522;
        c2[10, 1] := 0.8368166847159917e-1;
        c2[10, 2] := 0.3212074592527143;
        c2[11, 1] := 0.7710664731701103e-1;
        c2[11, 2] := 0.2510470347119383;
        c2[12, 1] := 0.6965807988411425e-1;
        c2[12, 2] := 0.1756419294111342;
        c2[13, 1] := 0.6080674930548766e-1;
        c2[13, 2] := 0.9234535279274277e-1;
      <font color="blue">elseif </font>order == 27<font color="blue"> then</font>
        alpha := 0.1658353543067995;
        c1[1] := 0.3308543720638957;
        c2[1, 1] := 0.1091618578712746;
        c2[1, 2] := 0.6577977071169651;
        c2[2, 1] := 0.1082549561495043;
        c2[2, 2] := 0.6461121666520275;
        c2[3, 1] := 0.1067479247890451;
        c2[3, 2] := 0.6267937760991321;
        c2[4, 1] := 0.1046471079537577;
        c2[4, 2] := 0.6000750116745808;
        c2[5, 1] := 0.1019605976654259;
        c2[5, 2] := 0.5662734183049320;
        c2[6, 1] := 0.9869726954433709e-1;
        c2[6, 2] := 0.5257827234948534;
        c2[7, 1] := 0.9486520934132483e-1;
        c2[7, 2] := 0.4790595019077763;
        c2[8, 1] := 0.9046906518775348e-1;
        c2[8, 2] := 0.4266025862147336;
        c2[9, 1] := 0.8550529998276152e-1;
        c2[9, 2] := 0.3689188223512328;
        c2[10, 1] := 0.7995282239306020e-1;
        c2[10, 2] := 0.3064589322702932;
        c2[11, 1] := 0.7375174596252882e-1;
        c2[11, 2] := 0.2394754504667310;
        c2[12, 1] := 0.6674377263329041e-1;
        c2[12, 2] := 0.1676223546666024;
        c2[13, 1] := 0.5842458027529246e-1;
        c2[13, 2] := 0.8825044329219431e-1;
      <font color="blue">elseif </font>order == 28<font color="blue"> then</font>
        alpha := 0.1627710671942929;
        c2[1, 1] := 0.1057232656113488;
        c2[1, 2] := 0.6496161226860832;
        c2[2, 1] := 0.1051786825724864;
        c2[2, 2] := 0.6424661279909941;
        c2[3, 1] := 0.1040917964935006;
        c2[3, 2] := 0.6282470268918791;
        c2[4, 1] := 0.1024670101953951;
        c2[4, 2] := 0.6071189030701136;
        c2[5, 1] := 0.1003105109519892;
        c2[5, 2] := 0.5793175191747016;
        c2[6, 1] := 0.9762969425430802e-1;
        c2[6, 2] := 0.5451486608855443;
        c2[7, 1] := 0.9443223803058400e-1;
        c2[7, 2] := 0.5049796971628137;
        c2[8, 1] := 0.9072460982036488e-1;
        c2[8, 2] := 0.4592270546572523;
        c2[9, 1] := 0.8650956423253280e-1;
        c2[9, 2] := 0.4083368605952977;
        c2[10, 1] := 0.8178165740374893e-1;
        c2[10, 2] := 0.3527525188880655;
        c2[11, 1] := 0.7651838885868020e-1;
        c2[11, 2] := 0.2928534570013572;
        c2[12, 1] := 0.7066010532447490e-1;
        c2[12, 2] := 0.2288185204390681;
        c2[13, 1] := 0.6405358596145789e-1;
        c2[13, 2] := 0.1602396172588190;
        c2[14, 1] := 0.5621780070227172e-1;
        c2[14, 2] := 0.8447589564915071e-1;
      <font color="blue">elseif </font>order == 29<font color="blue"> then</font>
        alpha := 0.1598706626277596;
        c1[1] := 0.3199314513011623;
        c2[1, 1] := 0.1021101032532951;
        c2[1, 2] := 0.6365758882240111;
        c2[2, 1] := 0.1013729819392774;
        c2[2, 2] := 0.6267495975736321;
        c2[3, 1] := 0.1001476175660628;
        c2[3, 2] := 0.6104876178266819;
        c2[4, 1] := 0.9843854640428316e-1;
        c2[4, 2] := 0.5879603139195113;
        c2[5, 1] := 0.9625164534591696e-1;
        c2[5, 2] := 0.5594012291050210;
        c2[6, 1] := 0.9359356960417668e-1;
        c2[6, 2] := 0.5251016150410664;
        c2[7, 1] := 0.9047086748649986e-1;
        c2[7, 2] := 0.4854024475590397;
        c2[8, 1] := 0.8688856407189167e-1;
        c2[8, 2] := 0.4406826457109709;
        c2[9, 1] := 0.8284779224069856e-1;
        c2[9, 2] := 0.3913408089298914;
        c2[10, 1] := 0.7834154620997181e-1;
        c2[10, 2] := 0.3377643999400627;
        c2[11, 1] := 0.7334628941928766e-1;
        c2[11, 2] := 0.2802710651919946;
        c2[12, 1] := 0.6780290487362146e-1;
        c2[12, 2] := 0.2189770008083379;
        c2[13, 1] := 0.6156321231528423e-1;
        c2[13, 2] := 0.1534235999306070;
        c2[14, 1] := 0.5416797446761512e-1;
        c2[14, 2] := 0.8098664736760292e-1;
      <font color="blue">elseif </font>order == 30<font color="blue"> then</font>
        alpha := 0.1571200296252450;
        c2[1, 1] := 0.9908074847842124e-1;
        c2[1, 2] := 0.6289618807831557;
        c2[2, 1] := 0.9863509708328196e-1;
        c2[2, 2] := 0.6229164525571278;
        c2[3, 1] := 0.9774542692037148e-1;
        c2[3, 2] := 0.6108853364240036;
        c2[4, 1] := 0.9641490581986484e-1;
        c2[4, 2] := 0.5929869253412513;
        c2[5, 1] := 0.9464802912225441e-1;
        c2[5, 2] := 0.5693960175547550;
        c2[6, 1] := 0.9245027206218041e-1;
        c2[6, 2] := 0.5403402396359503;
        c2[7, 1] := 0.8982754584112941e-1;
        c2[7, 2] := 0.5060948065875106;
        c2[8, 1] := 0.8678535291732599e-1;
        c2[8, 2] := 0.4669749797983789;
        c2[9, 1] := 0.8332744242052199e-1;
        c2[9, 2] := 0.4233249626334694;
        c2[10, 1] := 0.7945356393775309e-1;
        c2[10, 2] := 0.3755006094498054;
        c2[11, 1] := 0.7515543969833788e-1;
        c2[11, 2] := 0.3238400339292700;
        c2[12, 1] := 0.7040879901685638e-1;
        c2[12, 2] := 0.2686072427439079;
        c2[13, 1] := 0.6515528854010540e-1;
        c2[13, 2] := 0.2098650589782619;
        c2[14, 1] := 0.5925168237177876e-1;
        c2[14, 2] := 0.1471138832654873;
        c2[15, 1] := 0.5225913954211672e-1;
        c2[15, 2] := 0.7775248839507864e-1;
      <font color="blue">elseif </font>order == 31<font color="blue"> then</font>
        alpha := 0.1545067022920929;
        c1[1] := 0.3100206996451866;
        c2[1, 1] := 0.9591020358831668e-1;
        c2[1, 2] := 0.6172474793293396;
        c2[2, 1] := 0.9530301275601203e-1;
        c2[2, 2] := 0.6088916323460413;
        c2[3, 1] := 0.9429332655402368e-1;
        c2[3, 2] := 0.5950511595503025;
        c2[4, 1] := 0.9288445429894548e-1;
        c2[4, 2] := 0.5758534119053522;
        c2[5, 1] := 0.9108073420087422e-1;
        c2[5, 2] := 0.5514734636081183;
        c2[6, 1] := 0.8888719137536870e-1;
        c2[6, 2] := 0.5221306199481831;
        c2[7, 1] := 0.8630901440239650e-1;
        c2[7, 2] := 0.4880834248148061;
        c2[8, 1] := 0.8335074993373294e-1;
        c2[8, 2] := 0.4496225358496770;
        c2[9, 1] := 0.8001502494376102e-1;
        c2[9, 2] := 0.4070602306679052;
        c2[10, 1] := 0.7630041338037624e-1;
        c2[10, 2] := 0.3607139804818122;
        c2[11, 1] := 0.7219760885744920e-1;
        c2[11, 2] := 0.3108783301229550;
        c2[12, 1] := 0.6768185077153345e-1;
        c2[12, 2] := 0.2577706252514497;
        c2[13, 1] := 0.6269571766328638e-1;
        c2[13, 2] := 0.2014081375889921;
        c2[14, 1] := 0.5710081766945065e-1;
        c2[14, 2] := 0.1412581515841926;
        c2[15, 1] := 0.5047740914807019e-1;
        c2[15, 2] := 0.7474725873250158e-1;
      <font color="blue">elseif </font>order == 32<font color="blue"> then</font>
        alpha := 0.1520196210848210;
        c2[1, 1] := 0.9322163554339406e-1;
        c2[1, 2] := 0.6101488690506050;
        c2[2, 1] := 0.9285233997694042e-1;
        c2[2, 2] := 0.6049832320721264;
        c2[3, 1] := 0.9211494244473163e-1;
        c2[3, 2] := 0.5946969295569034;
        c2[4, 1] := 0.9101176786042449e-1;
        c2[4, 2] := 0.5793791854364477;
        c2[5, 1] := 0.8954614071360517e-1;
        c2[5, 2] := 0.5591619969234026;
        c2[6, 1] := 0.8772216763680164e-1;
        c2[6, 2] := 0.5342177994699602;
        c2[7, 1] := 0.8554440426912734e-1;
        c2[7, 2] := 0.5047560942986598;
        c2[8, 1] := 0.8301735302045588e-1;
        c2[8, 2] := 0.4710187048140929;
        c2[9, 1] := 0.8014469519188161e-1;
        c2[9, 2] := 0.4332730387207936;
        c2[10, 1] := 0.7692807528893225e-1;
        c2[10, 2] := 0.3918021436411035;
        c2[11, 1] := 0.7336507157284898e-1;
        c2[11, 2] := 0.3468890521471250;
        c2[12, 1] := 0.6944555312763458e-1;
        c2[12, 2] := 0.2987898029050460;
        c2[13, 1] := 0.6514446669420571e-1;
        c2[13, 2] := 0.2476810747407199;
        c2[14, 1] := 0.6040544477732702e-1;
        c2[14, 2] := 0.1935412053397663;
        c2[15, 1] := 0.5509478650672775e-1;
        c2[15, 2] := 0.1358108994174911;
        c2[16, 1] := 0.4881064725720192e-1;
        c2[16, 2] := 0.7194819894416505e-1;
      <font color="blue">elseif </font>order == 33<font color="blue"> then</font>
        alpha := 0.1496489351138032;
        c1[1] := 0.3009752799176432;
        c2[1, 1] := 0.9041725460994505e-1;
        c2[1, 2] := 0.5995521047364046;
        c2[2, 1] := 0.8991117804113002e-1;
        c2[2, 2] := 0.5923764112099496;
        c2[3, 1] := 0.8906941547422532e-1;
        c2[3, 2] := 0.5804822013853129;
        c2[4, 1] := 0.8789442491445575e-1;
        c2[4, 2] := 0.5639663528946501;
        c2[5, 1] := 0.8638945831033775e-1;
        c2[5, 2] := 0.5429623519607796;
        c2[6, 1] := 0.8455834602616358e-1;
        c2[6, 2] := 0.5176379938389326;
        c2[7, 1] := 0.8240517431382334e-1;
        c2[7, 2] := 0.4881921474066189;
        c2[8, 1] := 0.7993380417355076e-1;
        c2[8, 2] := 0.4548502528082586;
        c2[9, 1] := 0.7714713890732801e-1;
        c2[9, 2] := 0.4178579388038483;
        c2[10, 1] := 0.7404596598181127e-1;
        c2[10, 2] := 0.3774715722484659;
        c2[11, 1] := 0.7062702339160462e-1;
        c2[11, 2] := 0.3339432938810453;
        c2[12, 1] := 0.6687952672391507e-1;
        c2[12, 2] := 0.2874950693388235;
        c2[13, 1] := 0.6277828912909767e-1;
        c2[13, 2] := 0.2382680702894708;
        c2[14, 1] := 0.5826808305383988e-1;
        c2[14, 2] := 0.1862073169968455;
        c2[15, 1] := 0.5321974125363517e-1;
        c2[15, 2] := 0.1307323751236313;
        c2[16, 1] := 0.4724820282032780e-1;
        c2[16, 2] := 0.6933542082177094e-1;
      <font color="blue">elseif </font>order == 34<font color="blue"> then</font>
        alpha := 0.1473858373968463;
        c2[1, 1] := 0.8801537152275983e-1;
        c2[1, 2] := 0.5929204288972172;
        c2[2, 1] := 0.8770594341007476e-1;
        c2[2, 2] := 0.5884653382247518;
        c2[3, 1] := 0.8708797598072095e-1;
        c2[3, 2] := 0.5795895850253119;
        c2[4, 1] := 0.8616320590689187e-1;
        c2[4, 2] := 0.5663615383647170;
        c2[5, 1] := 0.8493413175570858e-1;
        c2[5, 2] := 0.5488825092350877;
        c2[6, 1] := 0.8340387368687513e-1;
        c2[6, 2] := 0.5272851839324592;
        c2[7, 1] := 0.8157596213131521e-1;
        c2[7, 2] := 0.5017313864372913;
        c2[8, 1] := 0.7945402670834270e-1;
        c2[8, 2] := 0.4724089864574216;
        c2[9, 1] := 0.7704133559556429e-1;
        c2[9, 2] := 0.4395276256463053;
        c2[10, 1] := 0.7434009635219704e-1;
        c2[10, 2] := 0.4033126590648964;
        c2[11, 1] := 0.7135035113853376e-1;
        c2[11, 2] := 0.3639961488919042;
        c2[12, 1] := 0.6806813160738834e-1;
        c2[12, 2] := 0.3218025212900124;
        c2[13, 1] := 0.6448214312000864e-1;
        c2[13, 2] := 0.2769235521088158;
        c2[14, 1] := 0.6056719318430530e-1;
        c2[14, 2] := 0.2294693573271038;
        c2[15, 1] := 0.5626925196925040e-1;
        c2[15, 2] := 0.1793564218840015;
        c2[16, 1] := 0.5146352031547277e-1;
        c2[16, 2] := 0.1259877129326412;
        c2[17, 1] := 0.4578069074410591e-1;
        c2[17, 2] := 0.6689147319568768e-1;
      <font color="blue">elseif </font>order == 35<font color="blue"> then</font>
        alpha := 0.1452224267615486;
        c1[1] := 0.2926764667564367;
        c2[1, 1] := 0.8551731299267280e-1;
        c2[1, 2] := 0.5832758214629523;
        c2[2, 1] := 0.8509109732853060e-1;
        c2[2, 2] := 0.5770596582643844;
        c2[3, 1] := 0.8438201446671953e-1;
        c2[3, 2] := 0.5667497616665494;
        c2[4, 1] := 0.8339191981579831e-1;
        c2[4, 2] := 0.5524209816238369;
        c2[5, 1] := 0.8212328610083385e-1;
        c2[5, 2] := 0.5341766459916322;
        c2[6, 1] := 0.8057906332198853e-1;
        c2[6, 2] := 0.5121470053512750;
        c2[7, 1] := 0.7876247299954955e-1;
        c2[7, 2] := 0.4864870722254752;
        c2[8, 1] := 0.7667670879950268e-1;
        c2[8, 2] := 0.4573736721705665;
        c2[9, 1] := 0.7432449556218945e-1;
        c2[9, 2] := 0.4250013835198991;
        c2[10, 1] := 0.7170742126011575e-1;
        c2[10, 2] := 0.3895767735915445;
        c2[11, 1] := 0.6882488171701314e-1;
        c2[11, 2] := 0.3513097926737368;
        c2[12, 1] := 0.6567231746957568e-1;
        c2[12, 2] := 0.3103999917596611;
        c2[13, 1] := 0.6223804362223595e-1;
        c2[13, 2] := 0.2670123611280899;
        c2[14, 1] := 0.5849696460782910e-1;
        c2[14, 2] := 0.2212298104867592;
        c2[15, 1] := 0.5439628409499822e-1;
        c2[15, 2] := 0.1729443731341637;
        c2[16, 1] := 0.4981540179136920e-1;
        c2[16, 2] := 0.1215462157134930;
        c2[17, 1] := 0.4439981033536435e-1;
        c2[17, 2] := 0.6460098363520967e-1;
      <font color="blue">elseif </font>order == 36<font color="blue"> then</font>
        alpha := 0.1431515914458580;
        c2[1, 1] := 0.8335881847130301e-1;
        c2[1, 2] := 0.5770670512160201;
        c2[2, 1] := 0.8309698922852212e-1;
        c2[2, 2] := 0.5731929100172432;
        c2[3, 1] := 0.8257400347039723e-1;
        c2[3, 2] := 0.5654713811993058;
        c2[4, 1] := 0.8179117911600136e-1;
        c2[4, 2] := 0.5539556343603020;
        c2[5, 1] := 0.8075042173126963e-1;
        c2[5, 2] := 0.5387245649546684;
        c2[6, 1] := 0.7945413151258206e-1;
        c2[6, 2] := 0.5198817177723069;
        c2[7, 1] := 0.7790506514288866e-1;
        c2[7, 2] := 0.4975537629595409;
        c2[8, 1] := 0.7610613635339480e-1;
        c2[8, 2] := 0.4718884193866789;
        c2[9, 1] := 0.7406012816626425e-1;
        c2[9, 2] := 0.4430516443136726;
        c2[10, 1] := 0.7176927060205631e-1;
        c2[10, 2] := 0.4112237708115829;
        c2[11, 1] := 0.6923460172504251e-1;
        c2[11, 2] := 0.3765940116389730;
        c2[12, 1] := 0.6645495833489556e-1;
        c2[12, 2] := 0.3393522147815403;
        c2[13, 1] := 0.6342528888937094e-1;
        c2[13, 2] := 0.2996755899575573;
        c2[14, 1] := 0.6013361864949449e-1;
        c2[14, 2] := 0.2577053294053830;
        c2[15, 1] := 0.5655503081322404e-1;
        c2[15, 2] := 0.2135004731531631;
        c2[16, 1] := 0.5263798119559069e-1;
        c2[16, 2] := 0.1669320999865636;
        c2[17, 1] := 0.4826589873626196e-1;
        c2[17, 2] := 0.1173807590715484;
        c2[18, 1] := 0.4309819397289806e-1;
        c2[18, 2] := 0.6245036108880222e-1;
      <font color="blue">elseif </font>order == 37<font color="blue"> then</font>
        alpha := 0.1411669104782917;
        c1[1] := 0.2850271036215707;
        c2[1, 1] := 0.8111958235023328e-1;
        c2[1, 2] := 0.5682412610563970;
        c2[2, 1] := 0.8075727567979578e-1;
        c2[2, 2] := 0.5628142923227016;
        c2[3, 1] := 0.8015440554413301e-1;
        c2[3, 2] := 0.5538087696879930;
        c2[4, 1] := 0.7931239302677386e-1;
        c2[4, 2] := 0.5412833323304460;
        c2[5, 1] := 0.7823314328639347e-1;
        c2[5, 2] := 0.5253190555393968;
        c2[6, 1] := 0.7691895211595101e-1;
        c2[6, 2] := 0.5060183741977191;
        c2[7, 1] := 0.7537237072011853e-1;
        c2[7, 2] := 0.4835036020049034;
        c2[8, 1] := 0.7359601294804538e-1;
        c2[8, 2] := 0.4579149413954837;
        c2[9, 1] := 0.7159227884849299e-1;
        c2[9, 2] := 0.4294078049978829;
        c2[10, 1] := 0.6936295002846032e-1;
        c2[10, 2] := 0.3981491350382047;
        c2[11, 1] := 0.6690857785828917e-1;
        c2[11, 2] := 0.3643121502867948;
        c2[12, 1] := 0.6422751692085542e-1;
        c2[12, 2] := 0.3280684291406284;
        c2[13, 1] := 0.6131430866206096e-1;
        c2[13, 2] := 0.2895750997170303;
        c2[14, 1] := 0.5815677249570920e-1;
        c2[14, 2] := 0.2489521814805720;
        c2[15, 1] := 0.5473023527947980e-1;
        c2[15, 2] := 0.2062377435955363;
        c2[16, 1] := 0.5098441033167034e-1;
        c2[16, 2] := 0.1612849131645336;
        c2[17, 1] := 0.4680658811093562e-1;
        c2[17, 2] := 0.1134672937045305;
        c2[18, 1] := 0.4186928031694695e-1;
        c2[18, 2] := 0.6042754777339966e-1;
      <font color="blue">elseif </font>order == 38<font color="blue"> then</font>
        alpha := 0.1392625697140030;
        c2[1, 1] := 0.7916943373658329e-1;
        c2[1, 2] := 0.5624158631591745;
        c2[2, 1] := 0.7894592250257840e-1;
        c2[2, 2] := 0.5590219398777304;
        c2[3, 1] := 0.7849941672384930e-1;
        c2[3, 2] := 0.5522551628416841;
        c2[4, 1] := 0.7783093084875645e-1;
        c2[4, 2] := 0.5421574325808380;
        c2[5, 1] := 0.7694193770482690e-1;
        c2[5, 2] := 0.5287909941093643;
        c2[6, 1] := 0.7583430534712885e-1;
        c2[6, 2] := 0.5122376814029880;
        c2[7, 1] := 0.7451020436122948e-1;
        c2[7, 2] := 0.4925978555548549;
        c2[8, 1] := 0.7297197617673508e-1;
        c2[8, 2] := 0.4699889739625235;
        c2[9, 1] := 0.7122194706992953e-1;
        c2[9, 2] := 0.4445436860615774;
        c2[10, 1] := 0.6926216260386816e-1;
        c2[10, 2] := 0.4164072786327193;
        c2[11, 1] := 0.6709399961255503e-1;
        c2[11, 2] := 0.3857341621868851;
        c2[12, 1] := 0.6471757977022456e-1;
        c2[12, 2] := 0.3526828388476838;
        c2[13, 1] := 0.6213084287116965e-1;
        c2[13, 2] := 0.3174082831364342;
        c2[14, 1] := 0.5932799638550641e-1;
        c2[14, 2] := 0.2800495563550299;
        c2[15, 1] := 0.5629672408524944e-1;
        c2[15, 2] := 0.2407078154782509;
        c2[16, 1] := 0.5301264751544952e-1;
        c2[16, 2] := 0.1994026830553859;
        c2[17, 1] := 0.4942673259817896e-1;
        c2[17, 2] := 0.1559719194038917;
        c2[18, 1] := 0.4542996716979947e-1;
        c2[18, 2] := 0.1097844277878470;
        c2[19, 1] := 0.4070720755433961e-1;
        c2[19, 2] := 0.5852181110523043e-1;
      <font color="blue">elseif </font>order == 39<font color="blue"> then</font>
        alpha := 0.1374332900196804;
        c1[1] := 0.2779468246419593;
        c2[1, 1] := 0.7715084161825772e-1;
        c2[1, 2] := 0.5543001331300056;
        c2[2, 1] := 0.7684028301163326e-1;
        c2[2, 2] := 0.5495289890712267;
        c2[3, 1] := 0.7632343924866024e-1;
        c2[3, 2] := 0.5416083298429741;
        c2[4, 1] := 0.7560141319808483e-1;
        c2[4, 2] := 0.5305846713929198;
        c2[5, 1] := 0.7467569064745969e-1;
        c2[5, 2] := 0.5165224112570647;
        c2[6, 1] := 0.7354807648551346e-1;
        c2[6, 2] := 0.4995030679271456;
        c2[7, 1] := 0.7222060351121389e-1;
        c2[7, 2] := 0.4796242430956156;
        c2[8, 1] := 0.7069540462458585e-1;
        c2[8, 2] := 0.4569982440368368;
        c2[9, 1] := 0.6897453353492381e-1;
        c2[9, 2] := 0.4317502624832354;
        c2[10, 1] := 0.6705970959388781e-1;
        c2[10, 2] := 0.4040159353969854;
        c2[11, 1] := 0.6495194541066725e-1;
        c2[11, 2] := 0.3739379843169939;
        c2[12, 1] := 0.6265098412417610e-1;
        c2[12, 2] := 0.3416613843816217;
        c2[13, 1] := 0.6015440984955930e-1;
        c2[13, 2] := 0.3073260166338746;
        c2[14, 1] := 0.5745615876877304e-1;
        c2[14, 2] := 0.2710546723961181;
        c2[15, 1] := 0.5454383762391338e-1;
        c2[15, 2] := 0.2329316824061170;
        c2[16, 1] := 0.5139340231935751e-1;
        c2[16, 2] := 0.1929604256043231;
        c2[17, 1] := 0.4795705862458131e-1;
        c2[17, 2] := 0.1509655259246037;
        c2[18, 1] := 0.4412933231935506e-1;
        c2[18, 2] := 0.1063130748962878;
        c2[19, 1] := 0.3960672309405603e-1;
        c2[19, 2] := 0.5672356837211527e-1;
      <font color="blue">elseif </font>order == 40<font color="blue"> then</font>
        alpha := 0.1356742655825434;
        c2[1, 1] := 0.7538038374294594e-1;
        c2[1, 2] := 0.5488228264329617;
        c2[2, 1] := 0.7518806529402738e-1;
        c2[2, 2] := 0.5458297722483311;
        c2[3, 1] := 0.7480383050347119e-1;
        c2[3, 2] := 0.5398604576730540;
        c2[4, 1] := 0.7422847031965465e-1;
        c2[4, 2] := 0.5309482987446206;
        c2[5, 1] := 0.7346313704205006e-1;
        c2[5, 2] := 0.5191429845322307;
        c2[6, 1] := 0.7250930053201402e-1;
        c2[6, 2] := 0.5045099368431007;
        c2[7, 1] := 0.7136868456879621e-1;
        c2[7, 2] := 0.4871295553902607;
        c2[8, 1] := 0.7004317764946634e-1;
        c2[8, 2] := 0.4670962098860498;
        c2[9, 1] := 0.6853470921527828e-1;
        c2[9, 2] := 0.4445169164956202;
        c2[10, 1] := 0.6684507689945471e-1;
        c2[10, 2] := 0.4195095960479698;
        c2[11, 1] := 0.6497570123412630e-1;
        c2[11, 2] := 0.3922007419030645;
        c2[12, 1] := 0.6292726794917847e-1;
        c2[12, 2] := 0.3627221993494397;
        c2[13, 1] := 0.6069918741663154e-1;
        c2[13, 2] := 0.3312065181294388;
        c2[14, 1] := 0.5828873983769410e-1;
        c2[14, 2] := 0.2977798532686911;
        c2[15, 1] := 0.5568964389813015e-1;
        c2[15, 2] := 0.2625503293999835;
        c2[16, 1] := 0.5288947816690705e-1;
        c2[16, 2] := 0.2255872486520188;
        c2[17, 1] := 0.4986456327645859e-1;
        c2[17, 2] := 0.1868796731919594;
        c2[18, 1] := 0.4656832613054458e-1;
        c2[18, 2] := 0.1462410193532463;
        c2[19, 1] := 0.4289867647614935e-1;
        c2[19, 2] := 0.1030361558710747;
        c2[20, 1] := 0.3856310684054106e-1;
        c2[20, 2] := 0.5502423832293889e-1;
      <font color="blue">elseif </font>order == 41<font color="blue"> then</font>
        alpha := 0.1339811106984253;
        c1[1] := 0.2713685065531391;
        c2[1, 1] := 0.7355140275160984e-1;
        c2[1, 2] := 0.5413274778282860;
        c2[2, 1] := 0.7328319082267173e-1;
        c2[2, 2] := 0.5371064088294270;
        c2[3, 1] := 0.7283676160772547e-1;
        c2[3, 2] := 0.5300963437270770;
        c2[4, 1] := 0.7221298133014343e-1;
        c2[4, 2] := 0.5203345998371490;
        c2[5, 1] := 0.7141302173623395e-1;
        c2[5, 2] := 0.5078728971879841;
        c2[6, 1] := 0.7043831559982149e-1;
        c2[6, 2] := 0.4927768111819803;
        c2[7, 1] := 0.6929049381827268e-1;
        c2[7, 2] := 0.4751250308594139;
        c2[8, 1] := 0.6797129849758392e-1;
        c2[8, 2] := 0.4550083840638406;
        c2[9, 1] := 0.6648246325101609e-1;
        c2[9, 2] := 0.4325285673076087;
        c2[10, 1] := 0.6482554675958526e-1;
        c2[10, 2] := 0.4077964789091151;
        c2[11, 1] := 0.6300169683004558e-1;
        c2[11, 2] := 0.3809299858742483;
        c2[12, 1] := 0.6101130648543355e-1;
        c2[12, 2] := 0.3520508315700898;
        c2[13, 1] := 0.5885349417435808e-1;
        c2[13, 2] := 0.3212801560701271;
        c2[14, 1] := 0.5652528148656809e-1;
        c2[14, 2] := 0.2887316252774887;
        c2[15, 1] := 0.5402021575818373e-1;
        c2[15, 2] := 0.2545001287790888;
        c2[16, 1] := 0.5132588802608274e-1;
        c2[16, 2] := 0.2186415296842951;
        c2[17, 1] := 0.4841900639702602e-1;
        c2[17, 2] := 0.1811322622296060;
        c2[18, 1] := 0.4525419574485134e-1;
        c2[18, 2] := 0.1417762065404688;
        c2[19, 1] := 0.4173260173087802e-1;
        c2[19, 2] := 0.9993834530966510e-1;
        c2[20, 1] := 0.3757210572966463e-1;
        c2[20, 2] := 0.5341611499960143e-1;
      <font color="blue">else</font>
        <font color="red">Streams.error</font>(&quot;Input argument order (= &quot; + <font color="red">String</font>(order) +
          &quot;) of Bessel filter is not in the range 1..41&quot;);
      <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>BesselCoefficients</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Internal.'p+a'"><font color="blue">function</font> &#39;p+a&#39;
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> p;
      <font color="blue">input </font>Real a;
      <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> c;
    <font color="blue">protected </font>
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> j = <font color="red">Modelica_LinearSystems2.Math.Complex.j</font>();
    <font color="blue">algorithm </font>
      c := p.re + p.im*j +a;
    <font color="blue">end </font>&#39;p+a&#39;</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Internal.'p^2+k[1]*p+k[2]'"><font color="blue">function</font> &#39;p^2+k[1]*p+k[2]&#39;
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams.print"
>Modelica.Utilities.Streams.print</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> p;
      <font color="blue">input </font>Real k[2];
      <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> c;
    <font color="blue">protected </font>
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> c1;
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> c2;
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> c3;
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> c4;
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> j = <font color="red">Modelica_LinearSystems2.Math.Complex.j</font>();
    <font color="blue">algorithm </font>
      c := p.re^2 - p.im^2 + k[1]*p.re + k[2]+p.im*(2*p.re + k[1])*j;

    <font color="blue">end </font>&#39;p^2+k[1]*p+k[2]&#39;</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Internal.roots"><font color="blue">function</font> roots <font color="darkgreen">&quot;Determine zeros of factorized polynomial&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

      <font color="blue">input </font>Real poly1[:] <font color="darkgreen">&quot;[p^0] coefficients of first order polynomials&quot;</font>;
      <font color="blue">input </font>Real poly2[:,2] <font color="darkgreen">&quot;[p, p^0] coefficients of second order polynomials&quot;</font>;
      <font color="blue">input </font>Integer n_real <font color="darkgreen">
        &quot;Number of real zeros computed with Internal.numberOfRealZeros&quot;</font>;
      <font color="blue">output </font>Real realZeros[n_real] <font color="darkgreen">&quot;All real zeros of poly1 and poly2&quot;</font>;
      <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> complexZeros[:]=<font color="red">fill</font>(<font color="red">Complex</font>(0, 0), <font color="red">integer</font>((<font color="red">size</font>(poly1, 1)
           + 2*<font color="red">size</font>(poly2, 1) - n_real)/2)) <font color="darkgreen">
        &quot;All complex zeros of poly1 and poly2; for a complex conjugate pair, only one zero is stored&quot;</font>;
    <font color="blue">protected </font>
      Integer np1=<font color="red">size</font>(poly1, 1);
      Integer np2=<font color="red">size</font>(poly2, 1);
      Real D;
      Real D2;
      Real b;
      Integer j1;
      Integer j2;
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> j = <font color="red">Modelica_LinearSystems2.Math.Complex.j</font>();

    <font color="blue">algorithm </font>
      <font color="red">assert</font>(np1 &lt;= n_real, &quot;Size of poly1 = &quot; + <font color="red">String</font>(np1) + &quot; &gt; n_real &quot; +
        &quot; (= &quot; + <font color="red">String</font>(n_real) + &quot;).&quot;);
      <font color="blue">for </font>i<font color="blue"> in </font>1:np1<font color="blue"> loop</font>
        realZeros[i] := -poly1[i];
      <font color="blue">end for</font>;

      j1 := np1 + 1;
      j2 := 1;
      <font color="blue">for </font>i<font color="blue"> in </font>1:np2<font color="blue"> loop</font>
        b := poly2[i, 1]/2;
        D := b*b - poly2[i, 2];
        D2 := <font color="red">sqrt</font>(<font color="red">abs</font>(D));
        <font color="blue">if </font>D &gt;= 0<font color="blue"> then</font>
          realZeros[j1] := -b + D2;
          realZeros[j1 + 1] := -b - D2;
          j1 := j1 + 2;
        <font color="blue">else</font>
          complexZeros[j2] := -b+D2*j;
          j2 := j2 + 1;
        <font color="blue">end if</font>;
      <font color="blue">end for</font>;
    <font color="blue">end </font>roots</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Internal.frequencyRange"><font color="blue">function</font> frequencyRange <font color="darkgreen">
      &quot;Determine min. and max. resonance frequencies&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

      <font color="blue">input </font>Real poly1[:];
      <font color="blue">input </font>Real poly2[:,2];
      <font color="blue">output </font>Boolean w_found=false;
      <font color="blue">output </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>Modelica.SIunits.AngularVelocity</A> w_min;
      <font color="blue">output </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>Modelica.SIunits.AngularVelocity</A> w_max;
    <font color="blue">protected </font>
      Integer order=<font color="red">size</font>(poly1, 1) + 2*<font color="red">size</font>(poly2, 1);
      Integer n_real=<font color="red">numberOfRealZeros</font>(poly1, poly2);
      Real zeros1[n_real];
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> zeros2[:]=<font color="red">fill</font>(<font color="red">Complex</font>(0, 0), <font color="red">integer</font>((order - n_real)/2));
      Real w;
    <font color="blue">algorithm </font>
      <font color="darkgreen">// Compute zeros</font>
      (zeros1,zeros2) := <font color="red">roots</font>(
            poly1,
            poly2,
            n_real);

      <font color="darkgreen">// Compute resonance frequencies</font>
      w_min := Modelica.Constants.inf;
      w_max := -Modelica.Constants.inf;
      <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(zeros1, 1)<font color="blue"> loop</font>
        <font color="blue">if </font>zeros1[i] &lt;&gt; 0<font color="blue"> then</font>
          w := <font color="red">abs</font>(zeros1[i]);
          w_min := <font color="red">min</font>(w_min, w);
          w_max := <font color="red">max</font>(w_max, w);
          w_found := true;
        <font color="blue">end if</font>;
      <font color="blue">end for</font>;

      <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(zeros2, 1)<font color="blue"> loop</font>
        w := <font color="red">Complex.&#39;abs&#39;</font>(zeros2[i]);
        w_min := <font color="red">min</font>(w_min, w);
        w_max := <font color="red">max</font>(w_max, w);
        w_found := true;
      <font color="blue">end for</font>;
    <font color="blue">end </font>frequencyRange</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Internal.frequencyRangeBode"><font color="blue">function</font> frequencyRangeBode <font color="darkgreen">
      &quot;Determine min. and max. frequencies for Bode plot&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> tf <font color="darkgreen">&quot;ZerosAndPoles transfer function&quot;</font>;
      <font color="blue">output </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>Modelica.SIunits.AngularVelocity</A> w_min;
      <font color="blue">output </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>Modelica.SIunits.AngularVelocity</A> w_max;
    <font color="blue">protected </font>
      Real phi_min=<font color="red">Modelica.SIunits.Conversions.from_deg</font>(3);
      Real real_min=1.0e-4;
      Real pi=Modelica.Constants.pi;
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> numZeros[:];
      <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> denZeros[:];
      Integer n_num;
      Integer n_den;
      Real w_min1;
      Real w_min2;
      Real w_max1;
      Real w_max2;
    <font color="blue">algorithm </font>
      <font color="darkgreen">// Compute zeros and poles</font>
      (numZeros,denZeros) := <font color="red">ZerosAndPoles.Analysis.zerosAndPoles</font>(tf);

      <font color="darkgreen">// Compute frequencies for numerator</font>
      n_num := <font color="red">size</font>(numZeros, 1);
      <font color="blue">if </font>n_num &gt; 0<font color="blue"> then</font>
        (w_min1,w_max1) := <font color="red">Modelica_LinearSystems2.Internal.frequencyRangeZeros</font>(
              numZeros,
              phi_min,
              real_min);
      <font color="blue">end if</font>;

      <font color="darkgreen">// Compute frequencies for denominator</font>
      n_den := <font color="red">size</font>(denZeros, 1);
      <font color="blue">if </font>n_den &gt; 0<font color="blue"> then</font>
        (w_min2,w_max2) := <font color="red">Modelica_LinearSystems2.Internal.frequencyRangeZeros</font>(
              denZeros,
              phi_min,
              real_min);
      <font color="blue">end if</font>;

      <font color="darkgreen">// Use largest range</font>
      <font color="blue">if </font>n_num == 0<font color="blue"> and </font>n_den == 0<font color="blue"> then</font>
        w_min := 0.1;
        w_max := 10;
      <font color="blue">elseif </font>n_num == 0<font color="blue"> then</font>
        w_min := w_min2;
        w_max := w_max2;
      <font color="blue">elseif </font>n_den == 0<font color="blue"> then</font>
        w_min := w_min1;
        w_max := w_max1;
      <font color="blue">else</font>
        w_min := <font color="red">min</font>(w_min1, w_min2);
        w_max := <font color="red">max</font>(w_max1, w_max2);
      <font color="blue">end if</font>;
    <font color="blue">end </font>frequencyRangeBode</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Internal.filterToNormalized"><font color="blue">function</font> filterToNormalized <font color="darkgreen">
      &quot;Given [p^2,p] and [p] coefficients, transform to normalized form with highest power of p equal 1&quot;</font>

      <font color="blue">input </font>Real c1[:] <font color="darkgreen">&quot;[p] coefficients of polynomials (a*p + 1)&quot;</font>;
      <font color="blue">input </font>Real c2[:,2] <font color="darkgreen">
        &quot;[p^2, p] coefficients of polynomials (b*p^2 + a*p + 1)&quot;</font>;
      <font color="blue">output </font>Real n1[<font color="red">size</font>(c1, 1)] <font color="darkgreen">&quot;[p^0] coefficients of polynomials a*(p+1/a)&quot;</font>;
      <font color="blue">output </font>Real n2[<font color="red">size</font>(c2, 1),2] <font color="darkgreen">
        &quot;[p, p^0] coefficients of polynomials b*(p^2 + (a/b)*p + (1/b))&quot;</font>;
      <font color="blue">output </font>Real k <font color="darkgreen">&quot;Gain (product(1/a)*(1/b)&quot;</font>;
    <font color="blue">algorithm </font>
      k := 1.0;
      <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(c1, 1)<font color="blue"> loop</font>
        k := k*c1[i];
        n1[i] := 1/c1[i];
      <font color="blue">end for</font>;

      <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(c2, 1)<font color="blue"> loop</font>
        k := k*c2[i, 1];
        n2[i, 1] := c2[i, 2]/c2[i, 1];
        n2[i, 2] := 1/c2[i, 1];
      <font color="blue">end for</font>;
    <font color="blue">end </font>filterToNormalized</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Internal.numberOfRealZeros"><font color="blue">encapsulated </font><font color="blue">function</font> numberOfRealZeros <font color="darkgreen">
      &quot;Calculate number of real zeros&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;

      <font color="blue">input </font>Real poly1[:];
      <font color="blue">input </font>Real poly2[:,2];
      <font color="blue">output </font>Integer result <font color="darkgreen">&quot;Number of real zeros&quot;</font>;
    <font color="blue">protected </font>
      Real D;
    <font color="blue">algorithm </font>
      result := <font color="red">size</font>(poly1, 1);
      <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(poly2, 1)<font color="blue"> loop</font>
        D := (poly2[i, 1]/2)^2 - poly2[i, 2];
        <font color="blue">if </font>D &gt;= 0<font color="blue"> then</font>
            <font color="darkgreen">// two real zeros</font>
          result := result + 2;
        <font color="blue">end if</font>;
      <font color="blue">end for</font>;
    <font color="blue">end </font>numberOfRealZeros</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Internal.numberOfRealZeros2"><font color="blue">function</font> numberOfRealZeros2 <font color="darkgreen">&quot;Calculate number of real zeros&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Modelica_LinearSystems2.Math.Polynomial</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf <font color="darkgreen">&quot;TransferFunction&quot;</font>;
      <font color="blue">output </font>Integer result=<font color="red">Internal.numberOfRealZeros</font>(<font color="red">Polynomial.roots</font>(<font color="red">Polynomial</font>(tf.n)));
    <font color="blue">algorithm </font>
    <font color="blue">end </font>numberOfRealZeros2</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Internal.numberOfRealPoles"><font color="blue">function</font> numberOfRealPoles <font color="darkgreen">&quot;Calculate number of real poles&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Modelica_LinearSystems2.Math.Polynomial</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf <font color="darkgreen">&quot;TransferFunction&quot;</font>;
    <font color="blue">output </font>Integer result=<font color="red">Internal.numberOfRealZeros</font>(<font color="red">Polynomial.roots</font>(<font color="red">Polynomial</font>(tf.d)));
    <font color="blue">algorithm </font>
    <font color="blue">end </font>numberOfRealPoles</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Internal.isRoot"><font color="blue">function</font> isRoot <font color="darkgreen">
      &quot;check if frequency is an element of the complex vector zeros&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="darkgreen">//import Modelica_LinearSystems2;</font>

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> zeros[:];
      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> p;
    <font color="darkgreen">//Never used</font>
      <font color="blue">input </font>Real eps(min=0) = 0;
      <font color="blue">output </font>Boolean result;

    <font color="blue">protected </font>
      Integer sz=<font color="red">size</font>(zeros, 1);
      Integer i;

    <font color="blue">algorithm </font>
      i := 1;
      result := false;
      <font color="blue">while </font>i &lt;= sz<font color="blue"> and </font><font color="blue">not </font>result<font color="blue"> loop</font>

    <font color="darkgreen">//The implementation of Complex.&#39;==&#39; does not take a third parameter.</font>
        result := p == zeros[i];
        i := i + 1;
      <font color="blue">end while</font>;

    <font color="blue">end </font>isRoot</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Internal.numberOfRealZerosAndPoles_zp"><font color="blue">function</font> numberOfRealZerosAndPoles_zp <font color="darkgreen">
      &quot;Get the number of first oder polynomials (n1, d1) and second order polynomials (n2, d2) of zeros and poles from zeros and poles written in a MAT-file&quot;</font>

      <font color="blue">import </font>Modelica_LinearSystems2.DataDir;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>;

      <font color="blue">input </font>String fileName=DataDir + &quot;/zp.mat&quot; <font color="darkgreen">
        &quot;Name of the zeros and poles data file&quot;</font>;
      <font color="blue">input </font>Real eps=Modelica.Constants.eps;

      <font color="blue">output </font>Integer n1n2d1d2[4];

    <font color="blue">protected </font>
      Integer n1;
      Integer d1;

      Integer zSize[2]=<font color="red">readMatrixSize</font>(fileName, &quot;z&quot;);
      Integer pSize[2]=<font color="red">readMatrixSize</font>(fileName, &quot;p&quot;);

      Real zerosMatrix[zSize[1],zSize[2]]=<font color="red">readMatrix</font>(
              fileName,
              &quot;z&quot;,
              zSize[1],
              zSize[2]) <font color="darkgreen">&quot;zeros in rows of real parts and imaginary parts&quot;</font>;
      Real polesMatrix[pSize[1],pSize[2]]=<font color="red">readMatrix</font>(
              fileName,
              &quot;p&quot;,
              pSize[1],
              pSize[2]) <font color="darkgreen">&quot;poles in rows of real parts and imaginary parts&quot;</font>;

    <font color="blue">algorithm </font>
      n1 := zSize[1];
      d1 := pSize[1];
      <font color="blue">for </font>i<font color="blue"> in </font>1:zSize[1]<font color="blue"> loop</font>
        <font color="blue">if </font><font color="red">abs</font>(zerosMatrix[i, 2]) &gt;= eps<font color="blue"> then</font>
          n1 := n1 - 1;
        <font color="blue">end if</font>;
      <font color="blue">end for</font>;
      <font color="blue">for </font>i<font color="blue"> in </font>1:pSize[1]<font color="blue"> loop</font>
        <font color="blue">if </font><font color="red">abs</font>(polesMatrix[i, 2]) &gt;= eps<font color="blue"> then</font>
          d1 := d1 - 1;
        <font color="blue">end if</font>;
      <font color="blue">end for</font>;
      n1n2d1d2[1] := n1;
      n1n2d1d2[2] := <font color="red">div</font>((zSize[1] - n1), 2);
      n1n2d1d2[3] := d1;
      n1n2d1d2[4] := <font color="red">div</font>((pSize[1] - d1), 2);

    <font color="blue">end </font>numberOfRealZerosAndPoles_zp</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Internal.numberOfRealZerosAndPoles_pc"><font color="blue">function</font> numberOfRealZerosAndPoles_pc <font color="darkgreen">
      &quot;Generate a zeros and poles data record by reading the polynomial coefficients from a file (default file name is zp.mat)&quot;</font>
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;

      <font color="blue">input </font>String fileName=&quot;pc.mat&quot; <font color="darkgreen">&quot;Name of the zeros and poles data file&quot;</font>;
      <font color="blue">output </font>Integer n1n2d1d2[4];

    <font color="blue">protected </font>
      Integer n1Size[2]=<font color="red">readMatrixSize</font>(fileName, &quot;n1&quot;);
      Integer n2Size[2]=<font color="red">readMatrixSize</font>(fileName, &quot;n2&quot;);
      Integer d1Size[2]=<font color="red">readMatrixSize</font>(fileName, &quot;d1&quot;);
      Integer d2Size[2]=<font color="red">readMatrixSize</font>(fileName, &quot;d2&quot;);

    <font color="blue">algorithm </font>
      n1n2d1d2[1] := n1Size[1];
      n1n2d1d2[2] := n2Size[1];
      n1n2d1d2[3] := d1Size[1];
      n1n2d1d2[4] := d2Size[1];

    <font color="blue">end </font>numberOfRealZerosAndPoles_pc</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Internal.isControllableAndObservableSISO"><font color="blue">encapsulated </font><font color="blue">function</font> isControllableAndObservableSISO <font color="darkgreen">
      &quot;To check whether a SISO system is controllable and observable&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp;

      <font color="blue">output </font>Boolean controllableAndObservable;
    <font color="blue">protected </font>
      <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss=<font color="red">StateSpace</font>(zp);

    <font color="blue">algorithm </font>
      controllableAndObservable := <font color="red">StateSpace.Internal.isControllableAndObservableSISO</font>(ss=ss);

    <font color="blue">end </font>isControllableAndObservableSISO</textblock>;

  <font color="blue">end </font>Internal</textblock>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>ZerosAndPoles;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE DiscreteStateSpace<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.StateSpaceI.png" ALT="Modelica_LinearSystems2.DiscreteStateSpace" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.DiscreteStateSpace"></A><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>.DiscreteStateSpace</H2>
<B>Discrete state space description of a linear, time invariant difference equation system (data + operations)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This record defines a linear time invariant difference
equation system in state space form:
</p>
<pre>     <b>x</b>(Ts*(k+1)) = <b>A</b> * <b>x</b>(Ts*k) + <b>B</b> * <b>u</b>(Ts*k)
     <b>y</b>(Ts*k)     = <b>C</b> * <b>x</b>(Ts*k) + <b>D</b> * <b>u</b>(Ts*k)
     <b>x</b>_continuous(Ts*k) = <b>x</b>(Ts*k) + <b>B2</b> * <b>u</b>(Ts*k) 
</pre>
<p>
with
</p>
<ul>
<li> <b>Ts</b> - the sample time</li>
<li> <b>k</b> - the index of the actual sample instance (k=0,1,2,3,...)</li>
<li> <b>t</b> - the time</li>
<li> <b>u</b>(t) - the input vector,</li>
<li> <b>y</b>(t) - the output vector,</li>
<li> <b>x</b>(t) - the discrete state vector (x(t=Ts*0) is the initial state),</li>
<li> <b>x</b>_continuous(t) - the state vector of the continuous system
     from which the discrete block has been derived (details see below),</li>
<li> <b>A,B,C,D,B2</b> - matrices of appropriate dimensions.</li>
</ul>
<p>
A discrete system is usually derived by discretization from a 
continuous block, e.g., by function
LinearSystems.DiscreteStateSpace.fromStateSpace.
If the discretization method, e.g., the trapezoidal method,
accesses <b>actual and past</b> values of the input <b>u</b> 
(e.g. <b>u</b>(Ts*k), <b>u</b>(Ts*(k-1), <b>u</b>(Ts*(k-2))), 
a state transformation is needed to get the difference equation 
above where only the actual value <b>u</b>(Ts*k) is accessed. 
</p>
<p>
If the original continuous state vector should be computed
from the sampled data system above, the matrices of this 
transformation have to be known. For simplicity and efficiency,
here only the specific transformation used by function
LinearSystems.DiscreteStateSpace.fromStateSpace is stored in 
the data record of the discrete system via matrix <b>B2</b>.
Therefore, the state vector of the underlying continuous
system can be calculated by adding the term <b>B2</b>*<b>u</b> to the
state vector of the discretized system.
</p>
<p>
In Modelica notation, the difference equation above
can be implemented as:
</p>
<pre>
     <b>when</b> {<b>initial</b>(), <b>sample</b>(Ts,Ts)} <b>then</b>
        new_x = A * x + B * u;
            y = C * x + D * u;
            x = <b>pre</b>(new_x);
        x_continuous = x + B2 * u;
     <b>end when</b>;
</pre>
<p>
Since no "next value" operator is available in Modelica, an
auxiliary variable new_x stores the value of x for the
next sampling instant. The relationship between new_x and x
is defined via equation "x = <b>pre</b>(new_x)".
</p>
<p>
The body of the when-clause is active during initialization and at the
next sample instant t=Ts. Note, the when-equation is not
active after the initialization at t=0 (due to <b>sample</b>(Ts,Ts)), 
since the state x of the initialization has to be used also at t=0.
</p>
<p>
In library Blocks.<b>Controller</b> additional equations are
added for the initialization to uniquely compute the
initial vector x:
</p>
<pre>
  <b>initial equation</b> 
     <b>if</b> init == InitialState <b>then</b>
        x = x_start;
     <b>elseif</b> init == SteadyState <b>then</b>
        x = new_x;
     <b>end if</b>;
</pre>
<p>
Optionally, x is set to a given start vector x_start.
As <b>default initialization</b>, the equation "x = new_x" is
added that defines steady state initialization for the
discrete system. As a consequence, the output y(Ts*k), k=0,1,2,..,
remains constant after this initialization, 
provided the input vector u(Ts*k) remains constant.
</p>
<pre></PRE><P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Record"
>Modelica.Icons.Record</A> (Icon for a record).
<P><H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>new_x = A*x + B*u;  y = C*x + D*u;  x_cont = x + B2*u</TD></TR>
<TR><TD>Real</TD><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>B[size(A, 1), :]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>C[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>D[size(C, 1), size(B, 2)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>Data used to construct discrete from continuous system</TD></TR>
<TR><TD><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.Time"
>Time</A></TD><TD>Ts</TD><TD>1</TD><TD>Sample time [s]</TD></TR>
<TR><TD>Real</TD><TD>B2[size(B, 1), size(B, 2)]</TD><TD>fill(0, size(B, 1), size(B, ...</TD><TD>Reconstruct continuous state</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.Method"
>Method</A></TD><TD>method</TD><TD>Modelica_LinearSystems2.Type...</TD><TD>Discretization method</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">record</font> DiscreteStateSpace <font color="darkgreen">
  &quot;Discrete state space description of a linear, time invariant difference equation system (data + operations)&quot;</font>
  <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Record"
>Modelica.Icons.Record</A>;

  Real A[:,<font color="red">size</font>(A, 1)];
  Real B[<font color="red">size</font>(A, 1),:];
  Real C[:,<font color="red">size</font>(A, 1)];
  Real D[<font color="red">size</font>(C, 1),<font color="red">size</font>(B, 2)];

  <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.Time"
>Modelica.SIunits.Time</A> Ts=1 <font color="darkgreen">&quot;Sample time&quot;</font>;
  Real B2[<font color="red">size</font>(B, 1),<font color="red">size</font>(B, 2)]=<font color="red">fill</font>(0,<font color="red">size</font>(B,1),<font color="red">size</font>(B,2)) <font color="darkgreen">
    &quot;Reconstruct continuous state&quot;</font>;
  <A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.Method"
>Modelica_LinearSystems2.Types.Method</A> method=Modelica_LinearSystems2.Types.Method.Trapezoidal <font color="darkgreen">
    &quot;Discretization method&quot;</font>;

  <textblock type="packagesmall" expanded="false" path="Modelica_LinearSystems2.DiscreteStateSpace.'constructor'"><font color="blue">encapsulated </font><font color="blue">operator</font> &#39;constructor&#39;
    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.DiscreteStateSpace.'constructor'.fromMatrices"><font color="blue">function</font> fromMatrices <font color="darkgreen">
      &quot;Default constructor for a DiscreteStateSpace record&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.DiscreteStateSpace"
>Modelica_LinearSystems2.DiscreteStateSpace</A>;

      <font color="blue">input </font>Real A[:,<font color="red">size</font>(A, 1)];
      <font color="blue">input </font>Real B[<font color="red">size</font>(A, 1),:];
      <font color="blue">input </font>Real C[:,<font color="red">size</font>(A, 1)];
      <font color="blue">input </font>Real D[<font color="red">size</font>(C, 1),<font color="red">size</font>(B, 2)];

      <font color="blue">input </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.Time"
>Modelica.SIunits.Time</A> Ts=1 <font color="darkgreen">&quot;Sample time&quot;</font>;
      <font color="blue">input </font>Real B2[:,:]=<font color="red">zeros</font>(<font color="red">size</font>(B, 1), <font color="red">size</font>(B, 2));
      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.Method"
>Modelica_LinearSystems2.Types.Method</A> method=Modelica_LinearSystems2.Types.Method.Trapezoidal <font color="darkgreen">
        &quot;Discretization methodDiscretization method&quot;</font>;
      <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.DiscreteStateSpace"
>DiscreteStateSpace</A> result(
        <font color="blue">redeclare </font>Real A[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)],
        <font color="blue">redeclare </font>Real B[<font color="red">size</font>(B, 1),<font color="red">size</font>(B, 2)],
        <font color="blue">redeclare </font>Real C[<font color="red">size</font>(C, 1),<font color="red">size</font>(C, 2)],
        <font color="blue">redeclare </font>Real D[<font color="red">size</font>(D, 1),<font color="red">size</font>(D, 2)],
        <font color="blue">redeclare </font>Real B2[<font color="red">size</font>(B2, 1),<font color="red">size</font>(B2, 2)]);
    <font color="blue">algorithm </font>
      result.A := A;
      result.B := B;
      result.C := C;
      result.D := D;

      result.B2 := B2;
      result.Ts := Ts;
      result.method := method;
    <font color="blue">end </font>fromMatrices</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.DiscreteStateSpace.'constructor'.fromStateSpace"><font color="blue">function</font> fromStateSpace <font color="darkgreen">
      &quot;Transform a continuous into a discrete linear state space system&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.Method"
>Modelica_LinearSystems2.Types.Method</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.LU_solve2"
>Modelica_LinearSystems2.Math.Matrices.LU_solve2</A>;

      <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A> sc <font color="darkgreen">
        &quot;Continuous linear state space system&quot;</font>;
      <font color="blue">input </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.Time"
>Modelica.SIunits.Time</A> Ts <font color="darkgreen">&quot;Sample time&quot;</font>;
      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.Method"
>Modelica_LinearSystems2.Types.Method</A> method=Modelica_LinearSystems2.Types.Method.Trapezoidal <font color="darkgreen">
        &quot;Discretization method&quot;</font>;
      <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.DiscreteStateSpace"
>Modelica_LinearSystems2.DiscreteStateSpace</A> sd(
        <font color="blue">redeclare </font>Real A[<font color="red">size</font>(sc.A, 1),<font color="red">size</font>(sc.A, 2)],
        <font color="blue">redeclare </font>Real B[<font color="red">size</font>(sc.B, 1),<font color="red">size</font>(sc.B, 2)],
        <font color="blue">redeclare </font>Real C[<font color="red">size</font>(sc.C, 1),<font color="red">size</font>(sc.C, 2)],
        <font color="blue">redeclare </font>Real D[<font color="red">size</font>(sc.D, 1),<font color="red">size</font>(sc.D, 2)],
        <font color="blue">redeclare </font>Real B2[<font color="red">size</font>(sc.B, 1),<font color="red">size</font>(sc.B, 2)]) <font color="darkgreen">
        &quot;Discrete state space system&quot;</font>;

    <font color="blue">protected </font>
      Integer nx=<font color="red">size</font>(sc.A, 1) <font color="darkgreen">&quot;Number of states&quot;</font>;
      Integer nu=<font color="red">size</font>(sc.B, 2) <font color="darkgreen">&quot;Number of input signals&quot;</font>;
      Real LU[nx,nx] <font color="darkgreen">&quot;LU decomposition&quot;</font>;
      Integer pivots[nx] <font color="darkgreen">&quot;Pivots of LU decomposition&quot;</font>;
    <font color="blue">algorithm </font>
      sd.Ts := Ts;
      sd.method := method;

      <font color="blue">if </font>method == Method.ExplicitEuler<font color="blue"> then</font>
        <font color="darkgreen">    /*  der_x = A*x + B*u
             x = pre(x) + Ts*pre(der_x)
     */</font>
        sd.A := <font color="red">identity</font>(nx) + Ts*sc.A;
        sd.B := Ts*sc.B;
        sd.C := sc.C;
        sd.D := sc.D;
        sd.B2 := <font color="red">zeros</font>(nx, nu);

      <font color="blue">elseif </font>method == Method.ImplicitEuler<font color="blue"> then</font>
        <font color="darkgreen">    /*  der_x = A*x + B*u
             x = pre(x) + Ts*der_x 
     */</font>
        (LU,pivots) := <font color="red">Modelica_LinearSystems2.Math.Matrices.LU</font>(<font color="red">identity</font>(nx) -
          Ts*sc.A);
        sd.B2 := <font color="red">LU_solve2</font>(
              LU,
              pivots,
              Ts*sc.B);
        sd.A := <font color="red">LU_solve2</font>(
              LU,
              pivots,
              <font color="red">identity</font>(nx));
        sd.B := sd.A*sd.B2;
        sd.C := sc.C;
        sd.D := sd.C*sd.B2 + sc.D;

      <font color="blue">elseif </font>method == Method.Trapezoidal<font color="blue"> then</font>
        <font color="darkgreen">    /*  der_x = A*x + B*u
             x = pre_x + (Ts/2)*(pre_der_x + der_x); 
     */</font>
        (LU,pivots) := <font color="red">Modelica_LinearSystems2.Math.Matrices.LU</font>(<font color="red">identity</font>(nx) -
          (Ts/2)*sc.A);
        sd.B2 := <font color="red">LU_solve2</font>(
              LU,
              pivots,
              (Ts/2)*sc.B);
        sd.A := <font color="red">LU_solve2</font>(
              LU,
              pivots,
              <font color="red">identity</font>(nx) + (Ts/2)*sc.A);
        sd.B := sd.A*sd.B2 + sd.B2;
        sd.C := sc.C;
        sd.D := sd.C*sd.B2 + sc.D;

      <font color="blue">elseif </font>method == Method.StepExact<font color="blue"> then</font>
           <font color="darkgreen">/* x = phi*pre(x) + gamma*pre(u);
       y = C*x + D*u
    */</font>
        (sd.A,sd.B) := <font color="red">Modelica.Math.Matrices.integralExp</font>(
              sc.A,
              sc.B,
              Ts);
        sd.C := sc.C;
        sd.D := sc.D;
        sd.B2 := <font color="red">zeros</font>(nx, nu);

      <font color="blue">elseif </font>method == Method.RampExact<font color="blue"> then</font>
           <font color="darkgreen">/* x = phi*pre(x) + gamma*pre(u) + gamma1/Ts*(u - pre_u);
        -&gt; x = phi*pre(x) + (gamma - gamma1/Ts)*pre(u) + gamma1/Ts*u;
  z = x - gamma1/Ts*u
      leads to
        z = phi*pre(z) + phi*gamma1/Ts*pre(u) +gamma*pre(u) - gamma1/Ts*pre(u) 
       y = C*x + D*u
      -&gt; y = C*z + (D + C*gamma1/Ts)*u
      x = z + gamma1/Ts*u
    
    */</font>
        (sd.A,sd.B,sd.B2) := <font color="red">Modelica.Math.Matrices.integralExpT</font>(
              sc.A,
              sc.B,
              Ts);
        sd.B2 := sd.B2/Ts;
        sd.B := sd.A*sd.B2 + sd.B - sd.B2;
        sd.C := sc.C;
        sd.D := sd.C*sd.B2 + sc.D;

      <font color="blue">elseif </font>method == Method.ImpulseExact<font color="blue"> then</font>
           <font color="darkgreen">/* x = phi*pre(x) + phi*B*u;
        y = C*x
        (u = [1,0,1,1,0..,0])
      Limitations: The infinit impulses at t = kT is ignored in the mapping
    */</font>

        sd.A := <font color="red">Modelica.Math.Matrices.exp</font>(sc.A, Ts);
        sd.B := sd.A*sc.B;
        sd.C := sc.C;
        sd.D := sc.C*sc.B;
        sd.B2 := sc.B;

      <font color="blue">else</font>
        <font color="red">assert</font>(false, &quot;Argument method (= &quot; + <font color="red">String</font>(method) +
          &quot;) of makeDiscrete is wrong.&quot;);
      <font color="blue">end if</font>;
<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>fromStateSpace</textblock>;

    <textblock type="model" expanded="false" path="Modelica_LinearSystems2.DiscreteStateSpace.'constructor'.fromMatrices2"><font color="blue">encapsulated </font><font color="blue">function</font> fromMatrices2 <font color="darkgreen">
      &quot;Transform a continuous into a discrete linear state space system&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.Method"
>Modelica_LinearSystems2.Types.Method</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.LU_solve2"
>Modelica_LinearSystems2.Math.Matrices.LU_solve2</A>;

      <font color="blue">input </font>Real A[:,<font color="red">size</font>(A, 1)];
      <font color="blue">input </font>Real B[<font color="red">size</font>(A, 1),:];
      <font color="blue">input </font>Real C[:,<font color="red">size</font>(A, 1)];
      <font color="blue">input </font>Real D[<font color="red">size</font>(C, 1),<font color="red">size</font>(B, 2)];
      <font color="blue">input </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.Time"
>Modelica.SIunits.Time</A> Ts <font color="darkgreen">&quot;Sample time&quot;</font>;
      <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.Method"
>Modelica_LinearSystems2.Types.Method</A> method=Modelica_LinearSystems2.Types.Method.Trapezoidal <font color="darkgreen">
        &quot;Discretization method&quot;</font>;
    <font color="darkgreen">//  input Modelica_LinearSystems2.Types method=Modelica_LinearSystems2.Types.Method.Trapezoidal</font>
      <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.DiscreteStateSpace"
>Modelica_LinearSystems2.DiscreteStateSpace</A> sd(
        <font color="blue">redeclare </font>Real A[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)],
        <font color="blue">redeclare </font>Real B[<font color="red">size</font>(B, 1),<font color="red">size</font>(B, 2)],
        <font color="blue">redeclare </font>Real C[<font color="red">size</font>(C, 1),<font color="red">size</font>(C, 2)],
        <font color="blue">redeclare </font>Real D[<font color="red">size</font>(D, 1),<font color="red">size</font>(D, 2)],
        <font color="blue">redeclare </font>Real B2[<font color="red">size</font>(B, 1),<font color="red">size</font>(B, 2)]) <font color="darkgreen">&quot;Discrete state space system&quot;</font>;

    <font color="blue">protected </font>
      Integer nx=<font color="red">size</font>(A, 1) <font color="darkgreen">&quot;Number of states&quot;</font>;
      Integer nu=<font color="red">size</font>(B, 2) <font color="darkgreen">&quot;Number of input signals&quot;</font>;
      Real LU[nx,nx] <font color="darkgreen">&quot;LU decomposition&quot;</font>;
      Integer pivots[nx] <font color="darkgreen">&quot;Pivots of LU decomposition&quot;</font>;
    <font color="blue">algorithm </font>
      sd.Ts := Ts;
      sd.method := method;

      <font color="blue">if </font>method == Method.ExplicitEuler<font color="blue"> then</font>
        <font color="darkgreen">    /*  der_x = A*x + B*u
             x = pre(x) + Ts*pre(der_x)
     */</font>
        sd.A := <font color="red">identity</font>(nx) + Ts*A;
        sd.B := Ts*B;
        sd.C := C;
        sd.D := D;
        sd.B2 := <font color="red">zeros</font>(nx, nu);

      <font color="blue">elseif </font>method == Method.ImplicitEuler<font color="blue"> then</font>
        <font color="darkgreen">    /*  der_x = A*x + B*u
             x = pre(x) + Ts*der_x 
     */</font>
        (LU,pivots) := <font color="red">Modelica_LinearSystems2.Math.Matrices.LU</font>(<font color="red">identity</font>(nx) -
          Ts*A);
        sd.B2 := <font color="red">LU_solve2</font>(
              LU,
              pivots,
              Ts*B);
        sd.A := <font color="red">LU_solve2</font>(
              LU,
              pivots,
              <font color="red">identity</font>(nx));
        sd.B := sd.A*sd.B2;
        sd.C := C;
        sd.D := sd.C*sd.B2 + D;

      <font color="blue">elseif </font>method == Method.Trapezoidal<font color="blue"> then</font>
        <font color="darkgreen">    /*  der_x = A*x + B*u
             x = pre_x + (Ts/2)*(pre_der_x + der_x); 
     */</font>
        (LU,pivots) := <font color="red">Modelica_LinearSystems2.Math.Matrices.LU</font>(<font color="red">identity</font>(nx) -
          (Ts/2)*A);
        sd.B2 := <font color="red">LU_solve2</font>(
              LU,
              pivots,
              (Ts/2)*B);
        sd.A := <font color="red">LU_solve2</font>(
              LU,
              pivots,
              <font color="red">identity</font>(nx) + (Ts/2)*A);
        sd.B := sd.A*sd.B2 + sd.B2;
        sd.C := C;
        sd.D := sd.C*sd.B2 + D;

      <font color="blue">elseif </font>method == Method.StepExact<font color="blue"> then</font>
           <font color="darkgreen">/* x = phi*pre(x) + gamma*pre(u);
       y = C*x + D*u
    */</font>
        (sd.A,sd.B) := <font color="red">Modelica.Math.Matrices.integralExp</font>(
              A,
              B,
              Ts);
        sd.C := C;
        sd.D := D;
        sd.B2 := <font color="red">zeros</font>(nx, nu);

      <font color="blue">elseif </font>method == Method.RampExact<font color="blue"> then</font>
           <font color="darkgreen">/* x = phi*pre(x) + gamma*pre(u) + gamma1/Ts*(u - pre_u);
        -&gt; x = phi*pre(x) + (gamma - gamma1/Ts)*pre(u) + gamma1/Ts*u;
  z = x - gamma1/Ts*u
      leads to
        z = phi*pre(z) + phi*gamma1/Ts*pre(u) +gamma*pre(u) - gamma1/Ts*pre(u) 
       y = C*x + D*u
      -&gt; y = C*z + (D + C*gamma1/Ts)*u
      x = z + gamma1/Ts*u
    
    */</font>
        (sd.A,sd.B,sd.B2) := <font color="red">Modelica.Math.Matrices.integralExpT</font>(
              A,
              B,
              Ts);
        sd.B2 := sd.B2/Ts;
        sd.B := sd.A*sd.B2 + sd.B - sd.B2;
        sd.C := C;
        sd.D := sd.C*sd.B2 + D;

      <font color="blue">elseif </font>method == Method.ImpulseExact<font color="blue"> then</font>
           <font color="darkgreen">/* x = phi*pre(x) + phi*B*u;
        y = C*x
        (u = [1,0,1,1,0..,0])
      Limitations: The infinit impulses at t = kT is ignored in the mapping
    */</font>

        sd.A := <font color="red">Modelica.Math.Matrices.exp</font>(A, Ts);
        sd.B := sd.A*B;
        sd.C := C;
        sd.D := C*B;
        sd.B2 := B;

      <font color="blue">else</font>
        <font color="red">assert</font>(false, &quot;Argument method (= &quot; + <font color="red">String</font>(method) +
          &quot;) of makeDiscrete is wrong.&quot;);
      <font color="blue">end if</font>;
<textblock type="annotcomp" expanded="false">    <font color="blue">end </font>fromMatrices2</textblock>;
  <font color="blue">end </font>&#39;constructor&#39;</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.DiscreteStateSpace.timeResponse"><font color="blue">encapsulated </font><font color="blue">function</font> timeResponse <font color="darkgreen">
    &quot;Compute time response of DiscreteStateSpace system&quot;</font>
    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.DiscreteStateSpace"
>Modelica_LinearSystems2.DiscreteStateSpace</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.DiscreteStateSpace"
>DiscreteStateSpace</A> sd <font color="darkgreen">&quot;Linear system in discrete state space form&quot;</font>;
    <font color="blue">input </font>Real u[:,<font color="red">size</font>(sd.B, 2)]=<font color="red">ones</font>(3, <font color="red">size</font>(sd.B, 2)) <font color="darkgreen">
      &quot;System input (dimension: (input samples) x (number of inputs))&quot;</font>;
    <font color="blue">input </font>Real x0[<font color="red">size</font>(sd.A, 1)]=<font color="red">zeros</font>(<font color="red">size</font>(sd.A, 1)) <font color="darkgreen">&quot;Initial system state&quot;</font>;
    <font color="blue">output </font>Real y[<font color="red">size</font>(u, 1),<font color="red">size</font>(sd.C, 1)] <font color="darkgreen">
      &quot;System response (dimension: (input samples) x (number of outputs))&quot;</font>;
    <font color="blue">output </font>Real x_continuous[<font color="red">size</font>(u, 1),<font color="red">size</font>(sd.A, 1)] <font color="darkgreen">
      &quot;State trajectories (dimension: (input samples) x (number of states)&quot;</font>;

  <font color="blue">protected </font>
    Integer samples=<font color="red">size</font>(u, 1);
    Integer i;
    Real new_x[<font color="red">size</font>(sd.A, 1)];
    Real x[<font color="red">size</font>(sd.A, 1)]=x0;

  <font color="blue">algorithm </font>
    <font color="blue">for </font>i<font color="blue"> in </font>1:samples<font color="blue"> loop</font>
      new_x := sd.A*x + sd.B*u[i, :];
      y[i, :] := sd.C*x + sd.D*u[i, :];
      x_continuous[i, :] := x + sd.B2*u[i, :];
      x := new_x;
    <font color="blue">end for</font>;
<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>timeResponse</textblock>;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.DiscreteStateSpace.initialResponse"><font color="blue">encapsulated </font><font color="blue">function</font> initialResponse <font color="darkgreen">
    &quot;Compute initial response of DiscreteStateSpace system&quot;</font>
    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.DiscreteStateSpace"
>Modelica_LinearSystems2.DiscreteStateSpace</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.DiscreteStateSpace"
>DiscreteStateSpace</A> sd <font color="darkgreen">&quot;Linear system in discrete state space form&quot;</font>;
    <font color="blue">input </font>Real x0[<font color="red">size</font>(sd.A, 1)]=<font color="red">zeros</font>(<font color="red">size</font>(sd.A, 1)) <font color="darkgreen">&quot;Initial system state&quot;</font>;
    <font color="blue">input </font>Integer samples <font color="darkgreen">&quot;Number of samples&quot;</font>;
    <font color="blue">output </font>Real y[samples,<font color="red">size</font>(sd.C, 1)] <font color="darkgreen">
      &quot;System response (dimension: (input samples) x (number of outputs))&quot;</font>;
    <font color="blue">output </font>Real x_continuous[samples,<font color="red">size</font>(sd.A, 1)] <font color="darkgreen">
      &quot;State trajectories (dimension: (input samples) x (number of states)&quot;</font>;

  <font color="blue">protected </font>
    Integer i;
    Real new_x[<font color="red">size</font>(sd.A, 1)];
    Real x[<font color="red">size</font>(sd.A, 1)]=x0;

  <font color="blue">algorithm </font>
    <font color="blue">for </font>i<font color="blue"> in </font>1:samples<font color="blue"> loop</font>
      new_x := sd.A*x;
      y[i, :] := sd.C*x;
      x_continuous[i, :] := x;
      x := new_x;
    <font color="blue">end for</font>;
<textblock type="annotcomp" expanded="false">  <font color="blue">end </font>initialResponse</textblock>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>DiscreteStateSpace;
</PRE>
<HR>
<address>HTML-documentation generated by <a href="http://www.Dymola.com/">Dymola</a> Fri Jan 15 12:28:38 2010.
</address></BODY>
</HTML>
