<HTML>
<HEAD>
<TITLE>Modelica_LinearSystems2.Internal</TITLE>
<META name="HTML-Generator" content="Dymola">
<META name="description" content="&quot;Internal library of library LinearSystems (should not be directly used by user)&quot;">
<style type="text/css">
*       { font-size: 10pt; font-family: Arial,sans-serif; }
pre     { font-size:  9pt; font-family: Courier,monospace;}
h4      { font-size: 10pt; font-weight: bold; color: green; }
h3      { font-size: 11pt; font-weight: bold; color: green; }
h2      { font-size: 13pt; font-weight: bold; color: green; }
address {                  font-weight: normal} 
td      { solid #000; vertical-align:top; }
th      { solid #000; vertical-align:top; font-weight: bold; }
table   { solid #000; border-collapse: collapse;}
</style>
</HEAD>
<BODY><P>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Internal<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Internal"></A><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>.Internal</H2>
<B>Internal library of library LinearSystems (should not be directly used by user)</B>
<P>
<P><H3>Information</H3></P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons_Library.html#Modelica.Icons.Library"
>Modelica.Icons.Library</A> (Icon for library).
<P><H3>Package Content</H3><p>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 >
<TR><TH >Name</TH><TH>Description</TH></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Internal.StreamsS.png" ALT="Modelica_LinearSystems2.Internal.Streams" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal_Streams.html#Modelica_LinearSystems2.Internal.Streams"
>Streams</A>
</TD><TD>&nbsp;</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Internal.EigenvalueS.png" ALT="Modelica_LinearSystems2.Internal.Eigenvalue" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Eigenvalue</A>
</TD><TD>Record containing a eigen value or a pair of conjugated complex pair, repectively and additionally characteristics of the eigenvalue(s)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Internal.EigenvalueS.png" ALT="Modelica_LinearSystems2.Internal.PolesAndZeros" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.PolesAndZeros"
>PolesAndZeros</A>
</TD><TD>Record containing poles and zeros of a system in two real vectors containing the real parts and the imaginary parts respctively</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Internal.EigenvalueS.png" ALT="Modelica_LinearSystems2.Internal.StateSpaceR" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.StateSpaceR"
>StateSpaceR</A>
</TD><TD>Continuous state space description of a linear, time invariant differential equation system (data + operations)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Internal.EigenvalueS.png" ALT="Modelica_LinearSystems2.Internal.AnalyseOptions" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.AnalyseOptions"
>AnalyseOptions</A>
</TD><TD>Defines the characteristics of the eigenvalues to be print or to be plot</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Internal.EigenvalueS.png" ALT="Modelica_LinearSystems2.Internal.AnalyseOptions2" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.AnalyseOptions2"
>AnalyseOptions2</A>
</TD><TD>Defines the characteristics of the eigenvalues to be print or to be plot</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Internal.EigenvalueS.png" ALT="Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros"
>DefaultDiagramPolesAndZeros</A>
</TD><TD>Default diagram for polesAndZeros plot</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Internal.EigenvalueS.png" ALT="Modelica_LinearSystems2.Internal.DefaultDiagramBodePlot" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.DefaultDiagramBodePlot"
>DefaultDiagramBodePlot</A>
</TD><TD>Default diagram for Bode plot</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Internal.EigenvalueS.png" ALT="Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse"
>DefaultDiagramTimeResponse</A>
</TD><TD>Default diagram for a time response plot</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Internal.PartialPlotFunctionS.png" ALT="Modelica_LinearSystems2.Internal.PartialPlotFunction" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.PartialPlotFunction"
>PartialPlotFunction</A>
</TD><TD>Interface of a plot function</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Internal.PartialPlotFunctionS.png" ALT="Modelica_LinearSystems2.Internal.PartialPlotFunctionMIMO" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.PartialPlotFunctionMIMO"
>PartialPlotFunctionMIMO</A>
</TD><TD>Interface of a plot function for MIMO systems</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Internal.PartialPlotFunctionS.png" ALT="Modelica_LinearSystems2.Internal.defaultColumnLabels" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.defaultColumnLabels"
>defaultColumnLabels</A>
</TD><TD>Compute default column labels for plot</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Internal.PartialPlotFunctionS.png" ALT="Modelica_LinearSystems2.Internal.defaultImpulseResponseHeadings" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.defaultImpulseResponseHeadings"
>defaultImpulseResponseHeadings</A>
</TD><TD>Compute default headings for impulse response plot</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Internal.PartialPlotFunctionS.png" ALT="Modelica_LinearSystems2.Internal.defaultInitialResponseHeadings" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.defaultInitialResponseHeadings"
>defaultInitialResponseHeadings</A>
</TD><TD>Compute default headings for initial response plot</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Internal.PartialPlotFunctionS.png" ALT="Modelica_LinearSystems2.Internal.defaultRampResponseHeadings" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.defaultRampResponseHeadings"
>defaultRampResponseHeadings</A>
</TD><TD>Compute default headings for ramp response plot</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Internal.PartialPlotFunctionS.png" ALT="Modelica_LinearSystems2.Internal.defaultStepResponseHeadings" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.defaultStepResponseHeadings"
>defaultStepResponseHeadings</A>
</TD><TD>Compute default headings for step response plot</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Internal.PartialPlotFunctionS.png" ALT="Modelica_LinearSystems2.Internal.extractRealZeros" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.extractRealZeros"
>extractRealZeros</A>
</TD><TD>Extract real and conjugate complex elements from a complex vector</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Internal.PartialPlotFunctionS.png" ALT="Modelica_LinearSystems2.Internal.frequencyRangeBode" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.frequencyRangeBode"
>frequencyRangeBode</A>
</TD><TD>Determine min. and max. frequencies for Bode plot</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Internal.PartialPlotFunctionS.png" ALT="Modelica_LinearSystems2.Internal.frequencyRangeZeros" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.frequencyRangeZeros"
>frequencyRangeZeros</A>
</TD><TD>Determine min. and max. frequencies for a vector of zeros (numerator or denominator zeros)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Internal.PartialPlotFunctionS.png" ALT="Modelica_LinearSystems2.Internal.frequencyVector" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.frequencyVector"
>frequencyVector</A>
</TD><TD>Determine frequency vector for Bode plot</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Internal.PartialPlotFunctionS.png" ALT="Modelica_LinearSystems2.Internal.numberOfRealZeros" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.numberOfRealZeros"
>numberOfRealZeros</A>
</TD><TD>Determine the number of elements of a Complex vector where the imaginary part is zero</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Internal.PartialPlotFunctionS.png" ALT="Modelica_LinearSystems2.Internal.printComplexVector" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.printComplexVector"
>printComplexVector</A>
</TD><TD>&nbsp;</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Internal.PartialPlotFunctionS.png" ALT="Modelica_LinearSystems2.Internal.reorderEigenvalue" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.reorderEigenvalue"
>reorderEigenvalue</A>
</TD><TD>Extract real and conjugate complex elements from a complex vector as part of a record Eigenvalue</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Internal.PartialPlotFunctionS.png" ALT="Modelica_LinearSystems2.Internal.reorderZeros" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.reorderZeros"
>reorderZeros</A>
</TD><TD>Extract real and conjugate complex elements from a complex vector</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Internal.sortEigenvalueS.png" ALT="Modelica_LinearSystems2.Internal.sortEigenvalue" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.sortEigenvalue"
>sortEigenvalue</A>
</TD><TD>Sort elements of Eigenvalue-record depending on the eigenvalues</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Internal.timeResponseMaskS.png" ALT="Modelica_LinearSystems2.Internal.timeResponseMask" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.timeResponseMask"
>timeResponseMask</A>
</TD><TD>Declares the common structure for the set of response functions</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Internal.timeResponseMaskS.png" ALT="Modelica_LinearSystems2.Internal.timeResponseMask2" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.timeResponseMask2"
>timeResponseMask2</A>
</TD><TD>Declares the common structure for the set of response functions</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Internal.timeResponseMaskS.png" ALT="Modelica_LinearSystems2.Internal.timeResponseMask2_tf" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.timeResponseMask2_tf"
>timeResponseMask2_tf</A>
</TD><TD>Declares the common structure for the set of response functions</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Internal.timeResponseMaskS.png" ALT="Modelica_LinearSystems2.Internal.timeResponseMask2_zp" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.timeResponseMask2_zp"
>timeResponseMask2_zp</A>
</TD><TD>Declares the common structure for the set of response functions</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Internal.timeResponseMaskS.png" ALT="Modelica_LinearSystems2.Internal.timeResponseMask_tf" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.timeResponseMask_tf"
>timeResponseMask_tf</A>
</TD><TD>Declares the common structure for the set of response functions for a transfer function</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Internal.timeResponseMaskS.png" ALT="Modelica_LinearSystems2.Internal.timeResponseMask_zp" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.timeResponseMask_zp"
>timeResponseMask_zp</A>
</TD><TD>Declares the common structure for the set of response functions for a zeros and poles transfer function</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Internal.timeResponseMaskS.png" ALT="Modelica_LinearSystems2.Internal.timeResponseSamples" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.timeResponseSamples"
>timeResponseSamples</A>
</TD><TD>Estimate reasonable discretisation sample time and simulation time span for time response plot</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Internal.from_HzS.png" ALT="Modelica_LinearSystems2.Internal.from_Hz" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.from_Hz"
>from_Hz</A>
</TD><TD>Convert from Hz to rad/s</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Internal.from_HzS.png" ALT="Modelica_LinearSystems2.Internal.to_Hz" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.to_Hz"
>to_Hz</A>
</TD><TD>Convert from rad/s to Hz</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Eigenvalue<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Internal.EigenvalueI.png" ALT="Modelica_LinearSystems2.Internal.Eigenvalue" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Internal.Eigenvalue"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>.Eigenvalue</H2>
<B>Record containing a eigen value or a pair of conjugated complex pair, repectively and additionally characteristics of the eigenvalue(s)</B><p>
<P><H3>Information</H3></P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Record"
>Modelica.Icons.Record</A> (Icon for a record).
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">record</font> Eigenvalue <font color="darkgreen">
  &quot;Record containing a eigen value or a pair of conjugated complex pair, repectively and additionally characteristics of the eigenvalue(s)&quot;</font>
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
  <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Record"
>Modelica.Icons.Record</A>;

  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> ev;
  Boolean imag = false;
  Boolean isStable = false;
  Boolean isControllable = false;
  Boolean isStabilizable = false;
  Boolean isObservable = false;
  Boolean isDetectable = false;
  Real frequency;
  Real damping;
  Real timeConstant;

<textblock type="model" expanded="false" path="Modelica_LinearSystems2.Internal.Eigenvalue.constructor"><font color="blue">encapsulated </font><font color="blue">function</font> constructor <font color="darkgreen">
    &quot;Default constructor for eigenvalue&quot;</font>
    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Modelica_LinearSystems2.Internal.Eigenvalue</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> ev_in=<font color="red">Complex</font>(0);
  <font color="blue">input </font>Boolean isControllable=false;
  <font color="blue">input </font>Boolean isObservable = false;
  <font color="blue">input </font>Integer maxIndex1=0;
  <font color="blue">input </font>Integer maxIndex2=0;
  <font color="blue">input </font>Real Teps = 1e6 <font color="darkgreen">
      &quot;maximum time constant before regarded as infinity, i.e. a real eigenvalue is zero&quot;</font>;

  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Eigenvalue</A> ev;

  <font color="blue">protected </font>
  Boolean isStable = ev_in.re&lt;0;
  Boolean isImag =<font color="red"> abs</font>(ev_in.im)&gt;Modelica.Constants.eps;
  Real abs_ev = (ev_in.re^2+ev_in.im^2)^0.5;

<font color="blue">algorithm </font>
  ev.ev := ev_in;
  ev.imag := isImag;
  ev.isStable := isStable;
  ev.isControllable := isControllable;
  ev.isStabilizable := isStable<font color="blue"> or </font>isControllable;
  ev.isObservable := isObservable;
  ev.isDetectable := isStable<font color="blue"> or </font>isObservable;
  ev.frequency := <font color="blue">if </font>ev.imag<font color="blue"> then </font>abs_ev/(2*Modelica.Constants.pi)<font color="blue"> else </font>0.0;
  ev.damping := <font color="blue">if </font>ev.imag<font color="blue"> then </font><font color="blue">if </font>abs_ev&gt;Modelica.Constants.eps<font color="blue"> then </font>-ev.ev.re/abs_ev<font color="blue"> else </font>0.0<font color="blue"> else </font>1.0;
  ev.timeConstant := <font color="blue">if </font>ev.imag<font color="blue"> then </font>0.0<font color="blue"> else </font><font color="blue">if </font><font color="red">abs</font>(ev.ev.re) &gt; 1/Teps<font color="blue"> then </font>1/<font color="red">abs</font>(ev.ev.re)<font color="blue"> else </font>Teps;
<font color="blue">end </font>constructor</textblock>;

<font color="blue">end </font>Eigenvalue;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE PolesAndZeros<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Internal.EigenvalueI.png" ALT="Modelica_LinearSystems2.Internal.PolesAndZeros" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Internal.PolesAndZeros"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>.PolesAndZeros</H2>
<B>Record containing poles and zeros of a system in two real vectors containing the real parts and the imaginary parts respctively</B><p>
<P><H3>Information</H3></P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Record"
>Modelica.Icons.Record</A> (Icon for a record).
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">record</font> PolesAndZeros <font color="darkgreen">
  &quot;Record containing poles and zeros of a system in two real vectors containing the real parts and the imaginary parts respctively&quot;</font>
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
  <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Record"
>Modelica.Icons.Record</A>;

  Real p_real[:];
  Real p_im[:];
  Real z_real[:];
  Real z_im[:];

  Integer norz_p <font color="darkgreen">&quot;number of real zeros of p&quot;</font>;
  Integer norz_z <font color="darkgreen">&quot;number of real zeros of z&quot;</font>;
  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.Internal.PolesAndZeros.constructor"><font color="blue">encapsulated </font><font color="blue">function</font> constructor <font color="darkgreen">
    &quot;Default constructor for poles and zeros&quot;</font>
    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
    <font color="blue">import </font>PolesAndZeros2 = <A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.PolesAndZeros"
>Modelica_LinearSystems2.Internal.PolesAndZeros</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> p[:]={<font color="red">Complex</font>(0, 0)} <font color="darkgreen">&quot;Complex zeros&quot;</font>;
    <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> z[:]={<font color="red">Complex</font>(0, 0)} <font color="darkgreen">&quot;Complex zeros&quot;</font>;
    <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.PolesAndZeros"
>PolesAndZeros2</A> pz(
      <font color="blue">redeclare </font>Real p_real[<font color="red">size</font>(p, 1)],
      <font color="blue">redeclare </font>Real p_im[<font color="red">size</font>(p, 1)],
      <font color="blue">redeclare </font>Real z_real[<font color="red">size</font>(z, 1)],
      <font color="blue">redeclare </font>Real z_im[<font color="red">size</font>(z, 1)]);
  <font color="blue">algorithm </font>
    pz.p_real := p[:].re;
    pz.p_im := p[:].im;
    pz.z_real := z[:].re;
    pz.z_im := z[:].im;
    pz.norz_p := <font color="red">Internal.numberOfRealZeros</font>(p);
    pz.norz_z := <font color="red">Internal.numberOfRealZeros</font>(z);

  <font color="blue">end </font>constructor</textblock>;

<font color="blue">end </font>PolesAndZeros;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE StateSpaceR<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Internal.EigenvalueI.png" ALT="Modelica_LinearSystems2.Internal.StateSpaceR" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Internal.StateSpaceR"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>.StateSpaceR</H2>
<B>Continuous state space description of a linear, time invariant differential equation system (data + operations)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This record defines a linear time invariant differential
equation system in state space form:
</p>
<pre>    <b>der</b>(x) = A * x + B * u
        y  = C * x + D * u
</pre>
<p>
with
</p>
<ul>
<li> u - the input vector</li>
<li> y - the output vector</li>
<li> x - the state vector</li>
<li> A,B,C,D - matrices of appropriate dimensions</li>
</ul>
Compared to record StateSpace StateSpaceR cantains an additional Integer value r
<pre></PRE><P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Record"
>Modelica.Icons.Record</A> (Icon for a record).
<P><H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>der(x) = A*x + B*u;  y = C*x + D*u</TD></TR>
<TR><TD>Real</TD><TD>A[:, :]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>B[size(A, 1), :]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>C[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>D[size(C, 1), size(B, 2)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">record</font> StateSpaceR <font color="darkgreen">
  &quot;Continuous state space description of a linear, time invariant differential equation system (data + operations)&quot;</font>

  <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Record"
>Modelica.Icons.Record</A>;

  Real A[:,:];
  Real B[<font color="red">size</font>(A, 1),:];
  Real C[:,<font color="red">size</font>(A, 1)];
  Real D[<font color="red">size</font>(C, 1),<font color="red">size</font>(B, 2)];
  Integer r=0;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.Internal.StateSpaceR.constructor"><font color="blue">encapsulated </font><font color="blue">function</font> constructor <font color="darkgreen">
    &quot;Default constructor for a StateSpace record&quot;</font>
    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.StateSpaceR"
>Modelica_LinearSystems2.Internal.StateSpaceR</A>;

    <font color="blue">input </font>Real A[:,<font color="red">size</font>(A, 1)] <font color="darkgreen">&quot;der(x) = A*x + B*u&quot;</font>;
    <font color="blue">input </font>Real B[<font color="red">size</font>(A, 1),:] <font color="darkgreen">&quot;der(x) = A*x + B*u&quot;</font>;
    <font color="blue">input </font>Real C[:,<font color="red">size</font>(A, 1)] <font color="darkgreen">&quot;y = C*x + D*u&quot;</font>;
    <font color="blue">input </font>Real D[<font color="red">size</font>(C, 1),<font color="red">size</font>(B, 2)] <font color="darkgreen">&quot;y = C*x + D*u&quot;</font>;
    <font color="blue">input </font>Integer r;
    <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.StateSpaceR"
>StateSpaceR</A> result(
      <font color="blue">redeclare </font>Real A[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)],
      <font color="blue">redeclare </font>Real B[<font color="red">size</font>(B, 1),<font color="red">size</font>(B, 2)],
      <font color="blue">redeclare </font>Real C[<font color="red">size</font>(C, 1),<font color="red">size</font>(C, 2)],
      <font color="blue">redeclare </font>Real D[<font color="red">size</font>(D, 1),<font color="red">size</font>(D, 2)]);
  <font color="blue">algorithm </font>
    result.A := A;
    result.B := B;
    result.C := C;
    result.D := D;
    result.r := r;
  <font color="blue">end </font>constructor</textblock>;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>StateSpaceR;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE AnalyseOptions<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Internal.EigenvalueI.png" ALT="Modelica_LinearSystems2.Internal.AnalyseOptions" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Internal.AnalyseOptions"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>.AnalyseOptions</H2>
<B>Defines the characteristics of the eigenvalues to be print or to be plot</B><p>
<P><H3>Information</H3></P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Record"
>Modelica.Icons.Record</A> (Icon for a record).
<P><H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>analyse options</TD></TR>
<TR><TD>Boolean</TD><TD>plotEigenValues</TD><TD>true</TD><TD>plot eigenvalues</TD></TR>
<TR><TD>Boolean</TD><TD>plotInvariantZeros</TD><TD>true</TD><TD>plot invariant zeros</TD></TR>
<TR><TD>Boolean</TD><TD>plotStepResponse</TD><TD>true</TD><TD>plot step respones. Only for SISO system</TD></TR>
<TR><TD>Boolean</TD><TD>plotFrequencyResponse</TD><TD>true</TD><TD>plot bode diagram. Only for SISO system</TD></TR>
<TR><TD>Boolean</TD><TD>printEigenValues</TD><TD>true</TD><TD>write eigenvalues into the report</TD></TR>
<TR><TD>Boolean</TD><TD>printEigenValueProperties</TD><TD>true</TD><TD>write eigenvalues with properties</TD></TR>
<TR><TD>Boolean</TD><TD>printInvariantZeros</TD><TD>true</TD><TD>write invariant zreos into the report</TD></TR>
<TR><TD>Boolean</TD><TD>printControllability</TD><TD>true</TD><TD>indicates controllability of every single pole</TD></TR>
<TR><TD>Boolean</TD><TD>printObservability</TD><TD>true</TD><TD>indicates observability of every single pole</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">record</font> AnalyseOptions <font color="darkgreen">
  &quot;Defines the characteristics of the eigenvalues to be print or to be plot&quot;</font>
  <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Record"
>Modelica.Icons.Record</A>;
  Boolean plotEigenValues=true <font color="darkgreen">&quot;plot eigenvalues&quot;</font>;
  Boolean plotInvariantZeros=true <font color="darkgreen">&quot;plot invariant zeros&quot;</font>;
  Boolean plotStepResponse=true <font color="darkgreen">&quot;plot step respones. Only for SISO system&quot;</font>;
  Boolean plotFrequencyResponse=true <font color="darkgreen">&quot;plot bode diagram. Only for SISO system&quot;</font>;
  Boolean printEigenValues=true <font color="darkgreen">&quot;write eigenvalues into the report&quot;</font>;
  Boolean printEigenValueProperties=true <font color="darkgreen">&quot;write eigenvalues with properties&quot;</font>;

  Boolean printInvariantZeros=true <font color="darkgreen">&quot;write invariant zreos into the report&quot;</font>;
  Boolean printControllability=true <font color="darkgreen">
    &quot;indicates controllability of every single pole&quot;</font>;
  Boolean printObservability=true <font color="darkgreen">
    &quot;indicates observability of every single pole&quot;</font>;
  String headingEigenValues=&quot;Eigenvalues&quot;;
  String headingInvariantzeros=&quot;Invariant zeros&quot;;
  String headingStepResponse=&quot;Step response&quot;;
  String headingFrequencyResponse=&quot;Frequency response&quot;;

<font color="blue">end </font>AnalyseOptions;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE AnalyseOptions2<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Internal.EigenvalueI.png" ALT="Modelica_LinearSystems2.Internal.AnalyseOptions2" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Internal.AnalyseOptions2"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>.AnalyseOptions2</H2>
<B>Defines the characteristics of the eigenvalues to be print or to be plot</B><p>
<P><H3>Information</H3></P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Record"
>Modelica.Icons.Record</A> (Icon for a record).
<P><H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>analyse options</TD></TR>
<TR><TD>Boolean</TD><TD>plotEigenValues</TD><TD>true</TD><TD>plot eigenvalues</TD></TR>
<TR><TD>Boolean</TD><TD>plotInvariantZeros</TD><TD>true</TD><TD>plot invariant zeros</TD></TR>
<TR><TD>Boolean</TD><TD>plotStepResponse</TD><TD>true</TD><TD>plot step respones. Only for SISO system</TD></TR>
<TR><TD>Boolean</TD><TD>plotFrequencyResponse</TD><TD>true</TD><TD>plot bode diagram. Only for SISO system</TD></TR>
<TR><TD>Boolean</TD><TD>printEigenValues</TD><TD>true</TD><TD>write eigenvalues into the report</TD></TR>
<TR><TD>Boolean</TD><TD>printInvariantZeros</TD><TD>true</TD><TD>write invariant zreos into the report</TD></TR>
<TR><TD>Boolean</TD><TD>printControllability</TD><TD>false</TD><TD>indicates controllability of every single pole</TD></TR>
<TR><TD>Boolean</TD><TD>printObservability</TD><TD>false</TD><TD>indicates observability of every single pole</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">record</font> AnalyseOptions2 <font color="darkgreen">
  &quot;Defines the characteristics of the eigenvalues to be print or to be plot&quot;</font>
  <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Record"
>Modelica.Icons.Record</A>;
  Boolean plotEigenValues=true <font color="darkgreen">&quot;plot eigenvalues&quot;</font>;
  Boolean plotInvariantZeros=true <font color="darkgreen">&quot;plot invariant zeros&quot;</font>;
  Boolean plotStepResponse=true <font color="darkgreen">&quot;plot step respones. Only for SISO system&quot;</font>;
  Boolean plotFrequencyResponse=true <font color="darkgreen">&quot;plot bode diagram. Only for SISO system&quot;</font>;
  Boolean printEigenValues=true <font color="darkgreen">&quot;write eigenvalues into the report&quot;</font>;

  Boolean printInvariantZeros=true <font color="darkgreen">&quot;write invariant zreos into the report&quot;</font>;
  Boolean printControllability=false <font color="darkgreen">
    &quot;indicates controllability of every single pole&quot;</font>;
  Boolean printObservability=false <font color="darkgreen">
    &quot;indicates observability of every single pole&quot;</font>;
  String headingEigenValues=&quot;Eigenvalues&quot;;
  String headingInvariantzeros=&quot;Invariant zeros&quot;;
  String headingStepResponse=&quot;Step response&quot;;
  String headingFrequencyResponse=&quot;Frequency response&quot;;

<font color="blue">final </font>Boolean printEigenValueProperties = false <font color="darkgreen">
    &quot;write eigenvalues with properties&quot;</font>;

<font color="blue">end </font>AnalyseOptions2;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE DefaultDiagramPolesAndZeros<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Internal.EigenvalueI.png" ALT="Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Internal.DefaultDiagramPolesAndZeros"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>.DefaultDiagramPolesAndZeros</H2>
<B>Default diagram for polesAndZeros plot</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This record contains the default diagram options for pole/zero plots.
</p>
<pre></PRE><P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Record"
>Modelica.Icons.Record</A> (Icon for a record), <A HREF="Modelica_LinearSystems2_Utilities_Plot_Records.html#Modelica_LinearSystems2.Utilities.Plot.Records.DefaultDiagram"
>Modelica_LinearSystems2.Utilities.Plot.Records.DefaultDiagram</A> (Diagram with no curves (might be used as default diagram)).
<P><H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Utilities_Plot_Records.html#Modelica_LinearSystems2.Utilities.Plot.Records.Curve"
>Curve</A></TD><TD>curve[:]</TD><TD>fill(Curve(x=fill(0.0, 0), y...</TD><TD>Properties of the curves in one diagram of the figure</TD></TR>
<TR><TD>String</TD><TD>heading</TD><TD>&quot;Poles (x) and invariant zer...</TD><TD>Heading displayed above diagram</TD></TR>
<TR><TD>Real</TD><TD>heightRatio</TD><TD>0.6</TD><TD>Height of diagram = heightRatio*diagramWidth</TD></TR>
<TR><TD>Boolean</TD><TD>grid</TD><TD>true</TD><TD>= true, if grid is shown</TD></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>Axes</TD></TR>
<TR><TD>String</TD><TD>xLabel</TD><TD>&quot;Real part&quot;</TD><TD>String displayed at horizontal axis</TD></TR>
<TR><TD>String</TD><TD>yLabel</TD><TD>&quot;Imaginary part&quot;</TD><TD>String displayed at vertical axis</TD></TR>
<TR><TD>Boolean</TD><TD>logX</TD><TD>false</TD><TD>= true, if logarithmic scale of x-axis</TD></TR>
<TR><TD>Boolean</TD><TD>logY</TD><TD>false</TD><TD>= true, if logarithmic scale of y-axis</TD></TR>
<TR><TD>Boolean</TD><TD>uniformScaling</TD><TD>false</TD><TD>= true, if same vertical and horizontal axis increment</TD></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>Legend</TD></TR>
<TR><TD>Boolean</TD><TD>legend</TD><TD>false</TD><TD>= true, if legend is shown</TD></TR>
<TR><TD>Boolean</TD><TD>legendFrame</TD><TD>false</TD><TD>= true, if frame around legend</TD></TR>
<TR><TD>Boolean</TD><TD>legendHorizontal</TD><TD>true</TD><TD>= true, if horizontal legend (provided it is meaningful)</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Utilities_Plot_Types.html#Modelica_LinearSystems2.Utilities.Plot.Types.LegendLocation"
>LegendLocation</A></TD><TD>legendLocation</TD><TD>Modelica_LinearSystems2.Util...</TD><TD>Legend placement</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">record</font> DefaultDiagramPolesAndZeros <font color="darkgreen">
  &quot;Default diagram for polesAndZeros plot&quot;</font>
  <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;

   <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Record"
>Modelica.Icons.Record</A>;
   <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Utilities_Plot_Records.html#Modelica_LinearSystems2.Utilities.Plot.Records.DefaultDiagram"
>Modelica_LinearSystems2.Utilities.Plot.Records.DefaultDiagram</A>(
                      heading=&quot;Poles (x) and invariant zeros (o)&quot;,
                      heightRatio=0.6,
                      legend=false,
                      xLabel=&quot;Real part&quot;,
                      yLabel=&quot;Imaginary part&quot;);
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>DefaultDiagramPolesAndZeros;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE DefaultDiagramBodePlot<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Internal.EigenvalueI.png" ALT="Modelica_LinearSystems2.Internal.DefaultDiagramBodePlot" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Internal.DefaultDiagramBodePlot"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>.DefaultDiagramBodePlot</H2>
<B>Default diagram for Bode plot</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>This record contains the default diagram options for magnitude in bode plots. </p>
<pre></PRE><P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Record"
>Modelica.Icons.Record</A> (Icon for a record), <A HREF="Modelica_LinearSystems2_Utilities_Plot_Records.html#Modelica_LinearSystems2.Utilities.Plot.Records.DefaultDiagram"
>Modelica_LinearSystems2.Utilities.Plot.Records.DefaultDiagram</A> (Diagram with no curves (might be used as default diagram)).
<P><H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Utilities_Plot_Records.html#Modelica_LinearSystems2.Utilities.Plot.Records.Curve"
>Curve</A></TD><TD>curve[:]</TD><TD>fill(Curve(x=fill(0.0, 0), y...</TD><TD>Properties of the curves in one diagram of the figure</TD></TR>
<TR><TD>String</TD><TD>heading</TD><TD>&quot;Bode-Diagram&quot;</TD><TD>Heading displayed above diagram</TD></TR>
<TR><TD>Real</TD><TD>heightRatio</TD><TD>0.4</TD><TD>Height of diagram = heightRatio*diagramWidth</TD></TR>
<TR><TD>Boolean</TD><TD>grid</TD><TD>true</TD><TD>= true, if grid is shown</TD></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>Axes</TD></TR>
<TR><TD>String</TD><TD>xLabel</TD><TD>&quot;Frequency [Hz]&quot;</TD><TD>String displayed at horizontal axis</TD></TR>
<TR><TD>String</TD><TD>yLabel</TD><TD>&quot;&quot;</TD><TD>String displayed at vertical axis</TD></TR>
<TR><TD>Boolean</TD><TD>logX</TD><TD>true</TD><TD>= true, if logarithmic scale of x-axis</TD></TR>
<TR><TD>Boolean</TD><TD>logY</TD><TD>true</TD><TD>= true, if logarithmic scale of y-axis</TD></TR>
<TR><TD>Boolean</TD><TD>uniformScaling</TD><TD>false</TD><TD>= true, if same vertical and horizontal axis increment</TD></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>Legend</TD></TR>
<TR><TD>Boolean</TD><TD>legend</TD><TD>false</TD><TD>= true, if legend is shown</TD></TR>
<TR><TD>Boolean</TD><TD>legendFrame</TD><TD>false</TD><TD>= true, if frame around legend</TD></TR>
<TR><TD>Boolean</TD><TD>legendHorizontal</TD><TD>true</TD><TD>= true, if horizontal legend (provided it is meaningful)</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Utilities_Plot_Types.html#Modelica_LinearSystems2.Utilities.Plot.Types.LegendLocation"
>LegendLocation</A></TD><TD>legendLocation</TD><TD>Modelica_LinearSystems2.Util...</TD><TD>Legend placement</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">record</font> DefaultDiagramBodePlot <font color="darkgreen">&quot;Default diagram for Bode plot&quot;</font>
  <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;

   <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Record"
>Modelica.Icons.Record</A>;
   <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Utilities_Plot_Records.html#Modelica_LinearSystems2.Utilities.Plot.Records.DefaultDiagram"
>Modelica_LinearSystems2.Utilities.Plot.Records.DefaultDiagram</A>(
                      heading=&quot;Bode-Diagram&quot;,
                      heightRatio=0.4,
                      legend=false,
                      xLabel=&quot;Frequency [Hz]&quot;,
                      yLabel=&quot;&quot;,
                      logX=true,
                      logY=true);
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>DefaultDiagramBodePlot;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE DefaultDiagramTimeResponse<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Internal.EigenvalueI.png" ALT="Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Internal.DefaultDiagramTimeResponse"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>.DefaultDiagramTimeResponse</H2>
<B>Default diagram for a time response plot</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This record contains the default diagram options for pole/zero plots.
</p>
<pre></PRE><P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Record"
>Modelica.Icons.Record</A> (Icon for a record), <A HREF="Modelica_LinearSystems2_Utilities_Plot_Records.html#Modelica_LinearSystems2.Utilities.Plot.Records.DefaultDiagram"
>Modelica_LinearSystems2.Utilities.Plot.Records.DefaultDiagram</A> (Diagram with no curves (might be used as default diagram)).
<P><H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Utilities_Plot_Records.html#Modelica_LinearSystems2.Utilities.Plot.Records.Curve"
>Curve</A></TD><TD>curve[:]</TD><TD>fill(Curve(x=fill(0.0, 0), y...</TD><TD>Properties of the curves in one diagram of the figure</TD></TR>
<TR><TD>String</TD><TD>heading</TD><TD>&quot;time response&quot;</TD><TD>Heading displayed above diagram</TD></TR>
<TR><TD>Real</TD><TD>heightRatio</TD><TD>0.4</TD><TD>Height of diagram = heightRatio*diagramWidth</TD></TR>
<TR><TD>Boolean</TD><TD>grid</TD><TD>true</TD><TD>= true, if grid is shown</TD></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>Axes</TD></TR>
<TR><TD>String</TD><TD>xLabel</TD><TD>&quot;time [s]&quot;</TD><TD>String displayed at horizontal axis</TD></TR>
<TR><TD>String</TD><TD>yLabel</TD><TD>&quot;system output&quot;</TD><TD>String displayed at vertical axis</TD></TR>
<TR><TD>Boolean</TD><TD>logX</TD><TD>false</TD><TD>= true, if logarithmic scale of x-axis</TD></TR>
<TR><TD>Boolean</TD><TD>logY</TD><TD>false</TD><TD>= true, if logarithmic scale of y-axis</TD></TR>
<TR><TD>Boolean</TD><TD>uniformScaling</TD><TD>false</TD><TD>= true, if same vertical and horizontal axis increment</TD></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>Legend</TD></TR>
<TR><TD>Boolean</TD><TD>legend</TD><TD>false</TD><TD>= true, if legend is shown</TD></TR>
<TR><TD>Boolean</TD><TD>legendFrame</TD><TD>false</TD><TD>= true, if frame around legend</TD></TR>
<TR><TD>Boolean</TD><TD>legendHorizontal</TD><TD>true</TD><TD>= true, if horizontal legend (provided it is meaningful)</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Utilities_Plot_Types.html#Modelica_LinearSystems2.Utilities.Plot.Types.LegendLocation"
>LegendLocation</A></TD><TD>legendLocation</TD><TD>Modelica_LinearSystems2.Util...</TD><TD>Legend placement</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">record</font> DefaultDiagramTimeResponse <font color="darkgreen">
  &quot;Default diagram for a time response plot&quot;</font>
  <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;

   <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Record"
>Modelica.Icons.Record</A>;
   <font color="blue">extends </font><A HREF="Modelica_LinearSystems2_Utilities_Plot_Records.html#Modelica_LinearSystems2.Utilities.Plot.Records.DefaultDiagram"
>Modelica_LinearSystems2.Utilities.Plot.Records.DefaultDiagram</A>(
                      heading=&quot;time response&quot;,
                      heightRatio=0.4,
                      legend=false,
                      xLabel=&quot;time [s]&quot;,
                      yLabel=&quot;system output&quot;);
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>DefaultDiagramTimeResponse;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE PartialPlotFunction<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Internal.PartialPlotFunction"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>.PartialPlotFunction</H2>
<B>Interface of a plot function</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Utilities_Plot_Records.html#Modelica_LinearSystems2.Utilities.Plot.Records.Diagram"
>Diagram</A></TD><TD>defaultDiagram</TD><TD>&nbsp;</TD><TD>Default diagram layout</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Utilities_Plot_Records.html#Modelica_LinearSystems2.Utilities.Plot.Records.Device"
>Device</A></TD><TD>device</TD><TD>Modelica_LinearSystems2.Util...</TD><TD>Properties of device where figure is shown</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">partial </font><font color="blue">function</font> PartialPlotFunction <font color="darkgreen">&quot;Interface of a plot function&quot;</font>

  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Utilities_Plot.html#Modelica_LinearSystems2.Utilities.Plot"
>Modelica_LinearSystems2.Utilities.Plot</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Utilities_Plot_Records.html#Modelica_LinearSystems2.Utilities.Plot.Records.Diagram"
>Plot.Records.Diagram</A> defaultDiagram <font color="darkgreen">&quot;Default diagram layout&quot;</font>;
  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Utilities_Plot_Records.html#Modelica_LinearSystems2.Utilities.Plot.Records.Device"
>Plot.Records.Device</A> device=<font color="red">Modelica_LinearSystems2.Utilities.Plot.Records.Device</font>() <font color="darkgreen">
    &quot;Properties of device where figure is shown&quot;</font>;
<font color="blue">end </font>PartialPlotFunction;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE PartialPlotFunctionMIMO<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Internal.PartialPlotFunctionMIMO"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>.PartialPlotFunctionMIMO</H2>
<B>Interface of a plot function for MIMO systems</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Utilities_Plot_Records.html#Modelica_LinearSystems2.Utilities.Plot.Records.Diagram"
>Diagram</A></TD><TD>defaultDiagram</TD><TD>&nbsp;</TD><TD>Default diagram layout</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Utilities_Plot_Records.html#Modelica_LinearSystems2.Utilities.Plot.Records.Device"
>Device</A></TD><TD>device</TD><TD>Modelica_LinearSystems2.Util...</TD><TD>Properties of device where figure is shown</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">partial </font><font color="blue">function</font> PartialPlotFunctionMIMO <font color="darkgreen">
  &quot;Interface of a plot function for MIMO systems&quot;</font>

  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Utilities_Plot.html#Modelica_LinearSystems2.Utilities.Plot"
>Modelica_LinearSystems2.Utilities.Plot</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Utilities_Plot_Records.html#Modelica_LinearSystems2.Utilities.Plot.Records.Diagram"
>Plot.Records.Diagram</A> defaultDiagram <font color="darkgreen">&quot;Default diagram layout&quot;</font>;
  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Utilities_Plot_Records.html#Modelica_LinearSystems2.Utilities.Plot.Records.Device"
>Plot.Records.Device</A> device=<font color="red">Modelica_LinearSystems2.Utilities.Plot.Records.Device</font>() <font color="darkgreen">
    &quot;Properties of device where figure is shown&quot;</font>;
<font color="blue">end </font>PartialPlotFunctionMIMO;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE defaultColumnLabels<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Internal.defaultColumnLabels"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>.defaultColumnLabels</H2>
<B>Compute default column labels for plot</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>sizeC1</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>columnLabels[sizeC1 + 1]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> defaultColumnLabels <font color="darkgreen">&quot;Compute default column labels for plot&quot;</font>
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

  <font color="blue">input </font>Integer sizeC1;
  <font color="blue">output </font>String columnLabels[sizeC1 + 1];

<font color="blue">algorithm </font>
  columnLabels :=<font color="red"> cat</font>(
    1,
    {&quot;time [t]&quot;},
    {&quot;Out[&quot; +<font color="red"> String</font>(i) + &quot;]&quot; <font color="blue">for </font>i<font color="blue"> in </font>1:sizeC1}) <font color="darkgreen">&quot;Column labels&quot;</font>;
<font color="blue">end </font>defaultColumnLabels;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE defaultImpulseResponseHeadings<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Internal.defaultImpulseResponseHeadings"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>.defaultImpulseResponseHeadings</H2>
<B>Compute default headings for impulse response plot</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>sizeB2</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Integer</TD><TD>sizeC1</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>heading[sizeC1, sizeB2]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> defaultImpulseResponseHeadings <font color="darkgreen">
  &quot;Compute default headings for impulse response plot&quot;</font>

  <font color="blue">input </font>Integer sizeB2;
  <font color="blue">input </font>Integer sizeC1;
  <font color="blue">output </font>String heading[sizeC1,sizeB2];
<font color="blue">algorithm </font>
  heading[:, :] := {{&quot;Impulse response[&quot; +<font color="red"> String</font>(i) + &quot;,&quot; +<font color="red"> String</font>(j) + &quot;]&quot; 
    <font color="blue">for </font>j<font color="blue"> in </font>1:sizeB2} <font color="blue">for </font>i<font color="blue"> in </font>1:sizeC1};
<font color="blue">end </font>defaultImpulseResponseHeadings;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE defaultInitialResponseHeadings<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Internal.defaultInitialResponseHeadings"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>.defaultInitialResponseHeadings</H2>
<B>Compute default headings for initial response plot</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>sizeC1</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>heading[sizeC1, 1]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> defaultInitialResponseHeadings <font color="darkgreen">
  &quot;Compute default headings for initial response plot&quot;</font>

  <font color="blue">input </font>Integer sizeC1;
  <font color="blue">output </font>String heading[sizeC1,1];
<font color="blue">algorithm </font>
  heading[:, :] :=<font color="red"> matrix</font>({&quot;Initial response (Out &quot; +<font color="red"> String</font>(i) + &quot;)&quot; <font color="blue">for </font>i<font color="blue"> in </font>
    1:sizeC1});
<font color="blue">end </font>defaultInitialResponseHeadings;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE defaultRampResponseHeadings<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Internal.defaultRampResponseHeadings"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>.defaultRampResponseHeadings</H2>
<B>Compute default headings for ramp response plot</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>sizeB2</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Integer</TD><TD>sizeC1</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>heading[sizeC1, sizeB2]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> defaultRampResponseHeadings <font color="darkgreen">
  &quot;Compute default headings for ramp response plot&quot;</font>

  <font color="blue">input </font>Integer sizeB2;
  <font color="blue">input </font>Integer sizeC1;
  <font color="blue">output </font>String heading[sizeC1,sizeB2];
<font color="blue">algorithm </font>
  heading[:, :] := {{&quot;Ramp response[&quot; +<font color="red"> String</font>(i) + &quot;,&quot; +<font color="red"> String</font>(j) + &quot;]&quot; <font color="blue">for </font>j<font color="blue"> in </font>
        1:sizeB2} <font color="blue">for </font>i<font color="blue"> in </font>1:sizeC1};
<font color="blue">end </font>defaultRampResponseHeadings;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE defaultStepResponseHeadings<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Internal.defaultStepResponseHeadings"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>.defaultStepResponseHeadings</H2>
<B>Compute default headings for step response plot</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>sizeB2</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Integer</TD><TD>sizeC1</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>heading[sizeC1, sizeB2]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> defaultStepResponseHeadings <font color="darkgreen">
  &quot;Compute default headings for step response plot&quot;</font>

  <font color="blue">input </font>Integer sizeB2;
  <font color="blue">input </font>Integer sizeC1;
  <font color="blue">output </font>String heading[sizeC1,sizeB2];
<font color="blue">algorithm </font>
  heading[:, :] := {{&quot;Step response[&quot; +<font color="red"> String</font>(i) + &quot;,&quot; +<font color="red"> String</font>(j) + &quot;]&quot; <font color="blue">for </font>j<font color="blue"> in </font>
        1:sizeB2} <font color="blue">for </font>i<font color="blue"> in </font>1:sizeC1};
<font color="blue">end </font>defaultStepResponseHeadings;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE extractRealZeros<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Internal.extractRealZeros"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>.extractRealZeros</H2>
<B>Extract real and conjugate complex elements from a complex vector</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4><font color="#008000">Syntax</font></h4>
<blockquote><pre>
                realZeros = Matrices.<b>extractRealZeros</b>(complexVector, numberOfRealRoots);
(realZeros, complexZeros) = Matrices.<b>extractRealZeros</b>(complexVector, numberOfRealRoots,
                                                      name="complexVector");
</pre></blockquote>
<h4><font color="#008000">Description</font></h4>
<p>
Function <b>extractRealZeros</b>(..) extracts the real zeros from the
Complex vector "complexVector". It is required that all elements
of complexVector define either
a real zero (complexVector[i].im=0) or a conjugate complex zero pair
(complexVector[i].re == complexVector[i+1].re and
complexVector[i].im == -complexVector[i+1].im). 
The second argument "numberOfRealZeros" is determined by a function
call of Internal.numberOfRealZeros().
The optional input argument
"name" is used as name of "complexVector" in error messages.
</p>
<p>
The function returns the real elements of complexVector in
vector "realZeros" and the real and imaginary part of a conjugate
complex zero pair in matrix complexZeros[:]".
<h4><font color="#008000">Example</font></h4>
<blockquote><pre>
  // c = {0; 1+2j; 1-2j; 2; -3; -1-j; -1+j};
    Integer n = numberOfRealZeros(c);
    Real realZeros[n];
    Real complexZeros[:] = fill(Complex(0), integer((size(c,1)-n)/2));
  algorithm
  (realZeros, complexZeros) := extractRealZeros(c, n);
           -> realZeros    = {0, 2, (-3)};
              complexZeros = { 1+2j,
                              -1+j}
</pre></blockquote>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>complexVector[:]</TD><TD>&nbsp;</TD><TD>Zeros of a polynomial with real coefficients, e.g., eigen values of a real matrix</TD></TR>
<TR><TD>Integer</TD><TD>numberOfRealZeros</TD><TD>&nbsp;</TD><TD>Number of real zeros of ComplexVector determined with function numberOfRealZeros</TD></TR>
<TR><TD>String</TD><TD>name</TD><TD>&quot;complexVector&quot;</TD><TD>Name of complexVector to be used in error message</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>realZeros[numberOfRealZeros]</TD><TD>Real zeros of complexVector</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>complexZeros[:]</TD><TD>Complex zeros without the corresponding conjugate complex pair element</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> extractRealZeros <font color="darkgreen">
  &quot;Extract real and conjugate complex elements from a complex vector&quot;</font>
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> complexVector[:] <font color="darkgreen">
    &quot;Zeros of a polynomial with real coefficients, e.g., eigen values of a real matrix&quot;</font>;
  <font color="blue">input </font>Integer numberOfRealZeros <font color="darkgreen">
    &quot;Number of real zeros of ComplexVector determined with function numberOfRealZeros&quot;</font>;
  <font color="blue">input </font>String name=&quot;complexVector&quot; <font color="darkgreen">
    &quot;Name of complexVector to be used in error message&quot;</font>;
  <font color="blue">output </font>Real realZeros[numberOfRealZeros] <font color="darkgreen">&quot;Real zeros of complexVector&quot;</font>;
  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> complexZeros[:]=<font color="red">fill</font>(<font color="red">Complex</font>(0),<font color="red"> integer</font>((<font color="red">size</font>(complexVector, 1) -
      numberOfRealZeros)/2)) <font color="darkgreen">
    &quot;Complex zeros without the corresponding conjugate complex pair element&quot;</font>;

<font color="blue">protected </font>
  Integer n=<font color="red">size</font>(complexVector, 1);
  Integer i;
  Integer i1;
  Integer i2;
<font color="blue">algorithm </font>
  i1 := 0;
  i2 := 0;
  i := 1;
  <font color="blue">while </font>i &lt;= n<font color="blue"> loop</font>
    <font color="blue">if </font>complexVector[i].im == 0.0<font color="blue"> then</font>
      i1 := i1 + 1;
      realZeros[i1] := complexVector[i].re;
      i := i + 1;
    <font color="blue">else</font>
      <font color="darkgreen">  // check that the next two zeros are a conjugate complex pair</font>
      <font color="red">assert</font>(i &lt; n, &quot;Argument &quot; + name +
        &quot; does not define a real valued polynomial\n&quot; + name + &quot;[&quot; +<font color="red"> String</font>(n)
         + &quot;] is complex without complex conjugate.&quot;);

      <font color="red">assert</font>(complexVector[i].re == complexVector[i + 1].re,
        &quot;No conjugate complex pair (checked real parts)\n&quot; + &quot;  &quot; + name + &quot;[&quot;
         +<font color="red"> String</font>(i) + &quot;] = &quot; +<font color="red"> String</font>(complexVector[i]) + &quot;\n&quot; + &quot;  &quot; + name
         + &quot;[&quot; +<font color="red"> String</font>(i + 1) + &quot;] = &quot; +<font color="red"> String</font>(complexVector[i]) + &quot;\n&quot; +
        &quot;and the real parts of these two complex numbers should be identical\n&quot;
         + &quot;since conjugate complex pairs required.&quot;);
      <font color="red">assert</font>(complexVector[i].im == -complexVector[i + 1].im,
        &quot;No conjugate complex pair (checked the imaginary parts)\n&quot; + &quot;  &quot; +
        name + &quot;[&quot; +<font color="red"> String</font>(i) + &quot;] = &quot; +<font color="red"> String</font>(complexVector[i]) + &quot;\n&quot; +
        &quot;  &quot; + name + &quot;[&quot; +<font color="red"> String</font>(i + 1) + &quot;] = &quot; +<font color="red"> String</font>(complexVector[i + 1])
         + &quot;\n&quot; +
        &quot;and the imaginary parts of these two complex numbers should be identical\n&quot;
         + &quot;with opposite sign, since a conjugate complex pair is required.&quot;);
      i2 := i2 + 1;
      <font color="darkgreen">  // Store the zero with the positive imaginary part</font>
      <font color="blue">if </font>complexVector[i].im &gt;= 0<font color="blue"> then</font>
        complexZeros[i2] := complexVector[i];
      <font color="blue">else</font>
        complexZeros[i2] := complexVector[i + 1];
      <font color="blue">end if</font>;
      i := i + 2;
    <font color="blue">end if</font>;
  <font color="blue">end while</font>;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>extractRealZeros;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE frequencyRangeBode<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Internal.frequencyRangeBode"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>.frequencyRangeBode</H2>
<B>Determine min. and max. frequencies for Bode plot</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>numZeros[:]</TD><TD>&nbsp;</TD><TD>Zeros of numerator</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>denZeros[:]</TD><TD>&nbsp;</TD><TD>Zeros of denominator</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>AngularVelocity</A></TD><TD>w_min</TD><TD>[rad/s]</TD></TR>
<TR><TD><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>AngularVelocity</A></TD><TD>w_max</TD><TD>[rad/s]</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> frequencyRangeBode <font color="darkgreen">
  &quot;Determine min. and max. frequencies for Bode plot&quot;</font>
  <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
  <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams"
>Modelica.Utilities.Streams</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> numZeros[:] <font color="darkgreen">&quot;Zeros of numerator&quot;</font>;
  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> denZeros[:] <font color="darkgreen">&quot;Zeros of denominator&quot;</font>;
  <font color="blue">output </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>Modelica.SIunits.AngularVelocity</A> w_min;
  <font color="blue">output </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>Modelica.SIunits.AngularVelocity</A> w_max;
<font color="blue">protected </font>
  Real phi_min=<font color="red">Modelica.SIunits.Conversions.from_deg</font>(3);
  Real real_min=1.0e-4;
  Real pi=Modelica.Constants.pi;
  Integer n_num;
  Integer n_den;
  Real w_min1;
  Real w_min2;
  Real w_max1;
  Real w_max2;
  Real f_min;
  Real f_max;
<font color="blue">algorithm </font>
  <font color="darkgreen">// Compute frequencies for numerator</font>
  n_num :=<font color="red"> size</font>(numZeros, 1);
  <font color="blue">if </font>n_num &gt; 0<font color="blue"> then</font>
    (w_min1,w_max1) :=<font color="red"> Internal.frequencyRangeZeros</font>(
      numZeros,
      phi_min,
      real_min);
  <font color="blue">end if</font>;

  <font color="darkgreen">// Compute frequencies for denominator</font>
  n_den :=<font color="red"> size</font>(denZeros, 1);
  <font color="blue">if </font>n_den &gt; 0<font color="blue"> then</font>
    (w_min2,w_max2) :=<font color="red"> Internal.frequencyRangeZeros</font>(
      denZeros,
      phi_min,
      real_min);
  <font color="blue">end if</font>;

  <font color="darkgreen">// Use largest range</font>
  <font color="blue">if </font>n_num == 0<font color="blue"> and </font>n_den == 0<font color="blue"> then</font>
    w_min := 0.1;
    w_max := 10;
  <font color="blue">elseif </font>n_num == 0<font color="blue"> then</font>
    w_min := w_min2;
    w_max := w_max2;
  <font color="blue">elseif </font>n_den == 0<font color="blue"> then</font>
    w_min := w_min1;
    w_max := w_max1;
  <font color="blue">else</font>
    w_min :=<font color="red"> min</font>(w_min1, w_min2);
    w_max :=<font color="red"> max</font>(w_max1, w_max2);
  <font color="blue">end if</font>;
  f_min :=<font color="red"> Internal.to_Hz</font>(w_min);
  f_max :=<font color="red"> Internal.to_Hz</font>(w_max);
<font color="blue">end </font>frequencyRangeBode;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE frequencyRangeZeros<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Internal.frequencyRangeZeros"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>.frequencyRangeZeros</H2>
<B>Determine min. and max. frequencies for a vector of zeros (numerator or denominator zeros)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
This function estimates a useful frequency range for the
Bode plot of a vector of zeros (numerator or denominator zeros).
This frequency range is estimated such that the phase angle 
of <b>one</b> zero is in the range:
<p>
<pre>
   phi_min/n_zeros &le; |phase angle| &le; pi/2 - phi_min/n_zeros
</pre>
<p>
where n_zeros is the number of zeros.
Note, the phase angle of one zero for a frequency of 0 up to infinity
is in the range:
</p>
<pre>
   0 &le; |phase angle| &le; pi/2
</pre>
<p>
Therefore, the frequency range is estimated
such that the essential part of the phase angle (defined by phi_min)
is present.
</p>
<p>
If the real part of a complex zero vanishes 
(i.e., the zero is located on the imaginary axis), 
the maximum value of the bode plot magnitude of the zero 
is infinity. In order to avoid difficulties, zeros close to
the imaginary axis are shifted by the input argument
real_min along the real axis.
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>z[:]</TD><TD>&nbsp;</TD><TD>Vector of zeros</TD></TR>
<TR><TD><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.Angle"
>Angle</A></TD><TD>phi_min</TD><TD>Modelica.SIunits.Conversions...</TD><TD>Minimum phase angle [rad]</TD></TR>
<TR><TD>Real</TD><TD>real_min</TD><TD>1.e-4</TD><TD>[r| &lt; real_min are treated as |real_min|</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>AngularVelocity</A></TD><TD>w_min</TD><TD>Minimum frequency [rad/s]</TD></TR>
<TR><TD><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>AngularVelocity</A></TD><TD>w_max</TD><TD>Maximum frequency [rad/s]</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> frequencyRangeZeros <font color="darkgreen">
  &quot;Determine min. and max. frequencies for a vector of zeros (numerator or denominator zeros)&quot;</font>
  <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
  <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Math.html#Modelica.Math"
>Modelica.Math</A>;
  <font color="blue">import </font>SI = <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits"
>Modelica.SIunits</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> z[:] <font color="darkgreen">&quot;Vector of zeros&quot;</font>;
  <font color="blue">input </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.Angle"
>SI.Angle</A> phi_min(min=10*Modelica.Constants.eps)=
    <font color="red">Modelica.SIunits.Conversions.from_deg</font>(5) <font color="darkgreen">&quot;Minimum phase angle&quot;</font>;
  <font color="blue">input </font>Real real_min(min=0) = 1.e-4 <font color="darkgreen">&quot;[r| &lt; real_min are treated as |real_min|&quot;</font>;
  <font color="blue">output </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>Modelica.SIunits.AngularVelocity</A> w_min <font color="darkgreen">&quot;Minimum frequency&quot;</font>;
  <font color="blue">output </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>Modelica.SIunits.AngularVelocity</A> w_max <font color="darkgreen">&quot;Maximum frequency&quot;</font>;

<font color="blue">protected </font>
  Integer nz=<font color="red">size</font>(z, 1);
  Real tan_min;
  Real tan_max1;
  Real tan_max2;
  Real z_re;
  Real w_min1;
  Real w_max1;
  Real z_abs2;
  Real k1;
  Real k2;
<font color="blue">algorithm </font>
  <font color="darkgreen">/* - Real zero:
       tan(phi_desired) = w/re -&gt; w = re*tan(phi_desired)
  
     - Conjugate complex zero:
       tan(phi1) = (w + im)/re
       tan(phi2) = (w - im)/re
       phi1 + phi2 = phi_desired -&gt; tan(phi1 + phi2) = (tan(phi1) + tan(phi2))/(1-tan(phi1)*tan(phi2))
       -&gt; after a longer derivation it follows:
          w = sqrt( re^2/tan(phi_desired)^2 + (re^2 + im^2) ) - re/tan(phi_desired)
  */</font>
  <font color="red">assert</font>(nz &gt; 0, &quot;Vector z of zeros has dimension 0, This is not allowed&quot;);
  tan_min :=<font color="red"> Math.tan</font>(phi_min);
  tan_max1 :=<font color="red"> Math.tan</font>(Modelica.Constants.pi/2 - phi_min);
  tan_max2 :=<font color="red"> Math.tan</font>(Modelica.Constants.pi - phi_min);
  <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(z, 1)<font color="blue"> loop</font>
    <font color="blue">if </font>z[i].im &gt;= 0.0<font color="blue"> then</font>
      z_re :=<font color="red"> max</font>(<font color="red">abs</font>(z[i].re), real_min);
      <font color="blue">if </font>z[i].im &gt; 0.0<font color="blue"> then</font>
        z_abs2 := z_re^2 + z[i].im^2;
        k1 := z_re/tan_min;
        w_min1 :=<font color="red"> sqrt</font>(k1^2 + z_abs2) - k1;
        k2 := z_re/tan_max2;
        w_max1 :=<font color="red"> sqrt</font>(k2^2 + z_abs2) - k2;
      <font color="blue">else</font>
        w_min1 := z_re*tan_min;
        w_max1 := z_re*tan_max1;
      <font color="blue">end if</font>;

      <font color="blue">if </font>i == 1<font color="blue"> then</font>
        w_min := w_min1;
        w_max := w_max1;
      <font color="blue">else</font>
        w_min :=<font color="red"> min</font>(w_min, w_min1);
        w_max :=<font color="red"> max</font>(w_max, w_max1);
      <font color="blue">end if</font>;
    <font color="blue">end if</font>;
  <font color="blue">end for</font>;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>frequencyRangeZeros;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE frequencyVector<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Internal.frequencyVector"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>.frequencyVector</H2>
<B>Determine frequency vector for Bode plot</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>nPoints</TD><TD>200</TD><TD>Number of points</TD></TR>
<TR><TD>Boolean</TD><TD>autoRange</TD><TD>true</TD><TD>= true, if abszissa range is automatically determined</TD></TR>
<TR><TD><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Frequency</A></TD><TD>f_min</TD><TD>0.1</TD><TD>Minimum frequency value, if autoRange = false [Hz]</TD></TR>
<TR><TD><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Frequency</A></TD><TD>f_max</TD><TD>10</TD><TD>Maximum frequency value, if autoRange = false [Hz]</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>numZeros[:]</TD><TD>fill(Complex(0), 0)</TD><TD>Zeros of numerator</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>denZeros[:]</TD><TD>fill(Complex(0), 0)</TD><TD>Zeros of denominator</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Frequency</A></TD><TD>f[nPoints]</TD><TD>Frequency vector (automatic or manual) [Hz]</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> frequencyVector <font color="darkgreen">&quot;Determine frequency vector for Bode plot&quot;</font>
  <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
  <font color="blue">import </font>LinearSystems = <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>;
  <font color="blue">import </font>SI = <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits"
>Modelica.SIunits</A>;

  <font color="blue">input </font>Integer nPoints(min=2) = 200 <font color="darkgreen">&quot;Number of points&quot;</font>;
  <font color="blue">input </font>Boolean autoRange=true <font color="darkgreen">
    &quot;= true, if abszissa range is automatically determined&quot;</font>;
  <font color="blue">input </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Modelica.SIunits.Frequency</A> f_min(min=0) = 0.1 <font color="darkgreen">
    &quot;Minimum frequency value, if autoRange = false&quot;</font>;
  <font color="blue">input </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Modelica.SIunits.Frequency</A> f_max(min=0) = 10 <font color="darkgreen">
    &quot;Maximum frequency value, if autoRange = false&quot;</font>;
  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> numZeros[:]=<font color="red">fill</font>(<font color="red">Complex</font>(0), 0) <font color="darkgreen">&quot;Zeros of numerator&quot;</font>;
  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> denZeros[:]=<font color="red">fill</font>(<font color="red">Complex</font>(0), 0) <font color="darkgreen">&quot;Zeros of denominator&quot;</font>;
  <font color="blue">output </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.Frequency"
>SI.Frequency</A> f[nPoints] <font color="darkgreen">&quot;Frequency vector (automatic or manual)&quot;</font>;
<font color="blue">protected </font>
  Real w_min;
  Real w_max;
  Real f_min2;
  Real f_max2;
  Real f_log[nPoints];
<font color="blue">algorithm </font>
  <font color="darkgreen">// Determine f_min2, f_max2 (auto or manual)</font>
  <font color="blue">if </font>autoRange<font color="blue"> then</font>
    (w_min,w_max) :=<font color="red"> Internal.frequencyRangeBode</font>(numZeros, denZeros);
    f_min2 :=<font color="red"> Internal.to_Hz</font>(w_min);
    f_max2 :=<font color="red"> Internal.to_Hz</font>(w_max);

  <font color="blue">else</font>
    f_min2 := f_min;
    f_max2 := f_max;
  <font color="blue">end if</font>;
  w_min :=<font color="red"> Internal.from_Hz</font>(f_min2);
  w_max :=<font color="red"> Internal.from_Hz</font>(f_max2);

  <font color="darkgreen">// Compute logarithmic vector of frequency points</font>
  f_log :=<font color="red"> linspace</font>(
    <font color="red">Modelica.Math.log10</font>(f_min2),
    <font color="red">Modelica.Math.log10</font>(f_max2),
    nPoints);
  <font color="blue">for </font>i<font color="blue"> in </font>1:nPoints<font color="blue"> loop</font>
    f[i] := 10^f_log[i];
  <font color="blue">end for</font>;
<font color="blue">end </font>frequencyVector;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE numberOfRealZeros<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Internal.numberOfRealZeros"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>.numberOfRealZeros</H2>
<B>Determine the number of elements of a Complex vector where the imaginary part is zero</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4><font color="#008000">Syntax</font></h4>
<blockquote><pre>
     Matrices.<b>numberOfRealZeros</b>(complexVector);
</pre></blockquote>
<h4><font color="#008000">Description</font></h4>
<p>
Function <b>numberOfRealZeros</b>(..) determines the number of
elements of vector "complexVector" with vanishing imaginary part,
i.e., complexVector[i].im = 0.
</p>
<h4><font color="#008000">Example</font></h4>
<blockquote><pre>
  // c = {0; 1+2*j; 1-2*j; 2; -3; -1-j; -1+j};
  result = Matrices.numberOfRealZeros(c);
           -> result = 3;
</pre></blockquote>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>complexVector[:]</TD><TD>&nbsp;</TD><TD>Complex vector</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>result</TD><TD>Number of elements of v with v.im = 0</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> numberOfRealZeros <font color="darkgreen">
  &quot;Determine the number of elements of a Complex vector where the imaginary part is zero&quot;</font>
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> complexVector[:] <font color="darkgreen">&quot;Complex vector&quot;</font>;
  <font color="blue">output </font>Integer result <font color="darkgreen">&quot;Number of elements of v with v.im = 0&quot;</font>;

<font color="blue">algorithm </font>
  result := 0;
  <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(complexVector, 1)<font color="blue"> loop</font>
    <font color="blue">if </font>complexVector[i].im == 0<font color="blue"> then</font>
      result := result + 1;
    <font color="blue">end if</font>;
  <font color="blue">end for</font>;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>numberOfRealZeros;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE printComplexVector<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Internal.printComplexVector"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>.printComplexVector</H2>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>name</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>c[:]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> printComplexVector
  <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams.print"
>Modelica.Utilities.Streams.print</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

  <font color="blue">input </font>String name;
  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> c[:];

<font color="blue">algorithm </font>
  <font color="red">print</font>(name + &quot; =&quot;);
  <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(c, 1)<font color="blue"> loop</font>
    <font color="red">print</font>(&quot;   &quot; +<font color="red"> String</font>(c[i]));
  <font color="blue">end for</font>;
<font color="blue">end </font>printComplexVector;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE reorderEigenvalue<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Internal.reorderEigenvalue"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>.reorderEigenvalue</H2>
<B>Extract real and conjugate complex elements from a complex vector as part of a record Eigenvalue</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4><font color="#008000">Syntax</font></h4>
<blockquote><pre>
               reorderedZero = Matrices.<b>reorderZeros</b>(complexVector);
(reorderedZeros, nRealZeros) = Matrices.<b>reorderZeros</b>(complexVector, 
                                                     name="complexVector");
</pre></blockquote>
<h4><font color="#008000">Description</font></h4>
<p>
Function <b>reorderZeros</b>(..) reorders the zeros from the
Complex vector "complexVector" such that the returned Complex vector
reorderedZeros contains first all real Zeros and afterwards the conjugate
complex zero pairs. It is required that all elements
of complexVector define either a real zero (complexVector[i].im=0) 
or a conjugate complex zero pair
(complexVector[i].re == complexVector[i+1].re and
complexVector[i].im == -complexVector[i+1].im). 
The optional input argument
"name" is used as name of "complexVector" in error messages.
</p>
<p>
The function returns the vector element reordered, as well as
the number of real zeros (nRealZeros).
<h4><font color="#008000">Example</font></h4>
<blockquote><pre>
    
  // c = {0; 1+2j; 1-2j; 2; -3; -1-j; -1+j};
    Real complexZeros[:] = fill(Complex(0), integer((size(c,1)-n)/2));
  algorithm
  (reorderedZeros, nRealZeros) := reorderZeros(c);
      -> reorderedZeros = {0, 2, (-3), 1+2j, 1-2j, -1+j, -1-j}
         nRealZeros     = 3
 
</pre></blockquote>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Eigenvalue</A></TD><TD>EigenvalueVector[:]</TD><TD>&nbsp;</TD><TD>Zeros of a polynomial with real coefficients, e.g., eigen values of a real matrix</TD></TR>
<TR><TD>String</TD><TD>name</TD><TD>&quot;EigenvalueVector&quot;</TD><TD>Name of complexVector to be used in error message</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Eigenvalue</A></TD><TD>reorderedEigenvalues[size(EigenvalueVector, 1)]</TD><TD>Reordered zeros</TD></TR>
<TR><TD>Integer</TD><TD>nRealEigenvalues</TD><TD>Number of real zeros (EigenvalueVector[1:nRealEigenvalues] are the real zeros)</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> reorderEigenvalue <font color="darkgreen">
  &quot;Extract real and conjugate complex elements from a complex vector as part of a record Eigenvalue&quot;</font>
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Modelica_LinearSystems2.Internal.Eigenvalue</A>;
  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Eigenvalue</A> EigenvalueVector[:] <font color="darkgreen">
    &quot;Zeros of a polynomial with real coefficients, e.g., eigen values of a real matrix&quot;</font>;
  <font color="blue">input </font>String name=&quot;EigenvalueVector&quot; <font color="darkgreen">
    &quot;Name of complexVector to be used in error message&quot;</font>;
  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Eigenvalue</A> reorderedEigenvalues[<font color="red">size</font>(EigenvalueVector, 1)] <font color="darkgreen">
    &quot;Reordered zeros&quot;</font>;
  <font color="blue">output </font>Integer nRealEigenvalues <font color="darkgreen">
    &quot;Number of real zeros (EigenvalueVector[1:nRealEigenvalues] are the real zeros)&quot;</font>;

<font color="blue">protected </font>
  Integer n=<font color="red">size</font>(EigenvalueVector, 1);
  Integer i;
  Integer jr;
  Integer jc;
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> complexVector[<font color="red">size</font>(EigenvalueVector, 1)];
<font color="blue">algorithm </font>
nRealEigenvalues:=<font color="red">numberOfRealZeros</font>(complexVector);

  i := 1;
  jr := 1;
  jc := nRealEigenvalues + 1;
  <font color="blue">while </font>i &lt;= n<font color="blue"> loop</font>
    <font color="blue">if </font>EigenvalueVector[i].ev.im == 0.0<font color="blue"> then</font>

      reorderedEigenvalues[jr] := EigenvalueVector[i];
      reorderedEigenvalues[jr].ev.im := 0.0;
      i := i + 1;
      jr := jr + 1;
    <font color="blue">else</font>
<font color="darkgreen">// check that the next two zeros are a conjugate complex pair</font>
      <font color="red">assert</font>(i &lt; n, &quot;Argument &quot; + name +
        &quot; does not define a real valued polynomial\n&quot; + name + &quot;[&quot; +<font color="red"> String</font>(n)
         + &quot;] is complex without complex conjugate.&quot;);
      <font color="red">assert</font>(<font color="red">abs</font>(EigenvalueVector[i].ev.re - EigenvalueVector[i+1].ev.re) &lt;<font color="red"> max</font>(Modelica.Constants.eps,
        <font color="red">abs</font>(EigenvalueVector[i+1].ev.re)*100*Modelica.Constants.eps),
        &quot;No conjugate complex pair (checked the real parts)\n&quot; + &quot;  &quot; + name +
        &quot;[&quot; +<font color="red"> String</font>(i) + &quot;] = &quot; +<font color="red"> String</font>(EigenvalueVector[i].ev) + &quot;\n&quot; + &quot;  &quot; +
        name + &quot;[&quot; +<font color="red"> String</font>(i + 1) + &quot;] = &quot; +<font color="red"> String</font>(EigenvalueVector[i].ev) + &quot;\n&quot;
         +
        &quot;and the real parts of these two complex numbers should be identical\n&quot;
         + &quot;since conjugate complex pairs required.&quot;);
      <font color="red"> assert</font>(<font color="red">abs</font>(EigenvalueVector[i].ev.im + EigenvalueVector[i+1].ev.im) &lt;<font color="red"> max</font>(Modelica.Constants.eps,
        <font color="red">abs</font>(EigenvalueVector[i+1].ev.im)*100*Modelica.Constants.eps),
        &quot;No conjugate complex pair (checked the imaginary parts)\n&quot; + &quot;  &quot; +
        name + &quot;[&quot; +<font color="red"> String</font>(i) + &quot;] = &quot; +<font color="red"> String</font>(EigenvalueVector[i].ev) + &quot;\n&quot; +
        &quot;  &quot; + name + &quot;[&quot; +<font color="red"> String</font>(i + 1) + &quot;] = &quot; +<font color="red"> String</font>(EigenvalueVector[i + 1].ev)
         + &quot;\n&quot; +
        &quot;and the imaginary parts of these two complex numbers should be identical\n&quot;
         + &quot;with opposite sign, since a conjugate complex pair is required.&quot;);

      <font color="darkgreen">  // Store the zero with the positive imaginary part</font>

      <font color="blue">if </font>EigenvalueVector[i].ev.im &gt;= 0<font color="blue"> then</font>
        reorderedEigenvalues[jc] := EigenvalueVector[i];
        reorderedEigenvalues[jc + 1] := EigenvalueVector[i+1];
      <font color="blue">else</font>
        reorderedEigenvalues[jc] := EigenvalueVector[i+1];
        reorderedEigenvalues[jc + 1] := EigenvalueVector[i];
      <font color="blue">end if</font>;
      i := i + 2;
      jc := jc + 2;
    <font color="blue">end if</font>;
  <font color="blue">end while</font>;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>reorderEigenvalue;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE reorderZeros<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Internal.reorderZeros"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>.reorderZeros</H2>
<B>Extract real and conjugate complex elements from a complex vector</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4><font color="#008000">Syntax</font></h4>
<blockquote><pre>
               reorderedZero = Internal.<b>reorderZeros</b>(complexVector);
(reorderedZeros, nRealZeros) = Internal.<b>reorderZeros</b>(complexVector, 
                                                     name="complexVector");
</pre></blockquote>
<h4><font color="#008000">Description</font></h4>
<p>
Function <b>reorderZeros</b>(..) reorders the zeros from the
Complex vector "complexVector" such that the returned Complex vector
reorderedZeros contains first all real Zeros and afterwards the conjugate
complex zero pairs. It is required that all elements
of complexVector define either a real zero (complexVector[i].im=0) 
or a conjugate complex zero pair
(complexVector[i].re == complexVector[i+1].re and
complexVector[i].im == -complexVector[i+1].im). 
The optional input argument
"name" is used as name of "complexVector" in error messages.
</p>
<p>
The function returns the vector element reordered, as well as
the number of real zeros (nRealZeros).
<h4><font color="#008000">Example</font></h4>
<blockquote><pre>
    
  // c = {0; 1+2j; 1-2j; 2; -3; -1-j; -1+j};
    Real complexZeros[:] = fill(Complex(0), integer((size(c,1)-n)/2));
  algorithm
  (reorderedZeros, nRealZeros) := reorderZeros(c);
      -> reorderedZeros = {0, 2, (-3), 1+2j, 1-2j, -1+j, -1-j}
         nRealZeros     = 3
 
</pre></blockquote>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>complexVector[:]</TD><TD>&nbsp;</TD><TD>Zeros of a polynomial with real coefficients, e.g., eigen values of a real matrix</TD></TR>
<TR><TD>String</TD><TD>name</TD><TD>&quot;complexVector&quot;</TD><TD>Name of complexVector to be used in error message</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>reorderedZeros[size(complexVector, 1)]</TD><TD>Reordered zeros</TD></TR>
<TR><TD>Integer</TD><TD>nRealZeros</TD><TD>Number of real zeros (reorderedZeros[1:nRealZeros] are the real zeros)</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> reorderZeros <font color="darkgreen">
  &quot;Extract real and conjugate complex elements from a complex vector&quot;</font>
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> complexVector[:] <font color="darkgreen">
    &quot;Zeros of a polynomial with real coefficients, e.g., eigen values of a real matrix&quot;</font>;
  <font color="blue">input </font>String name=&quot;complexVector&quot; <font color="darkgreen">
    &quot;Name of complexVector to be used in error message&quot;</font>;
  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> reorderedZeros[<font color="red">size</font>(complexVector, 1)] <font color="darkgreen">&quot;Reordered zeros&quot;</font>;
  <font color="blue">output </font>Integer nRealZeros=<font color="red">numberOfRealZeros</font>(complexVector) <font color="darkgreen">
    &quot;Number of real zeros (reorderedZeros[1:nRealZeros] are the real zeros)&quot;</font>;

<font color="blue">protected </font>
  Integer n=<font color="red">size</font>(complexVector, 1);
  Integer i;
  Integer jr;
  Integer jc;
<font color="blue">algorithm </font>
  i := 1;
  jr := 1;
  jc := nRealZeros + 1;
  <font color="blue">while </font>i &lt;= n<font color="blue"> loop</font>
    <font color="blue">if </font><font color="red">abs</font>(complexVector[i].im) &lt; Modelica.Constants.eps<font color="blue"> then</font>
      reorderedZeros[jr].re := complexVector[i].re;
      reorderedZeros[jr].im := 0.0;
      i := i + 1;
      jr := jr + 1;
    <font color="blue">else</font>
<font color="darkgreen">// check that the next two zeros are a conjugate complex pair</font>
      <font color="red">assert</font>(i &lt; n, &quot;Argument &quot; + name +
        &quot; does not define a real valued polynomial\n&quot; + name + &quot;[&quot; +<font color="red"> String</font>(n)
         + &quot;] is complex without complex conjugate.&quot;);
      <font color="red">assert</font>(<font color="red">abs</font>(complexVector[i].re - complexVector[i + 1].re) &lt;<font color="red"> max</font>(Modelica.Constants.eps,
        <font color="red">abs</font>(complexVector[i + 1].re)*100*Modelica.Constants.eps),
        &quot;No conjugate complex pair (checked the real parts)\n&quot; + &quot;  &quot; + name +
        &quot;[&quot; +<font color="red"> String</font>(i) + &quot;] = &quot; +<font color="red"> String</font>(complexVector[i]) + &quot;\n&quot; + &quot;  &quot; +
        name + &quot;[&quot; +<font color="red"> String</font>(i + 1) + &quot;] = &quot; +<font color="red"> String</font>(complexVector[i]) + &quot;\n&quot;
         +
        &quot;and the real parts of these two complex numbers should be identical\n&quot;
         + &quot;since conjugate complex pairs required.&quot;);
      <font color="red">assert</font>(<font color="red">abs</font>(complexVector[i].im + complexVector[i + 1].im) &lt;<font color="red"> max</font>(Modelica.Constants.eps,
        <font color="red">abs</font>(complexVector[i + 1].im)*100*Modelica.Constants.eps),
        &quot;No conjugate complex pair (checked the imaginary parts)\n&quot; + &quot;  &quot; +
        name + &quot;[&quot; +<font color="red"> String</font>(i) + &quot;] = &quot; +<font color="red"> String</font>(complexVector[i]) + &quot;\n&quot; +
        &quot;  &quot; + name + &quot;[&quot; +<font color="red"> String</font>(i + 1) + &quot;] = &quot; +<font color="red"> String</font>(complexVector[i + 1])
         + &quot;\n&quot; +
        &quot;and the imaginary parts of these two complex numbers should be identical\n&quot;
         + &quot;with opposite sign, since a conjugate complex pair is required.&quot;);

      <font color="darkgreen">  // Store the zero with the positive imaginary part</font>
      <font color="blue">if </font>complexVector[i].im &gt;= 0<font color="blue"> then</font>
        reorderedZeros[jc] := complexVector[i];
        reorderedZeros[jc + 1] := complexVector[i + 1];
      <font color="blue">else</font>
        reorderedZeros[jc] := complexVector[i + 1];
        reorderedZeros[jc + 1] := complexVector[i];
      <font color="blue">end if</font>;
      i := i + 2;
      jc := jc + 2;
    <font color="blue">end if</font>;
  <font color="blue">end while</font>;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>reorderZeros;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE sortEigenvalue<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Internal.sortEigenvalueI.png" ALT="Modelica_LinearSystems2.Internal.sortEigenvalue" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Internal.sortEigenvalue"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>.sortEigenvalue</H2>
<B>Sort elements of Eigenvalue-record depending on the eigenvalues</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4><font color="#008000">Syntax</font></h4>
<blockquote><pre>
           sorted_v = Vectors.<b>sort</b>(v);
(sorted_v, indices) = Vectors.<b>sort</b>(v, ascending=true);
</pre></blockquote>
<h4><font color="#008000">Description</font></h4>
<p>
Function <b>sort</b>(..) sorts a Real vector v
in ascending order and returns the result in sorted_v.
If the optional argument "ascending" is <b>false</b>, the vector
is sorted in descending order. In the optional second
output argument the indices of the sorted vector with respect
to the original vector are given, such that sorted_v = v[indices].
</p>
<h4><font color="#008000">Example</font></h4>
<blockquote><pre>
  (v2, i2) := Vectors.sort({-1, 8, 3, 6, 2});
       -> v2 = {-1, 2, 3, 6, 8}
          i2 = {1, 5, 3, 4, 2}
</pre></blockquote>
<pre></PRE><P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Eigenvalue</A></TD><TD>ev[:]</TD><TD>&nbsp;</TD><TD>Vector to be sorted</TD></TR>
<TR><TD>Boolean</TD><TD>ascending</TD><TD>true</TD><TD>= true if ascending order, otherwise descending order</TD></TR>
<TR><TD>Boolean</TD><TD>sortFrequency</TD><TD>true</TD><TD>= true, if sorting is first for imaginary then for real value; = false, if sorting is for absolute value</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Eigenvalue</A></TD><TD>sorted_ev[size(ev, 1)]</TD><TD>Sorted vector</TD></TR>
<TR><TD>Integer</TD><TD>indices[size(ev, 1)]</TD><TD>sorted_ev = ev[indices]</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> sortEigenvalue <font color="darkgreen">
  &quot;Sort elements of Eigenvalue-record depending on the eigenvalues&quot;</font>
  <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;

  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Modelica_LinearSystems2.Internal.Eigenvalue</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Eigenvalue</A> ev[:] <font color="darkgreen">&quot;Vector to be sorted&quot;</font>;
  <font color="blue">input </font>Boolean ascending = true <font color="darkgreen">
    &quot;= true if ascending order, otherwise descending order&quot;</font>;
  <font color="blue">input </font>Boolean sortFrequency=true <font color="darkgreen">
    &quot;= true, if sorting is first for imaginary then for real value; = false, if sorting is for absolute value&quot;</font>;
  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Eigenvalue</A> sorted_ev[<font color="red">size</font>(ev,1)] = ev <font color="darkgreen">&quot;Sorted vector&quot;</font>;
  <font color="blue">output </font>Integer indices[<font color="red">size</font>(ev,1)] = 1:<font color="red">size</font>(ev,1) <font color="darkgreen">&quot;sorted_ev = ev[indices]&quot;</font>;

  <font color="darkgreen">/* shellsort algorithm; should be improved later */</font>
<font color="blue">protected </font>
  Integer gap;
  Integer i;
  Integer j;
  <A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Eigenvalue</A> wev;
  Integer wi;
  Integer nev =<font color="red"> size</font>(ev,1);
  Boolean swap;
  Integer k1;
  Integer k2;
<font color="blue">algorithm </font>
  gap :=<font color="red"> div</font>(nev,2);

  <font color="blue">while </font>gap &gt; 0<font color="blue"> loop</font>
     i := gap;
     <font color="blue">while </font>i &lt; nev<font color="blue"> loop</font>
        j := i-gap;
        <font color="blue">if </font>j&gt;=0<font color="blue"> then</font>
           k1 := j+1;
           k2 := j + gap + 1;
           <font color="blue">if </font>sortFrequency<font color="blue"> then</font>
              <font color="blue">if </font>ascending<font color="blue"> then</font>
                 swap :=<font color="red"> abs</font>(sorted_ev[k1].ev.im) &gt;<font color="red">  abs</font>(sorted_ev[k2].ev.im)<font color="blue"> or </font>
                         <font color="red">abs</font>(sorted_ev[k1].ev.im) ==<font color="red"> abs</font>(sorted_ev[k2].ev.im)<font color="blue"> and </font>
                         (sorted_ev[k1].ev.re  &gt; sorted_ev[k2].ev.re<font color="blue"> or </font>
                          sorted_ev[k1].ev.re  == sorted_ev[k2].ev.re<font color="blue"> and </font>sorted_ev[k1].ev.im &lt; sorted_ev[k2].ev.im);
              <font color="blue">else</font>
                 swap :=<font color="red"> abs</font>(sorted_ev[k1].ev.im) &lt;<font color="red">  abs</font>(sorted_ev[k2].ev.im)<font color="blue"> or </font>
                         <font color="red">abs</font>(sorted_ev[k1].ev.im) ==<font color="red"> abs</font>(sorted_ev[k2].ev.im)<font color="blue"> and </font>
                         (sorted_ev[k1].ev.re  &lt; sorted_ev[k2].ev.re<font color="blue"> or </font>
                          sorted_ev[k1].ev.re  == sorted_ev[k2].ev.re<font color="blue"> and </font>sorted_ev[k1].ev.im &lt; sorted_ev[k2].ev.im);
              <font color="blue">end if</font>;
           <font color="blue">else</font>
              <font color="blue">if </font>ascending<font color="blue"> then</font>
                 swap :=<font color="red"> Complex.&#39;abs&#39;</font>(sorted_ev[k1].ev) &gt;<font color="red"> Complex.&#39;abs&#39;</font>(sorted_ev[k2].ev);
              <font color="blue">else</font>
                 swap :=<font color="red"> Complex.&#39;abs&#39;</font>(sorted_ev[k1].ev) &lt;<font color="red"> Complex.&#39;abs&#39;</font>(sorted_ev[k2].ev);
              <font color="blue">end if</font>;
           <font color="blue">end if</font>;
        <font color="blue">else</font>
           swap := false;
        <font color="blue">end if</font>;

        <font color="blue">while </font>swap<font color="blue"> loop</font>
           wev := sorted_ev[j+1];
           wi := indices[j+1];
           sorted_ev[j+1] := sorted_ev[j+gap+1];
           sorted_ev[j+gap+1] := wev;
           indices[j+1] := indices[j+gap+1];
           indices[j+gap+1] := wi;
           j := j - gap;
           <font color="blue">if </font>j &gt;= 0<font color="blue"> then</font>
              k1 := j+1;
              k2 := j + gap + 1;
              <font color="blue">if </font>sortFrequency<font color="blue"> then</font>
                 <font color="blue">if </font>ascending<font color="blue"> then</font>
                    swap :=<font color="red"> abs</font>(sorted_ev[k1].ev.im) &gt;<font color="red">  abs</font>(sorted_ev[k2].ev.im)<font color="blue"> or </font>
                            <font color="red">abs</font>(sorted_ev[k1].ev.im) ==<font color="red"> abs</font>(sorted_ev[k2].ev.im)<font color="blue"> and </font>
                            (sorted_ev[k1].ev.re  &gt; sorted_ev[k2].ev.re<font color="blue"> or </font>
                             sorted_ev[k1].ev.re  == sorted_ev[k2].ev.re<font color="blue"> and </font>sorted_ev[k1].ev.im &lt; sorted_ev[k2].ev.im);
                 <font color="blue">else</font>
                    swap :=<font color="red"> abs</font>(sorted_ev[k1].ev.im) &lt;<font color="red">  abs</font>(sorted_ev[k2].ev.im)<font color="blue"> or </font>
                            <font color="red">abs</font>(sorted_ev[k1].ev.im) ==<font color="red"> abs</font>(sorted_ev[k2].ev.im)<font color="blue"> and </font>
                            (sorted_ev[k1].ev.re  &lt; sorted_ev[k2].ev.re<font color="blue"> or </font>
                             sorted_ev[k1].ev.re  == sorted_ev[k2].ev.re<font color="blue"> and </font>sorted_ev[k1].ev.im &lt; sorted_ev[k2].ev.im);
                 <font color="blue">end if</font>;
              <font color="blue">else</font>
                 <font color="blue">if </font>ascending<font color="blue"> then</font>
                    swap :=<font color="red"> Complex.&#39;abs&#39;</font>(sorted_ev[k1].ev) &gt;<font color="red"> Complex.&#39;abs&#39;</font>(sorted_ev[k2].ev);
                 <font color="blue">else</font>
                    swap :=<font color="red"> Complex.&#39;abs&#39;</font>(sorted_ev[k1].ev) &lt;<font color="red"> Complex.&#39;abs&#39;</font>(sorted_ev[k2].ev);
                 <font color="blue">end if</font>;
              <font color="blue">end if</font>;
           <font color="blue">else</font>
              swap := false;
           <font color="blue">end if</font>;
        <font color="blue">end while</font>;
        i := i + 1;
     <font color="blue">end while</font>;
     gap :=<font color="red"> div</font>(gap,2);
  <font color="blue">end while</font>;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>sortEigenvalue;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE timeResponseMask<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Internal.timeResponseMask"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>.timeResponseMask</H2>
<B>Declares the common structure for the set of response functions</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>sc</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>dt</TD><TD>0</TD><TD>Sample time [s]</TD></TR>
<TR><TD>Real</TD><TD>tSpan</TD><TD>0</TD><TD>Simulation time span [s]</TD></TR>
<TR><TD>Integer</TD><TD>toWindow[:, :]</TD><TD>fill(-1, size(sc.C, 1), size...</TD><TD>-1/0/&gt;0 plot in new window/last window/window ID</TD></TR>
<TR><TD>Boolean</TD><TD>clearWindow[:, :]</TD><TD>fill(false, size(sc.C, 1), s...</TD><TD>= true, if previous window content is removed</TD></TR>
<TR><TD>String</TD><TD>heading[:, :]</TD><TD>fill(&quot;Time response&quot;, size(s...</TD><TD>Heading of the response diagram</TD></TR>
<TR><TD>String</TD><TD>columnLabels[size(sc.C, 1) + 1]</TD><TD>Modelica_LinearSystems2.Inte...</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>y[:, size(sc.C, 1), size(sc.B, 2)]</TD><TD>Output response: (number of samples) x (number of outputs) x (number of inputs)</TD></TR>
<TR><TD>Real</TD><TD>t[:]</TD><TD>Time vector: (number of samples)</TD></TR>
<TR><TD>Real</TD><TD>x_continuous[:, size(sc.A, 1), size(sc.B, 2)]</TD><TD>State trajectories: (number of samples) x (number of states) x (number of inputs)</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">partial </font><font color="blue">function</font> timeResponseMask <font color="darkgreen">
  &quot;Declares the common structure for the set of response functions&quot;</font>
  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> sc;
  <font color="blue">input </font>Real dt=0 <font color="darkgreen">&quot;Sample time [s]&quot;</font>;
  <font color="blue">input </font>Real tSpan=0 <font color="darkgreen">&quot;Simulation time span [s]&quot;</font>;
  <font color="blue">input </font>Integer toWindow[:,:]=<font color="red">fill</font>(
      -1,
      <font color="red">size</font>(sc.C, 1),
      <font color="red">size</font>(sc.B, 2)) <font color="darkgreen">&quot;-1/0/&gt;0 plot in new window/last window/window ID&quot;</font>;
  <font color="darkgreen">/* the Dialog annotation seems not to work properly. why? */</font>
  <font color="blue">input </font>Boolean clearWindow[:,:]=<font color="red">fill</font>(
      false,
      <font color="red">size</font>(sc.C, 1),
      <font color="red">size</font>(sc.B, 2)) <font color="darkgreen">&quot;= true, if previous window content is removed&quot;</font>;
  <font color="blue">input </font>String heading[:,:]=<font color="red">fill</font>(
      &quot;Time response&quot;,
      <font color="red">size</font>(sc.C, 1),
      <font color="red">size</font>(sc.B, 2)) <font color="darkgreen">&quot;Heading of the response diagram&quot;</font>;

  <font color="blue">input </font>String columnLabels[<font color="red">size</font>(sc.C, 1) + 1]=
      <font color="red">Modelica_LinearSystems2.Internal.defaultColumnLabels</font>(<font color="red">size</font>(sc.C, 1));

  <font color="blue">replaceable </font><font color="blue">output </font>Real y[:,<font color="red">size</font>(sc.C, 1),<font color="red">size</font>(sc.B, 2)] <font color="darkgreen">
    &quot;Output response: (number of samples) x (number of outputs) x (number of inputs)&quot;</font>;
  <font color="blue">output </font>Real t[:] <font color="darkgreen">&quot;Time vector: (number of samples)&quot;</font>;
  <font color="blue">replaceable </font><font color="blue">output </font>Real x_continuous[:,<font color="red">size</font>(sc.A, 1),<font color="red">size</font>(sc.B, 2)] <font color="darkgreen">
    &quot;State trajectories: (number of samples) x (number of states) x (number of inputs)&quot;</font>;

<font color="blue">end </font>timeResponseMask;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE timeResponseMask2<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Internal.timeResponseMask2"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>.timeResponseMask2</H2>
<B>Declares the common structure for the set of response functions</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>sc</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>dt</TD><TD>0</TD><TD>Sample time [s]</TD></TR>
<TR><TD>Real</TD><TD>tSpan</TD><TD>0</TD><TD>Simulation time span [s]</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>y[:, size(sc.C, 1), size(sc.B, 2)]</TD><TD>Output response: (number of samples) x (number of outputs) x (number of inputs)</TD></TR>
<TR><TD>Real</TD><TD>t[:]</TD><TD>Time vector: (number of samples)</TD></TR>
<TR><TD>Real</TD><TD>x_continuous[:, size(sc.A, 1), size(sc.B, 2)]</TD><TD>State trajectories: (number of samples) x (number of states) x (number of inputs)</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">partial </font><font color="blue">function</font> timeResponseMask2 <font color="darkgreen">
  &quot;Declares the common structure for the set of response functions&quot;</font>
  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> sc;
  <font color="blue">input </font>Real dt=0 <font color="darkgreen">&quot;Sample time [s]&quot;</font>;
  <font color="blue">input </font>Real tSpan=0 <font color="darkgreen">&quot;Simulation time span [s]&quot;</font>;

  <font color="blue">replaceable </font><font color="blue">output </font>Real y[:,<font color="red">size</font>(sc.C, 1),<font color="red">size</font>(sc.B, 2)] <font color="darkgreen">
    &quot;Output response: (number of samples) x (number of outputs) x (number of inputs)&quot;</font>;
  <font color="blue">output </font>Real t[:] <font color="darkgreen">&quot;Time vector: (number of samples)&quot;</font>;
  <font color="blue">replaceable </font><font color="blue">output </font>Real x_continuous[:,<font color="red">size</font>(sc.A, 1),<font color="red">size</font>(sc.B, 2)] <font color="darkgreen">
    &quot;State trajectories: (number of samples) x (number of states) x (number of inputs)&quot;</font>;

<font color="blue">end </font>timeResponseMask2;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE timeResponseMask2_tf<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Internal.timeResponseMask2_tf"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>.timeResponseMask2_tf</H2>
<B>Declares the common structure for the set of response functions</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A></TD><TD>tf</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>dt</TD><TD>0</TD><TD>Sample time [s]</TD></TR>
<TR><TD>Real</TD><TD>tSpan</TD><TD>0</TD><TD>Simulation time span [s]</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>y[:, 1, 1]</TD><TD>Output response: (number of samples) x (number of outputs) x (number of inputs)</TD></TR>
<TR><TD>Real</TD><TD>t[:]</TD><TD>Time vector: (number of samples)</TD></TR>
<TR><TD>Real</TD><TD>x_continuous[:, Modelica_LinearSystems2.TransferFunction.Analysis.denominatorDegree(tf), 1]</TD><TD>State trajectories: (number of samples) x (number of states) x (number of inputs)</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">partial </font><font color="blue">function</font> timeResponseMask2_tf <font color="darkgreen">
  &quot;Declares the common structure for the set of response functions&quot;</font>
  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A> tf;
  <font color="blue">input </font>Real dt=0 <font color="darkgreen">&quot;Sample time [s]&quot;</font>;
  <font color="blue">input </font>Real tSpan=0 <font color="darkgreen">&quot;Simulation time span [s]&quot;</font>;

  <font color="blue">replaceable </font><font color="blue">output </font>Real y[:,1,1] <font color="darkgreen">
    &quot;Output response: (number of samples) x (number of outputs) x (number of inputs)&quot;</font>;
  <font color="blue">output </font>Real t[:] <font color="darkgreen">&quot;Time vector: (number of samples)&quot;</font>;
  <font color="blue">replaceable </font><font color="blue">output </font>Real x_continuous[:,<font color="red">Modelica_LinearSystems2.TransferFunction.Analysis.denominatorDegree</font>(tf), 1] <font color="darkgreen">
    &quot;State trajectories: (number of samples) x (number of states) x (number of inputs)&quot;</font>;

<font color="blue">end </font>timeResponseMask2_tf;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE timeResponseMask2_zp<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Internal.timeResponseMask2_zp"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>.timeResponseMask2_zp</H2>
<B>Declares the common structure for the set of response functions</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A></TD><TD>zp</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>dt</TD><TD>0</TD><TD>Sample time [s]</TD></TR>
<TR><TD>Real</TD><TD>tSpan</TD><TD>0</TD><TD>Simulation time span [s]</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>y[:, 1, 1]</TD><TD>Output response: (number of samples) x (number of outputs) x (number of inputs)</TD></TR>
<TR><TD>Real</TD><TD>t[:]</TD><TD>Time vector: (number of samples)</TD></TR>
<TR><TD>Real</TD><TD>x_continuous[:, Modelica_LinearSystems2.ZerosAndPoles.Analysis.denominatorDegree(zp), 1]</TD><TD>State trajectories: (number of samples) x (number of states) x (number of inputs)</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">partial </font><font color="blue">function</font> timeResponseMask2_zp <font color="darkgreen">
  &quot;Declares the common structure for the set of response functions&quot;</font>
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A> zp;
  <font color="blue">input </font>Real dt=0 <font color="darkgreen">&quot;Sample time [s]&quot;</font>;
  <font color="blue">input </font>Real tSpan=0 <font color="darkgreen">&quot;Simulation time span [s]&quot;</font>;

  <font color="blue">replaceable </font><font color="blue">output </font>Real y[:,1,1] <font color="darkgreen">
    &quot;Output response: (number of samples) x (number of outputs) x (number of inputs)&quot;</font>;
  <font color="blue">output </font>Real t[:] <font color="darkgreen">&quot;Time vector: (number of samples)&quot;</font>;
  <font color="blue">replaceable </font><font color="blue">output </font>Real x_continuous[:,<font color="red">Modelica_LinearSystems2.ZerosAndPoles.Analysis.denominatorDegree</font>(zp), 1] <font color="darkgreen">
    &quot;State trajectories: (number of samples) x (number of states) x (number of inputs)&quot;</font>;

<font color="blue">end </font>timeResponseMask2_zp;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE timeResponseMask_tf<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Internal.timeResponseMask_tf"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>.timeResponseMask_tf</H2>
<B>Declares the common structure for the set of response functions for a transfer function</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A></TD><TD>tf</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>dt</TD><TD>0</TD><TD>Sample time [s]</TD></TR>
<TR><TD>Real</TD><TD>tSpan</TD><TD>0</TD><TD>Simulation time span [s]</TD></TR>
<TR><TD>Integer</TD><TD>toWindow[:, :]</TD><TD>fill(-1, 1, 1)</TD><TD>-1/0/&gt;0 plot in new window/last window/window ID</TD></TR>
<TR><TD>Boolean</TD><TD>clearWindow[:, :]</TD><TD>fill(false, 1, 1)</TD><TD>= true, if previous window content is removed</TD></TR>
<TR><TD>String</TD><TD>heading[:, :]</TD><TD>fill(&quot;Time response&quot;, 1, 1)</TD><TD>Heading of the response diagram</TD></TR>
<TR><TD>String</TD><TD>columnLabels[2]</TD><TD>Modelica_LinearSystems2.Inte...</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>y[:, 1, 1]</TD><TD>Output response: (number of samples) x (number of outputs) x (number of inputs)</TD></TR>
<TR><TD>Real</TD><TD>t[:]</TD><TD>Time vector: (number of samples)</TD></TR>
<TR><TD>Real</TD><TD>x_continuous[:, Modelica_LinearSystems2.TransferFunction.Analysis.denominatorDegree(tf), 1]</TD><TD>State trajectories: (number of samples) x (number of states) x (number of inputs)</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">partial </font><font color="blue">function</font> timeResponseMask_tf <font color="darkgreen">
  &quot;Declares the common structure for the set of response functions for a transfer function&quot;</font>
  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf;
  <font color="blue">input </font>Real dt=0 <font color="darkgreen">&quot;Sample time [s]&quot;</font>;
  <font color="blue">input </font>Real tSpan=0 <font color="darkgreen">&quot;Simulation time span [s]&quot;</font>;
  <font color="blue">input </font>Integer toWindow[:,:]=<font color="red">fill</font>(
      -1,
      1,
      1) <font color="darkgreen">&quot;-1/0/&gt;0 plot in new window/last window/window ID&quot;</font>;
  <font color="darkgreen">/* the Dialog annotation seems not to work properly. why? */</font>
  <font color="blue">input </font>Boolean clearWindow[:,:]=<font color="red">fill</font>(
      false,
      1,
      1) <font color="darkgreen">&quot;= true, if previous window content is removed&quot;</font>;
  <font color="blue">input </font>String heading[:,:]=<font color="red">fill</font>(
      &quot;Time response&quot;,
      1,
      1) <font color="darkgreen">&quot;Heading of the response diagram&quot;</font>;

  <font color="blue">input </font>String columnLabels[2]=
      <font color="red">Modelica_LinearSystems2.Internal.defaultColumnLabels</font>(1);

  <font color="blue">replaceable </font><font color="blue">output </font>Real y[:,1,1] <font color="darkgreen">
    &quot;Output response: (number of samples) x (number of outputs) x (number of inputs)&quot;</font>;
  <font color="blue">output </font>Real t[:] <font color="darkgreen">&quot;Time vector: (number of samples)&quot;</font>;
  <font color="blue">replaceable </font><font color="blue">output </font>Real x_continuous[:,<font color="red"> Modelica_LinearSystems2.TransferFunction.Analysis.denominatorDegree</font>(tf), 1] <font color="darkgreen">
    &quot;State trajectories: (number of samples) x (number of states) x (number of inputs)&quot;</font>;

<font color="blue">end </font>timeResponseMask_tf;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE timeResponseMask_zp<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Internal.timeResponseMask_zp"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>.timeResponseMask_zp</H2>
<B>Declares the common structure for the set of response functions for a zeros and poles transfer function</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A></TD><TD>zp</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>dt</TD><TD>0</TD><TD>Sample time [s]</TD></TR>
<TR><TD>Real</TD><TD>tSpan</TD><TD>0</TD><TD>Simulation time span [s]</TD></TR>
<TR><TD>Integer</TD><TD>toWindow[:, :]</TD><TD>fill(-1, 1, 1)</TD><TD>-1/0/&gt;0 plot in new window/last window/window ID</TD></TR>
<TR><TD>Boolean</TD><TD>clearWindow[:, :]</TD><TD>fill(false, 1, 1)</TD><TD>= true, if previous window content is removed</TD></TR>
<TR><TD>String</TD><TD>heading[:, :]</TD><TD>fill(&quot;Time response&quot;, 1, 1)</TD><TD>Heading of the response diagram</TD></TR>
<TR><TD>String</TD><TD>columnLabels[2]</TD><TD>Modelica_LinearSystems2.Inte...</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>y[:, 1, 1]</TD><TD>Output response: (number of samples) x (number of outputs) x (number of inputs)</TD></TR>
<TR><TD>Real</TD><TD>t[:]</TD><TD>Time vector: (number of samples)</TD></TR>
<TR><TD>Real</TD><TD>x_continuous[:, Modelica_LinearSystems2.ZerosAndPoles.Analysis.denominatorDegree(zp), 1]</TD><TD>State trajectories: (number of samples) x (number of states) x (number of inputs)</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">partial </font><font color="blue">function</font> timeResponseMask_zp <font color="darkgreen">
  &quot;Declares the common structure for the set of response functions for a zeros and poles transfer function&quot;</font>
  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp;
  <font color="blue">input </font>Real dt=0 <font color="darkgreen">&quot;Sample time [s]&quot;</font>;
  <font color="blue">input </font>Real tSpan=0 <font color="darkgreen">&quot;Simulation time span [s]&quot;</font>;
  <font color="blue">input </font>Integer toWindow[:,:]=<font color="red">fill</font>(
      -1,
      1,
      1) <font color="darkgreen">&quot;-1/0/&gt;0 plot in new window/last window/window ID&quot;</font>;
  <font color="darkgreen">/* the Dialog annotation seems not to work properly. why? */</font>
  <font color="blue">input </font>Boolean clearWindow[:,:]=<font color="red">fill</font>(
      false,
      1,
      1) <font color="darkgreen">&quot;= true, if previous window content is removed&quot;</font>;
  <font color="blue">input </font>String heading[:,:]=<font color="red">fill</font>(
      &quot;Time response&quot;,
      1,
      1) <font color="darkgreen">&quot;Heading of the response diagram&quot;</font>;

  <font color="blue">input </font>String columnLabels[2]=
      <font color="red">Modelica_LinearSystems2.Internal.defaultColumnLabels</font>(1);

  <font color="blue">replaceable </font><font color="blue">output </font>Real y[:,1,1] <font color="darkgreen">
    &quot;Output response: (number of samples) x (number of outputs) x (number of inputs)&quot;</font>;
  <font color="blue">output </font>Real t[:] <font color="darkgreen">&quot;Time vector: (number of samples)&quot;</font>;
  <font color="blue">replaceable </font><font color="blue">output </font>Real x_continuous[:,<font color="red"> Modelica_LinearSystems2.ZerosAndPoles.Analysis.denominatorDegree</font>(zp), 1] <font color="darkgreen">
    &quot;State trajectories: (number of samples) x (number of states) x (number of inputs)&quot;</font>;

<font color="blue">end </font>timeResponseMask_zp;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE timeResponseSamples<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Internal.timeResponseSamples"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>.timeResponseSamples</H2>
<B>Estimate reasonable discretisation sample time and simulation time span for time response plot</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>sc</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>dt</TD><TD>Sample time</TD></TR>
<TR><TD>Real</TD><TD>tSpan</TD><TD>Time span</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> timeResponseSamples <font color="darkgreen">
  &quot;Estimate reasonable discretisation sample time and simulation time span for time response plot&quot;</font>
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A> sc;
  <font color="blue">output </font>Real dt <font color="darkgreen">&quot;Sample time&quot;</font>;
  <font color="blue">output </font>Real tSpan <font color="darkgreen">&quot;Time span&quot;</font>;
<font color="blue">protected </font>
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A> eig[<font color="red">size</font>(sc.A, 1)];
  Real realp[<font color="red">size</font>(sc.A, 1)];
  Real sorted[<font color="red">size</font>(sc.A, 1)];
  Real indices[<font color="red">size</font>(sc.A, 1)];
  Integer i;
<font color="blue">algorithm </font>
  eig :=<font color="red"> Modelica_LinearSystems2.StateSpace.Analysis.eigenValues</font>(sc);
  <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(eig, 1)<font color="blue"> loop</font>
    realp[i] := eig[i].re;
  <font color="blue">end for</font>;
  (sorted,indices) :=<font color="red"> Modelica.Math.Vectors.sort</font>(realp);

  <font color="darkgreen">// Estimate simulation time span</font>
  <font color="blue">if </font>sorted[<font color="blue">end</font>] &lt; 0<font color="blue"> then</font>
    tSpan := -5*sorted[<font color="blue">end</font>];
  <font color="blue">elseif </font>sorted[<font color="blue">end</font>] &gt; 0<font color="blue"> then</font>
    tSpan := 15/sorted[<font color="blue">end</font>];
  <font color="blue">elseif </font>sorted[<font color="blue">end</font>] == 0<font color="blue"> then</font>
    tSpan := 15000;
  <font color="blue">end if</font>;
  <font color="darkgreen">// Curb simulation time span to maximal 15000s</font>
  <font color="blue">if </font>tSpan &gt; 15000<font color="blue"> then</font>
    tSpan := 15000;
  <font color="blue">end if</font>;

  <font color="darkgreen">// set sample time:</font>
  dt := tSpan/1000;

<font color="blue">end </font>timeResponseSamples;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE from_Hz<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Internal.from_HzI.png" ALT="Modelica_LinearSystems2.Internal.from_Hz" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Internal.from_Hz"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>.from_Hz</H2>
<B>Convert from Hz to rad/s</B><p>
<P><H3>Information</H3></P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits_Conversions.html#Modelica.SIunits.Conversions.ConversionIcon"
>Modelica.SIunits.Conversions.ConversionIcon</A> (Base icon for conversion functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Frequency</A></TD><TD>f</TD><TD>&nbsp;</TD><TD>frequency [Hz]</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>AngularVelocity</A></TD><TD>w</TD><TD>angular velocity [rad/s]</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> from_Hz <font color="darkgreen">&quot;Convert from Hz to rad/s&quot;</font>
  <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits_Conversions.html#Modelica.SIunits.Conversions.ConversionIcon"
>Modelica.SIunits.Conversions.ConversionIcon</A>;
  <font color="blue">input </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Modelica.SIunits.Frequency</A> f <font color="darkgreen">&quot;frequency&quot;</font>;
  <font color="blue">output </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>Modelica.SIunits.AngularVelocity</A> w <font color="darkgreen">&quot;angular velocity&quot;</font>;

<font color="blue">algorithm </font>
  w := 2*Modelica.Constants.pi*f;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>from_Hz;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE to_Hz<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Internal.from_HzI.png" ALT="Modelica_LinearSystems2.Internal.to_Hz" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Internal.to_Hz"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>.to_Hz</H2>
<B>Convert from rad/s to Hz</B><p>
<P><H3>Information</H3></P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits_Conversions.html#Modelica.SIunits.Conversions.ConversionIcon"
>Modelica.SIunits.Conversions.ConversionIcon</A> (Base icon for conversion functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>AngularVelocity</A></TD><TD>w</TD><TD>&nbsp;</TD><TD>angular velocity [rad/s]</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Frequency</A></TD><TD>f</TD><TD>frequency [Hz]</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> to_Hz <font color="darkgreen">&quot;Convert from rad/s to Hz&quot;</font>
  <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits_Conversions.html#Modelica.SIunits.Conversions.ConversionIcon"
>Modelica.SIunits.Conversions.ConversionIcon</A>;
  <font color="blue">input </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>Modelica.SIunits.AngularVelocity</A> w <font color="darkgreen">&quot;angular velocity&quot;</font>;
  <font color="blue">output </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Modelica.SIunits.Frequency</A> f <font color="darkgreen">&quot;frequency&quot;</font>;
<font color="blue">algorithm </font>
  f := w/(2*Modelica.Constants.pi);
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>to_Hz;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Internal<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal"></A><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>.Internal</H2>
<B>Internal library of record StateSpace (should not be directly used by user)</B>
<P>
<P><H3>Information</H3></P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons_Library.html#Modelica.Icons.Library"
>Modelica.Icons.Library</A> (Icon for library).
<P><H3>Package Content</H3><p>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 >
<TR><TH >Name</TH><TH>Description</TH></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.isSISO" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.isSISO"
>isSISO</A>
</TD><TD>To check a state space system to be SISO (or not)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.invariantZeros2" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.invariantZeros2"
>invariantZeros2</A>
</TD><TD>Compute invariant zeros of linear SISO state space system with a generalized system matrix [A, B, C, D] which is of upper Hessenberg form</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.characterizeEigenvalue" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.characterizeEigenvalue"
>characterizeEigenvalue</A>
</TD><TD>Check stability, stabilizability, controllability, observability nad detectability of the single poles</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.isStabilizableSISO" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.isStabilizableSISO"
>isStabilizableSISO</A>
</TD><TD>To check wether a SISO system is stabliziable</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.isStabilizableMIMO" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.isStabilizableMIMO"
>isStabilizableMIMO</A>
</TD><TD>To check wether a MIMO system is stabliziable</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.isDetectableSISO" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.isDetectableSISO"
>isDetectableSISO</A>
</TD><TD>To check wether a SISO system is detectable</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.isDetectableMIMO" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.isDetectableMIMO"
>isDetectableMIMO</A>
</TD><TD>To check wether a MIMO system is detectable</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.isObservableSISO" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.isObservableSISO"
>isObservableSISO</A>
</TD><TD>To check wether a SISO system is observable</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.isControllableSISO" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.isControllableSISO"
>isControllableSISO</A>
</TD><TD>To check a SISO system wether it is controllable</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.isControllableMIMO" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.isControllableMIMO"
>isControllableMIMO</A>
</TD><TD>To check a MIMO system wether it is controllable</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.isObservableMIMO" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.isObservableMIMO"
>isObservableMIMO</A>
</TD><TD>To check a MIMO system wether it is observable</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.isControllableAndObservableSISO" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.isControllableAndObservableSISO"
>isControllableAndObservableSISO</A>
</TD><TD>To check whether a SISO system is controllable and observable</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.readLength_nx" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.readLength_nx"
>readLength_nx</A>
</TD><TD>Read the order nx of a state space system from a file</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.staircaseQR" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.staircaseQR"
>staircaseQR</A>
</TD><TD>Staircase algorithm to put a state space system to controller Hessenberg form</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.staircaseSVD" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.staircaseSVD"
>staircaseSVD</A>
</TD><TD>Staircase algorithm based on singular value decomposition</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.partialGain" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.partialGain"
>partialGain</A>
</TD><TD>&nbsp;</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.assignOneOrTwoPoles_alpha" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.assignOneOrTwoPoles_alpha"
>assignOneOrTwoPoles_alpha</A>
</TD><TD>Algorithm to assign p (p = 1 or 2) eigenvalues</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.assignOneOrTwoPoles" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.assignOneOrTwoPoles"
>assignOneOrTwoPoles</A>
</TD><TD>Algorithm to assign p (p = 1 or 2) eigenvalues</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.readSystemDimension" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.readSystemDimension"
>readSystemDimension</A>
</TD><TD>Read the order nx of state matrix and the numbers nu and ny of inputs and outputs</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.readLength_nu" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.readLength_nu"
>readLength_nu</A>
</TD><TD>Read the number of inputs nu of a state space system from a file</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.readLength_ny" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.readLength_ny"
>readLength_ny</A>
</TD><TD>Read the number of outputs ny of a state space system from a file</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.dgreeOfRedSys" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.dgreeOfRedSys"
>dgreeOfRedSys</A>
</TD><TD>Calculate the controllable and observable part of a state space system</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.householder" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.householder"
>householder</A>
</TD><TD>&nbsp;</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.numberOfZeros" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.numberOfZeros"
>numberOfZeros</A>
</TD><TD>Calculate the number of zeros of the related transfer function</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.complexZeros" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.complexZeros"
>complexZeros</A>
</TD><TD>Calculate the zeros of the related transfer function</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.numberOfPoles" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.numberOfPoles"
>numberOfPoles</A>
</TD><TD>Calculate the number of poles of the related transfer function</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.numberOfPolesAndZeros" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.numberOfPolesAndZeros"
>numberOfPolesAndZeros</A>
</TD><TD>Calculate the number poles and of zeros of the related transfer function</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.complexPoles" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.complexPoles"
>complexPoles</A>
</TD><TD>Generate a zeros-and-poles representation from state space representation</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.trianUpperHess" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.trianUpperHess"
>trianUpperHess</A>
</TD><TD>Triangulize an upper Hessenberg matrix by repeatedly applicated householder reflexion</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.reducedCtrSystem2" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.reducedCtrSystem2"
>reducedCtrSystem2</A>
</TD><TD>calculate the controllable part of a SISO system</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.controllablePoles" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.controllablePoles"
>controllablePoles</A>
</TD><TD>Compute the controllable and uncontrollable poles of a state space system</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.polesAndZeros" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.polesAndZeros"
>polesAndZeros</A>
</TD><TD>Generate poles and zeros from state space representation</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.scaleFactor1" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.scaleFactor1"
>scaleFactor1</A>
</TD><TD>Return scale factor for first order block</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.scaleFactor2" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.scaleFactor2"
>scaleFactor2</A>
</TD><TD>Return scale factor for second order block</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.invariantZerosHessenberg" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.invariantZerosHessenberg"
>invariantZerosHessenberg</A>
</TD><TD>Fast version to calculate the system zeros of a SISO system with D=[0] and A has upper Hessenberg form, delivered by StateSpace.reduceSystem</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.cntrHessenberg" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.cntrHessenberg"
>cntrHessenberg</A>
</TD><TD>calculate the controllable part of a SISO system</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.transposeStateSpace" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.transposeStateSpace"
>transposeStateSpace</A>
</TD><TD>Return the transposed state space system</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.reduceRosenbrock" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.reduceRosenbrock"
>reduceRosenbrock</A>
</TD><TD>Algorithm to compress the generalized system matrix [A, B; C, D] to calculate the invariant zeros of a system</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.reducedCtrSystem" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.reducedCtrSystem"
>reducedCtrSystem</A>
</TD><TD>calculate the controllable part of a SISO system</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.reducedCtrSystemX" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.reducedCtrSystemX"
>reducedCtrSystemX</A>
</TD><TD>calculate the controllable part of a SISO system</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.StateSpace.Internal.isSISOS.png" ALT="Modelica_LinearSystems2.StateSpace.Internal.assignPolesMI2" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal.assignPolesMI2"
>assignPolesMI2</A>
</TD><TD>Pole assigment design algorithm for multi input systems</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE isSISO<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.isSISO"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.isSISO</H2>
<B>To check a state space system to be SISO (or not)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
 
 
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>ss</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Boolean</TD><TD>isSISO</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> isSISO <font color="darkgreen">
  &quot;To check a state space system to be SISO (or not)&quot;</font>

    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;

  <font color="blue">output </font>Boolean isSISO;
<font color="blue">algorithm </font>
  isSISO :=<font color="red"> size</font>(ss.B, 2) == 1<font color="blue"> and </font><font color="red">size</font>(ss.C, 1) == 1;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>isSISO;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE invariantZeros2<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.invariantZeros2"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.invariantZeros2</H2>
<B>Compute invariant zeros of linear SISO state space system with a generalized system matrix [A, B, C, D] which is of upper Hessenberg form</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
Computes the invariant zeros of a system in state space form:
</p>
<pre>
   der(<b>x</b>) = <b>A</b>*<b>x</b> + <b>B</b>*<b>u</b>
        <b>y</b> = <b>C</b>*<b>x</b> + <b>D</b>*<b>u</b>
</pre>
<p>
The invariant zeros of this system are defined as the variables
z that make the following matrix singular:
</p>
<pre> 
    | <b>A</b> <b>B</b> |     | <b>I</b> <b>0</b> |
    |     | - z*|     |
    | <b>C</b> <b>D</b> |     | <b>0</b> <b>0</b> |
</pre>
<p>
where <b>I</b> is the identity matrix of the same size as <b>A</b>
and <b>0</b> are zero matrices of appropriate dimensions.
</p>
<p>
Unlike to function StateSpace.Analysis.invariantZeros for general systems, it is
assumned in StateSpace.Analysis.invariantZeros that the generalized system matrix
[<b>A</b>, <b>B</b>; <b>C</b>, <b>D</b>] hast upper Hessenberg form. Especially for SISO system this is
achieved when <b>A</b> is of upper Hessenberg form and [1, n] matrix <b>C</b> is of form
<b>C</b> = k*[0, 0, ..., 0, 1].
<p>
The function uses the LAPACK routine DHGEQZ. Look at <b>Modelica_LinearSystems2.Math.Matrices.LAPACK.dhgeqz</b> for details.
<p>
The advantage of this function in comparision to the general invariantZeros function
is the lower computatioal effort bacause systems with arbitrary system functions are first transformed
into an upper Hessenberg form system.
<p>
This function is used in fromStateSpace transformation functions which use Hessenberg form systems anyway.
</p>
<p>
Currently, there is the restriction that the number of 
inputs and the number of outputs must be identical. Other systems
have to be treated like p*q SISO systems where p is the number of putputs and q the number of inputs of the MIMO system.
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>ss</TD><TD>&nbsp;</TD><TD>Linear system in state space form</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>Zeros[:]</TD><TD>Finite, invariant zeros of ss; size(Zeros,1) &lt;= size(ss.A,1)</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> invariantZeros2 <font color="darkgreen">
  &quot;Compute invariant zeros of linear SISO state space system with a generalized system matrix [A, B, C, D] which is of upper Hessenberg form&quot;</font>
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;Linear system in state space form&quot;</font>;
  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> Zeros[:] <font color="darkgreen">
    &quot;Finite, invariant zeros of ss; size(Zeros,1) &lt;= size(ss.A,1)&quot;</font>;

<font color="blue">protected </font>
  Integer nx=<font color="red">size</font>(ss.A, 1) <font color="darkgreen">&quot;Number of states&quot;</font>;
  Integer nu=<font color="red">size</font>(ss.B, 2) <font color="darkgreen">&quot;Number of inputs&quot;</font>;
  Integer ny=<font color="red">size</font>(ss.C, 1) <font color="darkgreen">&quot;Number of outputs&quot;</font>;
  Integer na=nx + nu;
  Real A[nx + ny,nx + nu]=[ss.A,ss.B; ss.C,ss.D];
  Real B[nx + ny,nx + nu]=[<font color="red">identity</font>(nx),<font color="red">zeros</font>(nx, nu);<font color="red"> zeros</font>(ny, nx + nu)];
  Real alphaReal[na];
  Real alphaImag[na];
  Real beta[na];
  Integer info;
  Real beta_small=100*Modelica.Constants.eps;
  Integer nZeros;
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> z[<font color="red">size</font>(ss.A, 1)];
  Integer j;
  Real normB=<font color="red">max</font>(beta_small,<font color="red">Modelica.Math.Matrices.norm</font>(ss.B, p=1));
<font color="blue">algorithm </font>
  <font color="red">assert</font>(nu == ny, &quot;Function invariantZeros requires currently that the number of
inputs (= &quot;
          +<font color="red"> String</font>(nu) + &quot;) = number of outputs (= &quot; +<font color="red"> String</font>(ny) + &quot;)
This condition is however not fulfilled&quot;);

<font color="darkgreen">// Compute zeros</font>

  (alphaReal,alphaImag,beta,info) :=
    <font color="red">Matrices.generalizedEigenvaluesTriangular</font>(A, B);

  <font color="red">assert</font>(info == 0,
    &quot;Failed to compute invariant zeros with function invariantZeros(..)&quot;);

<font color="darkgreen">// If beta[i] is zero, then zero i is infinite.</font>
  j := 1;
  <font color="blue">for </font>i<font color="blue"> in </font>1:na<font color="blue"> loop</font>

   <font color="blue">if </font>beta[i] &gt;= normB*1e-6<font color="blue"> then</font>
     <font color="darkgreen">// finite eigenvalue</font>
      z[j].re := <font color="blue">if </font><font color="red">abs</font>(alphaReal[i]) &gt;= normB*1e-12<font color="blue"> then </font>alphaReal[i]/beta[i]<font color="blue"> else </font>
              0;
      z[j].im := <font color="blue">if </font><font color="red">abs</font>(alphaImag[i]) &gt;= normB*1e-12<font color="blue"> then </font>alphaImag[i]/beta[i]<font color="blue"> else </font>
              0;
      j := j + 1;
    <font color="blue">end if</font>;
  <font color="blue">end for</font>;
  nZeros := j - 1;
  Zeros := z[1:nZeros];
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>invariantZeros2;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE characterizeEigenvalue<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.characterizeEigenvalue"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.characterizeEigenvalue</H2>
<B>Check stability, stabilizability, controllability, observability nad detectability of the single poles</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>ss</TD><TD>Modelica_LinearSystems2.Stat...</TD><TD>&nbsp;</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Eigenvalue</A></TD><TD>evin[:]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Eigenvalue</A></TD><TD>ev[size(ss.A, 1)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> characterizeEigenvalue <font color="darkgreen">
  &quot;Check stability, stabilizability, controllability, observability nad detectability of the single poles&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Modelica_LinearSystems2.Internal.Eigenvalue</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss=<font color="red">Modelica_LinearSystems2.StateSpace</font>(
      A=<font color="red">fill</font>(
        0,
        0,
        0),
      B=<font color="red">fill</font>(
        0,
        0,
        0),
      C=<font color="red">fill</font>(
        0,
        0,
        0),
      D=<font color="red">fill</font>(
        0,
        0,
        0));
  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Eigenvalue</A> evin[:];
  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Eigenvalue</A> ev[<font color="red">size</font>(ss.A, 1)];

<font color="blue">protected </font>
  Real cPoles[:,2] <font color="darkgreen">&quot;controllable poles&quot;</font>;
  Real ncPoles[:,2] <font color="darkgreen">&quot;uncontrollable poles&quot;</font>;
  Real poles[<font color="red">size</font>(ss.A, 1),2] <font color="darkgreen">&quot;controllable and uncontrollable poles&quot;</font>;
  Integer n_c;
  Integer nx=<font color="red">size</font>(ss.A, 1);

  <A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Eigenvalue</A> cdummy[<font color="red">size</font>(ss.A, 1)];
  <A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.Eigenvalue"
>Eigenvalue</A> odummy[<font color="red">size</font>(ss.A, 1)];
  <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> sst=<font color="red">StateSpace</font>(
      A=<font color="red">transpose</font>(ss.A),
      B=<font color="red">transpose</font>(ss.C),
      C=<font color="red">transpose</font>(ss.B),
      D=<font color="red">transpose</font>(ss.D));
  Boolean equal;
  Integer ii;

  Real eps=1e-16*<font color="red">Modelica.Math.Matrices.norm</font>(A=ss.A, p=1);
  Real factor_eps=1;
  Real absVector[nx];
  Integer indices[:];
  Integer indexMin;
  Real indexVector[:];
  Integer vv[:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> j =<font color="red"> Modelica_LinearSystems2.Math.Complex.j</font>();

<font color="blue">algorithm </font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
    ev[i].ev := evin[i].ev;
  <font color="blue">end for</font>;

  (cPoles,ncPoles,poles) :=<font color="red"> StateSpace.Internal.controllablePoles</font>(ss);
  n_c :=<font color="red"> size</font>(cPoles, 1);
  <font color="blue">for </font>i<font color="blue"> in </font>1:n_c<font color="blue"> loop</font>
    cdummy[i].ev := cPoles[i, 1]+cPoles[i, 2]*j;
    cdummy[i].isControllable := true;
  <font color="blue">end for</font>;
  <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(ncPoles, 1)<font color="blue"> loop</font>
    cdummy[n_c + i].ev := ncPoles[i, 1]+ncPoles[i, 2]*j;
    cdummy[n_c + i].isControllable := false;
  <font color="blue">end for</font>;

<font color="darkgreen">// controllable poles of the trnasposed system are the observable poles</font>
  (cPoles,ncPoles,poles) :=<font color="red"> StateSpace.Internal.controllablePoles</font>(sst);
  n_c :=<font color="red"> size</font>(cPoles, 1);
  <font color="blue">for </font>i<font color="blue"> in </font>1:n_c<font color="blue"> loop</font>
    odummy[i].ev := cPoles[i, 1]+cPoles[i, 2]*j;
    odummy[i].isObservable := true;
  <font color="blue">end for</font>;
  <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(ncPoles, 1)<font color="blue"> loop</font>
    odummy[n_c + i].ev := ncPoles[i, 1]+ncPoles[i, 2]*j;
    odummy[n_c + i].isObservable := false;
  <font color="blue">end for</font>;

<font color="darkgreen">// using ev.imag as an flag to mark the eigenvalues</font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
    absVector :=<font color="red"> fill</font>(1e50, nx);
    <font color="blue">for </font>ii<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
      <font color="blue">if </font><font color="blue">not </font>odummy[ii].imag<font color="blue"> then</font>
        absVector[ii] :=<font color="red"> Complex.&#39;abs&#39;</font>(ev[i].ev - odummy[ii].ev);
      <font color="blue">end if</font>;
    <font color="blue">end for</font>;
    (absVector,indices) :=<font color="red"> Modelica.Math.Vectors.sort</font>(absVector);
    indexMin := indices[1];
    ev[i].isObservable := odummy[indexMin].isObservable;
    odummy[indexMin].imag := true;
  <font color="blue">end for</font>;

  <font color="blue">for </font>i<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
    absVector :=<font color="red"> fill</font>(1e50, nx);
    <font color="blue">for </font>ii<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
      <font color="blue">if </font><font color="blue">not </font>cdummy[ii].imag<font color="blue"> then</font>
        absVector[ii] :=<font color="red"> Complex.&#39;abs&#39;</font>(ev[i].ev - cdummy[ii].ev);
      <font color="blue">end if</font>;
    <font color="blue">end for</font>;
    (absVector,indices) :=<font color="red"> Modelica.Math.Vectors.sort</font>(absVector);
    indexMin := indices[1];
    ev[i].isControllable := cdummy[indexMin].isControllable;
    cdummy[indexMin].imag := true;
  <font color="blue">end for</font>;

  <font color="blue">for </font>i<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
    ev[i] :=<font color="red"> Eigenvalue</font>(
      ev[i].ev,
      ev[i].isControllable,
      ev[i].isObservable);
  <font color="blue">end for</font>;

<font color="blue">end </font>characterizeEigenvalue;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE isStabilizableSISO<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.isStabilizableSISO"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.isStabilizableSISO</H2>
<B>To check wether a SISO system is stabliziable</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
This function checks whether a SISO state space system is stabilizable or not.
<p>
A system is stabilizable for the continuous-time case if all of the uncontrollable eigenvalues have neagtive real part
or for the discrete-time case if all of the uncontrollable eigenvalues are in the complex unit circle respectively.
Hence, a controllable system is always stabilizable of course.
<p>
To check stabilizability, ths system is transformed to to upper controller Hessenberg form
<blockquote><pre>
               | *   *   ...   ...    * |               | * |
               | *   *   ...   ...    * |               | 0 |
 <b>Q</b>*<b>A</b>*<b>Q</b> ' = <b>H</b> = | 0   *   ...   ...    * |,    <b>Q</b>*<b>b</b> = <b>q</b> = | . |,   <b>c</b>*<b>Q</b> = ( *, ..., * )
               | .   .    .     .     . |               | . |
               | 0  ...   0     *     * |               | 0 |
 
</pre>
</blockquote>
The system can be partitioned to 
 
<blockquote><pre>
<b>H</b>=[<b>H</b>11,<b>H</b>12; <b>H</b>21, <b>H</b>22], <b>q</b>=[<b>q</b>1;<b>0</b>],
</pre>
</blockquote
where the pair (<b>H</b>11, <b>q</b>1) contains the controllable part of the system, that is, rank(<b>H</b>) = rank(<b>H</b>11). For
stabilizability the <b>H</b>22 has to be stable.
 
 
 
 
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>ss</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Boolean</TD><TD>stabilizable</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> isStabilizableSISO <font color="darkgreen">
  &quot;To check wether a SISO system is stabliziable&quot;</font>

    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;

<font color="blue">protected </font>
  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.StateSpaceR"
>Modelica_LinearSystems2.Internal.StateSpaceR</A> ssm=
      <font color="red">StateSpace.Internal.cntrHessenberg</font>(ss);
<font color="blue">public </font>
  <font color="blue">output </font>Boolean stabilizable;

<font color="blue">protected </font>
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> evd[:]=<font color="red">fill</font>(<font color="red">Complex</font>(0),<font color="red"> size</font>(ss.A, 1) - ssm.r);

<font color="blue">algorithm </font>
  <font color="blue">if </font><font color="red">size</font>(ss.C, 1) &lt;&gt; 1<font color="blue"> or </font><font color="red">size</font>(ss.B, 2) &lt;&gt; 1<font color="blue"> then</font>
    <font color="red">assert</font>(<font color="red">size</font>(ss.B, 2) == 1,
      &quot;A SISO-system is expected as input\n but the number of inputs is &quot; +
      <font color="red">String</font>(<font color="red">size</font>(ss.B, 2)) + &quot; instead of 1&quot;);
    <font color="red">assert</font>(<font color="red">size</font>(ss.C, 1) == 1,
      &quot; A SISO-system is expected as input\n but the number of outputs is &quot; +
      <font color="red">String</font>(<font color="red">size</font>(ss.C, 1)) + &quot; instead of 1&quot;);
  <font color="blue">end if</font>;
  evd :=<font color="red"> Complex.eigenValues</font>(ssm.A[ssm.r + 1:<font color="red">size</font>(ss.A, 1), ssm.r + 1:<font color="red">size</font>(ss.A,
    1)]);
  stabilizable := true;

  <font color="blue">if </font><font color="red">size</font>(ss.A, 1) &gt; ssm.r<font color="blue"> then</font>
     <font color="blue">for </font>i1<font color="blue"> in </font>1:<font color="red">size</font>(evd, 1)<font color="blue"> loop</font>
      stabilizable := stabilizable<font color="blue"> and </font>evd[i1].re &lt; 0;
    <font color="blue">end for</font>;
  <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>isStabilizableSISO;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE isStabilizableMIMO<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.isStabilizableMIMO"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.isStabilizableMIMO</H2>
<B>To check wether a MIMO system is stabliziable</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
This function checks whether a MIMO state space system is stabilizable or not.
<p>
A system is stabilizable for the continuous-time case if all of the uncontrollable eigenvalues have neagtive real part
or for the discrete-time case if all of the uncontrollable eigenvalues are in the complex unit circle respectively.
Hence, a controllable system is always stabilizable of course.
<p>
To check stabilizability, staircase algorithm is used to separate the controllable subspace from the uncontrollable subspace.
The uncontrollable poles are checked to to stable.
  
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>ss</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Boolean</TD><TD>stabilizable</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> isStabilizableMIMO <font color="darkgreen">
  &quot;To check wether a MIMO system is stabliziable&quot;</font>

    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;

    <font color="blue">output </font>Boolean stabilizable;

<font color="blue">protected </font>
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> evnc[:] <font color="darkgreen">&quot;complex vector of uncontrollable poles&quot;</font>;
    Real cPoles[:,2] <font color="darkgreen">&quot;controllable poles&quot;</font>;
    Real ncPoles[:,2] <font color="darkgreen">&quot;uncontrollable poles&quot;</font>;
    Real poles[<font color="red">size</font>(ss.A, 1),2] <font color="darkgreen">&quot;controllable and uncontrollable poles&quot;</font>;
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> j=<font color="red">Modelica_LinearSystems2.Math.Complex.j</font>();

<font color="blue">algorithm </font>
    (cPoles,ncPoles,poles) :=<font color="red"> StateSpace.Internal.controllablePoles</font>(ss);
    evnc :=<font color="red"> fill</font>(<font color="red">Complex</font>(0),<font color="red"> size</font>(ncPoles, 1));
    <font color="blue">for </font>i1<font color="blue"> in </font>1:<font color="red">size</font>(ncPoles, 1)<font color="blue"> loop</font>
      evnc[i1] := ncPoles[i1, 1] + j*ncPoles[i1, 2];
    <font color="blue">end for</font>;

    stabilizable := true;

    <font color="blue">if </font><font color="red">size</font>(ss.A, 1) &gt;<font color="red"> size</font>(cPoles, 1)<font color="blue"> then</font>
      <font color="blue">for </font>i1<font color="blue"> in </font>1:<font color="red">size</font>(ncPoles, 1)<font color="blue"> loop</font>
        stabilizable := stabilizable<font color="blue"> and </font>ncPoles[i1, 1] &lt; 0;
      <font color="blue">end for</font>;
    <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>isStabilizableMIMO;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE isDetectableSISO<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.isDetectableSISO"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.isDetectableSISO</H2>
<B>To check wether a SISO system is detectable</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
This function checks whether a SISO state space system is detectable or not.
<p>
A system is detectable for the continuous-time case if all of the unobservable eigenvalues have neagtive real part
or for the discrete-time case if all of the unobservable eigenvalues are in the complex unit circle respectively.
Hence, a oberservable system is always detectable of course.
<p>
As observability is a dual concept of controllability, the concept of detectability is dual to stabilizability, that is,
a system is detectable if the pair (<b>A</b>', <b>C</b>') is stabilizable. Therefore, the same algorithm to check stabilizability
are applied to the dual pair (<b>A</b>', <b>C</b>') of the system:
<p>
To check stabilizability (see Modelica_LinearSystems2.StateSpace.Analysis.isStabilizable) , ths system is transformed to to upper controller Hessenberg form
<blockquote><pre>
               | *   *   ...   ...    * |               | * |
               | *   *   ...   ...    * |               | 0 |
 <b>Q</b>*<b>A</b>*<b>Q</b> ' = <b>H</b> = | 0   *   ...   ...    * |,    <b>Q</b>*<b>b</b> = <b>q</b> = | . |,   <b>c</b>*<b>Q</b> = ( *, ..., * )
               | .   .    .     .     . |               | . |
               | 0  ...   0     *     * |               | 0 |
 
</pre>
</blockquote>
The system can be partitioned to 
 
<blockquote><pre>
<b>H</b>=[<b>H</b>11,<b>H</b>12; <b>H</b>21, <b>H</b>22], <b>q</b>=[<b>q</b>1;<b>0</b>],
</pre>
</blockquote
where the pair (<b>H</b>11, <b>q</b>1) contains the controllable part of the system, that is, rank(<b>H</b>) = rank(<b>H</b>11). For
stabilizability the <b>H</b>22 has to be stable.
</p>
 
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>ss</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Boolean</TD><TD>detectable</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> isDetectableSISO <font color="darkgreen">
  &quot;To check wether a SISO system is detectable&quot;</font>

    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;

<font color="blue">protected </font>
  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.StateSpaceR"
>Modelica_LinearSystems2.Internal.StateSpaceR</A> ssm=
      <font color="red">StateSpace.Internal.cntrHessenberg</font>(
      <font color="red">StateSpace.Internal.transposeStateSpace</font>(ss));
<font color="blue">public </font>
  <font color="blue">output </font>Boolean detectable;
<font color="blue">protected </font>
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> evd[:]=<font color="red">fill</font>(<font color="red">Complex</font>(0),<font color="red"> size</font>(ss.A, 1) - ssm.r);

<font color="blue">algorithm </font>
  <font color="blue">if </font><font color="red">size</font>(ss.C, 1) &lt;&gt; 1<font color="blue"> or </font><font color="red">size</font>(ss.B, 2) &lt;&gt; 1<font color="blue"> then</font>
    <font color="red">assert</font>(<font color="red">size</font>(ss.B, 2) == 1,
      &quot;A SISO-system is expected as input\n but the number of inputs is &quot; +
      <font color="red">String</font>(<font color="red">size</font>(ss.B, 2)) + &quot; instead of 1&quot;);
    <font color="red">assert</font>(<font color="red">size</font>(ss.C, 1) == 1,
      &quot; A SISO-system is expected as input\n but the number of outputs is &quot; +
      <font color="red">String</font>(<font color="red">size</font>(ss.C, 1)) + &quot; instead of 1&quot;);
  <font color="blue">end if</font>;
  evd :=<font color="red"> Complex.eigenValues</font>(ssm.A[ssm.r + 1:<font color="red">size</font>(ss.A, 1), ssm.r + 1:<font color="red">size</font>(ss.A,1)]);

  <font color="blue">if </font><font color="red">size</font>(ss.A, 1) == ssm.r<font color="blue"> then</font>
    detectable := true;

  <font color="blue">else</font>
    detectable := true;
    <font color="blue">for </font>i1<font color="blue"> in </font>1:<font color="red">size</font>(evd, 1)<font color="blue"> loop</font>
      detectable := detectable<font color="blue"> and </font>evd[i1].re &lt; 0;
    <font color="blue">end for</font>;
  <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>isDetectableSISO;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE isDetectableMIMO<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.isDetectableMIMO"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.isDetectableMIMO</H2>
<B>To check wether a MIMO system is detectable</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
This function checks whether a MIMO state space system is detectable or not.
<p>
A system is detectable for the continuous-time case if all of the unobservable eigenvalues have negative real part
or for the discrete-time case if all of the unobservable eigenvalues are in the complex unit circle respectively.
Hence, a observable system is always detectable of course.
<p>
To check detectability, staircase algorithm is used to separate the observable subspace from the unobservable subspace.
The unobservable poles are checked to be stable.
 
 
 
 
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>ss</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Boolean</TD><TD>detectable</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> isDetectableMIMO <font color="darkgreen">
  &quot;To check wether a MIMO system is detectable&quot;</font>

    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;

    <font color="blue">output </font>Boolean detectable;

<font color="blue">protected </font>
    <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> sst=<font color="red">StateSpace.Internal.transposeStateSpace</font>(ss);

    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> evnd[:] <font color="darkgreen">&quot;complex vector of uncontrollable poles&quot;</font>;
    Real dPoles[:,2] <font color="darkgreen">&quot;controllable poles&quot;</font>;
    Real ndPoles[:,2] <font color="darkgreen">&quot;uncontrollable poles&quot;</font>;
    Real poles[<font color="red">size</font>(ss.A, 1),2] <font color="darkgreen">&quot;controllable and uncontrollable poles&quot;</font>;
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> j=<font color="red">Modelica_LinearSystems2.Math.Complex.j</font>();

<font color="blue">algorithm </font>
    (dPoles,ndPoles,poles) :=<font color="red"> StateSpace.Internal.controllablePoles</font>(sst);
    evnd :=<font color="red"> fill</font>(<font color="red">Complex</font>(0),<font color="red"> size</font>(ndPoles, 1));
    <font color="blue">for </font>i1<font color="blue"> in </font>1:<font color="red">size</font>(ndPoles, 1)<font color="blue"> loop</font>
      evnd[i1] := ndPoles[i1, 1] + j*ndPoles[i1, 2];
    <font color="blue">end for</font>;

    detectable := true;

    <font color="blue">if </font><font color="red">size</font>(sst.A, 1) ==<font color="red"> size</font>(dPoles, 1)<font color="blue"> then</font>
      detectable := true;
    <font color="blue">else</font>
      <font color="blue">for </font>i1<font color="blue"> in </font>1:<font color="red">size</font>(ndPoles, 1)<font color="blue"> loop</font>
        detectable := detectable<font color="blue"> and </font>ndPoles[i1, 1] &lt; 0;
      <font color="blue">end for</font>;
    <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>isDetectableMIMO;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE isObservableSISO<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.isObservableSISO"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.isObservableSISO</H2>
<B>To check wether a SISO system is observable</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
This function is to calculate whether a SISO state space system is observable or not. Therefore, the dual System (A', c', b', d')
it is transformed to upper observer Hessenberg form
<blockquote><pre>
               | *   *   ...   ...    * |             | * |
               | *   *   ...   ...    * |             | . |
 <b>Q</b>*<b>A'</b>*<b>Q</b>' = <b>H</b> = | 0   *   ...   ...    * |,    <b>Q</b>*<b>c'</b> =  | . |,   <b>b'</b>*<b>Q</b> = <b>q</b> = ( 0, ..., 0, * )
               | .   .    .     .     . |             | * |
               | 0  ...   0     *     * |             | * |
  
</pre>
</blockquote>
Note, that
<blockquote><pre>
                         n-1                          n-1
rank(<b>c'</b>; <b>c'*<b>A'</b>; ...; <b>c'</b>*A'</b>   ) = rank(<b>q</b>; <b>q</b>*<b>H</b>; ...; <b>q</b>*<b>H</b>   )
</pre>
</blockquote>
and that
<blockquote><pre>
                  n-1
 (<b>q</b>; <b>H</b>*<b>q</b>; ...; <b>q</b>*<b>H</b>  )
</pre>
</blockquote>
is a lower triangular matrix and has full rank if and only if none of the elements in the diagonal is zero. That is, that neither qn or hi,i-1,   i = 2,..., n   may be zero.
 
 
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>ss</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Boolean</TD><TD>observable</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> isObservableSISO <font color="darkgreen">
  &quot;To check wether a SISO system is observable&quot;</font>

    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

   <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;

<font color="blue">protected </font>
   <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss2=<font color="red">StateSpace.Internal.transposeStateSpace</font>(ss);

   <A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.StateSpaceR"
>Modelica_LinearSystems2.Internal.StateSpaceR</A> ssm2=
       <font color="red">StateSpace.Internal.reducedCtrSystem</font>(ss2);
<font color="blue">public </font>
   <font color="blue">output </font>Boolean observable;
<font color="blue">algorithm </font>
 <font color="blue">if </font><font color="red">size</font>(ss.C, 1) &lt;&gt; 1<font color="blue"> or </font><font color="red">size</font>(ss.B, 2) &lt;&gt; 1<font color="blue"> then</font>
    <font color="red">   assert</font>(<font color="red">size</font>(ss.B, 2) == 1,
         &quot;A SISO-system is expected as input\n but the number of inputs is &quot;
          +<font color="red"> String</font>(<font color="red">size</font>(ss.B, 2)) + &quot; instead of 1&quot;);
    <font color="red">   assert</font>(<font color="red">size</font>(ss.C, 1) == 1,
         &quot; A SISO-system is expected as input\n but the number of outputs is &quot;
          +<font color="red"> String</font>(<font color="red">size</font>(ss.C, 1)) + &quot; instead of 1&quot;);
     <font color="blue">end if</font>;
   observable :=<font color="red"> size</font>(ss.A, 1) == ssm2.r;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>isObservableSISO;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE isControllableSISO<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.isControllableSISO"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.isControllableSISO</H2>
<B>To check a SISO system wether it is controllable</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
This function is to calculate whether a SISO state space system is controllable or not. Therefore,
it is transformed to lower controller Hessenberg form
<blockquote><pre>
               | *    *     0   ...  0 |               | 0 |
               | .    .     .    .   . |               | . |
 <b>Q</b>*<b>A</b>*<b>Q</b> ' = <b>H</b> = | *   ...   ...   *   0 |,    <b>Q</b>*<b>b</b> = <b>q</b> = | . |,   <b>c</b>*<b>Q</b> = ( *, ..., * )
               | *   ...   ...   *   * |               | 0 |
               | *   ...   ...   *   * |               | * |
 
</pre>
</blockquote>
Note, that
<blockquote><pre>
                   n-1                        n-1
rank(<b>b</b>, <b>A</b>*<b>b</b>, ..., <b>A</b>  *<b>b</b>) = rank(<b>q</b>, <b>H</b>*<b>q</b>, ..., <b>H  </b>*<b>q</b>)
</pre>
</blockquote>
and that
<blockquote><pre>
                 n-1
 (<b>q</b>, <b>H</b>*<b>q</b>, ..., <b>H</b>  *<b>q</b>)
</pre>
</blockquote>
is a lower triangular matrix and has full rank if and only if none of the elements in the diagonal is zero. That is, that neither qn or hi,i+1,   i = 1,..., n-1   may be zero.
 
 
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>ss</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Boolean</TD><TD>controllable</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> isControllableSISO <font color="darkgreen">
  &quot;To check a SISO system wether it is controllable&quot;</font>

    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;

<font color="blue">protected </font>
  <A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.StateSpaceR"
>Modelica_LinearSystems2.Internal.StateSpaceR</A> ssm=
      <font color="red">StateSpace.Internal.reducedCtrSystem</font>(ss);

<font color="blue">public </font>
  <font color="blue">output </font>Boolean controllable;
<font color="blue">algorithm </font>
  <font color="blue">if </font><font color="red">size</font>(ss.C, 1) &lt;&gt; 1<font color="blue"> or </font><font color="red">size</font>(ss.B, 2) &lt;&gt; 1<font color="blue"> then</font>
    <font color="red">assert</font>(<font color="red">size</font>(ss.B, 2) == 1,
      &quot;A SISO-system is expected as input\n but the number of inputs is &quot;
       +<font color="red"> String</font>(<font color="red">size</font>(ss.B, 2)) + &quot; instead of 1&quot;);
    <font color="red">assert</font>(<font color="red">size</font>(ss.C, 1) == 1,
      &quot; A SISO-system is expected as input\n but the number of outputs is &quot;
       +<font color="red"> String</font>(<font color="red">size</font>(ss.C, 1)) + &quot; instead of 1&quot;);
  <font color="blue">end if</font>;
  controllable :=<font color="red"> size</font>(ss.A, 1) == ssm.r;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>isControllableSISO;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE isControllableMIMO<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.isControllableMIMO"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.isControllableMIMO</H2>
<B>To check a MIMO system wether it is controllable</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
 
 
 
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>ss</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.StaircaseMethod"
>StaircaseMethod</A></TD><TD>method</TD><TD>Modelica_LinearSystems2.Type...</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Boolean</TD><TD>controllable</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> isControllableMIMO <font color="darkgreen">
  &quot;To check a MIMO system wether it is controllable&quot;</font>

    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;
    <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.StaircaseMethod"
>Modelica_LinearSystems2.Types.StaircaseMethod</A> method=
        Modelica_LinearSystems2.Types.StaircaseMethod.SVD;

    <font color="blue">output </font>Boolean controllable;
<font color="blue">algorithm </font>
  <font color="red">  assert</font>(method == Modelica_LinearSystems2.Types.StaircaseMethod.SVD<font color="blue"> or </font>
      method == Modelica_LinearSystems2.Types.StaircaseMethod.QR, &quot;\nMethods for staircase algorithm are QR factorization or singular value decomposition. Therefore, 
the variable \&quot;method\&quot; in \&quot;Modelica_LinearSystems2.StateSpace.Internal.isControllableMIMO\&quot; has to be qr or svd but is method = &quot;
       +<font color="red"> String</font>(method));
    <font color="blue">if </font><font color="red">min</font>(<font color="red">size</font>(ss.B)) == 0<font color="blue"> then</font>
      controllable := false;
    <font color="blue">else</font>
      <font color="blue">if </font>method == Modelica_LinearSystems2.Types.StaircaseMethod.QR<font color="blue"> then</font>
        controllable :=<font color="red"> StateSpace.Internal.staircaseQR</font>(ss);
      <font color="blue">else</font>
        controllable :=<font color="red"> StateSpace.Internal.staircaseSVD</font>(ss);
      <font color="blue">end if</font>;
    <font color="blue">end if</font>;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>isControllableMIMO;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE isObservableMIMO<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.isObservableMIMO"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.isObservableMIMO</H2>
<B>To check a MIMO system wether it is observable</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
 
 
 
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>ss</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.StaircaseMethod"
>StaircaseMethod</A></TD><TD>method</TD><TD>Modelica_LinearSystems2.Type...</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Boolean</TD><TD>observable</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> isObservableMIMO <font color="darkgreen">
  &quot;To check a MIMO system wether it is observable&quot;</font>

    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

    <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;
    <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.StaircaseMethod"
>Modelica_LinearSystems2.Types.StaircaseMethod</A> method=
        Modelica_LinearSystems2.Types.StaircaseMethod.SVD;

<font color="blue">protected </font>
    <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss2=<font color="red">StateSpace.Internal.transposeStateSpace</font>(ss);

<font color="blue">public </font>
    <font color="blue">output </font>Boolean observable;
<font color="blue">algorithm </font>
  <font color="red">  assert</font>(method == Modelica_LinearSystems2.Types.StaircaseMethod.SVD<font color="blue"> or </font>
      method == Modelica_LinearSystems2.Types.StaircaseMethod.QR, &quot;\nMethods for staircase algorithm are QR factorization or singular value decomposition. Therefore, 
the variable \&quot;method\&quot; in \&quot;Modelica_LinearSystems2.StateSpace.Internal.isControllableMIMO\&quot; has to be qr or svd but is method = &quot;
       +<font color="red"> String</font>(method));
    <font color="blue">if </font><font color="red">min</font>(<font color="red">size</font>(ss.C)) == 0<font color="blue"> then</font>
      observable := false;
    <font color="blue">else</font>
      <font color="blue">if </font>method == Modelica_LinearSystems2.Types.StaircaseMethod.QR<font color="blue"> then</font>
        observable :=<font color="red"> StateSpace.Internal.staircaseQR</font>(ss2);
      <font color="blue">else</font>
        observable :=<font color="red"> StateSpace.Internal.staircaseSVD</font>(ss2);
      <font color="blue">end if</font>;

    <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>isObservableMIMO;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE isControllableAndObservableSISO<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.isControllableAndObservableSISO"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.isControllableAndObservableSISO</H2>
<B>To check whether a SISO system is controllable and observable</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>ss</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Boolean</TD><TD>controllableAndObservable</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> isControllableAndObservableSISO <font color="darkgreen">
  &quot;To check whether a SISO system is controllable and observable&quot;</font>

     <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
     <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

   <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;

<font color="blue">protected </font>
   <A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.StateSpaceR"
>Modelica_LinearSystems2.Internal.StateSpaceR</A> ssm1=
       <font color="red">StateSpace.Internal.reducedCtrSystem</font>(ss);
   Integer nx=<font color="red">size</font>(ss.A, 1);
   Integer rankQ=ssm1.r;
   <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss2=<font color="red">StateSpace</font>(
         A=<font color="red">transpose</font>(ssm1.A[nx - rankQ + 1:nx, nx - rankQ + 1:nx]),
         B=<font color="red">transpose</font>(ssm1.C[:, nx - rankQ + 1:nx]),
         C=<font color="red">transpose</font>(ssm1.B[nx - rankQ + 1:nx, :]),
         D=ssm1.D);
   Integer nx2=ssm1.r;
   <A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.StateSpaceR"
>Modelica_LinearSystems2.Internal.StateSpaceR</A> ssm2=
       <font color="red">StateSpace.Internal.reducedCtrSystem</font>(ss2);
<font color="blue">public </font>
   <font color="blue">output </font>Boolean controllableAndObservable;
<font color="blue">algorithm </font>
   <font color="blue">if </font><font color="red">size</font>(ss.C, 1) &lt;&gt; 1<font color="blue"> or </font><font color="red">size</font>(ss.B, 2) &lt;&gt; 1<font color="blue"> then</font>
    <font color="red"> assert</font>(<font color="red">size</font>(ss.B, 2) == 1,
       &quot;A SISO-system is expected as input\n but the number of inputs is &quot; +
       <font color="red">String</font>(<font color="red">size</font>(ss.B, 2)) + &quot; instead of 1&quot;);
    <font color="red"> assert</font>(<font color="red">size</font>(ss.C, 1) == 1,
       &quot; A SISO-system is expected as input\n but the number of outputs is &quot;
        +<font color="red"> String</font>(<font color="red">size</font>(ss.C, 1)) + &quot; instead of 1&quot;);
   <font color="blue">end if</font>;
   controllableAndObservable :=<font color="red"> size</font>(ss.A, 1) == ssm2.r;
<font color="blue">equation </font>

<font color="blue">end </font>isControllableAndObservableSISO;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE readLength_nx<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.readLength_nx"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.readLength_nx</H2>
<B>Read the order nx of a state space system from a file</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>fileName</TD><TD>&quot;ss_siso.mat&quot;</TD><TD>Name of the state space system data file</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>nx</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> readLength_nx <font color="darkgreen">
  &quot;Read the order nx of a state space system from a file&quot;</font>

  <font color="blue">input </font>String fileName=&quot;ss_siso.mat&quot; <font color="darkgreen">
    &quot;Name of the state space system data file&quot;</font>;
  <font color="blue">output </font>Integer nx;
<font color="blue">protected </font>
  Real nxMat[1,1]=<font color="red">readMatrix</font>(
          fileName,
          &quot;nx&quot;,
          1,
          1);
<font color="blue">algorithm </font>
  nx :=<font color="red"> integer</font>(nxMat[1, 1]);
<font color="blue">end </font>readLength_nx;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE staircaseQR<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.staircaseQR"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.staircaseQR</H2>
<B>Staircase algorithm to put a state space system to controller Hessenberg form</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
This algorithm usues QR factorization to generate staircase form i.e. block upper Hessenberg form of the pair (A,B). Due to the well known problem to determine 
numerically reliable the rank of a matrix, this algorithm should only be used to well conditioned systems. The best way for rank decision would be singular value decomposition, that is used in staicasSVD.
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>ss</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Boolean</TD><TD>isControllable</TD><TD>&nbsp;</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.StateSpaceR"
>StateSpaceR</A></TD><TD>ssm1</TD><TD>controllable state space system</TD></TR>
<TR><TD>Real</TD><TD>PP[:, :]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> staircaseQR <font color="darkgreen">
  &quot;Staircase algorithm to put a state space system to controller Hessenberg form&quot;</font>

    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Vectors.html#Modelica_LinearSystems2.Math.Vectors"
>Modelica_LinearSystems2.Math.Vectors</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;

  <font color="blue">output </font>Boolean isControllable;
  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.StateSpaceR"
>Modelica_LinearSystems2.Internal.StateSpaceR</A> ssm1(
    <font color="blue">redeclare </font>Real A[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)],
    <font color="blue">redeclare </font>Real B[<font color="red">size</font>(ss.B, 1),<font color="red">size</font>(ss.B, 2)],
    <font color="blue">redeclare </font>Real C[<font color="red">size</font>(ss.C, 1),<font color="red">size</font>(ss.C, 2)],
    <font color="blue">redeclare </font>Real D[<font color="red">size</font>(ss.D, 1),<font color="red">size</font>(ss.D, 2)]) <font color="darkgreen">
    &quot;controllable state space system&quot;</font>;
  <font color="blue">output </font>Real PP[:,:];
<font color="blue">protected </font>
  Real A[:,:];
  Real B[<font color="red">size</font>(ss.B, 1),<font color="red">size</font>(ss.B, 2)];
  Real C[:,:];
  Real Q[:,:];
  Real Q2[:,:];
  Real R[:,:];

  Real P[:,:];
  Real tau[:];

  Integer nx=<font color="red">size</font>(ss.A, 1);
  Integer nu=<font color="red">size</font>(ss.B, 2);
  Integer n1;
  Boolean stop;
  Real normA=<font color="red">Modelica.Math.Matrices.norm</font>(A=ss.A, p=1);
  Real eps=normA*1e-10;
  Integer stairStepinSys;
  Integer info;
  Integer nn;
  Integer stairStep;
  Integer rankR;

<font color="blue">algorithm </font>
  <font color="blue">if </font>nu &gt; 0<font color="blue"> then</font>
  <font color="blue">if </font>nx &gt; 1<font color="blue"> then</font>

     <font color="darkgreen">//#####  first step of staircase</font>
      <font color="darkgreen"> // transform b-&gt;Q&#39;b = {*,0,...,0} and c-&gt;cQ, A-&gt;Q&#39;AQ</font>

    (Q,R,tau,Q2) :=<font color="red"> Matrices.QR</font>( ss.B);
    B := [R;<font color="red"> zeros</font>(nx - nu, nu)];<font color="darkgreen">  // should be the same as transopse(Q2)*ss.B</font>

    A :=<font color="red"> transpose</font>(Q2)*ss.A;
    A := A*Q2;
    C := ss.C*Q2;
    PP :=<font color="red"> transpose</font>(Q2);

    stairStep := 0;
    rankR := 0;
     <font color="darkgreen">// for i in 1:size(R, 1) loop</font>
     <font color="darkgreen">//   if abs(R[i, i]) &gt; eps then</font>
     <font color="darkgreen">//     rankR := rankR + 1;</font>
     <font color="darkgreen">//   end if;</font>
     <font color="darkgreen">// end for;</font>

<font color="darkgreen">//  !!!! rank has to be determined. In the case of ill conditioned systems svd should be used</font>
    <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">min</font>(<font color="red">size</font>(R, 1),<font color="red"> size</font>(R, 2))<font color="blue"> loop</font>
      <font color="blue">if </font><font color="red">abs</font>(R[i,<font color="red"> size</font>(R, 2) -<font color="red"> min</font>(<font color="red">size</font>(R, 1),<font color="red"> size</font>(R, 2)) + i]) &gt; eps<font color="blue"> then</font>
        rankR := rankR + 1;
      <font color="blue">end if</font>;
    <font color="blue">end for</font>;
    stairStep := stairStep + rankR;
    n1 := nx - stairStep;
    stop := false;

     <font color="darkgreen">// #######  buildig rest of staircase</font>
    <font color="blue">while </font><font color="blue">not </font>stop<font color="blue"> loop</font>

      (Q,R,tau,Q2) :=<font color="red"> Matrices.QR</font>( A[stairStep + 1:nx, stairStep - rankR +
        1:stairStep]);
      P := [<font color="red">identity</font>(nx - n1),<font color="red">zeros</font>(nx - n1, n1);<font color="red"> zeros</font>(n1, nx - n1),Q2];
      PP :=<font color="red"> transpose</font>(P)*PP;
      A := [A[1:stairStep, 1:stairStep],A[1:stairStep, stairStep + 1:nx]*Q2;
        <font color="red">transpose</font>(Q2)*A[stairStep + 1:nx, 1:stairStep],<font color="red">transpose</font>(Q2)*A[
        stairStep + 1:nx, stairStep + 1:nx]*Q2];
       <font color="darkgreen">//=transpose(P)*A*P = [A11, A12*Q2; transpose(Q2)*A21, transpose(Q2)*A22*Q2]</font>
      C[:, nx - n1 + 1:nx] := C[:, nx - n1 + 1:nx]*Q2;

      rankR := 0;
       <font color="darkgreen">// for i in 1:size(R, 1) loop</font>
       <font color="darkgreen">//   if abs(R[i, i]) &gt; eps then</font>
       <font color="darkgreen">//     rankR := rankR + 1;</font>
       <font color="darkgreen">//   end if;</font>
       <font color="darkgreen">// end for;</font>

<font color="darkgreen">//  !!!! rank has to be determined. In the case of ill conditioned systems svd should be used</font>
      <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">min</font>(<font color="red">size</font>(R, 1),<font color="red"> size</font>(R, 2))<font color="blue"> loop</font>
        <font color="blue">if </font><font color="red">abs</font>(R[i,<font color="red"> size</font>(R, 2) -<font color="red"> min</font>(<font color="red">size</font>(R, 1),<font color="red"> size</font>(R, 2)) + i]) &gt; eps<font color="blue"> then</font>
          rankR := rankR + 1;
        <font color="blue">end if</font>;
      <font color="blue">end for</font>;
      stairStep := stairStep + rankR;
      n1 := <font color="blue">if </font>rankR &lt; 1<font color="blue"> then </font>-1<font color="blue"> else </font>n1 - rankR;
      stop := n1 &lt;= 0;

    <font color="blue">end while</font>;
  <font color="blue">else</font>
    stairStep := <font color="blue">if </font><font color="red">Modelica.Math.Matrices.isEqual</font>(ss.B,<font color="red"> zeros</font>(<font color="red">size</font>(ss.B, 1),<font color="red"> size</font>(ss.B, 2)))<font color="blue"> then </font>0<font color="blue"> else </font>
            1;
    A := ss.A;
    B := ss.B;
    C := ss.C;
  <font color="blue">end if</font>;

  ssm1 :=<font color="red"> Modelica_LinearSystems2.Internal.StateSpaceR</font>(
        A=A,
        B=B,
        C=C,
        D=ss.D,
        r=stairStep);

  isControllable := stairStep == nx;
  <font color="blue">else</font><font color="darkgreen"> // no inputs, nu==0</font>
  isControllable := false;
  ssm1 :=<font color="red">  Modelica_LinearSystems2.Internal.StateSpaceR</font>(
        A=ss.A,
        B=ss.B,
        C=ss.C,
        D=ss.D,
        r=0);
  P :=<font color="red"> identity</font>(nu);
  <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>staircaseQR;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE staircaseSVD<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.staircaseSVD"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.staircaseSVD</H2>
<B>Staircase algorithm based on singular value decomposition</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>ss</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Boolean</TD><TD>isControllable</TD><TD>&nbsp;</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.StateSpaceR"
>StateSpaceR</A></TD><TD>ssm1</TD><TD>upper block Hessenberg form state space system</TD></TR>
<TR><TD>Real</TD><TD>P[:, :]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> staircaseSVD <font color="darkgreen">
  &quot;Staircase algorithm based on singular value decomposition&quot;</font>

    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Vectors.html#Modelica_LinearSystems2.Math.Vectors"
>Modelica_LinearSystems2.Math.Vectors</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;

  <font color="blue">output </font>Boolean isControllable;
  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.StateSpaceR"
>Modelica_LinearSystems2.Internal.StateSpaceR</A> ssm1(
    <font color="blue">redeclare </font>Real A[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)],
    <font color="blue">redeclare </font>Real B[<font color="red">size</font>(ss.B, 1),<font color="red">size</font>(ss.B, 2)],
    <font color="blue">redeclare </font>Real C[<font color="red">size</font>(ss.C, 1),<font color="red">size</font>(ss.C, 2)],
    <font color="blue">redeclare </font>Real D[<font color="red">size</font>(ss.D, 1),<font color="red">size</font>(ss.D, 2)]) <font color="darkgreen">
    &quot;upper block Hessenberg form state space system&quot;</font>;
  <font color="blue">output </font>Real P[:,:];

<font color="blue">protected </font>
  Real A[:,:];
  Real B[<font color="red">size</font>(ss.B, 1),<font color="red">size</font>(ss.B, 2)];
  Real C[:,:];
  Real U[:,:];
  Real VT[:,:];

  Real Q[:,:];
  Real Pi[:,:];
  Real tau[:];
  Real sigma[:];

  Integer nx=<font color="red">size</font>(ss.A, 1);
  Integer nu=<font color="red">size</font>(ss.B, 2);
  Integer ni;
  Boolean stop;
  Real normA=<font color="red">Modelica.Math.Matrices.norm</font>(A=ss.A, p=1);
  Real eps=normA*1e-10;
  Integer stairStepinSys;
  Integer info;
  Integer nn;
  Integer stairStep;
  Integer rankS;
  Integer maxA=<font color="red">max</font>(<font color="red">size</font>(ss.A));
<font color="darkgreen">//   Real evc[:,2];</font>
<font color="darkgreen">//   Real evnc[:,2];</font>

<font color="blue">algorithm </font>
  <font color="blue">if </font>nu &gt; 0<font color="blue"> then</font>
  <font color="blue">if </font>nx &gt; 1<font color="blue"> then</font>
<font color="darkgreen">//#####  first step of staircase</font>
      <font color="darkgreen">  // transform b-&gt;Q&#39;b = {*,0,...,0} and c-&gt;cQ, A-&gt;Q&#39;AQ</font>
    (sigma,U,VT) :=<font color="red"> Modelica.Math.Matrices.singularValues</font>(ss.B);

    rankS := 0;
    <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(sigma, 1)<font color="blue"> loop</font>
      <font color="blue">if </font>sigma[i] &gt; maxA*sigma[1]*Modelica.Constants.eps<font color="blue"> then</font>
        rankS := rankS + 1;
      <font color="blue">end if</font>;
    <font color="blue">end for</font>;

    B := [<font color="red">diagonal</font>(sigma[1:rankS]),<font color="red">zeros</font>(rankS, nu - rankS);<font color="red"> zeros</font>(nx - rankS, nu)];
    P :=<font color="red"> transpose</font>(U);
    Q :=<font color="red"> transpose</font>(VT);
    A :=<font color="red"> transpose</font>(U)*ss.A*U;
    C := ss.C*U;
    (sigma,U,VT) :=<font color="red"> Modelica.Math.Matrices.singularValues</font>(A[rankS + 1:nx, 1:rankS]);

    stairStep := rankS;
    rankS := 0;
    <font color="blue">if </font><font color="red">size</font>(sigma, 1) &gt; 1<font color="blue"> then</font>
      <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(sigma, 1)<font color="blue"> loop</font>
        <font color="blue">if </font>sigma[i] &gt; maxA*sigma[1]*Modelica.Constants.eps<font color="blue"> then</font>
          rankS := rankS + 1;
        <font color="blue">end if</font>;
      <font color="blue">end for</font>;
    <font color="blue">else</font>
      rankS := <font color="blue">if </font><font color="red">size</font>(sigma, 1) &gt; 0<font color="blue"> then </font><font color="blue">if </font>sigma[1] &gt; maxA*Modelica.Constants.eps<font color="blue"> then </font>1<font color="blue"> else </font>0<font color="blue"> else </font>0;
    <font color="blue">end if</font>;

    stairStep := stairStep + rankS;
    Pi := [VT,<font color="red">zeros</font>(<font color="red">size</font>(VT, 1),<font color="red"> size</font>(U, 1));<font color="red"> zeros</font>(<font color="red">size</font>(U, 2),<font color="red"> size</font>(VT, 2)),<font color="red">transpose</font>(U)];
    B := Pi*B;
    P := Pi*P;

 <font color="darkgreen">// P could be ambigious according to the sign</font>
    <font color="blue">if </font><font color="red">transpose</font>(P)*B[:,1]*ss.B[:,1]&lt;0<font color="blue"> then</font>
      Pi:=-Pi;
      P:=-P;
    <font color="blue">end if</font>;

    A := Pi*A*<font color="red">transpose</font>(Pi);

   <font color="darkgreen">// should be made better because of many zeros in B</font>

    <font color="blue">while </font>stairStep &lt; nx<font color="blue"> and </font>rankS &gt; 0<font color="blue"> and </font><font color="blue">not </font>
        <font color="red">Modelica.Math.Matrices.isEqual</font>(
            A[stairStep + 1:nx, stairStep - rankS + 1:stairStep],
            <font color="red">zeros</font>(stairStep - rankS, rankS),
            eps)<font color="blue"> loop</font>

      (sigma,U,VT) :=<font color="red"> Modelica.Math.Matrices.singularValues</font>(A[stairStep + 1:nx, stairStep
         - rankS + 1:stairStep]);

      Pi := [<font color="red">identity</font>(stairStep - rankS),<font color="red">zeros</font>(stairStep - rankS, nx -
        stairStep + rankS);<font color="red"> zeros</font>(nx - stairStep + rankS, stairStep - rankS),
        [VT,<font color="red">zeros</font>(rankS, nx - stairStep);<font color="red"> zeros</font>(nx - stairStep, rankS),
        <font color="red">transpose</font>(U)]];
      P := Pi*P;
      A := Pi*A*<font color="red">transpose</font>(Pi);

<font color="darkgreen">//new implenmentation necessary because of many zeros in Pi</font>
      C := C*<font color="red">transpose</font>(Pi);
      rankS := 0;
      <font color="blue">if </font><font color="red">size</font>(sigma, 1) &gt; 1<font color="blue"> then</font>
        <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(sigma, 1)<font color="blue"> loop</font>
          <font color="blue">if </font>sigma[i] &gt; maxA*sigma[1]*Modelica.Constants.eps<font color="blue"> then</font>
            rankS := rankS + 1;
          <font color="blue">end if</font>;
        <font color="blue">end for</font>;
      <font color="blue">else</font>
        rankS := <font color="blue">if </font><font color="red">size</font>(sigma, 1) &gt; 0<font color="blue"> then </font><font color="blue">if </font>sigma[1] &gt; maxA*Modelica.Constants.eps<font color="blue"> then </font>
                1<font color="blue"> else </font>0<font color="blue"> else </font>0;
      <font color="blue">end if</font>;
      stairStep := stairStep + rankS;
    <font color="blue">end while</font>;

  <font color="blue">else</font>
    stairStep := <font color="blue">if </font><font color="red">Modelica.Math.Matrices.isEqual</font>(ss.B,<font color="red"> zeros</font>(<font color="red">size</font>(ss.B, 1),
      <font color="red">size</font>(ss.B, 2)))<font color="blue"> then </font>0<font color="blue"> else </font>1;
    A := ss.A;
    B := ss.B;
    C := ss.C;
  <font color="blue">end if</font>;

  ssm1 :=<font color="red"> Modelica_LinearSystems2.Internal.StateSpaceR</font>(
        A=A,
        B=B,
        C=C,
        D=ss.D,
        r=stairStep);

<font color="darkgreen">//   evc := Modelica.Math.Matrices.eigenValues(A[1:stairStep, 1:stairStep]);</font>
<font color="darkgreen">//   evnc := Modelica.Math.Matrices.eigenValues(A[stairStep + 1:nx, stairStep + 1:nx]);</font>

  isControllable := stairStep == nx;

  <font color="blue">else</font><font color="darkgreen"> // no inputs, nu==0</font>
  isControllable := false;
  ssm1 :=<font color="red">  Modelica_LinearSystems2.Internal.StateSpaceR</font>(
        A=ss.A,
        B=ss.B,
        C=ss.C,
        D=ss.D,
        r=0);
  P :=<font color="red"> identity</font>(nu);
  <font color="blue">end if</font>;

<font color="blue">end </font>staircaseSVD;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE partialGain<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.partialGain"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.partialGain</H2>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>H[:, size(H, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>b[size(H, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>result</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> partialGain
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>;

  <font color="blue">input </font>Real H[:,<font color="red">size</font>(H, 1)];
  <font color="blue">input </font>Real b[<font color="red">size</font>(H, 1)];
  <font color="blue">output </font>Real result;
<font color="blue">protected </font>
  Real Hh[:,:]=H;
  Real bh[:]=b;
  Integer q=<font color="red">size</font>(H, 1);
<font color="blue">algorithm </font>

  (Hh,bh) :=<font color="red"> Internal.trianUpperHess</font>(Hh, bh);
  result := bh[q]/Hh[q, q];

<font color="blue">end </font>partialGain;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE assignOneOrTwoPoles_alpha<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.assignOneOrTwoPoles_alpha"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.assignOneOrTwoPoles_alpha</H2>
<B>Algorithm to assign p (p = 1 or 2) eigenvalues</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>F[:, size(F, 1)]</TD><TD>&nbsp;</TD><TD>system matrix of order p=1 or p=2</TD></TR>
<TR><TD>Real</TD><TD>G[size(F, 1), :]</TD><TD>&nbsp;</TD><TD>control input matrix p rows</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>gamma[size(F, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>tolerance</TD><TD>Modelica.Constants.eps</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>K[:, size(F, 1)]</TD><TD>feedback matrix p columns</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> assignOneOrTwoPoles_alpha <font color="darkgreen">
  &quot;Algorithm to assign p (p = 1 or 2) eigenvalues&quot;</font>

    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Vectors.html#Modelica_LinearSystems2.Math.Vectors"
>Modelica_LinearSystems2.Math.Vectors</A>;

  <font color="blue">input </font>Real F[:,<font color="red">size</font>(F, 1)] <font color="darkgreen">&quot;system matrix of order p=1 or p=2&quot;</font>;
  <font color="blue">input </font>Real G[<font color="red">size</font>(F, 1),:] <font color="darkgreen">&quot;control input matrix p rows&quot;</font>;
  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> gamma[<font color="red">size</font>(F, 1)];
  <font color="blue">input </font>Real tolerance=Modelica.Constants.eps;
  <font color="blue">output </font>Real K[:,<font color="red">size</font>(F, 1)] <font color="darkgreen">&quot;feedback matrix p columns&quot;</font>;

<font color="blue">protected </font>
  Real Gamma[:,:];
  Integer rankGs;
  Real Fs[<font color="red">size</font>(F, 1),<font color="red">size</font>(F, 2)];
  Real Gs[<font color="red">size</font>(G, 1),<font color="red">size</font>(G, 2)];
  Real Gst[:,:]=<font color="red">transpose</font>(G);
  Real Ks[:,<font color="red">size</font>(F, 1)];
  Real c;
  Real s;
  Real r;

  Real V1[<font color="red">size</font>(G, 2),<font color="red">size</font>(G, 2)];
  Real V2[<font color="red">size</font>(G, 2),<font color="red">size</font>(G, 2)];
  Real V[<font color="red">size</font>(G, 2),<font color="red">size</font>(G, 2)];
  Real U[<font color="red">size</font>(F, 1),<font color="red">size</font>(F, 2)];

  Real u1[:];
  Real u2[:];

<font color="blue">algorithm </font>
  <font color="red">assert</font>(<font color="red">size</font>(F, 1) &gt;=<font color="red"> size</font>(gamma, 1),
    &quot;\n In function StateSpace.Internal.assignOneOrTwoPoles() matrix F is of size [&quot;
     +<font color="red"> String</font>(<font color="red">size</font>(F, 1)) + &quot;,&quot; +<font color="red"> String</font>(<font color="red">size</font>(F, 1)) + &quot;] and &quot; +<font color="red"> String</font>(
    <font color="red">size</font>(F, 1)) + &quot; demanded assigned poles are expected. However, &quot; +
    <font color="red">String</font>(<font color="red">size</font>(gamma, 1)) + &quot; poles are given&quot;);
<font color="darkgreen">//assert(not Modelica.Math.Matrices.isEqual(G,zeros(size(G,1),size(G,2)),tolerance),&quot;A subsystem (F, G) in StateSpace.Internal.assignOneOrTwoPoles() is not controllable, since G is equal to zero matrix &quot;);</font>
  <font color="blue">if </font><font color="red">size</font>(gamma, 1) == 1<font color="blue"> then</font>
    <font color="red">assert</font>(gamma[1].im == 0, &quot;\n In function StateSpace.Internal.assignOneOrTwoPoles() matrix F has size [&quot; +<font color="red"> String</font>(<font color="red">size</font>(F, 1)) + &quot;,&quot; +<font color="red"> String</font>(<font color="red">size</font>(F, 1)) +
      &quot;], therefore, the demanded assigned pole must be real. However, the imaginary part is &quot;
       +<font color="red"> String</font>(gamma[1].im));
  <font color="blue">elseif </font><font color="red">abs</font>(gamma[1].im) &gt; 0<font color="blue"> or </font><font color="red">abs</font>(gamma[2].im) &gt; 0<font color="blue"> then</font>
    <font color="red">assert</font>(gamma[1].re == gamma[2].re<font color="blue"> and </font>gamma[1].im == -gamma[2].im,
      &quot;\nThe assigned pole pair given in function StateSpace.Internal.assignOneOrTwoPoles() must be conjungated complex. However, the poles are\npole1 = &quot;
       +<font color="red"> String</font>(gamma[1]) + &quot;\npole2 = &quot; +<font color="red"> String</font>(gamma[2]) +
      &quot;. \nTry\npole1 = &quot; +<font color="red"> String</font>(gamma[1]) + &quot;\npole2 = &quot; +<font color="red"> String</font>(
      <font color="red">Complex.conj</font>(gamma[1])) + &quot;\ninstead&quot;);
  <font color="blue">end if</font>;

  <font color="blue">if </font><font color="blue">not </font><font color="red">Modelica.Math.Matrices.isEqual</font>(
          G,
          <font color="red">zeros</font>(<font color="red">size</font>(G, 1),<font color="red"> size</font>(G, 2)),
          tolerance)<font color="blue"> then</font>
    <font color="blue">if </font><font color="red">size</font>(G, 2) == 1<font color="blue"> then</font>
      V := [1];
      <font color="blue">if </font><font color="red">size</font>(G, 1) == 1<font color="blue"> then</font>
        U := [1];
      <font color="blue">else</font>
        <font color="darkgreen"> // Givens</font>
        r :=<font color="red"> sqrt</font>(G[1, 1]^2 + G[2, 1]^2);
        c := G[1, 1]/r;
        s := G[2, 1]/r;
        U := [c,s; -s,c];
      <font color="blue">end if</font>;
      Gs := U*G;

      rankGs := <font color="blue">if </font><font color="red">abs</font>(Gs[1, 1]) &gt; tolerance<font color="blue"> then </font>1<font color="blue"> else </font>0;
    <font color="blue">else</font>
     <font color="darkgreen">// size(G, 2)&gt;1</font>

      <font color="blue">if </font><font color="red">size</font>(G, 1) == 1<font color="blue"> then</font><font color="darkgreen"> // U=I, compute V by just one Householder transformation</font>
        U := [1];
        u1 :=<font color="red"> cat</font>(1,<font color="red"> Vectors.householderVector</font>(Gst[:, 1],<font color="red"> cat</font>(1, {1},<font color="red"> zeros</font>(<font color="red">size</font>(G, 2) - 1))));
        <font color="darkgreen">                         // Householder vector</font>
        Gst :=<font color="red"> Modelica_LinearSystems2.Math.Matrices.householderReflexion</font>(
          Gst, u1);

        V :=<font color="red"> identity</font>(<font color="red">size</font>(G, 2)) - 2*<font color="red">matrix</font>(u1)*<font color="red">transpose</font>(<font color="red">matrix</font>(u1))/(u1*u1);
        Gs :=<font color="red"> transpose</font>(Gst);
        rankGs := <font color="blue">if </font><font color="red">abs</font>(Gs[1, 1]) &gt; tolerance<font color="blue"> then </font>1<font color="blue"> else </font>0;

      <font color="blue">else</font>
        <font color="darkgreen">//2xHH + Givens</font>
        u1 :=<font color="red"> cat</font>(1,<font color="red"> Vectors.householderVector</font>(Gst[:, 1],<font color="red"> cat</font>(
              1,
              {1},
              <font color="red">zeros</font>(<font color="red">size</font>(G, 2) - 1))));
        <font color="darkgreen">                         // Householder vector1</font>
        Gst :=<font color="red"> Modelica_LinearSystems2.Math.Matrices.householderReflexion</font>(
          Gst, u1);
        V1 :=<font color="red"> identity</font>(<font color="red">size</font>(G, 2)) - 2*<font color="red">matrix</font>(u1)*<font color="red">transpose</font>(<font color="red">matrix</font>(u1))/(u1
          *u1);

<font color="darkgreen">// if rank of G of a multi input system is equal to 1</font>
        <font color="blue">if </font><font color="red">Modelica.Math.Vectors.isEqual</font>(Gst[:, 2],<font color="red"> zeros</font>(<font color="red">size</font>(G, 2)), tolerance)<font color="blue"> or </font>
          <font color="red">Modelica.Math.Matrices.isEqual</font>(Gst[2:<font color="red">size</font>(Gst, 1), :],<font color="red"> zeros</font>(<font color="red">size</font>(Gst, 1) - 1,<font color="red"> size</font>(Gst, 2)), tolerance)<font color="blue"> then</font>
          V := V1;
          rankGs := <font color="blue">if </font><font color="red">abs</font>(Gs[1, 1]) &gt; tolerance<font color="blue"> then </font>1<font color="blue"> else </font>0;
        <font color="blue">else</font>

          u2 :=<font color="red"> cat</font>(
                1,
                <font color="red">zeros</font>(1),
                <font color="red">Vectors.householderVector</font>(Gst[2:<font color="red">size</font>(G, 2), 2],<font color="red"> cat</font>(
                  1,
                  {1},
                  <font color="red">zeros</font>(<font color="red">size</font>(G, 2) - 2))));
          <font color="darkgreen">                         // Householder vector2</font>
          Gst :=<font color="red"> Modelica_LinearSystems2.Math.Matrices.householderReflexion</font>(
            Gst, u2);

          V2 :=<font color="red"> identity</font>(<font color="red">size</font>(G, 2)) - 2*<font color="red">matrix</font>(u2)*<font color="red">transpose</font>(<font color="red">matrix</font>(u2))/(
            u1*u1);
          V := V2*V1;

        <font color="blue">end if</font>;

        Gs :=<font color="red"> transpose</font>(Gst);

        rankGs := 0;
        <font color="blue">for </font>i<font color="blue"> in </font>1:2<font color="blue"> loop</font>
          <font color="blue">if </font><font color="red">abs</font>(Gs[i, i]) &gt; tolerance<font color="blue"> then</font>
            rankGs := rankGs + 1;
          <font color="blue">end if</font>;
        <font color="blue">end for</font>;
     <font color="darkgreen">// Givens rotation to transfotm Gs[1:2,1:2] to right upper triangle</font>
        r :=<font color="red"> sqrt</font>(Gs[1, 1]^2 + Gs[2, 1]^2);
        c := Gs[1, 1]/r;
        s := Gs[2, 1]/r;
        U := [c,s; -s,c];
        Gs := U*Gs;

      <font color="blue">end if</font>;
          <font color="blue">end if</font>;

<font color="darkgreen">// check controllability</font>
    <font color="red">assert</font>(<font color="blue">not </font><font color="red">Modelica.Math.Matrices.isEqual</font>(
          Gs,
          <font color="red">zeros</font>(<font color="red">size</font>(Gs, 1),<font color="red"> size</font>(Gs, 2)),
          tolerance),
      &quot;A subsystem in StateSpace.Internal.assignOneOrTwoPoles() is not controllable&quot;);

    Ks :=<font color="red"> fill</font>(
          0,
          rankGs,
          <font color="red">size</font>(F, 1));
    Fs := U*F*<font color="red">transpose</font>(U);

    <font color="blue">if </font><font color="red">size</font>(F, 1) == 1<font color="blue"> then</font>
      Ks :=<font color="red"> matrix</font>((Fs[1, 1] - gamma[1].re)/Gs[1, 1]);
    <font color="blue">else</font>
      <font color="blue">if </font>rankGs ==<font color="red"> size</font>(F, 1)<font color="blue"> then</font>

        <font color="darkgreen">// Gamma:= if size(F,1)==1 then [gamma[1].re] else [gamma[1].re, -(gamma[1].im)^2;1, gamma[2].re];</font>
        <font color="darkgreen">//  Ks :=  Modelica_LinearSystems2.Math.Matrices.solve2(Gs, Fs - Gamma);</font>
        Ks := [(Fs[1, 1] - gamma[1].re)/Gs[1, 1] - Gs[1, 2]*(Fs[2, 1] - 1)/Gs[1, 1]/Gs[2,
          2],(Fs[1, 2] + (gamma[1].im)^2)/Gs[1, 1] - Gs[1, 2]*(Fs[2, 2] -
          gamma[2].re)/Gs[1, 1]/Gs[2, 2]; (Fs[2, 1] - 1)/Gs[2, 2],(Fs[2, 2]
           - gamma[2].re)/Gs[2, 2]];
      <font color="blue">else</font>

        Ks[1, 1] := (gamma[1].re + gamma[2].re - Fs[1, 1] - Fs[2, 2])/Gs[1,
          1];
        Ks[1, 2] := Ks[1, 1]*Fs[2, 2]/Fs[2, 1] + (Fs[1, 1]*Fs[2, 2] - Fs[1,
          2]*Fs[2, 1] - (gamma[1].re*gamma[2].re - gamma[1].im*gamma[2].im))
          /Fs[2, 1]/Gs[1, 1];
        Ks := -Ks;
      <font color="blue">end if</font>;
    <font color="blue">end if</font>;

<font color="darkgreen">//    K := transpose(V)*[Ks; zeros(size(G, 2) - rankGs, size(Ks, 2))]*(U);</font>
    K :=<font color="red"> transpose</font>(V[1:<font color="red">size</font>(Ks, 1), :])*Ks*U;

  <font color="blue">else</font>
    <font color="red">Modelica.Utilities.Streams.print</font>(
      &quot;\n A subsystem (F, G) in StateSpace.Internal.assignOneOrTwoPoles() is not controllable, since G is equal to zero matrix. Therefore, K is set to zero matrix and the eigenvalues are retained&quot;);
    K :=<font color="red"> zeros</font>(<font color="red">size</font>(G, 2),<font color="red"> size</font>(F, 1));
  <font color="blue">end if</font>;

<font color="blue">end </font>assignOneOrTwoPoles_alpha;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE assignOneOrTwoPoles<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.assignOneOrTwoPoles"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.assignOneOrTwoPoles</H2>
<B>Algorithm to assign p (p = 1 or 2) eigenvalues</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>F[:, size(F, 1)]</TD><TD>&nbsp;</TD><TD>system matrix of order p=1 or p=2</TD></TR>
<TR><TD>Real</TD><TD>G[size(F, 1), :]</TD><TD>&nbsp;</TD><TD>control input matrix p rows</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>gamma[size(F, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>tolerance</TD><TD>Modelica.Constants.eps</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>K[:, size(F, 1)]</TD><TD>feedback matrix p columns</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> assignOneOrTwoPoles <font color="darkgreen">
  &quot;Algorithm to assign p (p = 1 or 2) eigenvalues&quot;</font>

    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Vectors.html#Modelica_LinearSystems2.Math.Vectors"
>Modelica_LinearSystems2.Math.Vectors</A>;

  <font color="blue">input </font>Real F[:,<font color="red">size</font>(F, 1)] <font color="darkgreen">&quot;system matrix of order p=1 or p=2&quot;</font>;
  <font color="blue">input </font>Real G[<font color="red">size</font>(F, 1),:] <font color="darkgreen">&quot;control input matrix p rows&quot;</font>;
  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> gamma[<font color="red">size</font>(F, 1)];
  <font color="blue">input </font>Real tolerance=Modelica.Constants.eps;
  <font color="blue">output </font>Real K[:,<font color="red">size</font>(F, 1)] <font color="darkgreen">&quot;feedback matrix p columns&quot;</font>;

<font color="blue">protected </font>
  Real Gamma[:,:];
  Integer rankGs;
  Real Fs[<font color="red">size</font>(F, 1),<font color="red">size</font>(F, 2)];
  Real Gs[<font color="red">size</font>(G, 1),<font color="red">size</font>(G, 2)];
  Real Gst[:,:]=<font color="red">transpose</font>(G);
  Real Ks[:,<font color="red">size</font>(F, 1)];
  Real c;
  Real s;
  Real r;
  Integer p=<font color="red">size</font>(F,1);
  Real sigmaG[:];

  Real V[<font color="red">size</font>(G, 2),<font color="red">size</font>(G, 2)];
  Real U[<font color="red">size</font>(F, 1),<font color="red">size</font>(F, 2)];

  Real u1[:];
  Real u2[:];
  Integer i;
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> system_ev[:];

<font color="blue">algorithm </font>
  <font color="red">assert</font>(<font color="red">size</font>(F, 1) &gt;=<font color="red"> size</font>(gamma, 1),
    &quot;\n In function StateSpace.Internal.assignOneOrTwoPoles() matrix F is of size [&quot;
     +<font color="red"> String</font>(<font color="red">size</font>(F, 1)) + &quot;,&quot; +<font color="red"> String</font>(<font color="red">size</font>(F, 1)) + &quot;] and &quot; +<font color="red"> String</font>(
    <font color="red">size</font>(F, 1)) + &quot; demanded assigned poles are expected. However, &quot; +
    <font color="red">String</font>(<font color="red">size</font>(gamma, 1)) + &quot; poles are given&quot;);
<font color="darkgreen">//assert(not Modelica.Math.Matrices.isEqual(G,zeros(size(G,1),size(G,2)),tolerance),&quot;A subsystem (F, G) in StateSpace.Internal.assignOneOrTwoPoles() is not controllable, since G is equal to zero matrix &quot;);</font>
  <font color="blue">if </font><font color="red">size</font>(gamma, 1) == 1<font color="blue"> then</font>
    <font color="red">assert</font>(gamma[1].im == 0, &quot;\n In function StateSpace.Internal.assignOneOrTwoPoles() matrix F has size [&quot; +<font color="red"> String</font>(<font color="red">size</font>(F, 1)) + &quot;,&quot; +<font color="red"> String</font>(<font color="red">size</font>(F, 1)) +
      &quot;], therefore, the demanded assigned pole must be real. However, the imaginary part is &quot;
       +<font color="red"> String</font>(gamma[1].im));
  <font color="blue">elseif </font><font color="red">abs</font>(gamma[1].im) &gt; 0<font color="blue"> or </font><font color="red">abs</font>(gamma[2].im) &gt; 0<font color="blue"> then</font>
    <font color="red">assert</font>(gamma[1].re == gamma[2].re<font color="blue"> and </font>gamma[1].im == -gamma[2].im,
      &quot;\nThe assigned pole pair given in function StateSpace.Internal.assignOneOrTwoPoles() must be conjungated complex. However, the poles are\npole1 = &quot;
       +<font color="red"> String</font>(gamma[1]) + &quot;\npole2 = &quot; +<font color="red"> String</font>(gamma[2]) +
      &quot;. \nTry\npole1 = &quot; +<font color="red"> String</font>(gamma[1]) + &quot;\npole2 = &quot; +<font color="red"> String</font>(
      <font color="red">Complex.conj</font>(gamma[1])) + &quot;\ninstead&quot;);
  <font color="blue">end if</font>;

  <font color="blue">if </font><font color="blue">not </font><font color="red">Modelica.Math.Matrices.isEqual</font>(
      G,
      <font color="red">zeros</font>(<font color="red">size</font>(G, 1),<font color="red"> size</font>(G, 2)),
      tolerance)<font color="blue"> then</font>
    <font color="blue">if </font><font color="red">size</font>(G, 2) == 1<font color="blue"> then</font>
      V := [1];
      <font color="blue">if </font><font color="red">size</font>(G, 1) == 1<font color="blue"> then</font>
        U := [1];
      <font color="blue">else</font>
        <font color="darkgreen"> // Givens</font>
        r :=<font color="red"> sqrt</font>(G[1, 1]^2 + G[2, 1]^2);
        c := G[1, 1]/r;
        s := G[2, 1]/r;
        U := [c,s; -s,c];
      <font color="blue">end if</font>;
      Gs := U*G;

      rankGs := <font color="blue">if </font><font color="red">abs</font>(Gs[1, 1]) &gt; tolerance<font color="blue"> then </font>1<font color="blue"> else </font>0;
    <font color="blue">else</font>
     <font color="darkgreen">// size(G, 2)&gt;1</font>

      <font color="blue">if </font><font color="red">size</font>(G, 1) == 1<font color="blue"> then</font><font color="darkgreen"> // U=I, compute V by just one Householder transformation</font>
        U := [1];
        u1 :=<font color="red"> cat</font>(1,<font color="red"> Vectors.householderVector</font>(Gst[:, 1],
                     <font color="red">cat</font>(1, {1},<font color="red"> zeros</font>(<font color="red">size</font>(G, 2) - 1))));<font color="darkgreen">// Householder vector</font>
        Gst :=<font color="red"> Modelica_LinearSystems2.Math.Matrices.householderReflexion</font>(Gst, u1);

        V :=<font color="red"> identity</font>(<font color="red">size</font>(G, 2)) - 2*<font color="red">matrix</font>(u1)*<font color="red">transpose</font>(<font color="red">matrix</font>(u1))/(u1*u1);
        Gs :=<font color="red"> transpose</font>(Gst);
        rankGs := <font color="blue">if </font><font color="red">abs</font>(Gs[1, 1]) &gt; tolerance<font color="blue"> then </font>1<font color="blue"> else </font>0;

      <font color="blue">else</font>
<font color="darkgreen">// systems with p==2 and m&gt;1 are transformed by svd</font>
        (sigmaG,U,V) :=<font color="red"> Modelica.Math.Matrices.singularValues</font>(G);
        rankGs := 0;
        i :=<font color="red"> size</font>(sigmaG, 1);
        <font color="blue">while </font>i &gt; 0<font color="blue"> loop</font>
          <font color="blue">if </font>sigmaG[i] &gt; 1e-10<font color="blue"> then</font>
            rankGs := i;
            i := 0;
          <font color="blue">end if</font>;
          i := i - 1;
        <font color="blue">end while</font>;
        Gs :=<font color="red"> zeros</font>(p,<font color="red"> size</font>(G, 2));
        <font color="blue">for </font>i<font color="blue"> in </font>1:rankGs<font color="blue"> loop</font>
          Gs[i, i] := sigmaG[i];
        <font color="blue">end for</font>;

      <font color="blue">end if</font>;
      V :=<font color="red"> transpose</font>(V);
    <font color="blue">end if</font>;

<font color="darkgreen">// check controllability</font>
    <font color="red">assert</font>(<font color="blue">not </font><font color="red">Modelica.Math.Matrices.isEqual</font>(
      Gs,
      <font color="red">zeros</font>(<font color="red">size</font>(Gs, 1),<font color="red"> size</font>(Gs, 2)),
      tolerance), &quot;A subsystem in StateSpace.Internal.assignOneOrTwoPoles() is not controllable&quot;);

    Ks :=<font color="red"> fill</font>(
      0,
      rankGs,
      <font color="red">size</font>(F, 1));
    Fs := U*F*<font color="red">transpose</font>(U);

    <font color="blue">if </font><font color="red">size</font>(F, 1) == 1<font color="blue"> then</font>
      Ks :=<font color="red"> matrix</font>((Fs[1, 1] - gamma[1].re)/Gs[1, 1]);
    <font color="blue">else</font>
      <font color="blue">if </font>rankGs ==<font color="red"> size</font>(F, 1)<font color="blue"> then</font>

        <font color="darkgreen">// Gamma:= if size(F,1)==1 then [gamma[1].re] else [gamma[1].re, -(gamma[1].im)^2;1, gamma[2].re];</font>
        <font color="darkgreen">//  Ks :=  Modelica_LinearSystems2.Math.Matrices.solve2(Gs, Fs - Gamma);</font>
        Ks := [(Fs[1, 1] - gamma[1].re)/Gs[1, 1] - Gs[1, 2]*(Fs[2, 1] - 1)/Gs[1, 1]/Gs[2,2],
        (Fs[1, 2] + (gamma[1].im)^2)/Gs[1, 1] - Gs[1, 2]*(Fs[2, 2] - gamma[2].re)/Gs[1, 1]/Gs[2, 2];
        (Fs[2, 1] - 1)/Gs[2, 2],(Fs[2, 2] - gamma[2].re)/Gs[2, 2]];
      <font color="blue">else</font>

        Ks[1, 1] := (gamma[1].re + gamma[2].re - Fs[1, 1] - Fs[2, 2])/Gs[1, 1];
        Ks[1, 2] := Ks[1, 1]*Fs[2, 2]/Fs[2, 1] + (Fs[1, 1]*Fs[2, 2] - Fs[1, 2]*
          Fs[2, 1] - (gamma[1].re*gamma[2].re - gamma[1].im*gamma[2].im))/Fs[2,1]/Gs[1, 1];
        Ks := -Ks;
      <font color="blue">end if</font>;
    <font color="blue">end if</font>;

    K := V[:, 1:<font color="red">size</font>(Ks, 1)]*Ks*U;

  <font color="blue">else</font>
    <font color="blue">if </font>p == 1<font color="blue"> then</font>
      <font color="red">Modelica.Utilities.Streams.print</font>(&quot;\n A subsystem (F, G) in StateSpace.Internal.assignOneOrTwoPoles() is not controllable, since G is equal to zero matrix. Therefore, K is set to zero matrix and the eigenvalues are retained.\n
      That is, &quot; +<font color="red"> String</font>(F[1, 1]) + &quot; remains and &quot; +<font color="red"> String</font>(gamma[1].re) + &quot; cannot be realized&quot;);
    <font color="blue">else</font>
      system_ev :=<font color="red"> Complex.eigenValues</font>(F);
      <font color="red">Modelica.Utilities.Streams.print</font>(&quot;\n A subsystem (F, G) in StateSpace.Internal.assignOneOrTwoPoles() is not controllable, since G is equal to zero matrix. Therefore, K is set to zero matrix and the eigenvalues are retained.\n
      That is, &quot; +<font color="red"> String</font>(system_ev[1].re) + (<font color="blue">if </font><font color="red">abs</font>(system_ev[1].im) &gt; 0<font color="blue"> then </font>&quot; + &quot;<font color="blue"> else </font>
              &quot; - &quot;) +<font color="red"> String</font>(system_ev[1].im) + &quot;j and &quot; +<font color="red"> String</font>(system_ev[2].re)
         + (<font color="blue">if </font><font color="red">abs</font>(system_ev[2].im) &gt; 0<font color="blue"> then </font>&quot; + &quot;<font color="blue"> else </font>&quot; - &quot;) +<font color="red"> String</font>(
        system_ev[2].im) + &quot;j remain and &quot; +<font color="red"> String</font>(gamma[1].re) + (<font color="blue">if </font><font color="red">abs</font>(
        gamma[1].im) &gt; 0<font color="blue"> then </font>(<font color="blue">if </font>gamma[1].im &gt; 0<font color="blue"> then </font>&quot; + &quot;<font color="blue"> else </font>&quot; - &quot; +
        <font color="red">String</font>(gamma[1].im) + &quot;j&quot;)<font color="blue"> else </font>&quot;&quot; + &quot; and &quot;) +<font color="red"> String</font>(gamma[2].re) + (
        <font color="blue">if </font><font color="red">abs</font>(gamma[2].im) &gt; 0<font color="blue"> then </font>(<font color="blue">if </font>gamma[2].im &gt; 0<font color="blue"> then </font>&quot; + &quot;<font color="blue"> else </font>&quot; - &quot; +
        <font color="red">String</font>(gamma[2].im) + &quot;j&quot;)<font color="blue"> else </font>&quot;&quot;) + &quot; cannot be realized&quot;);
    <font color="blue">end if</font>;
    K :=<font color="red"> zeros</font>(<font color="red">size</font>(G, 2),<font color="red"> size</font>(F, 1));
  <font color="blue">end if</font>;

<font color="blue">end </font>assignOneOrTwoPoles;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE readSystemDimension<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.readSystemDimension"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.readSystemDimension</H2>
<B>Read the order nx of state matrix and the numbers nu and ny of inputs and outputs</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>fileName</TD><TD>&quot;stateSpace.mat&quot;</TD><TD>&nbsp;</TD></TR>
<TR><TD>String</TD><TD>matrixName</TD><TD>&quot;ABCD&quot;</TD><TD>Name of the generalized state space system matrix</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>xuy[3]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> readSystemDimension <font color="darkgreen">
  &quot;Read the order nx of state matrix and the numbers nu and ny of inputs and outputs&quot;</font>
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
  <font color="blue">input </font>String fileName=&quot;stateSpace.mat&quot;;
  <font color="blue">input </font>String matrixName=&quot;ABCD&quot; <font color="darkgreen">
    &quot;Name of the generalized state space system matrix&quot;</font>;
  <font color="blue">output </font>Integer xuy[3];

<font color="blue">protected </font>
  Real sizeA[1,1]=<font color="red">readMatrix</font>(
          fileName,
          &quot;nx&quot;,
          1,
          1);

  Integer ABCDsizes[2]=<font color="red">readMatrixSize</font>(fileName, matrixName);

<font color="blue">algorithm </font>
  xuy[1] :=<font color="red"> integer</font>(sizeA[1, 1]);
  xuy[2] := ABCDsizes[2] - xuy[1];
  xuy[3] := ABCDsizes[1] - xuy[1];

<font color="blue">end </font>readSystemDimension;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE readLength_nu<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.readLength_nu"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.readLength_nu</H2>
<B>Read the number of inputs nu of a state space system from a file</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>fileName</TD><TD>&quot;ss_siso.mat&quot;</TD><TD>Name of the state space system data file</TD></TR>
<TR><TD>String</TD><TD>matrixName</TD><TD>&quot;ABCD&quot;</TD><TD>Name of the state space system matrix</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>nu</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> readLength_nu <font color="darkgreen">
  &quot;Read the number of inputs nu of a state space system from a file&quot;</font>

  <font color="blue">input </font>String fileName=&quot;ss_siso.mat&quot; <font color="darkgreen">
    &quot;Name of the state space system data file&quot;</font>;
  <font color="blue">input </font>String matrixName=&quot;ABCD&quot; <font color="darkgreen">&quot;Name of the state space system matrix&quot;</font>;

  <font color="blue">output </font>Integer nu;
<font color="blue">protected </font>
  Real nxMat[1,1]=<font color="red">readMatrix</font>(
          fileName,
          &quot;nx&quot;,
          1,
          1);
  Integer ABCDsizes[2]=<font color="red">readMatrixSize</font>(fileName, matrixName);
  Integer nx=<font color="red">integer</font>(nxMat[1, 1]);

<font color="blue">algorithm </font>
  nu := ABCDsizes[2] - nx;
<font color="blue">end </font>readLength_nu;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE readLength_ny<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.readLength_ny"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.readLength_ny</H2>
<B>Read the number of outputs ny of a state space system from a file</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>fileName</TD><TD>&quot;ss_siso.mat&quot;</TD><TD>Name of the state space system data file</TD></TR>
<TR><TD>String</TD><TD>matrixName</TD><TD>&quot;ABCD&quot;</TD><TD>Name of the state space system matrix</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>ny</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> readLength_ny <font color="darkgreen">
  &quot;Read the number of outputs ny of a state space system from a file&quot;</font>

  <font color="blue">input </font>String fileName=&quot;ss_siso.mat&quot; <font color="darkgreen">
    &quot;Name of the state space system data file&quot;</font>;
  <font color="blue">input </font>String matrixName=&quot;ABCD&quot; <font color="darkgreen">&quot;Name of the state space system matrix&quot;</font>;

  <font color="blue">output </font>Integer ny;
<font color="blue">protected </font>
  Real nxMat[1,1]=<font color="red">readMatrix</font>(
          fileName,
          &quot;nx&quot;,
          1,
          1);
  Integer ABCDsizes[2]=<font color="red">readMatrixSize</font>(fileName, matrixName);
  Integer nx=<font color="red">integer</font>(nxMat[1, 1]);

<font color="blue">algorithm </font>
  ny := ABCDsizes[1] - nx;
<font color="blue">end </font>readLength_ny;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE dgreeOfRedSys<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.dgreeOfRedSys"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.dgreeOfRedSys</H2>
<B>Calculate the controllable and observable part of a state space system</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>ss</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>degree_rs</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> dgreeOfRedSys <font color="darkgreen">
  &quot;Calculate the controllable and observable part of a state space system&quot;</font>

    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;
  <font color="blue">output </font>Integer degree_rs;

<font color="blue">protected </font>
  <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ssm1=
      <font color="red">Modelica_LinearSystems2.StateSpace.Internal.reducedCtrSystem</font>(ss);

  <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss2=<font color="red">StateSpace</font>(
          A=<font color="red">transpose</font>(ssm1.A),
          B=<font color="red">transpose</font>(ssm1.C),
          C=<font color="red">transpose</font>(ssm1.B),
          D=ssm1.D);

  <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ssm2=
      <font color="red">Modelica_LinearSystems2.StateSpace.Internal.reducedCtrSystem</font>(ss2);

<font color="blue">algorithm </font>
  degree_rs :=<font color="red"> size</font>(ssm2.A, 1);

<font color="blue">end </font>dgreeOfRedSys;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE householder<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.householder"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.householder</H2>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>ss</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>v[size(ss.A, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>ssh</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> householder
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Vectors.html#Modelica_LinearSystems2.Math.Vectors"
>Modelica_LinearSystems2.Math.Vectors</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;
  <font color="blue">input </font>Real v[<font color="red">size</font>(ss.A, 1)];

  <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ssh;

<font color="blue">protected </font>
  Real Ah[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)];
  Real Bh[<font color="red">size</font>(ss.B, 1),<font color="red">size</font>(ss.B, 2)];
  Real Ch[<font color="red">size</font>(ss.C, 1),<font color="red">size</font>(ss.C, 2)];
<font color="blue">algorithm </font>
  Ah :=<font color="red"> Matrices.householderSimilarityTransformation</font>(ss.A, v);
  Bh :=<font color="red"> Matrices.householderReflexion</font>(ss.B, v);
  Ch :=<font color="red"> transpose</font>(<font color="red">Matrices.householderReflexion</font>(<font color="red">transpose</font>(ss.C), v));

  ssh :=<font color="red"> StateSpace</font>(
        A=Ah,
        B=Bh,
        C=Ch,
        D=ss.D);

<font color="blue">end </font>householder;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE numberOfZeros<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.numberOfZeros"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.numberOfZeros</H2>
<B>Calculate the number of zeros of the related transfer function</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>ss</TD><TD>&nbsp;</TD><TD>StateSpace object</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>numberOfZeros</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> numberOfZeros <font color="darkgreen">
  &quot;Calculate the number of zeros of the related transfer function&quot;</font>

    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;StateSpace object&quot;</font>;

  <font color="blue">output </font>Integer numberOfZeros;

<font color="blue">protected </font>
  Integer nop;
  Integer noz;

<font color="blue">algorithm </font>
  (nop,noz) :=<font color="red"> StateSpace.Internal.numberOfPolesAndZeros</font>(ss);
  numberOfZeros := noz;
<font color="blue">end </font>numberOfZeros;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE complexZeros<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.complexZeros"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.complexZeros</H2>
<B>Calculate the zeros of the related transfer function</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>ss</TD><TD>&nbsp;</TD><TD>StateSpace object</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>zeros2[:]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> complexZeros <font color="darkgreen">
  &quot;Calculate the zeros of the related transfer function&quot;</font>

    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;StateSpace object&quot;</font>;
  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> zeros2[:]=<font color="red">fill</font>(<font color="red">Complex</font>(0, 0),
      <font color="red">StateSpace.Internal.numberOfZeros</font>(ss));

<font color="blue">protected </font>
  Integer nx=<font color="red">size</font>(ss.A, 2);

  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> zeros[:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> poles[:];
  Real eval[nx,2];
  Real evec[nx,nx];

  Integer index[:]=<font color="red">fill</font>(0, nx) <font color="darkgreen">&quot;indices of zeros which are equal to poles&quot;</font>;
  Integer i;
  Integer j;
  Integer k;
  Boolean h;
  Integer nzero;

<font color="blue">algorithm </font>
  <font color="blue">if </font><font color="red">size</font>(ss.C, 1) &lt;&gt; 1<font color="blue"> or </font><font color="red">size</font>(ss.B, 2) &lt;&gt; 1<font color="blue"> then</font>
    <font color="red">assert</font>(<font color="red">size</font>(ss.B, 2) == 1,
      &quot; function fromStateSpaceSISO expects a SISO-system as input\n but the number of inputs is &quot;
       +<font color="red"> String</font>(<font color="red">size</font>(ss.B, 2)) + &quot; instead of 1&quot;);
    <font color="red">assert</font>(<font color="red">size</font>(ss.C, 1) == 1,
      &quot; function fromStateSpaceSISO expects a SISO-system as input\n but the number of outputs is &quot;
       +<font color="red"> String</font>(<font color="red">size</font>(ss.C, 1)) + &quot; instead of 1&quot;);
  <font color="blue">end if</font>;

  zeros :=<font color="red"> StateSpace.Analysis.invariantZeros</font>( ss);

  poles :=<font color="red"> Modelica_LinearSystems2.Math.Complex.eigenValues</font>(ss.A);

  <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(zeros, 1)<font color="blue"> loop</font>
    <font color="blue">for </font>j<font color="blue"> in </font>1:<font color="red">size</font>(poles, 1)<font color="blue"> loop</font>
       <font color="blue">if </font>zeros[i] == poles[j]<font color="blue"> then</font>
        h := false;
        k := 1;
        <font color="blue">while </font>((k &lt; i)<font color="blue"> and </font>(<font color="blue">not </font>h))<font color="blue"> loop</font>
          h := <font color="blue">if </font>(j == index[k])<font color="blue"> then </font>true<font color="blue"> else </font>false;
          k := k + 1;
        <font color="blue">end while</font>;
        index[i] := <font color="blue">if </font>h<font color="blue"> then </font>0<font color="blue"> else </font>j;
      <font color="blue">end if</font>;
    <font color="blue">end for</font>;
  <font color="blue">end for</font>;

  j := 0;
  <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(zeros, 1)<font color="blue"> loop</font>
    <font color="blue">if </font>index[i] == 0<font color="blue"> then</font>
      j := j + 1;
      zeros2[j] := zeros[i];
    <font color="blue">end if</font>;
  <font color="blue">end for</font>;

<font color="blue">end </font>complexZeros;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE numberOfPoles<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.numberOfPoles"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.numberOfPoles</H2>
<B>Calculate the number of poles of the related transfer function</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>ss</TD><TD>&nbsp;</TD><TD>StateSpace object</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>numberOfPoles</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> numberOfPoles <font color="darkgreen">
  &quot;Calculate the number of poles of the related transfer function&quot;</font>

    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;StateSpace object&quot;</font>;

  <font color="blue">output </font>Integer numberOfPoles=<font color="red">StateSpace.Internal.numberOfPolesAndZeros</font>(ss);

<font color="blue">algorithm </font>
<font color="blue">end </font>numberOfPoles;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE numberOfPolesAndZeros<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.numberOfPolesAndZeros"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.numberOfPolesAndZeros</H2>
<B>Calculate the number poles and of zeros of the related transfer function</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>ss</TD><TD>&nbsp;</TD><TD>StateSpace object</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>numberOfPoles</TD><TD>&nbsp;</TD></TR>
<TR><TD>Integer</TD><TD>numberOfZeros</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> numberOfPolesAndZeros <font color="darkgreen">
  &quot;Calculate the number poles and of zeros of the related transfer function&quot;</font>

    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;StateSpace object&quot;</font>;
  <font color="blue">output </font>Integer numberOfPoles;
  <font color="blue">output </font>Integer numberOfZeros;

<font color="blue">protected </font>
  Integer nx=<font color="red">size</font>(ss.A, 2);
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> zeros[:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> zeros2[:] <font color="darkgreen">
    &quot;Finite, invariant zeros of ss; size(Zeros,1) &lt;= size(ss.A,1)&quot;</font>;
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> poles[:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> poles2[:] <font color="darkgreen">&quot;eigenvalues of ss&quot;</font>;
  Real eval[nx,2];
  Real evec[nx,nx];

  Integer index[:]=<font color="red">fill</font>(0, nx) <font color="darkgreen">&quot;indices of zeros which are equal to poles&quot;</font>;
  Integer i;
  Integer j;
  Integer k;
  Boolean h;
  Integer nzero;

<font color="blue">algorithm </font>
  <font color="blue">if </font><font color="red">size</font>(ss.C, 1) &lt;&gt; 1<font color="blue"> or </font><font color="red">size</font>(ss.B, 2) &lt;&gt; 1<font color="blue"> then</font>
    <font color="red">assert</font>(<font color="red">size</font>(ss.B, 2) == 1,
      &quot; function fromStateSpaceSISO expects a SISO-system as input\n but the number of inputs is &quot;
       +<font color="red"> String</font>(<font color="red">size</font>(ss.B, 2)) + &quot; instead of 1&quot;);
    <font color="red">assert</font>(<font color="red">size</font>(ss.C, 1) == 1,
      &quot; function fromStateSpaceSISO expects a SISO-system as input\n but the number of outputs is &quot;
       +<font color="red"> String</font>(<font color="red">size</font>(ss.C, 1)) + &quot; instead of 1&quot;);
  <font color="blue">end if</font>;

  zeros :=<font color="red"> StateSpace.Analysis.invariantZeros</font>(ss);
  zeros2 := zeros;

  poles :=<font color="red"> Modelica_LinearSystems2.Math.Complex.eigenValues</font>(ss.A);
  poles2 := poles;

<font color="darkgreen">//Reduce terms which are in nominator as well as in denominator</font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(zeros, 1)<font color="blue"> loop</font>
    <font color="blue">for </font>j<font color="blue"> in </font>1:<font color="red">size</font>(poles, 1)<font color="blue"> loop</font>
      <font color="blue">if </font>zeros[i] == poles[j]<font color="blue"> then</font>
        h := false;
        k := 1;
        <font color="blue">while </font>((k &lt; i)<font color="blue"> and </font>(<font color="blue">not </font>h))<font color="blue"> loop</font>
          h := <font color="blue">if </font>(j == index[k])<font color="blue"> then </font>true<font color="blue"> else </font>false;
          k := k + 1;
        <font color="blue">end while</font>;
        index[i] := <font color="blue">if </font>h<font color="blue"> then </font>0<font color="blue"> else </font>j;
      <font color="blue">end if</font>;
    <font color="blue">end for</font>;
  <font color="blue">end for</font>;

  j := 0;
  <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(zeros, 1)<font color="blue"> loop</font>
    <font color="blue">if </font>index[i] == 0<font color="blue"> then</font>
      j := j + 1;
      zeros2[j] := zeros[i];
    <font color="blue">end if</font>;
  <font color="blue">end for</font>;
  nzero := j;
  j := 0;
  <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(poles, 1)<font color="blue"> loop</font>
    h := false;
    k := 1;
    <font color="blue">while </font>(k &lt;=<font color="red"> size</font>(zeros, 1)<font color="blue"> and </font>(<font color="blue">not </font>h))<font color="blue"> loop</font>
      h := <font color="blue">if </font>i == index[k]<font color="blue"> then </font>true<font color="blue"> else </font>false;
      k := k + 1;
    <font color="blue">end while</font>;
    <font color="blue">if </font><font color="blue">not </font>h<font color="blue"> then</font>
      j := j + 1;
      poles2[j] := poles[i];

    <font color="blue">end if</font>;
  <font color="blue">end for</font>;

  numberOfPoles := nx -<font color="red"> size</font>(zeros, 1) + nzero;
  numberOfZeros := nzero;

<font color="blue">end </font>numberOfPolesAndZeros;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE complexPoles<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.complexPoles"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.complexPoles</H2>
<B>Generate a zeros-and-poles representation from state space representation</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>ss</TD><TD>&nbsp;</TD><TD>StateSpace object</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>poles2[:]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> complexPoles <font color="darkgreen">
  &quot;Generate a zeros-and-poles representation from state space representation&quot;</font>

    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;StateSpace object&quot;</font>;

  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> poles2[:]=<font color="red">fill</font>(<font color="red">Complex</font>(0, 0),
      <font color="red">StateSpace.Internal.numberOfPoles</font>(ss));

<font color="blue">protected </font>
  Integer nx=<font color="red">size</font>(ss.A, 2);

  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> zeros[:] <font color="darkgreen">
    &quot;Finite, invariant zeros of ss; size(Zeros,1) &lt;= size(ss.A,1)&quot;</font>;
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> zeros2[:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> poles[:] <font color="darkgreen">&quot;eigenvalues of ss&quot;</font>;
  Real eval[nx,2];
  Real evec[nx,nx];

  Integer index[:]=<font color="red">fill</font>(0, nx) <font color="darkgreen">&quot;indices of zeros which are equal to poles&quot;</font>;
  Integer i;
  Integer j;
  Integer k;
  Boolean h;
  Integer nzero;

<font color="blue">algorithm </font>
  <font color="blue">if </font><font color="red">size</font>(ss.C, 1) &lt;&gt; 1<font color="blue"> or </font><font color="red">size</font>(ss.B, 2) &lt;&gt; 1<font color="blue"> then</font>
    <font color="red">assert</font>(<font color="red">size</font>(ss.B, 2) == 1,
      &quot; function fromStateSpaceSISO expects a SISO-system as input\n but the number of inputs is &quot;
       +<font color="red"> String</font>(<font color="red">size</font>(ss.B, 2)) + &quot; instead of 1&quot;);
    <font color="red">assert</font>(<font color="red">size</font>(ss.C, 1) == 1,
      &quot; function fromStateSpaceSISO expects a SISO-system as input\n but the number of outputs is &quot;
       +<font color="red"> String</font>(<font color="red">size</font>(ss.C, 1)) + &quot; instead of 1&quot;);
  <font color="blue">end if</font>;

  h := false;
  zeros :=<font color="red"> StateSpace.Analysis.invariantZeros</font>( ss);
  zeros2 := zeros;

  poles :=<font color="red"> Modelica_LinearSystems2.Math.Complex.eigenValues</font>(ss.A);

  <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(zeros, 1)<font color="blue"> loop</font>
    <font color="blue">for </font>j<font color="blue"> in </font>1:<font color="red">size</font>(poles, 1)<font color="blue"> loop</font>
      <font color="blue">if </font>zeros[i] == poles[j]<font color="blue"> then</font>
        h := false;
        k := 1;
        <font color="blue">while </font>((k &lt; i)<font color="blue"> and </font>(<font color="blue">not </font>h))<font color="blue"> loop</font>
          h := <font color="blue">if </font>(j == index[k])<font color="blue"> then </font>true<font color="blue"> else </font>false;
          k := k + 1;
        <font color="blue">end while</font>;
        index[i] := <font color="blue">if </font>h<font color="blue"> then </font>0<font color="blue"> else </font>j;
      <font color="blue">end if</font>;
    <font color="blue">end for</font>;
  <font color="blue">end for</font>;

  j := 0;
  <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(zeros, 1)<font color="blue"> loop</font>
    <font color="blue">if </font>index[i] == 0<font color="blue"> then</font>
      j := j + 1;
      zeros2[j] := zeros[i];
    <font color="blue">end if</font>;
  <font color="blue">end for</font>;
  nzero := j;
  j := 0;
  <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(poles, 1)<font color="blue"> loop</font>
    h := false;
    k := 1;
    <font color="blue">while </font>(k &lt;=<font color="red"> size</font>(zeros, 1)<font color="blue"> and </font>(<font color="blue">not </font>h))<font color="blue"> loop</font>
      h := <font color="blue">if </font>i == index[k]<font color="blue"> then </font>true<font color="blue"> else </font>false;
      k := k + 1;
    <font color="blue">end while</font>;
    <font color="blue">if </font><font color="blue">not </font>h<font color="blue"> then</font>
      j := j + 1;
      poles2[j] := poles[i];

    <font color="blue">end if</font>;
  <font color="blue">end for</font>;

<font color="blue">end </font>complexPoles;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE trianUpperHess<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.trianUpperHess"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.trianUpperHess</H2>
<B>Triangulize an upper Hessenberg matrix by repeatedly applicated householder reflexion</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
This function computes an triangular matrix from an upper Hessenberg matrix by stepwise annihilation of the subdiagonal elements.
<p>
<blockquote><pre>
<b>A</b> -> <b>QA</b> = <b>T</b>
</pre></blockquote>
</p>
It is assumend that the original matrix has upper hessenberg form.
Additionally the vector b is transformed in the same way
<blockquote><pre>
<b>b</b> -> <b>Qb</b> = <b>q</b>
</pre></blockquote>
</p>
The function is primarily used to calculate the transfer function gain from a SISO state space system in observer Hessenberg form
<blockquote><pre>
     ( *   *   ...   ...    * )          ( * )
     ( *   *   ...   ...    * )          ( . )
 <b>A</b> = ( 0   *   ...   ...    * ),    <b>b</b> =  ( . ),   <b>c</b> = ( 0, ..., 0, * )
     ( .   .    .     .     . )          ( * )
     ( 0  ...   0     *     * )          ( * )
 
</pre>
</blockquote>
If <b>A</b> is upper Hessenberg and <b>T</b> = <b>Q</b>*<b>A</b> is triangular then obviously <b>H</b>(s) = <b>Q</b>*(s*<b>I</b> -<b>A</b>) = s*<b>I</b> - <b>T</b>.
<p>
Further on, if <b>T</b> is triangular then also <b>H</b> = s<b>I</b> - <b>T</b> is and the element l_nn of <b>L</b> = inv(<b>H</b>) is given by 1/h_nn.
The frequency response G(s0)for a given s0 that is neither zero nor pole of the system can be calculated by
<blockquote><pre>
                    -1               -1     -1         -1           -1  -1        -1
G(s0)  = <b>c</b>*(s0*<b>I</b> -<b>A</b>)  *<b>b</b> = <b>c</b>*(s0*<b>I</b> -<b>A</b>)  *<b>Q</b>*<b>Q</b>  *<b>b</b> = <b>c</b>*(<b>Q</b>  *(s0*<b>I</b> -<b>A</b>))  *<b>Q</b>  *<b>b</b> = <b>c</b>*<b>H</b>(s0)*<b>q</b>
</pre></blockquote>
and because only the n'th element of <b>c</b> is different to zero the gain k is given by
<blockquote><pre>
    q_nn*c_nn     product(s0 - poles_i)
k = ---------- * ----------------------
       h_nn       product(s0 - zeros_i)
</pre></blockquote>
 
 
</p>
 
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>H[:, :]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>b[size(H, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>Ht[size(H, 1), size(H, 2)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>bt[size(b, 1)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> trianUpperHess <font color="darkgreen">
  &quot;Triangulize an upper Hessenberg matrix by repeatedly applicated householder reflexion&quot;</font>
    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Vectors.html#Modelica_LinearSystems2.Math.Vectors"
>Modelica_LinearSystems2.Math.Vectors</A>;

  <font color="blue">input </font>Real H[:,:];
  <font color="blue">input </font>Real b[<font color="red">size</font>(H, 1)];

  <font color="blue">output </font>Real Ht[<font color="red">size</font>(H, 1),<font color="red">size</font>(H, 2)];
  <font color="blue">output </font>Real bt[<font color="red">size</font>(b, 1)];

<font color="blue">protected </font>
  Integer q=<font color="red">size</font>(H, 1);
  Real u[:] <font color="darkgreen">&quot;householder vector&quot;</font>;
  Integer ll;

<font color="blue">algorithm </font>
  Ht := H;
  bt := b;

  <font color="blue">for </font>ll<font color="blue"> in </font>1:q - 1<font color="blue"> loop</font>
    u :=<font color="red"> cat</font>(
          1,
          <font color="red">zeros</font>(ll - 1),
          <font color="red">cat</font>(
            1,
            <font color="red">Vectors.householderVector</font>(<font color="red">vector</font>(Ht[ll:ll + 1, ll]), {1,0}),
            <font color="red">zeros</font>(q - ll - 1)));
    Ht :=<font color="red"> Matrices.householderReflexion</font>(Ht, u);
    bt :=<font color="red"> Vectors.householderReflexion</font>(bt, u);
  <font color="blue">end for</font>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>trianUpperHess;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE reducedCtrSystem2<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.reducedCtrSystem2"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.reducedCtrSystem2</H2>
<B>calculate the controllable part of a SISO system</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>ss</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>eps</TD><TD>0</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>ssm1</TD><TD>controllable state space system</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> reducedCtrSystem2 <font color="darkgreen">
  &quot;calculate the controllable part of a SISO system&quot;</font>

    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Vectors.html#Modelica_LinearSystems2.Math.Vectors"
>Modelica_LinearSystems2.Math.Vectors</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;
  <font color="blue">input </font>Real eps=0;

<font color="blue">protected </font>
  <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> sst(
    <font color="blue">redeclare </font>Real A[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)],
    <font color="blue">redeclare </font>Real B[<font color="red">size</font>(ss.B, 1),<font color="red">size</font>(ss.B, 2)],
    <font color="blue">redeclare </font>Real C[<font color="red">size</font>(ss.C, 1),<font color="red">size</font>(ss.C, 2)],
    <font color="blue">redeclare </font>Real D[<font color="red">size</font>(ss.D, 1),<font color="red">size</font>(ss.D, 2)]) <font color="darkgreen">
    &quot;tranformed state space system&quot;</font>;

  Integer nx=<font color="red">size</font>(ss.A, 1);
  Real Ah1[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)];
  Real bh1[<font color="red">size</font>(ss.A, 1)];
  Real ch1[<font color="red">size</font>(ss.A, 1)];

  Real u[:] <font color="darkgreen">&quot;householder vector&quot;</font>;
  Real cpoles[:,2]=<font color="red">Modelica_LinearSystems2.StateSpace.Internal.controllablePoles</font>(ss);
  Integer rankQc=<font color="red">size</font>(cpoles,1);

  Integer rankQc2;
  Real Qc2[nx,nx];
  Real sigma[:];
  Real eps2;

  Real Ah2[rankQc,rankQc];
  Real bh2[rankQc];
  Real ch2[rankQc];

  Integer ll;
  Integer r;

  Boolean h;

<font color="blue">public </font>
  <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ssm1(
    <font color="blue">redeclare </font>Real A[rankQc,rankQc],
    <font color="blue">redeclare </font>Real B[rankQc,1],
    <font color="blue">redeclare </font>Real C[1,rankQc],
    <font color="blue">redeclare </font>Real D[<font color="red">size</font>(ss.D, 1),<font color="red">size</font>(ss.D, 2)]) <font color="darkgreen">
    &quot;controllable state space system&quot;</font>;

<font color="blue">algorithm </font>
  <font color="blue">if </font><font color="red">size</font>(ss.C, 1) &lt;&gt; 1<font color="blue"> or </font><font color="red">size</font>(ss.B, 2) &lt;&gt; 1<font color="blue"> then</font>
    <font color="red">assert</font>(<font color="red">size</font>(ss.B, 2) == 1,
      &quot;A SISO-system is expected as input\n but the number of inputs is &quot;
       +<font color="red"> String</font>(<font color="red">size</font>(ss.B, 2)) + &quot; instead of 1&quot;);
    <font color="red">assert</font>(<font color="red">size</font>(ss.C, 1) == 1,
      &quot; A SISO-system is expected as input\n but the number of outputs is &quot;
       +<font color="red"> String</font>(<font color="red">size</font>(ss.C, 1)) + &quot; instead of 1&quot;);
  <font color="blue">end if</font>;

  Ah1 := ss.A;
  bh1 := ss.B[:, 1];
  ch1 := ss.C[1, :];

  <font color="blue">if </font>nx &gt; 1<font color="blue"> then</font>

    u :=<font color="red"> Vectors.householderVector</font>(bh1,<font color="red"> cat</font>(
          1,
          <font color="red">fill</font>(0, nx - 1),
          {1}));

    Ah1 :=<font color="red"> Matrices.householderSimilarityTransformation</font>(Ah1, u);

    bh1 :=<font color="red"> Vectors.householderReflexion</font>(bh1, u);
    ch1 :=<font color="red"> Vectors.householderReflexion</font>(ch1, u);

    ll := nx;

    h := true;
    r := 1;

    <font color="blue">while </font>r &lt;= nx - 2<font color="blue"> and </font>h<font color="blue"> loop</font>
      <font color="blue">if </font><font color="red">max</font>(Ah1[1:ll - 1, ll]) &lt;= 1e-8<font color="blue"> then</font>

        u :=<font color="red"> cat</font>(
              1,
              <font color="red">Vectors.householderVector</font>(Ah1[1:ll - 1, ll],<font color="red"> cat</font>(
                1,
                <font color="red">fill</font>(0, ll - 2),
                {1})),
              <font color="red">fill</font>(0, nx - ll + 1));
        Ah1 :=<font color="red"> Matrices.householderSimilarityTransformation</font>(Ah1, u);
        ch1 :=<font color="red"> Vectors.householderReflexion</font>(ch1, u);

        Ah1[1:ll - 2, ll] :=<font color="red"> fill</font>(0, ll - 2);

        ll := ll - 1;

      <font color="blue">else</font>
        h := false;

      <font color="blue">end if</font>;
      r := r + 1;
    <font color="blue">end while</font>;
  <font color="blue">end if</font>;

  Qc2 :=<font color="red"> cat</font>(
        2,
        Ah1[:, 2:nx],
        <font color="red">matrix</font>(bh1));
  sigma :=<font color="red"> Modelica.Math.Matrices.singularValues</font>(Qc2);
  eps2 := <font color="blue">if </font>eps &gt; 0<font color="blue"> then </font>eps<font color="blue"> else </font>1000*sigma[1]*Modelica.Constants.eps;
  rankQc2 := 0;

  <font color="blue">for </font>i<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
    <font color="red">Modelica.Utilities.Streams.print</font>(&quot; s[&quot; +<font color="red"> String</font>(i) + &quot;] = &quot; +<font color="red"> String</font>(
      sigma[i]));
    <font color="blue">if </font>sigma[i] &gt; eps2<font color="blue"> then</font>
      rankQc2 := rankQc2 + 1;
    <font color="blue">end if</font>;
  <font color="blue">end for</font>;

  <font color="red">Modelica.Utilities.Streams.print</font>(&quot;rankQc = &quot; +<font color="red"> String</font>(rankQc) +
    &quot;     rankQc2 = &quot; +<font color="red"> String</font>(rankQc2) + &quot;     eps2 = &quot; +<font color="red"> String</font>(eps2));

  sst :=<font color="red"> StateSpace</font>(
        A=Ah1,
        B=<font color="red">matrix</font>(bh1),
        C=<font color="red">transpose</font>(<font color="red">matrix</font>(ch1)),
        D=ss.D);

  Ah2 := Ah1[nx - rankQc2 + 1:nx, nx - rankQc2 + 1:nx];
  bh2 := bh1[nx - rankQc2 + 1:nx];
  ch2 := ch1[nx - rankQc2 + 1:nx];
  ssm1 :=<font color="red"> StateSpace</font>(
        A=Ah2,
        B=<font color="red">matrix</font>(bh2),
        C=<font color="red">transpose</font>(<font color="red">matrix</font>(ch2)),
        D=ss.D);

<font color="blue">end </font>reducedCtrSystem2;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE controllablePoles<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.controllablePoles"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.controllablePoles</H2>
<B>Compute the controllable and uncontrollable poles of a state space system</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
The function uses the SVD based staircase algorithm to transform the state space representation into a similar state space
to separate the uncontrollable poles from the controllable poles.
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>ss</TD><TD>StateSpace(A=[-1], B=[1], C=...</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>cPoles[:, 2]</TD><TD>controllable poles</TD></TR>
<TR><TD>Real</TD><TD>ncPoles[:, 2]</TD><TD>uncontrollable poles</TD></TR>
<TR><TD>Real</TD><TD>poles[size(ss.A, 1), 2]</TD><TD>controllable and uncontrollable poles</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> controllablePoles <font color="darkgreen">
  &quot;Compute the controllable and uncontrollable poles of a state space system&quot;</font>

    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss=<font color="red">StateSpace</font>(
      A=[-1],
      B=[1],
      C=[0],
      D=[0]);

  <font color="blue">output </font>Real cPoles[:,2] <font color="darkgreen">&quot;controllable poles&quot;</font>;
  <font color="blue">output </font>Real ncPoles[:,2] <font color="darkgreen">&quot;uncontrollable poles&quot;</font>;
  <font color="blue">output </font>Real poles[<font color="red">size</font>(ss.A, 1),2] <font color="darkgreen">&quot;controllable and uncontrollable poles&quot;</font>;
<font color="blue">protected </font>
  <A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.StateSpaceR"
>Modelica_LinearSystems2.Internal.StateSpaceR</A> ssch(
    <font color="blue">redeclare </font>Real A[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)],
    <font color="blue">redeclare </font>Real B[<font color="red">size</font>(ss.B, 1),<font color="red">size</font>(ss.B, 2)],
    <font color="blue">redeclare </font>Real C[<font color="red">size</font>(ss.C, 1),<font color="red">size</font>(ss.C, 2)],
    <font color="blue">redeclare </font>Real D[<font color="red">size</font>(ss.D, 1),<font color="red">size</font>(ss.D, 2)]) <font color="darkgreen">
    &quot;upper block controller Hessenberg form state space system&quot;</font>;
  Boolean isControllable;

<font color="blue">algorithm </font>
  <font color="blue">if </font><font color="red">size</font>(ss.B, 2) == 0<font color="blue"> then</font>
    poles :=<font color="red"> Modelica.Math.Matrices.eigenValues</font>(ss.A);
    ncPoles := poles;
    cPoles :=<font color="red"> fill</font>(0, 0, 2);
  <font color="blue">else</font>
<font color="darkgreen">// build upper Hessenberg staircase to decomposite controllable/uncontrollable subspaces</font>
<font color="darkgreen">// The controllable part of A is in A[1:ssch.r, 1:ssch.r]</font>
    (isControllable,ssch) :=<font color="red"> StateSpace.Internal.staircaseSVD</font>(ss);
    <font color="blue">if </font>isControllable<font color="blue"> then</font>
      poles :=<font color="red"> Modelica.Math.Matrices.eigenValues</font>(ss.A);
      cPoles := poles;
      ncPoles :=<font color="red"> fill</font>(0, 0, 2);
    <font color="blue">else</font>
      cPoles :=<font color="red"> Modelica.Math.Matrices.eigenValues</font>(ssch.A[1:ssch.r, 1:ssch.r]);
      ncPoles :=<font color="red"> Modelica.Math.Matrices.eigenValues</font>(ssch.A[ssch.r + 1:<font color="red">size</font>(ss.A,
        1), ssch.r + 1:<font color="red">size</font>(ss.A, 1)]);
      poles := [cPoles; ncPoles];
    <font color="blue">end if</font>;
  <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>controllablePoles;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE polesAndZeros<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.polesAndZeros"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.polesAndZeros</H2>
<B>Generate poles and zeros from state space representation</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>ss</TD><TD>&nbsp;</TD><TD>StateSpace object</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>ssm</TD><TD>Modelica_LinearSystems2.Stat...</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.PolesAndZeros"
>PolesAndZeros</A></TD><TD>pz</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> polesAndZeros <font color="darkgreen">
  &quot;Generate poles and zeros from state space representation&quot;</font>

    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.PolesAndZeros"
>Modelica_LinearSystems2.Internal.PolesAndZeros</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;StateSpace object&quot;</font>;
  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ssm=<font color="red">Modelica_LinearSystems2.StateSpace.Transformation.toIrreducibleForm</font>(
                                                                       ss);
  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.PolesAndZeros"
>Internal.PolesAndZeros</A> pz(
    <font color="blue">redeclare </font>Real p_real[<font color="red">size</font>(ssm.A, 1)],
    <font color="blue">redeclare </font>Real p_im[<font color="red">size</font>(ssm.A, 1)],
    <font color="blue">redeclare </font>Real z_real[<font color="red">size</font>(<font color="red">StateSpace.Analysis.invariantZeros</font>(ssm), 1)],
    <font color="blue">redeclare </font>Real z_im[<font color="red">size</font>(<font color="red">StateSpace.Analysis.invariantZeros</font>(ssm), 1)]);
<font color="blue">protected </font>
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> poles[:]=<font color="red">Complex.eigenValues</font>(ssm.A);
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> zeros[:]=<font color="red">StateSpace.Analysis.invariantZeros</font>( ssm);

<font color="blue">algorithm </font>
  pz.p_real := poles[:].re;
  pz.p_im := poles[:].im;
  pz.z_real := zeros[:].re;
  pz.z_im := zeros[:].im;
  pz.norz_p :=<font color="red"> Internal.numberOfRealZeros</font>(poles);
  pz.norz_z :=<font color="red"> Internal.numberOfRealZeros</font>(zeros);

<font color="blue">end </font>polesAndZeros;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE scaleFactor1<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.scaleFactor1"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.scaleFactor1</H2>
<B>Return scale factor for first order block</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>n</TD><TD>&nbsp;</TD><TD>(s+n)/(s+d)</TD></TR>
<TR><TD>Real</TD><TD>d</TD><TD>&nbsp;</TD><TD>(s+n)/(s+d)</TD></TR>
<TR><TD>Real</TD><TD>small</TD><TD>100*Modelica.Constants.eps</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>k</TD><TD>= d/n, if d,n are not zero, otherwise special cases</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> scaleFactor1 <font color="darkgreen">
  &quot;Return scale factor for first order block&quot;</font>
    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
  <font color="blue">input </font>Real n <font color="darkgreen">&quot;(s+n)/(s+d)&quot;</font>;
  <font color="blue">input </font>Real d <font color="darkgreen">&quot;(s+n)/(s+d)&quot;</font>;
  <font color="blue">input </font>Real small=100*Modelica.Constants.eps;
  <font color="blue">output </font>Real k <font color="darkgreen">&quot;= d/n, if d,n are not zero, otherwise special cases&quot;</font>;
<font color="blue">algorithm </font>
  k := (<font color="blue">if </font><font color="red">abs</font>(d) &gt; small<font color="blue"> then </font><font color="red">abs</font>(d)<font color="blue"> else </font>1)/(<font color="blue">if </font><font color="red">abs</font>(n) &gt; small<font color="blue"> then </font><font color="red">abs</font>(n)<font color="blue"> else </font>
          1);
<font color="blue">end </font>scaleFactor1;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE scaleFactor2<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.scaleFactor2"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.scaleFactor2</H2>
<B>Return scale factor for second order block</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>n1</TD><TD>&nbsp;</TD><TD>(s^2 + n1*s + n2)/(s^2 + d1*s + d2)</TD></TR>
<TR><TD>Real</TD><TD>n2</TD><TD>&nbsp;</TD><TD>(s^2 + n1*s + n2)/(s^2 + d1*s + d2)</TD></TR>
<TR><TD>Real</TD><TD>d1</TD><TD>&nbsp;</TD><TD>(s^2 + n1*s + n2)/(s^2 + d1*s + d2)</TD></TR>
<TR><TD>Real</TD><TD>d2</TD><TD>&nbsp;</TD><TD>(s^2 + n1*s + n2)/(s^2 + d1*s + d2)</TD></TR>
<TR><TD>Real</TD><TD>small</TD><TD>100*Modelica.Constants.eps</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>k</TD><TD>= d2/n2, if d2,n2 are not zero, otherwise special cases</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> scaleFactor2 <font color="darkgreen">&quot;Return scale factor for second order block&quot;</font>
    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
  <font color="blue">input </font>Real n1 <font color="darkgreen">&quot;(s^2 + n1*s + n2)/(s^2 + d1*s + d2)&quot;</font>;
  <font color="blue">input </font>Real n2 <font color="darkgreen">&quot;(s^2 + n1*s + n2)/(s^2 + d1*s + d2)&quot;</font>;
  <font color="blue">input </font>Real d1 <font color="darkgreen">&quot;(s^2 + n1*s + n2)/(s^2 + d1*s + d2)&quot;</font>;
  <font color="blue">input </font>Real d2 <font color="darkgreen">&quot;(s^2 + n1*s + n2)/(s^2 + d1*s + d2)&quot;</font>;
  <font color="blue">input </font>Real small=100*Modelica.Constants.eps;
  <font color="blue">output </font>Real k <font color="darkgreen">&quot;= d2/n2, if d2,n2 are not zero, otherwise special cases&quot;</font>;
<font color="blue">algorithm </font>
  k := (<font color="blue">if </font><font color="red">abs</font>(d2) &gt; small<font color="blue"> then </font><font color="red">abs</font>(d2)<font color="blue"> else </font>(<font color="blue">if </font><font color="red">abs</font>(d1) &gt; small<font color="blue"> then </font><font color="red">abs</font>(
    d1)<font color="blue"> else </font>1))/(<font color="blue">if </font><font color="red">abs</font>(n2) &gt; small<font color="blue"> then </font><font color="red">abs</font>(n2)<font color="blue"> else </font>(<font color="blue">if </font><font color="red">abs</font>(n1) &gt; small<font color="blue"> then </font>
          <font color="red">abs</font>(n1)<font color="blue"> else </font>1));
<font color="blue">end </font>scaleFactor2;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE invariantZerosHessenberg<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.invariantZerosHessenberg"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.invariantZerosHessenberg</H2>
<B>Fast version to calculate the system zeros of a SISO system with D=[0] and A has upper Hessenberg form, delivered by StateSpace.reduceSystem</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<p>
Computes the invariant zeros of a system in state space form:
</p>
<pre>
   der(<b>x</b>) = <b>A</b>*<b>x</b> + <b>B</b>*<b>u</b>
        <b>y</b> = <b>C</b>*<b>x</b> + <b>D</b>*<b>u</b>
</pre>
<p>
The invariant zeros of this system are defined as the variables
z that make the following matrix singular:
</p>
<pre> 
    | <b>A</b> <b>B</b> |     | <b>I</b> <b>0</b> |
    |     | - z*|     |
    | <b>C</b> <b>D</b> |     | <b>0</b> <b>0</b> |
</pre>
<p>
where <b>I</b> is the identity matrix of the same size as <b>A</b>
and <b>0</b> are zero matrices of appropriate dimensions.
</p>
<p>
Currently, there is the restriction that the number of 
inputs and the number of outputs must be identical.
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>ss</TD><TD>&nbsp;</TD><TD>Linear system in state space form</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>Zeros[:]</TD><TD>Finite, invariant zeros of ss; size(Zeros,1) &lt;= size(ss.A,1)</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> invariantZerosHessenberg <font color="darkgreen">
  &quot;Fast version to calculate the system zeros of a SISO system with D=[0] and A has upper Hessenberg form, delivered by StateSpace.reduceSystem&quot;</font>
    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;Linear system in state space form&quot;</font>;
  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> Zeros[:] <font color="darkgreen">
    &quot;Finite, invariant zeros of ss; size(Zeros,1) &lt;= size(ss.A,1)&quot;</font>;

<font color="blue">protected </font>
  Integer nx=<font color="red">size</font>(ss.A, 1) <font color="darkgreen">&quot;Number of states&quot;</font>;
  Integer nu=<font color="red">size</font>(ss.B, 2) <font color="darkgreen">&quot;Number of inputs&quot;</font>;
  Integer ny=<font color="red">size</font>(ss.C, 1) <font color="darkgreen">&quot;Number of outputs&quot;</font>;
  Real Ah[nx,nx]=ss.A;
  Real eps=100*Modelica.Constants.eps;
  Integer k;
  Boolean h;

<font color="blue">algorithm </font>
  <font color="red">assert</font>(nu == 1, &quot;Function invariantZeros2 requires currently a SISO-input system.\n
This condition is however not fulfilled because the number of inputs is nu = &quot;
     +<font color="red"> String</font>(nu));
  <font color="red">assert</font>(ny == 1, &quot;Function invariantZeros2 requires currently a SISO-input system.\n
This condition is however not fulfilled because the number of outputs is ny = &quot;
     +<font color="red"> String</font>(ny));

  h := true;
  k := nx + 1;

  <font color="blue">if </font><font color="red">size</font>(ss.B, 2) &gt; 0<font color="blue"> then</font>
    <font color="blue">while </font>k &gt;= 1<font color="blue"> and </font>h<font color="blue"> loop</font>
      k := k - 1;
      <font color="blue">if </font><font color="red">abs</font>(ss.B[k, 1]) &gt;= eps<font color="blue"> then</font>

        h := false;
      <font color="blue">end if</font>;

    <font color="blue">end while</font>;

    Zeros :=<font color="red"> fill</font>(<font color="red">Complex</font>(0), k - 1);

    <font color="blue">if </font>k &gt; 1<font color="blue"> then</font>
      Ah[:, k - 1] := ss.A[:, k - 1] - ss.A[k, k - 1]/ss.B[k, 1]*ss.B[:, 1];

<font color="darkgreen">//    Zeros := Complex.eigenValues(Ah[1:k - 1, 1:k - 1]);</font>
      Zeros :=<font color="red"> Complex.Internal.eigenValues_dhseqr</font>(Ah[1:k - 1, 1:k - 1]);

      <font color="blue">for </font>i<font color="blue"> in </font>1:k - 1<font color="blue"> loop</font>
        <font color="blue">if </font><font color="red">Complex.&#39;abs&#39;</font>(Zeros[i]) &lt;<font color="red"> Modelica.Math.Matrices.norm</font>(Ah[1:k - 1, 1:
            k - 1], p=1)*1e-12<font color="blue"> then</font>
          Zeros[i] :=<font color="red"> Complex</font>(0);
        <font color="blue">end if</font>;

      <font color="blue">end for</font>;

    <font color="blue">end if</font>;
  <font color="blue">else</font>
    Zeros :=<font color="red"> fill</font>(<font color="red">Complex</font>(0, 0), 0);
  <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>invariantZerosHessenberg;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE cntrHessenberg<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.cntrHessenberg"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.cntrHessenberg</H2>
<B>calculate the controllable part of a SISO system</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>ss</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.StateSpaceR"
>StateSpaceR</A></TD><TD>ssm1</TD><TD>controllable state space system</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> cntrHessenberg <font color="darkgreen">
  &quot;calculate the controllable part of a SISO system&quot;</font>

    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Vectors.html#Modelica_LinearSystems2.Math.Vectors"
>Modelica_LinearSystems2.Math.Vectors</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;

  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.StateSpaceR"
>Modelica_LinearSystems2.Internal.StateSpaceR</A> ssm1(
    <font color="blue">redeclare </font>Real A[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)],
    <font color="blue">redeclare </font>Real B[<font color="red">size</font>(ss.B, 1),1],
    <font color="blue">redeclare </font>Real C[1,<font color="red">size</font>(ss.C, 2)],
    <font color="blue">redeclare </font>Real D[<font color="red">size</font>(ss.D, 1),<font color="red">size</font>(ss.D, 2)]) <font color="darkgreen">
    &quot;controllable state space system&quot;</font>;

<font color="blue">protected </font>
  Integer nx=<font color="red">size</font>(ss.A, 1);
  Real Ah1[nx,nx];
  Real bh1[nx];
  Real ch1[nx];
  Real u[:] <font color="darkgreen">&quot;householder vector&quot;</font>;
  Real Q[nx,nx];
  Real V[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)];
  Real tau[nx - 1];
  Real Qc[:,:];
  Real svd[:];
  Real normA=<font color="red">Modelica.Math.Matrices.norm</font>(A=ss.A, p=1);
  Integer rankMinSys;
  Boolean isZero=false;

<font color="blue">algorithm </font>
  <font color="blue">if </font><font color="red">size</font>(ss.C, 1) &lt;&gt; 1<font color="blue"> or </font><font color="red">size</font>(ss.B, 2) &lt;&gt; 1<font color="blue"> then</font>
    <font color="red">assert</font>(<font color="red">size</font>(ss.B, 2) == 1,
      &quot;A SISO-system is expected as input\n but the number of inputs is &quot;
       +<font color="red"> String</font>(<font color="red">size</font>(ss.B, 2)) + &quot; instead of 1&quot;);
    <font color="red">assert</font>(<font color="red">size</font>(ss.C, 1) == 1,
      &quot; A SISO-system is expected as input\n but the number of outputs is &quot;
       +<font color="red"> String</font>(<font color="red">size</font>(ss.C, 1)) + &quot; instead of 1&quot;);
  <font color="blue">end if</font>;

  Ah1 := ss.A;
  bh1 := ss.B[:, 1];
  ch1 := ss.C[1, :];

  <font color="blue">if </font><font color="red">Modelica.Math.Vectors.length</font>(bh1) &gt; 0<font color="blue"> then</font>

    <font color="blue">if </font>nx &gt; 1<font color="blue"> then</font>

      <font color="darkgreen">  // transform b-&gt;Qb = {*,0,...,0} and c-&gt;cQ, A-&gt;QAQ</font>
      u :=<font color="red"> Vectors.householderVector</font>(bh1,<font color="red"> cat</font>(
            1,
            {1},
            <font color="red">fill</font>(0, nx - 1)));<font color="darkgreen">  //householder vector to compute a housholder reflector S = I - 2*u*u&#39;/u&#39;*u</font>
      Ah1 :=<font color="red"> Matrices.householderSimilarityTransformation</font>(Ah1, u);
      bh1 :=<font color="red"> Vectors.householderReflexion_e1</font>(bh1, u);
      ch1 :=<font color="red"> Vectors.householderReflexion</font>(ch1, u);

      (Ah1,V,tau) :=<font color="red"> Matrices.toUpperHessenberg</font>(
            Ah1,
            1,
            nx);
      Q :=<font color="red"> Matrices.orthogonalQ</font>(
            V,
            tau,
            1,
            nx);
      ch1 := ch1*Q;

    <font color="blue">end if</font>;

    rankMinSys := 1;
    <font color="blue">while </font>rankMinSys &lt; nx<font color="blue"> and </font><font color="blue">not </font>isZero<font color="blue"> loop</font>
      isZero :=<font color="red"> abs</font>(Ah1[rankMinSys + 1, rankMinSys]) &lt; normA*1e-10;
      rankMinSys := rankMinSys + 1;
    <font color="blue">end while</font>;

    ssm1 :=<font color="red"> Modelica_LinearSystems2.Internal.StateSpaceR</font>(
          A=Ah1,
          B=<font color="red">matrix</font>(bh1),
          C=<font color="red">transpose</font>(<font color="red">matrix</font>(ch1)),
          D=ss.D,
          r=<font color="blue">if </font>isZero<font color="blue"> then </font>rankMinSys - 1<font color="blue"> else </font>rankMinSys);

  <font color="blue">end if</font>;

<font color="darkgreen">//equation</font>

<font color="darkgreen">//algorithm</font>
<font color="blue">end </font>cntrHessenberg;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE transposeStateSpace<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.transposeStateSpace"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.transposeStateSpace</H2>
<B>Return the transposed state space system</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
 
 
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>ss</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>sst</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> transposeStateSpace <font color="darkgreen">
  &quot;Return the transposed state space system&quot;</font>

    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;

  <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> sst=<font color="red">StateSpace</font>(
          A=<font color="red">transpose</font>(ss.A),
          B=<font color="red">transpose</font>(ss.C),
          C=<font color="red">transpose</font>(ss.B),
          D=<font color="red">transpose</font>(ss.D),
          uNames=ss.yNames,
          yNames=ss.uNames);
<font color="blue">algorithm </font>

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>transposeStateSpace;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE reduceRosenbrock<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.reduceRosenbrock"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.reduceRosenbrock</H2>
<B>Algorithm to compress the generalized system matrix [A, B; C, D] to calculate the invariant zeros of a system</B><p>
<P><H3>Information</H3></P>
<PRE></pre><pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, :]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>B[:, :]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>C[:, :]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>D[:, :]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>Ar[:, :]</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>Br[:, :]</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>Cr[:, :]</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>Dr[:, :]</TD><TD>&nbsp;</TD></TR>
<TR><TD>Integer</TD><TD>n</TD><TD>&nbsp;</TD></TR>
<TR><TD>Integer</TD><TD>m</TD><TD>&nbsp;</TD></TR>
<TR><TD>Integer</TD><TD>p</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> reduceRosenbrock <font color="darkgreen">
  &quot;Algorithm to compress the generalized system matrix [A, B; C, D] to calculate the invariant zeros of a system&quot;</font>

    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Vectors.html#Modelica_LinearSystems2.Math.Vectors"
>Modelica_LinearSystems2.Math.Vectors</A>;

    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams.print"
>Modelica.Utilities.Streams.print</A>;

  <font color="blue">input </font>Real A[:,:];
  <font color="blue">input </font>Real B[:,:];
  <font color="blue">input </font>Real C[:,:];
  <font color="blue">input </font>Real D[:,:];

  <font color="blue">output </font>Real Ar[:,:];
  <font color="blue">output </font>Real Br[:,:];
  <font color="blue">output </font>Real Cr[:,:];
  <font color="blue">output </font>Real Dr[:,:];
  <font color="blue">output </font>Integer n;
  <font color="blue">output </font>Integer m;
  <font color="blue">output </font>Integer p;

<font color="blue">protected </font>
  Real A2[:,:];
  Real B2[:,:];
  Real C2[:,:];
  Real CC[:,:];
  Real Co[:,:];
  Real Cu[:,:];
  Real D2[:,:];
  Real DD[:,:];
  Real Mr[:,:];
  Real Vf[:,:];
  Real V[:,:];
  Real V2[:,:];
  Real R[:,:];
  Real tau[:];

  Integer nx=<font color="red">size</font>(A, 1);
  Integer nu=<font color="red">size</font>(B, 2);
  Integer ny=<font color="red">size</font>(C, 1);

  Integer nue;
  Integer delta;
  Integer rho;
  Integer mue;
  Integer sigma;
  Integer j;
  Boolean stop;
  Boolean stop1 <font color="darkgreen">&quot;reduction finished&quot;</font>;
  Boolean stop2 <font color="darkgreen">&quot;system has no zeros&quot;</font>;
  Integer rankR;
  Real normA=<font color="red">Modelica.Math.Matrices.norm</font>(A=A, p=1);
  Real eps=normA*1e-10;

<font color="blue">algorithm </font>
  <font color="blue">if </font>nx &gt; 0<font color="blue"> then</font>

    A2 := A;
    B2 := B;
    C2 := C;
    D2 := D;
    stop := false;
    stop1 := false;
    stop2 := false;
    nue := nx;
    delta := 0;
    mue := ny;
    sigma := ny;
    j := 1;

    <font color="blue">while </font><font color="blue">not </font>stop<font color="blue"> loop</font>
      (V,R,tau,V2) :=<font color="red"> Matrices.QR</font>( D2);

      rankR := 0;
<font color="darkgreen">//  !!!! rank has to be determined. In the case of ill conditioned systems svd should be used</font>
      <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">min</font>(<font color="red">size</font>(R, 1),<font color="red"> size</font>(R, 2))<font color="blue"> loop</font>
        <font color="blue">if </font><font color="red">abs</font>(R[i,<font color="red"> size</font>(R, 2) -<font color="red"> min</font>(<font color="red">size</font>(R, 1),<font color="red"> size</font>(R, 2)) + i]) &gt; eps<font color="blue"> then</font>
          rankR := rankR + 1;
        <font color="blue">end if</font>;
      <font color="blue">end for</font>;

<font color="darkgreen">//rankR:=Modelica.Math.Matrices.rank(R);</font>

      DD := R[1:rankR, :];

      CC :=<font color="red"> transpose</font>(V2)*C2;

      sigma := rankR;
      stop1 :=<font color="red"> size</font>(CC,1) == rankR;

      <font color="blue">if </font><font color="blue">not </font>stop1<font color="blue"> then</font>
        Cu := CC[sigma + 1:<font color="blue">end</font>, :];
        Co := CC[1:sigma, :];

        (V,R,tau,V2) :=<font color="red"> Matrices.QR</font>(<font color="red"> Matrices.fliplr</font>(<font color="red">transpose</font>(Cu)));
         Vf:=<font color="red">Matrices.fliplr</font>(V2);

         rankR := 0;
<font color="darkgreen">//  !!!! rank determination</font>
        <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">min</font>(<font color="red">size</font>(R, 1),<font color="red"> size</font>(R, 2))<font color="blue"> loop</font>
          <font color="blue">if </font><font color="red">abs</font>(R[i,<font color="red"> size</font>(R, 2) -<font color="red"> min</font>(<font color="red">size</font>(R, 1),<font color="red"> size</font>(R, 2)) + i]) &gt; eps<font color="blue"> then</font>
            rankR := rankR + 1;
          <font color="blue">end if</font>;
        <font color="blue">end for</font>;
<font color="darkgreen">//rankR:=Modelica.Math.Matrices.rank(R);</font>

        rho := rankR;
        stop1 := rho == 0;
        stop2 :=<font color="red"> size</font>(Cu,2) == rankR;

        <font color="blue">if </font><font color="blue">not </font>stop1<font color="blue"> and </font><font color="blue">not </font>stop2<font color="blue"> then</font>
          nue :=<font color="red"> size</font>(Cu, 2) - rankR;
          mue := rho + sigma;
          delta := delta + rho;

          <font color="blue">if </font>sigma == 0<font color="blue"> then</font>
            Mr := [<font color="red">transpose</font>(Vf)*A2*Vf,<font color="red">transpose</font>(Vf)*B2];
          <font color="blue">else</font>
            Mr := [<font color="red">transpose</font>(Vf)*A2*Vf,<font color="red">transpose</font>(Vf)*B2; Co*Vf,DD];
          <font color="blue">end if</font>;

          A2 := Mr[1:nue, 1:nue];
          B2 := Mr[1:nue, nue + rho + 1:nue + rho + nu];
          C2 := Mr[nue + 1:nue + mue,1:nue];
          D2 := Mr[nue + 1:nue + mue,nue + rho + 1:nue + rho + nu];

          j := j + 1;
        <font color="blue">end if</font>;
       <font color="darkgreen">//not stop1 or not stop2</font>

      <font color="blue">end if</font>;
      <font color="darkgreen"> //if not stop1</font>

      stop := stop1<font color="blue"> or </font>stop2<font color="blue"> or </font>j&gt;3*nx;

    <font color="blue">end while</font>;

    <font color="blue">if </font>stop1<font color="blue"> then</font>
      Ar := A2;
      Br := B2;
      Cr := C2;
      Dr := D2;
      n := nue;
      p := sigma;
      m := nu;
    <font color="blue">else</font>
      n := 0;
      p := 0;
      m := 0;
      Ar :=<font color="red"> fill</font>(0,0,0);
      Br :=<font color="red"> fill</font>(0,0,0);
      Cr :=<font color="red"> fill</font>(0,0,0);
      Dr :=<font color="red"> fill</font>(0,0,0);
    <font color="blue">end if</font>;

  <font color="blue">else</font>
    n := 0;
    p := 0;
    m := 0;
    A2 := A;
    B2 := B;
    C2 := C;
    D2 := D;
  <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>reduceRosenbrock;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE reducedCtrSystem<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.reducedCtrSystem"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.reducedCtrSystem</H2>
<B>calculate the controllable part of a SISO system</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>ss</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.StateSpaceR"
>StateSpaceR</A></TD><TD>ssm1</TD><TD>controllable state space system</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> reducedCtrSystem <font color="darkgreen">
  &quot;calculate the controllable part of a SISO system&quot;</font>

    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Vectors.html#Modelica_LinearSystems2.Math.Vectors"
>Modelica_LinearSystems2.Math.Vectors</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;

  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.StateSpaceR"
>Modelica_LinearSystems2.Internal.StateSpaceR</A> ssm1(
    <font color="blue">redeclare </font>Real A[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)],
    <font color="blue">redeclare </font>Real B[<font color="red">size</font>(ss.B, 1),1],
    <font color="blue">redeclare </font>Real C[1,<font color="red">size</font>(ss.C, 2)],
    <font color="blue">redeclare </font>Real D[<font color="red">size</font>(ss.D, 1),<font color="red">size</font>(ss.D, 2)]) <font color="darkgreen">
    &quot;controllable state space system&quot;</font>;

<font color="blue">protected </font>
  Integer nx=<font color="red">size</font>(ss.A, 1);
  Real Ah1[nx,<font color="red">size</font>(ss.A, 2)];
  Real bh1[nx];
  Real ch1[nx];
  Real u[:] <font color="darkgreen">&quot;householder vector&quot;</font>;
  Integer ll;
  Integer r=1;
  Real maxa;
  Real normA=<font color="red">Modelica.Math.Matrices.norm</font>(A=ss.A, p=1);

<font color="blue">algorithm </font>
  <font color="blue">if </font><font color="red">size</font>(ss.C, 1) &lt;&gt; 1<font color="blue"> or </font><font color="red">size</font>(ss.B, 2) &lt;&gt; 1<font color="blue"> then</font>
    <font color="red">assert</font>(<font color="red">size</font>(ss.B, 2) == 1,
      &quot;A SISO-system is expected as input\n but the number of inputs is &quot;
       +<font color="red"> String</font>(<font color="red">size</font>(ss.B, 2)) + &quot; instead of 1&quot;);
    <font color="red">assert</font>(<font color="red">size</font>(ss.C, 1) == 1,
      &quot; A SISO-system is expected as input\n but the number of outputs is &quot;
       +<font color="red"> String</font>(<font color="red">size</font>(ss.C, 1)) + &quot; instead of 1&quot;);
  <font color="blue">end if</font>;

  Ah1 := ss.A;
  bh1 := ss.B[:, 1];
  ch1 := ss.C[1, :];

  <font color="blue">if </font><font color="red">Modelica.Math.Vectors.length</font>(bh1) &gt; 0<font color="blue"> then</font>
    r := 1;
    <font color="blue">if </font>nx &gt; 1<font color="blue"> then</font>

      u :=<font color="red"> Vectors.householderVector</font>(bh1,<font color="red"> cat</font>(
            1,
            <font color="red">fill</font>(0, nx - 1),
            {1}));

      Ah1 :=<font color="red"> Matrices.householderSimilarityTransformation</font>(Ah1, u);
      bh1 :=<font color="red"> Vectors.householderReflexion_en</font>(bh1, u);
      ch1 :=<font color="red"> Vectors.householderReflexion</font>(ch1, u);
      bh1[1:nx - 1] :=<font color="red"> fill</font>(0, nx - 1);

      ll := nx;
      maxa :=<font color="red"> max</font>(<font color="red">abs</font>(Ah1[1:ll - 1, ll]));

      <font color="blue">while </font>r &lt;= nx - 1<font color="blue"> and </font>maxa &gt; nx*normA*1e-10<font color="blue"> loop</font>
        u :=<font color="red"> cat</font>(
              1,
              <font color="red">Vectors.householderVector</font>(Ah1[1:ll - 1, ll],<font color="red"> cat</font>(
                1,
                <font color="red">fill</font>(0, ll - 2),
                {1})),
              <font color="red">fill</font>(0, nx - ll + 1));

        Ah1 :=<font color="red"> Matrices.Internal.hohoTrafoLowerHess</font>(
              Ah1,
              u,
              r);

        ch1 :=<font color="red"> Vectors.householderReflexion</font>(ch1, u);
        ll := ll - 1;
        maxa :=<font color="red"> max</font>(<font color="red">abs</font>(Ah1[1:ll - 1, ll]));

        r := r + 1;
      <font color="blue">end while</font>;

    <font color="blue">end if</font>;

    ssm1 :=<font color="red"> Modelica_LinearSystems2.Internal.StateSpaceR</font>(
          A=Ah1,
          B=<font color="red">matrix</font>(bh1),
          C=<font color="red">transpose</font>(<font color="red">matrix</font>(ch1)),
          D=ss.D,
          r=r);
    ssm1.r := r;
  <font color="blue">end if</font>;
<font color="blue">end </font>reducedCtrSystem;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE reducedCtrSystemX<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.reducedCtrSystemX"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.reducedCtrSystemX</H2>
<B>calculate the controllable part of a SISO system</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>ss</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.StateSpaceR"
>StateSpaceR</A></TD><TD>ssm1</TD><TD>controllable state space system</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> reducedCtrSystemX <font color="darkgreen">
  &quot;calculate the controllable part of a SISO system&quot;</font>

    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Vectors.html#Modelica_LinearSystems2.Math.Vectors"
>Modelica_LinearSystems2.Math.Vectors</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;

  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.StateSpaceR"
>Modelica_LinearSystems2.Internal.StateSpaceR</A> ssm1(
    <font color="blue">redeclare </font>Real A[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)],
    <font color="blue">redeclare </font>Real B[<font color="red">size</font>(ss.B, 1),1],
    <font color="blue">redeclare </font>Real C[1,<font color="red">size</font>(ss.C, 2)],
    <font color="blue">redeclare </font>Real D[<font color="red">size</font>(ss.D, 1),<font color="red">size</font>(ss.D, 2)]) <font color="darkgreen">
    &quot;controllable state space system&quot;</font>;

<font color="blue">protected </font>
  Integer nx=<font color="red">size</font>(ss.A, 1);
  Real Ah1[nx,<font color="red">size</font>(ss.A, 2)];
  Real bh1[nx];
  Real ch1[nx];
  Real u[:] <font color="darkgreen">&quot;householder vector&quot;</font>;
  Integer ll;
  Integer r=1;
  Real maxa;
  Real normA=<font color="red">Modelica.Math.Matrices.norm</font>(A=ss.A, p=1);

<font color="blue">algorithm </font>
  <font color="blue">if </font><font color="red">size</font>(ss.C, 1) &lt;&gt; 1<font color="blue"> or </font><font color="red">size</font>(ss.B, 2) &lt;&gt; 1<font color="blue"> then</font>
    <font color="red">assert</font>(<font color="red">size</font>(ss.B, 2) == 1,
      &quot;A SISO-system is expected as input\n but the number of inputs is &quot;
       +<font color="red"> String</font>(<font color="red">size</font>(ss.B, 2)) + &quot; instead of 1&quot;);
    <font color="red">assert</font>(<font color="red">size</font>(ss.C, 1) == 1,
      &quot; A SISO-system is expected as input\n but the number of outputs is &quot;
       +<font color="red"> String</font>(<font color="red">size</font>(ss.C, 1)) + &quot; instead of 1&quot;);
  <font color="blue">end if</font>;

  Ah1 := ss.A;
  bh1 := ss.B[:, 1];
  ch1 := ss.C[1, :];

  <font color="blue">if </font><font color="red">Modelica.Math.Vectors.length</font>(bh1) &gt; 0<font color="blue"> then</font>
    r := 1;
    <font color="blue">if </font>nx &gt; 1<font color="blue"> then</font>

      u :=<font color="red"> Vectors.householderVector</font>(bh1,<font color="red"> cat</font>(
            1,
            <font color="red">fill</font>(0, nx - 1),
            {1}));

      Ah1 :=<font color="red"> Matrices.householderSimilarityTransformation</font>(Ah1, u);
      bh1 :=<font color="red"> Vectors.householderReflexion_en</font>(bh1, u);
      ch1 :=<font color="red"> Vectors.householderReflexion</font>(ch1, u);
      bh1[1:nx - 1] :=<font color="red"> fill</font>(0, nx - 1);

      ll := nx;
      maxa :=<font color="red"> max</font>(<font color="red">abs</font>(Ah1[1:ll - 1, ll]));

      <font color="blue">while </font>r &lt;= nx - 1<font color="blue"> and </font>maxa &gt; nx*normA*1e-5<font color="blue"> loop</font>
        u :=<font color="red"> cat</font>(
              1,
              <font color="red">Vectors.householderVector</font>(Ah1[1:ll - 1, ll],<font color="red"> cat</font>(
                1,
                <font color="red">fill</font>(0, ll - 2),
                {1})),
              <font color="red">fill</font>(0, nx - ll + 1));

        Ah1 :=<font color="red"> Matrices.Internal.hohoTrafoLowerHess</font>(
              Ah1,
              u,
              r);

        ch1 :=<font color="red"> Vectors.householderReflexion</font>(ch1, u);
        ll := ll - 1;
        maxa :=<font color="red"> max</font>(<font color="red">abs</font>(Ah1[1:ll - 1, ll]));

        r := r + 1;
      <font color="blue">end while</font>;

    <font color="blue">end if</font>;

    ssm1 :=<font color="red"> Modelica_LinearSystems2.Internal.StateSpaceR</font>(
          A=Ah1,
          B=<font color="red">matrix</font>(bh1),
          C=<font color="red">transpose</font>(<font color="red">matrix</font>(ch1)),
          D=ss.D,
          r=r);
    ssm1.r := r;
  <font color="blue">end if</font>;
<font color="blue">end </font>reducedCtrSystemX;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE assignPolesMI2<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.StateSpace.Internal.assignPolesMI2"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.StateSpace.Internal"
>Modelica_LinearSystems2.StateSpace.Internal</A>.assignPolesMI2</H2>
<B>Pole assigment design algorithm for multi input systems</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4><font color="#008000">Syntax</font></h4>
<table>
<tr> <td align=right>  (K, S, po, nfp, nap, nup) </td><td align=center> =  </td>  <td> StateSpace.Design.<b>assignPolesMI</b>(ss, gamma, np, alpha, tol)  </td> </tr>
</table>
<h4><font color="#008000">Description</font></h4>
<p>
The purpose of this function is to determine the state feedback matrix <b>K</b> for a
given time invariant multi input state system (<b>A</b>,<b>B</b>) such that the
closed-loop state matrix <b>A</b>-<b>B</b>*<b>K</b> has specified eigenvalues. The
feedback matrix <b>K</b> is calculated by factorization following [1]. The algorithm
modifies the eigenvalues sequentially and also allows partial eigenvalue assignment.<br>
<br>


 At the beginning of the algorithm, the feedback matrix <b>K</b> is set to zero (<b>K</b> = <b>0</b>) and the matrix <b>A</b> is
 reduced to an ordered real Schur form by separating its spectrum in two parts

<blockquote><pre>
              | <b>F</b>1  <b>F</b>3|
 <b>F</b> = <b>Q</b>*<b>A</b>*<b>Q</b>' = |       |
              | <b>0</b>   <b>F</b>2|
 </pre>
</blockquote> in such a way, that <b>F</b>1 contains the eigenvalues that will be
retained and <b>F</b>3 contains the eigenvalues going to be modified. On the suggestion
of [1] the eigenvalues <i>evr</i> to be retained are chosen as
 <blockquote><pre>
  evr = {s in C: Re(s) &lt -alpha, alpha &gt =0}
 </pre> </blockquote>
but other specification are conceivable of course.<br>
<br>

Let
 <blockquote><pre>
  <b>G</b> = [<b>G</b>1;<b>G</b>2] = <b>Q</b>*<b>B</b>
 </pre> </blockquote>
with an appropriate partition according to <b>F</b>2. (<b>F</b>2, <b>G</b>2) has to be
controllable.<br>

If the feedback matrix <b>K</b> is taken in a form <blockquote><pre> <b>K</b> = [0, <b>K</b>2]
</pre></blockquote> the special structure of <b>F</b> and <b>K</b> results in a closed loop state
matrix <blockquote><pre>
          |<b>F</b>1 <b>F</b>3 - <b>G</b>1*<b>K</b>2|
<b>F</b> - <b>G</b>*<b>K</b> = |             |
          |0  <b>F</b>2 - <b>G</b>2*<b>K</b>2|
</pre></blockquote> with only the eigenvalues of <b>F</b>2 are modified. This approach to modify
separated eigenvalues is used to sequentially shift one real eigenvalue ore two
complex conjugated eigenvalues stepwise until all assigned eigenvalues are placed.
Therefore, at each step i always the (two) lower right eingenvalue(s) are modified by an
appropriate feedback matrix <b>K</b>i. The matrix <b>F</b> - <b>G</b>*<b>K</b>i remains in real Schur form. The
assigned eigenvalue(s) is (are) then moved to another diagonal position of the real Schur
form using reordering techniques <b>F</b> &lt -- <b>Q</b>i*<b>F</b>*<b>Q</b>i'  and a new block is transferred to the
lower right diagonal position. The transformations are accumulated in <b>Q</b>i and are also
applicated to the matrices <blockquote><pre> <b>G</b> &lt - <b>Q</b>i*<b>G</b> <b>Q</b> &lt - <b>Q</b>i*<b>Q</b> </pre></blockquote>
The eigenvalue(s) to be assigned at  each step is (are) chosen such that the norm of each <b>K</b>i is minimized [1].
<p>



</p>

<h4><font color="#008000">Example</font></h4>
<blockquote><pre>
   Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
      A=[-1, 1, 1;0, 1, 1;0, 0, 1],
      B=[0; 0; 1],
      C=[0, 1, 0],
      D=[0]);

   Real Q[3,3];

<b>algorithm</b>
  Q := Modelica_LinearSystems2.StateSpace.Analysis.observabilityMatrix(ss);
// Q = [0, 1, 0; 0, 1, 1; 1, 1, 2]
</pre></blockquote>


<h4><font color="#008000">References</font></h4>
<table>
<tr> <td align=right>  [1] </td><td align=center>  Varga A.  </td>  <td> "A Schur method for pole assignment"  </td> <td> IEEE Trans. Autom. Control, Vol. AC-26, pp. 517-519, 1981 </td></tr>
</table>

<pre> </PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>ss</TD><TD>&nbsp;</TD><TD>state space system</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>gamma[:]</TD><TD>fill(Complex(0), size(ss.A, ...</TD><TD>Designed Poles</TD></TR>
<TR><TD>Integer</TD><TD>np</TD><TD>size(gamma, 1)</TD><TD>number of given eigenvalues to assign</TD></TR>
<TR><TD>Boolean</TD><TD>giveEigenvalues</TD><TD>false</TD><TD>Boolean parameter to display the order of the eigenvalues</TD></TR>
<TR><TD>Real</TD><TD>alpha</TD><TD>-1e10</TD><TD>maximum admissible value for real parts(continuous) or for moduli (discrete) of the eigenvalues of A which will not be modified by the eigenvalue assignment algorithm</TD></TR>
<TR><TD>Real</TD><TD>tolerance</TD><TD>Modelica.Math.Matrices.norm(...</TD><TD>The tolerance to be used in determining the controllability of (A,B)</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>K[size(ss.B, 2), size(ss.A, 1)]</TD><TD>State feedback matrix assigning the desired poles</TD></TR>
<TR><TD>Real</TD><TD>S[:, :]</TD><TD>Closed loop System matrix</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>po[size(ss.A, 1)]</TD><TD>poles of the closed loop system</TD></TR>
<TR><TD>Integer</TD><TD>nfp</TD><TD>number of eigenvalues that are not modified with respect to alpha</TD></TR>
<TR><TD>Integer</TD><TD>nap</TD><TD>number of assigned eigenvalues</TD></TR>
<TR><TD>Integer</TD><TD>nup</TD><TD>number of uncontrollable eigenvalues</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>X[size(ss.A, 1), size(ss.A, 1)]</TD><TD>eigenvectors of the closed loop system</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> assignPolesMI2 <font color="darkgreen">
  &quot;Pole assigment design algorithm for multi input systems&quot;</font>

      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
      <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams.print"
>Modelica.Utilities.Streams.print</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
      <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss <font color="darkgreen">&quot;state space system&quot;</font>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> gamma[:]=<font color="red">fill</font>(<font color="red">Complex</font>(0),<font color="red"> size</font>(ss.A,1)) <font color="darkgreen">&quot;Designed Poles&quot;</font>;
  <font color="blue">input </font>Integer np=<font color="red">size</font>(gamma, 1) <font color="darkgreen">&quot;number of given eigenvalues to assign&quot;</font>;
  <font color="blue">input </font>Boolean giveEigenvalues=false <font color="darkgreen">
    &quot;Boolean parameter to display the order of the eigenvalues&quot;</font>;
  <font color="blue">input </font>Real alpha=-1e10 <font color="darkgreen">
    &quot;maximum admissible value for real parts(continuous) or for moduli (discrete) of the eigenvalues of A which will not be modified by the eigenvalue assignment algorithm&quot;</font>;
  <font color="blue">input </font>Real tolerance=<font color="red">Modelica.Math.Matrices.norm</font>(ss.A, 1)*1e-12 <font color="darkgreen">
    &quot;The tolerance to be used in determining the controllability of (A,B)&quot;</font>;
  <font color="blue">output </font>Real K[<font color="red">size</font>(ss.B, 2),<font color="red">size</font>(ss.A, 1)] <font color="darkgreen">
    &quot;State feedback matrix assigning the desired poles&quot;</font>;
  <font color="blue">output </font>Real S[:,:] <font color="darkgreen">&quot;Closed loop System matrix&quot;</font>;
  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> po[<font color="red">size</font>(ss.A, 1)] <font color="darkgreen">&quot;poles of the closed loop system&quot;</font>;
  <font color="blue">output </font>Integer nfp <font color="darkgreen">
    &quot;number of eigenvalues that are not modified with respect to alpha&quot;</font>;
  <font color="blue">output </font>Integer nap <font color="darkgreen">&quot;number of assigned eigenvalues&quot;</font>;
  <font color="blue">output </font>Integer nup <font color="darkgreen">&quot;number of uncontrollable eigenvalues&quot;</font>;
  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> X[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 1)] <font color="darkgreen">
    &quot;eigenvectors of the closed loop system&quot;</font>;

<font color="blue">protected </font>
  Real A_rsf[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 2)];
  Real B_rsf[<font color="red">size</font>(ss.B, 1),<font color="red">size</font>(ss.B, 2)];
  Real Q[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 1)];
  Real Ks1[:,:];
  Real Ks2[:,:];
  Real Q2[:,:];
  Real A_rsf_1[:,:];
  Real Q1[:,:];
  Boolean select[:];
  Boolean rselectA[:];
  Real Z[:,:] <font color="darkgreen">&quot;orthogonal transformation matrix&quot;</font>;
  Real ZT[:,:] <font color="darkgreen">&quot;orthogonal transformation matrix&quot;</font>;
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> pf[:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> gammaReordered[:]=gamma;
  Integer info;
  Real wr[<font color="red">size</font>(gamma, 1)];
  Real wi[<font color="red">size</font>(gamma, 1)];
  Boolean imag=false;
  Integer i;
  Integer ii;
  Integer counter;
  Integer n=<font color="red">size</font>(ss.A, 1);
  Integer ipf;
  Integer nccA <font color="darkgreen">&quot;number of conjugated complex pole pairs of unmodified system&quot;</font>;
  Integer nccg <font color="darkgreen">&quot;number of conjugated complex pole pairs of gamma&quot;</font>;
  Integer ncc;

  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> h;
  Integer h2[2];
  Real alphaReal[<font color="red">size</font>(ss.A, 1)] <font color="darkgreen">&quot;Real part of eigenvalue=alphaReal+i*alphaImag&quot;</font>;
  Real alphaImag[<font color="red">size</font>(ss.A, 1)] <font color="darkgreen">
    &quot;Imaginary part of eigenvalue=(alphaReal+i*alphaImag&quot;</font>;

  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> pi[:]=<font color="red">Complex.eigenValues</font>(ss.A);

  Boolean complex_assignedPoles=false <font color="darkgreen">
    &quot;true if there is at least one conjugated comples pole pair in the set of the assigned poles&quot;</font>;
  Boolean complex_originalPoles=false <font color="darkgreen">
    &quot;true if there is at least one conjugated comples pole pair in the set of unmodified system poles&quot;</font>;
  Boolean consistency;

  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> SS[:,:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> Xj[:,:];

  Integer markA[n]=<font color="red">fill</font>(1,n);
  Integer markg[n]=<font color="red">fill</font>(1,n);

  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> ev[:];

<font color="blue">algorithm </font>
  <font color="blue">if </font>giveEigenvalues<font color="blue"> then</font>
    (,,alphaReal,alphaImag,info) :=
      <font color="red">Modelica_LinearSystems2.Math.Matrices.LAPACK.dgees</font>(ss.A);
    <font color="red">assert</font>(info == 0, &quot;The output info of LAPACK.dgees should be zero, else if\n
     info &lt; 0:  if info = -i, the i-th argument of dgees had an illegal value\n
     info &gt; 0:  if INFO = i, and i is   
               &lt;= N: the QR algorithm failed to compute all the   
                     eigenvalues; elements 1:ILO-1 and i+1:N of WR and WI   
                     contain those eigenvalues which have converged; if   
                     JOBVS = &#39;V&#39;, VS contains the matrix which reduces A   
                     to its partially converged Schur form.\n&quot;);
    <font color="blue">for </font>i<font color="blue"> in </font>1:n<font color="blue"> loop</font>
      po[i].re := alphaReal[i];
      po[i].im := alphaImag[i];
    <font color="blue">end for</font>;
    <font color="red">Complex.Vectors.print</font>(&quot;The eigenvalues of the open loop system are sorted to\n eigenvalues&quot;, pi);
  <font color="blue">else</font>
    <font color="red">assert</font>(<font color="red">size</font>(gamma, 1) &lt;=<font color="red"> size</font>(ss.A, 1), &quot;At most n (order of ss) eigenvalues can be assigned&quot;);

 <font color="darkgreen">/* Extraction of Poles (Variable conversation) and pole sequence check */</font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(gamma, 1)<font color="blue"> loop</font>
    wr[i] := gamma[i].re;
    wi[i] := gamma[i].im;
    <font color="blue">if </font>imag<font color="blue"> then</font>
      <font color="red">assert</font>(wi[i - 1] == -wi[i]<font color="blue"> and </font>wr[i - 1] == wr[i],
        &quot;Poles are in wrong sequence&quot;);
      imag := false;
    <font color="blue">elseif </font>wi[i] &lt;&gt; 0<font color="blue"> then</font>
      imag := true;
    <font color="blue">end if</font>;
  <font color="blue">end for</font>;

  <font color="darkgreen">// put matrix ss.A to real Schur form A &lt;- QAQ&#39; and compute B &lt;- QB</font>
  (A_rsf,Z,alphaReal,alphaImag) :=<font color="red"> Matrices.rsf2</font>(ss.A);
  ZT :=<font color="red"> transpose</font>(Z);

  <font color="darkgreen">// determine number of poles not to be assigned according to alpha</font>
     nfp := 0;
     nccA := 0;
     nccg := 0;
     <font color="blue">for </font>i<font color="blue"> in </font>1:n<font color="blue"> loop</font>
       <font color="blue">if </font>alphaReal[i] &lt; alpha<font color="blue"> then</font>
         nfp := nfp + 1;
         markA[i] := 0;
         markg[i] := 0;
       <font color="blue">end if</font>;
       <font color="blue">if </font><font color="red">abs</font>(alphaImag[i]) &gt; 0<font color="blue"> then</font>
         markA[i] := 2;
         nccA := nccA + 1;
       <font color="blue">end if</font>;
       <font color="blue">if </font><font color="red">abs</font>(gammaReordered[i].im) &gt; 0<font color="blue"> then</font>
         markg[i] := 2;
         nccg := nccg + 1;
       <font color="blue">end if</font>;
     <font color="blue">end for</font>;
     nap := n - nfp;
     nccA :=<font color="red"> div</font>(nccA, 2);
     nccg :=<font color="red"> div</font>(nccg, 2);
     ncc :=<font color="red"> max</font>(nccA, nccg);

   <font color="darkgreen">// reorder real Schur form according to alpha</font>
   (A_rsf,Z,alphaReal,alphaImag) :=<font color="red"> Matrices.Internal.reorderRSF2</font>(
       A_rsf,
       <font color="red">identity</font>(<font color="red">size</font>(A_rsf, 1)),
       alphaReal,
       alphaImag,
       alpha);
   ZT :=<font color="red"> transpose</font>(Z)*ZT;
   B_rsf := ZT*ss.B;

    <font color="red">Modelica_LinearSystems2.Math.Vectors.printVector</font>(alphaReal,6,&quot;alphaReal&quot;);
    <font color="red">Modelica_LinearSystems2.Math.Vectors.printVector</font>(alphaImag,6,&quot;alphaImag&quot;);
   <font color="red">Modelica_LinearSystems2.Math.Complex.Vectors.print</font>(&quot;gammaReordered1&quot;,gammaReordered);

  <font color="darkgreen">// Reorder gammaReordered according to alpha</font>
    ii := 1;
    <font color="blue">for </font>i<font color="blue"> in </font>1:n<font color="blue"> loop</font>
      <font color="blue">if </font>markg[i]==0<font color="blue"> then</font>
        h := gammaReordered[ii];
        gammaReordered[ii] := gammaReordered[i];
        gammaReordered[i] := h;
        ii := ii+1;
      <font color="blue">end if</font>;
    <font color="blue">end for</font>;

   <font color="darkgreen">// check consistency of poles assignment, i.e. complex pole pairs in gammaReordered and alphaReal and alphaImag may not be separated</font>
    consistency:=true;
    i:=1;
    <font color="blue">while </font>i&lt;n<font color="blue"> loop</font>
      <font color="blue">if </font>markA[i]==2<font color="blue"> then</font>
        consistency :=markA[i + 1] == 2<font color="blue"> and </font>((markg[i] == 2<font color="blue"> and </font>markg[i + 1] == 2)<font color="blue">
          or </font>(markg[i] == 1<font color="blue"> and </font>markg[i + 1] == 1));
        i := i+2;
      <font color="blue">elseif </font>markg[i]==2<font color="blue"> then</font>
        consistency :=markg[i + 1] == 2<font color="blue"> and </font>(markA[i] == 1<font color="blue"> and </font>markA[i + 1] == 1);
        i := i+2;
      <font color="blue">else</font>
        i := i+1;
      <font color="blue">end if</font>;
    <font color="blue">end while</font>;
   <font color="red">assert</font>(consistency,&quot;System poles and assigned poles have to be assigned consistently, i.e. complex pole pairs may not be separated&quot;);

  <font color="darkgreen">// main algorithm</font>
  K :=<font color="red"> zeros</font>(<font color="red">size</font>(ss.B, 2),<font color="red"> size</font>(ss.A, 1));
  counter := nfp + 1;
   <font color="blue">while </font>counter&lt;=n<font color="blue"> loop</font>
    <font color="blue">if </font>markA[n + nfp + 1 - counter] == 2<font color="blue"> or </font>markg[n + nfp + 1 - counter] == 2<font color="blue"> then</font>

<font color="darkgreen">//#############################</font>
<font color="red">Modelica_LinearSystems2.Math.Complex.Vectors.print</font>(&quot;g2&quot;,gammaReordered[n + nfp - counter:n + nfp + 1 - counter]);
<font color="red">Modelica_LinearSystems2.Math.Vectors.printVector</font>(alphaReal[n + nfp - counter:n + nfp + 1 - counter],6,&quot;ar2&quot;);
ev:=<font color="red">Modelica_LinearSystems2.Math.Complex.eigenValues</font>( A_rsf[n - 1:n, n - 1:n]);
<font color="red">Modelica_LinearSystems2.Math.Complex.Vectors.print</font>(&quot;ev2&quot;,ev);
<font color="darkgreen">//#############################</font>

      Ks2 :=<font color="red"> StateSpace.Internal.assignOneOrTwoPoles</font>(
        A_rsf[n - 1:n, n - 1:n],
        <font color="red">matrix</font>(B_rsf[n - 1:n, :]),
        gammaReordered[n + nfp - counter:n + nfp +
        1 - counter],
        tolerance);
      K := K + [<font color="red">zeros</font>(<font color="red">size</font>(Ks2, 1),<font color="red"> size</font>(K, 2) - 2),Ks2]*ZT;
      A_rsf := A_rsf - B_rsf*[<font color="red">zeros</font>(<font color="red">size</font>(Ks2, 1),<font color="red"> size</font>(K, 2) - 2),Ks2];
      select :=<font color="red"> fill</font>(false, n - counter + 1);
      select[n - counter:n - counter + 1] := {true,true};

      (A_rsf[counter:n, counter:n],Q2) :=<font color="red"> Matrices.LAPACK.dtrsen</font>(
        &quot;E&quot;,
        &quot;V&quot;,
        select,
        A_rsf[counter:n, counter:n],
        <font color="red">identity</font>(n - counter + 1));<font color="darkgreen">  //The Schur vector matrix is identity, since A_rsf already has Schur form</font>

      A_rsf[1:counter - 1, counter:n] := A_rsf[1:counter - 1, counter:n]*Q2;
      B_rsf[counter:n, :] :=<font color="red"> transpose</font>(Q2)*B_rsf[counter:n, :];
      ZT[counter:n, :] :=<font color="red"> transpose</font>(Q2)*ZT[counter:n, :];
<font color="darkgreen">//       h2 := markA[counter:counter + 1];</font>
<font color="darkgreen">//       markA[counter:counter + 1] := markA[n - 1:n];</font>
<font color="darkgreen">//       markA[n - 1:n] := h2;</font>
<font color="darkgreen">//       h2 := markg[counter:counter + 1];</font>
<font color="darkgreen">//       markg[counter:counter + 1] := markg[n - 1:n];</font>
<font color="darkgreen">//       markg[n - 1:n] := h2;</font>
<font color="darkgreen">//       h := gammaReordered[n - 1];</font>
<font color="darkgreen">//       gammaReordered[n - 1] := gammaReordered[counter];</font>
<font color="darkgreen">//       gammaReordered[counter] := gammaReordered[n - 1];</font>
<font color="darkgreen">//       h := gammaReordered[n];</font>
<font color="darkgreen">//       gammaReordered[n] := gammaReordered[counter + 1];</font>
<font color="darkgreen">//       gammaReordered[counter + 1] := gammaReordered[n];</font>
      counter := counter + 2;
    <font color="blue">else</font>
<font color="darkgreen">//#############################</font>
<font color="red">print</font>(&quot;g1 = &quot;+<font color="red">String</font>(gammaReordered[n + nfp + 1 - counter]));
<font color="red">print</font>(&quot;ar1 = &quot;+<font color="red">String</font>(alphaReal[n + nfp + 1 - counter]));
<font color="red">print</font>(&quot;ev1 = &quot;+<font color="red">String</font>(A_rsf[n,n])+&quot;\n&quot;);
<font color="darkgreen">//#############################</font>

      Ks1 :=<font color="red"> StateSpace.Internal.assignOneOrTwoPoles</font>(
        <font color="red">matrix</font>(A_rsf[n, n]),
        <font color="red">transpose</font>(<font color="red">matrix</font>(B_rsf[n, :])),
        {gammaReordered[n + nfp + 1 - counter]},
        tolerance);

      K := K + [<font color="red">zeros</font>(<font color="red">size</font>(Ks1, 1),<font color="red"> size</font>(K, 2) - 1),Ks1]*ZT;
      A_rsf := A_rsf - B_rsf*[<font color="red">zeros</font>(<font color="red">size</font>(Ks1, 1),<font color="red"> size</font>(K, 2) - 1),Ks1];
      select :=<font color="red"> fill</font>(false, n - counter + 1);
      select[n - counter + 1] := true;

      (A_rsf[counter:n, counter:n],Q1) :=<font color="red"> Matrices.LAPACK.dtrsen</font>(
        &quot;E&quot;,
        &quot;V&quot;,
        select,
        A_rsf[counter:n, counter:n],
        <font color="red">identity</font>(n - counter + 1));<font color="darkgreen"> //The Schur vector matrix is identity, since A_rsf already has Schur form</font>

      A_rsf[1:counter - 1, counter:n] := A_rsf[1:counter - 1, counter:n]*Q1;
      B_rsf[counter:n, :] :=<font color="red"> transpose</font>(Q1)*B_rsf[counter:n, :];
      ZT[counter:n, :] :=<font color="red"> transpose</font>(Q1)*ZT[counter:n, :];
<font color="darkgreen">//       h2[1] := markA[counter];</font>
<font color="darkgreen">//       markA[counter] := markA[n];</font>
<font color="darkgreen">//       markA[n] := h2[1];</font>
<font color="darkgreen">//       h2[1] := markg[counter];</font>
<font color="darkgreen">//       markg[counter] := markg[n];</font>
<font color="darkgreen">//       markg[n] := h2[1];</font>
<font color="darkgreen">//       h := gammaReordered[n];</font>
<font color="darkgreen">//       gammaReordered[n] := gammaReordered[counter];</font>
<font color="darkgreen">//       gammaReordered[counter] := gammaReordered[n];</font>
      counter := counter + 1;
    <font color="blue">end if</font>;

    <font color="blue">end while</font>;

  S := ss.A - ss.B*K;
  po :=<font color="red"> Complex.eigenValues</font>(S);
   X :=<font color="red"> Complex.eigenVectors</font>(S);

<font color="darkgreen">//    X := fill(Complex(0),n,n);</font>
<font color="darkgreen">//    for i in 1:n loop</font>
<font color="darkgreen">//      SS:=Complex(1)*S;</font>
<font color="darkgreen">//      for ii in 1:n loop</font>
<font color="darkgreen">//        SS[ii,ii] := SS[ii,ii]-po[i];</font>
<font color="darkgreen">//      end for;</font>
<font color="darkgreen">//      Xj := Modelica_LinearSystems2.WorkInProgress.Math.Matrices.C_nullspace(</font>
<font color="darkgreen">//                                 SS);</font>
<font color="darkgreen">//      // Matrices.printMatrix(Complex.real(Xj),6,&quot;ReXj&quot;);</font>
<font color="darkgreen">//      // Matrices.printMatrix(Complex.imag(Xj),6,&quot;ImXj&quot;);</font>
<font color="darkgreen">//      for ii in 1:n loop</font>
<font color="darkgreen">//        X[ii,i] := Xj[ii,1];</font>
<font color="darkgreen">//      end for;</font>
<font color="darkgreen">//    end for;</font>

<font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>assignPolesMI2;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Internal<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.ZerosAndPoles.Internal"></A><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>.Internal</H2>
<B>Internal library of record Filter (should not be directly used by user)</B>
<P>
<P><H3>Information</H3></P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons_Library.html#Modelica.Icons.Library"
>Modelica.Icons.Library</A> (Icon for library).
<P><H3>Package Content</H3><p>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 >
<TR><TH >Name</TH><TH>Description</TH></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.ZerosAndPoles.Internal.ZerosAndPolesS.png" ALT="Modelica_LinearSystems2.ZerosAndPoles.Internal.ZerosAndPoles" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal.ZerosAndPoles"
>ZerosAndPoles</A>
</TD><TD>Continuous zeros and poles description of a single input, single output system (data + operations)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.ZerosAndPoles.Internal.filterS.png" ALT="Modelica_LinearSystems2.ZerosAndPoles.Internal.filter" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal.filter"
>filter</A>
</TD><TD>Generate the data record of a ZerosAndPoles transfer function from a filter description</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.ZerosAndPoles.Internal.filterS.png" ALT="Modelica_LinearSystems2.ZerosAndPoles.Internal.findMatrixName" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal.findMatrixName"
>findMatrixName</A>
</TD><TD>&nbsp;</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.ZerosAndPoles.Internal.filterS.png" ALT="Modelica_LinearSystems2.ZerosAndPoles.Internal.fromFile_pc" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal.fromFile_pc"
>fromFile_pc</A>
</TD><TD>Generate a zeros and poles data record by reading the polynomial coefficients from a file (default file name is pc.mat)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.ZerosAndPoles.Internal.filterS.png" ALT="Modelica_LinearSystems2.ZerosAndPoles.Internal.fromFile_zp" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal.fromFile_zp"
>fromFile_zp</A>
</TD><TD>Generate a zeros and poles data record by reading poles and zeros from a file (default file name is zp.mat)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.ZerosAndPoles.Internal.filterS.png" ALT="Modelica_LinearSystems2.ZerosAndPoles.Internal.checkRepresentation" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal.checkRepresentation"
>checkRepresentation</A>
</TD><TD>checks whether the system on file is represented by zeros and poles (z, p) or first and second order polynomials (n1, n2, d1, d2)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.ZerosAndPoles.Internal.filterS.png" ALT="Modelica_LinearSystems2.ZerosAndPoles.Internal.sameVectorElements" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal.sameVectorElements"
>sameVectorElements</A>
</TD><TD>Determine identical elements of a vector</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.ZerosAndPoles.Internal.filterS.png" ALT="Modelica_LinearSystems2.ZerosAndPoles.Internal.fromRealAndImag" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal.fromRealAndImag"
>fromRealAndImag</A>
</TD><TD>Generate a complex vector from a real part vector and imaginary part vector </TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.ZerosAndPoles.Internal.filterS.png" ALT="Modelica_LinearSystems2.ZerosAndPoles.Internal.sameMatrixRows" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal.sameMatrixRows"
>sameMatrixRows</A>
</TD><TD>Determine identical rows of a [:,2] matrix</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.ZerosAndPoles.Internal.filterS.png" ALT="Modelica_LinearSystems2.ZerosAndPoles.Internal.firstOrderToString" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal.firstOrderToString"
>firstOrderToString</A>
</TD><TD>Transform vector of coefficients of normalized first order polynomials to a string representation</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.ZerosAndPoles.Internal.filterS.png" ALT="Modelica_LinearSystems2.ZerosAndPoles.Internal.secondOrderToString" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal.secondOrderToString"
>secondOrderToString</A>
</TD><TD>Transform vector of coefficients of normalized second order polynomials to a string representation</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.ZerosAndPoles.Internal.filterS.png" ALT="Modelica_LinearSystems2.ZerosAndPoles.Internal.normalizationFactor" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal.normalizationFactor"
>normalizationFactor</A>
</TD><TD>Compute correction factor of low pass filter such that amplitude at cut-off frequency is 1/sqrt(2) (= 3db)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.ZerosAndPoles.Internal.filterS.png" ALT="Modelica_LinearSystems2.ZerosAndPoles.Internal.BesselCoefficients" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal.BesselCoefficients"
>BesselCoefficients</A>
</TD><TD>Return coefficients of normalized low pass Bessel filter (= gain at cut-off frequency 1 rad/s is decreased 3dB</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.ZerosAndPoles.Internal.filterS.png" ALT="Modelica_LinearSystems2.ZerosAndPoles.Internal.'p+a'" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal.'p+a'"
>'p+a'</A>
</TD><TD>&nbsp;</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.ZerosAndPoles.Internal.filterS.png" ALT="Modelica_LinearSystems2.ZerosAndPoles.Internal.'p^2+k[1]*p+k[2]'" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal.'p^2+k[1]*p+k[2]'"
>'p^2+k[1]*p+k[2]'</A>
</TD><TD>&nbsp;</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.ZerosAndPoles.Internal.filterS.png" ALT="Modelica_LinearSystems2.ZerosAndPoles.Internal.roots" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal.roots"
>roots</A>
</TD><TD>Determine zeros of factorized polynomial</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.ZerosAndPoles.Internal.filterS.png" ALT="Modelica_LinearSystems2.ZerosAndPoles.Internal.frequencyRange" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal.frequencyRange"
>frequencyRange</A>
</TD><TD>Determine min. and max. resonance frequencies</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.ZerosAndPoles.Internal.filterS.png" ALT="Modelica_LinearSystems2.ZerosAndPoles.Internal.frequencyRangeBode" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal.frequencyRangeBode"
>frequencyRangeBode</A>
</TD><TD>Determine min. and max. frequencies for Bode plot</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.ZerosAndPoles.Internal.filterS.png" ALT="Modelica_LinearSystems2.ZerosAndPoles.Internal.filterToNormalized" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal.filterToNormalized"
>filterToNormalized</A>
</TD><TD>Given [p^2,p] and [p] coefficients, transform to normalized form with highest power of p equal 1</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.ZerosAndPoles.Internal.filterS.png" ALT="Modelica_LinearSystems2.ZerosAndPoles.Internal.numberOfRealZeros" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal.numberOfRealZeros"
>numberOfRealZeros</A>
</TD><TD>Calculate number of real zeros</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.ZerosAndPoles.Internal.filterS.png" ALT="Modelica_LinearSystems2.ZerosAndPoles.Internal.numberOfRealZeros2" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal.numberOfRealZeros2"
>numberOfRealZeros2</A>
</TD><TD>Calculate number of real zeros</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.ZerosAndPoles.Internal.filterS.png" ALT="Modelica_LinearSystems2.ZerosAndPoles.Internal.numberOfRealPoles" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal.numberOfRealPoles"
>numberOfRealPoles</A>
</TD><TD>Calculate number of real poles</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.ZerosAndPoles.Internal.filterS.png" ALT="Modelica_LinearSystems2.ZerosAndPoles.Internal.isRoot" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal.isRoot"
>isRoot</A>
</TD><TD>check if frequency is an element of the complex vector zeros</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.ZerosAndPoles.Internal.filterS.png" ALT="Modelica_LinearSystems2.ZerosAndPoles.Internal.numberOfRealZerosAndPoles_zp" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal.numberOfRealZerosAndPoles_zp"
>numberOfRealZerosAndPoles_zp</A>
</TD><TD>Get the number of first oder polynomials (n1, d1) and second order polynomials (n2, d2) of zeros and poles from zeros and poles written in a MAT-file</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.ZerosAndPoles.Internal.filterS.png" ALT="Modelica_LinearSystems2.ZerosAndPoles.Internal.numberOfRealZerosAndPoles_pc" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal.numberOfRealZerosAndPoles_pc"
>numberOfRealZerosAndPoles_pc</A>
</TD><TD>Generate a zeros and poles data record by reading the polynomial coefficients from a file (default file name is zp.mat)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.ZerosAndPoles.Internal.filterS.png" ALT="Modelica_LinearSystems2.ZerosAndPoles.Internal.isControllableAndObservableSISO" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal.isControllableAndObservableSISO"
>isControllableAndObservableSISO</A>
</TD><TD>To check whether a SISO system is controllable and observable</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE ZerosAndPoles<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.ZerosAndPoles.Internal.ZerosAndPolesI.png" ALT="Modelica_LinearSystems2.ZerosAndPoles.Internal.ZerosAndPoles" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.ZerosAndPoles.Internal.ZerosAndPoles"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal"
>Modelica_LinearSystems2.ZerosAndPoles.Internal</A>.ZerosAndPoles</H2>
<B>Continuous zeros and poles description of a single input, single output system (data + operations)</B><p>
<P><H3>Information</H3></P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Record"
>Modelica.Icons.Record</A> (Icon for a record).
<P><H3>Parameters</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR bgcolor="#e0e0e0"><TD colspan=4>y = k*(product(p+n1[i]) * product(p^2+n2[i,1]*p+n2[i,2])) / (product(p+d1[i])*product(p^2+d2[i,1]*p+d2[i,2])) *u</TD></TR>
<TR><TD>Real</TD><TD>k</TD><TD>1.0</TD><TD>Multiplicative factor of transfer function</TD></TR>
<TR><TD>Real</TD><TD>n1[:]</TD><TD>&nbsp;</TD><TD>[p^0] coefficients of 1st order numerator polynomials</TD></TR>
<TR><TD>Real</TD><TD>n2[:, 2]</TD><TD>&nbsp;</TD><TD>[p,p^0] coefficients of 2nd order numerator polynomials</TD></TR>
<TR><TD>Real</TD><TD>d1[:]</TD><TD>&nbsp;</TD><TD>[p^0] coefficients of 1st order denominator polynomials</TD></TR>
<TR><TD>Real</TD><TD>d2[:, 2]</TD><TD>&nbsp;</TD><TD>[p,p^0] coefficients of 2nd order denominator polynomials</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">record</font> ZerosAndPoles <font color="darkgreen">
  &quot;Continuous zeros and poles description of a single input, single output system (data + operations)&quot;</font>
  <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Record"
>Modelica.Icons.Record</A>;

  Real k=1.0 <font color="darkgreen">&quot;Multiplicative factor of transfer function&quot;</font>;
  Real n1[:] <font color="darkgreen">&quot;[p^0] coefficients of 1st order numerator polynomials&quot;</font>;
  Real n2[:,2] <font color="darkgreen">&quot;[p,p^0] coefficients of 2nd order numerator polynomials&quot;</font>;
  Real d1[:] <font color="darkgreen">&quot;[p^0] coefficients of 1st order denominator polynomials&quot;</font>;
  Real d2[:,2] <font color="darkgreen">&quot;[p,p^0] coefficients of 2nd order denominator polynomials&quot;</font>;

<font color="blue">end </font>ZerosAndPoles;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE filter<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.ZerosAndPoles.Internal.filter"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal"
>Modelica_LinearSystems2.ZerosAndPoles.Internal</A>.filter</H2>
<B>Generate the data record of a ZerosAndPoles transfer function from a filter description</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4><font color="#008000">Syntax</font></h4>
<table>
<tr> <td align=right> filterFunction </td><td align=center> =  </td>  <td> Modelica_LinearSystems2.ZerosAndPoles.Design.<b>filter</b>(analogFilter, filterType, order, f_cut, gain, A_ripple, normalized)  </td> </tr>
</table>
<h4><font color="#008000">Description</font></h4>
<p>
This function constructs a ZerosAndPoles transfer function
description of low and high pass filters.
Typical frequency responses for the 4 supported low pass filter types
are shown in the next figure (this figure was generated with function
<a href="Modelica://Modelica_LinearSystems2.ZerosAndPoles.Examples.bodePlot_filter2">ZerosAndPoles.Examples.bodePlot_filter2</a>):
</p>
<p align="center">
<img src="H:/mb/Eurosyslib/WP6/Modelica_LinearSystems2/Extras/Images/LowPassOrder4Filters.png">
</p>
<p>
The step responses of the same low pass filters are shown in the next figure,
starting from a steady state initial filter with initial input = 0.2:
</p>
<p align="center">
<img src="H:/mb/Eurosyslib/WP6/Modelica_LinearSystems2/Extras/Images/LowPassOrder4FiltersStepResponse.png">
</p>
<p>
Obviously, the frequency responses give a somewhat wrong impression
of the filter characteristics: Although Butterworth and Chebyshev
filters have a significantly steeper magnitude as the
CriticalDamping and Bessel filters, the step responses of
the latter ones are much better. This means for example, that
a CriticalDamping or a Bessel filter should be selected,
if a filter is mainly used to make a non-linear inverse model
realizable.
</p>

<p>
Typical frequency responses for the 4 supported high pass filter types
are shown in the next figure:
</p>
<p align="center">
<img src="H:/mb/Eurosyslib/WP6/Modelica_LinearSystems2/Extras/Images/HighPassOrder4Filters.png">
</p>
<p>
The corresponding step responses of these high pass filters are
shown in the next figure:
</p>
<p align="center">
<img src="H:/mb/Eurosyslib/WP6/Modelica_LinearSystems2/Extras/Images/HighPassOrder4FiltersStepResponse.png">
</p>
<p>
All filters are available in <b>normalized</b> (default) and non-normalized form.
In the normalized form, the amplitude of the filter transfer function
at the cutoff frequency is 1/sqrt(2) (= 3 dB). Note, when comparing the filters
of this function with other software systems, the setting of "normalized"
has to be selected appropriately. For example, the signal processing
toolbox of Matlab provides the filters in non-normalized form and
therefore a comparision makes only sense, if normalized = <b>false</b>
is set.


</p>

<h4><font color="#008000">Example</font></h4>
<blockquote><pre>
   Types.AnalogFilter analogFilter=Types.AnalogFilter.CriticalDamping;
   Integer order=2; 
   Modelica.SIunits.Frequency f_cut=10;
   
   ZerosAndPoles zp_filter;

<b>algorithm</b>
    zp_filter=Modelica_LinearSystems2.ZerosAndPoles.Design.filter(
      order=order,
      f_cut=f_cut,
      analogFilter=analogFilter);

// zp_filter = 9530.93/( (p + 97.6265)^2 )
</pre></blockquote>


<h4><font color="#008000">References</font></h4>
<table>
<tr> <td align=right>  [1] </td><td align=center>  Tietze U., and Schenk Ch.  </td>  <td> "Halbleiter-Schaltungstechnik"  </td> <td> Springer Verlag, 12. Auflage, pp. 815-852, 2002. </td></tr>
</table>

<pre> </PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.AnalogFilter"
>AnalogFilter</A></TD><TD>analogFilter</TD><TD>Types.AnalogFilter.CriticalD...</TD><TD>Analog filter characteristics (CriticalDamping/Bessel/Butterworth/Chebyshev)</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.FilterType"
>FilterType</A></TD><TD>filterType</TD><TD>Types.FilterType.LowPass</TD><TD>Type of filter (LowPass/HighPass)</TD></TR>
<TR><TD>Integer</TD><TD>order</TD><TD>2</TD><TD>Order of filter</TD></TR>
<TR><TD><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Frequency</A></TD><TD>f_cut</TD><TD>1/(2*Modelica.Constants.pi)</TD><TD>Cut-off frequency (default is w_cut = 1 rad/s) [Hz]</TD></TR>
<TR><TD>Real</TD><TD>gain</TD><TD>1.0</TD><TD>Gain (= amplitude of frequency response at zero frequency)</TD></TR>
<TR><TD>Real</TD><TD>A_ripple</TD><TD>0.5</TD><TD>Pass band ripple for Chebyshev filter (otherwise not used) [dB]</TD></TR>
<TR><TD>Boolean</TD><TD>normalized</TD><TD>true</TD><TD>= true, if amplitude of low pass filter at f_cut where the magnitude of the filter sagged for 3dB, otherwise unmodified filter</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal.ZerosAndPoles"
>ZerosAndPoles</A></TD><TD>filter</TD><TD>Filter transfer function</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> filter <font color="darkgreen">
  &quot;Generate the data record of a ZerosAndPoles transfer function from a filter description&quot;</font>

    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams"
>Modelica.Utilities.Streams</A>;
    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams.print"
>Modelica.Utilities.Streams.print</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types"
>Modelica_LinearSystems2.Types</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;

    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal"
>Modelica_LinearSystems2.ZerosAndPoles.Internal</A>;
    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Math.html#Modelica.Math"
>Modelica.Math</A>.*;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math"
>Modelica_LinearSystems2.Math</A>.*;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.AnalogFilter"
>Modelica_LinearSystems2.Types.AnalogFilter</A> analogFilter=Types.AnalogFilter.CriticalDamping <font color="darkgreen">
    &quot;Analog filter characteristics (CriticalDamping/Bessel/Butterworth/Chebyshev)&quot;</font>;
  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Types.html#Modelica_LinearSystems2.Types.FilterType"
>Modelica_LinearSystems2.Types.FilterType</A> filterType=Types.FilterType.LowPass <font color="darkgreen">
    &quot;Type of filter (LowPass/HighPass)&quot;</font>;
  <font color="blue">input </font>Integer order(min=1) = 2 <font color="darkgreen">&quot;Order of filter&quot;</font>;
  <font color="blue">input </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.Frequency"
>Modelica.SIunits.Frequency</A> f_cut=1/(2*Modelica.Constants.pi) <font color="darkgreen">
    &quot;Cut-off frequency (default is w_cut = 1 rad/s)&quot;</font>;
  <font color="blue">input </font>Real gain=1.0 <font color="darkgreen">
    &quot;Gain (= amplitude of frequency response at zero frequency)&quot;</font>;
  <font color="blue">input </font>Real A_ripple(unit=&quot;dB&quot;) = 0.5 <font color="darkgreen">
    &quot;Pass band ripple for Chebyshev filter (otherwise not used)&quot;</font>;
  <font color="blue">input </font>Boolean normalized=true <font color="darkgreen">
    &quot;= true, if amplitude of low pass filter at f_cut where the magnitude of the filter sagged for 3dB, otherwise unmodified filter&quot;</font>;
  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal.ZerosAndPoles"
>Internal.ZerosAndPoles</A> filter(
    <font color="blue">redeclare </font>Real n1[<font color="blue">if </font>filterType == Types.FilterType.LowPass<font color="blue"> then </font>0<font color="blue"> else </font>(
      <font color="blue">if </font>analogFilter == Types.AnalogFilter.CriticalDamping<font color="blue"> then </font>order<font color="blue"> else </font>
      <font color="red">mod</font>(order, 2))],
    <font color="blue">redeclare </font>Real n2[<font color="blue">if </font>filterType == Types.FilterType.LowPass<font color="blue"> then </font>0<font color="blue"> else </font>(
      <font color="blue">if </font>analogFilter == Types.AnalogFilter.CriticalDamping<font color="blue"> then </font>0<font color="blue"> else </font>
      <font color="red">integer</font>((order + 1)/2)),2],
    <font color="blue">redeclare </font>Real d1[<font color="blue">if </font>analogFilter == Types.AnalogFilter.CriticalDamping<font color="blue"> then </font>
            order<font color="blue"> else </font><font color="red">mod</font>(order, 2)],
    <font color="blue">redeclare </font>Real d2[<font color="blue">if </font>analogFilter == Types.AnalogFilter.CriticalDamping<font color="blue"> then </font>
            0<font color="blue"> else </font><font color="red">integer</font>(order/2),2]) <font color="darkgreen">&quot;Filter transfer function&quot;</font>;

<font color="blue">protected </font>
  Integer n_num1=<font color="red">size</font>(filter.n1, 1);
  Integer n_num2=<font color="red">size</font>(filter.n2, 1);
  Integer n_den1=<font color="red">size</font>(filter.d1, 1);
  Integer n_den2=<font color="red">size</font>(filter.d2, 1);
  Integer n_num=n_num1 + 2*n_num2;
  Integer n_den=n_den1 + 2*n_den2;
  Real pi=Modelica.Constants.pi;
  Boolean evenOrder=<font color="red">mod</font>(order, 2) == 0 <font color="darkgreen">
    &quot;= true, if even filter order (otherwise uneven)&quot;</font>;
  <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>Modelica.SIunits.AngularVelocity</A> w_cut=2*pi*f_cut <font color="darkgreen">&quot;Cut-off angular frequency&quot;</font>;
  Real w_cut2 <font color="darkgreen">&quot;= w_cut*w_cut&quot;</font>;
  Real alpha=1.0 <font color="darkgreen">&quot;Frequency correction factor&quot;</font>;
  Real alpha2 <font color="darkgreen">&quot;= alpha*alpha&quot;</font>;

  Real alphax;

  Real poleReal <font color="darkgreen">&quot;Real part of pole&quot;</font>;
  Real poleImag <font color="darkgreen">&quot;Imaginary part of pole&quot;</font>;
  Real epsilon <font color="darkgreen">&quot;Ripple size&quot;</font>;
  Real fac <font color="darkgreen">&quot;arsinh(epsilon)&quot;</font>;
  Real A2 <font color="darkgreen">&quot;poleReal^2 + poleImag^2&quot;</font>;
  Real A <font color="darkgreen">&quot;Amplitude at w_cut&quot;</font>;
  Real num1[n_num1] <font color="darkgreen">
    &quot;[p] coefficients of numerator first order polynomials (a*p + 1)&quot;</font>;
  Real num2[n_num2,2] <font color="darkgreen">
    &quot;[p^2, p] coefficients of numerator second order polynomials (b*p^2 + a*p + 1I)&quot;</font>;
  Real den1[n_den1] <font color="darkgreen">
    &quot;[p] coefficients of denominator first order polynomials (a*p + 1)&quot;</font>;
  Real den2[n_den2,2] <font color="darkgreen">
    &quot;[p^2, p] coefficients of denominator second order polynomials (b*p^2 + a*p + 1I)&quot;</font>;
  Real aux;
  Real k;
<font color="blue">algorithm </font>
  <font color="darkgreen">// Set properties that are common for all filters</font>
  filter.k := gain;

  <font color="darkgreen">/* Compute filter coefficients of prototype low pass filter. If another filter
     characteristics is desired (e.g. high pass filter), it is derived
     from the low pass filter coefficients below
  */</font>
  <font color="blue">if </font>analogFilter == Types.AnalogFilter.CriticalDamping<font color="blue"> then</font>
    <font color="blue">if </font>normalized<font color="blue"> then</font>
      alpha :=<font color="red"> sqrt</font>(2^(1/order) - 1);
<font color="darkgreen">//alpha := sqrt(10^(3/10/order)-1)</font>
    <font color="blue">else</font>
      alpha := 1;
    <font color="blue">end if</font>;
    <font color="blue">for </font>i<font color="blue"> in </font>1:n_den1<font color="blue"> loop</font>
      den1[i] := alpha;
    <font color="blue">end for</font>;

  <font color="blue">elseif </font>analogFilter == Types.AnalogFilter.Bessel<font color="blue"> then</font>
    (den1,den2,alpha) :=<font color="red"> Internal.BesselCoefficients</font>(order);
    <font color="blue">if </font><font color="blue">not </font>normalized<font color="blue"> then</font>
      alpha2 := alpha*alpha;
      <font color="blue">for </font>i<font color="blue"> in </font>1:n_den2<font color="blue"> loop</font>
        den2[i, 1] := den2[i, 1]*alpha2;
        den2[i, 2] := den2[i, 2]*alpha;
      <font color="blue">end for</font>;
      <font color="blue">if </font><font color="blue">not </font>evenOrder<font color="blue"> then</font>
        den1[1] := den1[1]*alpha;
      <font color="blue">end if</font>;
    <font color="blue">end if</font>;

  <font color="blue">elseif </font>analogFilter == Types.AnalogFilter.Butterworth<font color="blue"> then</font>
    <font color="darkgreen"> // Original filter is already normalized</font>
    <font color="blue">for </font>i<font color="blue"> in </font>1:n_den2<font color="blue"> loop</font>
      den2[i, 1] := 1.0;
      den2[i, 2] := -2*<font color="red">cos</font>(pi*(0.5 + (i - 0.5)/order));
    <font color="blue">end for</font>;
    <font color="blue">if </font><font color="blue">not </font>evenOrder<font color="blue"> then</font>
      den1[1] := 1.0;
    <font color="blue">end if</font>;

  <font color="blue">elseif </font>analogFilter == Types.AnalogFilter.Chebyshev<font color="blue"> then</font>
    epsilon :=<font color="red"> sqrt</font>(10^(A_ripple/10) - 1);
    fac :=<font color="red"> asinh</font>(1/epsilon)/order;

    <font color="blue">for </font>i<font color="blue"> in </font>1:n_den2<font color="blue"> loop</font>
      <font color="darkgreen"> // poles of prototype lowpass</font>
      poleReal :=<font color="red"> cos</font>(pi/2 + pi*(2*i - 1)/(2*order))*<font color="red">sinh</font>(fac);
      poleImag := -<font color="red">sin</font>(pi/2 + pi*(2*i - 1)/(2*order))*<font color="red">cosh</font>(fac);

      <font color="darkgreen"> // second order filter coefficients</font>
      A2 := poleReal^2 + poleImag^2;
      den2[i, 1] := 1/A2;
      den2[i, 2] := -2*poleReal/A2;
    <font color="blue">end for</font>;
    <font color="blue">if </font><font color="blue">not </font>evenOrder<font color="blue"> then</font>
      den1[1] := -1.0/(<font color="red">cos</font>(pi/2 + pi*(2*n_den - 1)/(2*order))*<font color="red">sinh</font>(fac));
    <font color="blue">end if</font>;

    <font color="darkgreen"> /* Transformation of filter transfer function with &quot;new(p) = alpha*p&quot;
        in order that the filter transfer function has an amplitude of
        1/sqrt(2) at the cutoff frequency
     */</font>
    <font color="blue">if </font>normalized<font color="blue"> then</font>
      alpha :=<font color="red"> Internal.normalizationFactor</font>(den1, den2);
      alpha2 := alpha*alpha;
      <font color="blue">for </font>i<font color="blue"> in </font>1:n_den2<font color="blue"> loop</font>
        den2[i, 1] := den2[i, 1]*alpha2;
        den2[i, 2] := den2[i, 2]*alpha;
      <font color="blue">end for</font>;
      <font color="blue">if </font><font color="blue">not </font>evenOrder<font color="blue"> then</font>
        den1[1] := den1[1]*alpha;
      <font color="blue">end if</font>;
    <font color="blue">end if</font>;

  <font color="blue">else</font>
    <font color="red">Streams.error</font>(&quot;analogFilter (= &quot; +<font color="red"> String</font>(analogFilter) +
      &quot;) is not supported&quot;);
  <font color="blue">end if</font>;

  <font color="darkgreen">// Compute amplitude at w=1</font>
<font color="darkgreen">/*
  A := 1.0;
  for i in 1:n_den2 loop
     A := A*(1 + den2[i,2]^2 - 2*den2[i,1]
               + den2[i,1]^2);
  end for;
  for i in 1:n_den1 loop
     A := A*(1 + den1[i]^2);
  end for;
  A := 1/sqrt(A);
  print(&quot;A = &quot; + String(A));
*/</font>

  <font color="darkgreen">// Determine normalized denominator polynomials with highest power of p equal to one</font>
  filter.n1 :=<font color="red"> zeros</font>(n_num1);
  filter.n2 :=<font color="red"> zeros</font>(n_num2, 2);
  (filter.d1,filter.d2,k) :=<font color="red"> Internal.filterToNormalized</font>(den1, den2);
  filter.k := filter.k/k;

  <font color="darkgreen">// Compute desired filter characteristics from low pass filter coefficients</font>
  <font color="blue">if </font>filterType == Types.FilterType.HighPass<font color="blue"> then</font>
    <font color="darkgreen"> /* The high pass filter is derived from the low pass filter by
        the transformation new(p) = 1/p
        1/(p^2 + a*p + b) -&gt; 1/((1/p)^2 + a*(1/p) + b) = (1/b)*p^2 / (p^2 + (a/b)*p + 1/b)
        1/(p + a)         -&gt; 1/((1/p) + a) = (1/a)*p / (p + (1/a))
     */</font>
    <font color="red">assert</font>(n_num1 == n_den1<font color="blue"> and </font>n_num2 == n_den2,
      &quot;Internal error 1, should not occur&quot;);
    filter.n1 :=<font color="red"> zeros</font>(n_num1);
    filter.n2 :=<font color="red"> zeros</font>(n_num2, 2);
    <font color="blue">for </font>i<font color="blue"> in </font>1:n_num1<font color="blue"> loop</font>
      filter.k := filter.k/filter.d1[i];
      filter.d1[i] := 1/filter.d1[i];
    <font color="blue">end for</font>;
    <font color="blue">for </font>i<font color="blue"> in </font>1:n_num2<font color="blue"> loop</font>
      filter.k := filter.k/filter.d2[i, 2];
      filter.d2[i, 1] := filter.d2[i, 1]/filter.d2[i, 2];
      filter.d2[i, 2] := 1/filter.d2[i, 2];
    <font color="blue">end for</font>;
  <font color="blue">end if</font>;

  <font color="darkgreen">/* Change filter coefficients according to transformation new(p) = p/w_cut
     Numerator  :     (p/w)^2 + a*(p/w) + b = (1/w^2)*(p^2 + (a*w)*p + b*w^2)
                                  (p/w) + a = (1/w)*(p + w*a)
     Denominator: 1/((p/w)^2 + a*(p/w) + b) = w^2/(p^2 + (a*w)*p + w^2/b)
                              1/((p/w) + a) = w/(p + w*a)
  */</font>
  w_cut2 := w_cut*w_cut;
  filter.k := filter.k*w_cut^(n_den1 + 2*n_den2 - n_num1 - 2*n_num2);
  filter.n1 := w_cut*filter.n1;
  filter.d1 := w_cut*filter.d1;
  filter.n2 := [w_cut*filter.n2[:, 1],w_cut2*filter.n2[:, 2]];
  filter.d2 := [w_cut*filter.d2[:, 1],w_cut2*filter.d2[:, 2]];

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>filter;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE findMatrixName<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.ZerosAndPoles.Internal.findMatrixName"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal"
>Modelica_LinearSystems2.ZerosAndPoles.Internal</A>.findMatrixName</H2>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>filename</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>String</TD><TD>matName</TD><TD>&quot;z&quot;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>m</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> findMatrixName
  <font color="blue">input </font>String filename;
  <font color="blue">input </font>String matName=&quot;z&quot;;

  <font color="blue">output </font>Integer m;

<font color="blue">external</font> &quot;C&quot; m = <font color="red">findMatrixName</font>(
        filename,
        matName,
        &quot;NoClass&quot;);

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>findMatrixName;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE fromFile_pc<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.ZerosAndPoles.Internal.fromFile_pc"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal"
>Modelica_LinearSystems2.ZerosAndPoles.Internal</A>.fromFile_pc</H2>
<B>Generate a zeros and poles data record by reading the polynomial coefficients from a file (default file name is pc.mat)</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>fileName</TD><TD>&quot;pc.mat&quot;</TD><TD>Name of the zeros and poles data file</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A></TD><TD>zp</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> fromFile_pc <font color="darkgreen">
  &quot;Generate a zeros and poles data record by reading the polynomial coefficients from a file (default file name is pc.mat)&quot;</font>
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;

  <font color="blue">input </font>String fileName=&quot;pc.mat&quot; <font color="darkgreen">&quot;Name of the zeros and poles data file&quot;</font>;

<font color="blue">protected </font>
  <font color="blue">input </font>Integer n1n2d1d2[4]=
      <font color="red">ZerosAndPoles.Internal.numberOfRealZerosAndPoles_pc</font>(fileName);
  <font color="blue">input </font>Integer n1=n1n2d1d2[1];
  <font color="blue">input </font>Integer n2=n1n2d1d2[2];
  <font color="blue">input </font>Integer d1=n1n2d1d2[3];
  <font color="blue">input </font>Integer d2=n1n2d1d2[4];
  <font color="blue">input </font>Integer zSize=n1n2d1d2[1] + 2*n1n2d1d2[2];
  <font color="blue">input </font>Integer pSize=n1n2d1d2[3] + 2*n1n2d1d2[4];
<font color="blue">public </font>
  <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp(
    n1=<font color="red">fill</font>(0, n1),
    n2=<font color="red">fill</font>(
          0,
          n2,
          2),
    d1=<font color="red">fill</font>(0, d1),
    d2=<font color="red">fill</font>(
          0,
          d2,
          2));

<font color="blue">protected </font>
  Integer n1_2=<font color="blue">if </font>n1 &gt; 0<font color="blue"> then </font>1<font color="blue"> else </font>0 <font color="darkgreen">&quot;second dimension of n1-matrix&quot;</font>;
  Integer n2_2=<font color="blue">if </font>n2 &gt; 0<font color="blue"> then </font>2<font color="blue"> else </font>0 <font color="darkgreen">&quot;second dimension of n2-matrix&quot;</font>;
  Integer d1_2=<font color="blue">if </font>d1 &gt; 0<font color="blue"> then </font>1<font color="blue"> else </font>0 <font color="darkgreen">&quot;second dimension of d1-matrix&quot;</font>;
  Integer d2_2=<font color="blue">if </font>d2 &gt; 0<font color="blue"> then </font>2<font color="blue"> else </font>0 <font color="darkgreen">&quot;second dimension of d2-matrix&quot;</font>;

  Real k=<font color="red">scalar</font>(<font color="red">readMatrix</font>(
        fileName,
        &quot;k&quot;,
        1,
        1));
  Real n1Vector[n1]=<font color="red">vector</font>(<font color="red">readMatrix</font>(
        fileName,
        &quot;n1&quot;,
        n1,
        n1_2)) <font color="darkgreen">&quot;coefficients of first order numenator polynomials&quot;</font>;
  Real n2Matrix[n2,n2_2]=<font color="red">readMatrix</font>(
        fileName,
        &quot;n2&quot;,
        n2,
        n2_2) <font color="darkgreen">&quot;coefficients of second order denominator polynomials&quot;</font>;
  Real d1Vector[d1]=<font color="red">vector</font>(<font color="red">readMatrix</font>(
        fileName,
        &quot;d1&quot;,
        d2,
        d1_2)) <font color="darkgreen">&quot;coefficients of first order denominator polynomials&quot;</font>;
  Real d2Matrix[d2,d2_2]=<font color="red">readMatrix</font>(
        fileName,
        &quot;d2&quot;,
        d2,
        d2_2) <font color="darkgreen">&quot;coefficients of second order numenator polynomials&quot;</font>;

<font color="blue">algorithm </font>
  zp.k := k;
  zp.n1 := <font color="blue">if </font>n1 &gt; 0<font color="blue"> then </font>n1Vector<font color="blue"> else </font><font color="red">fill</font>(0, 0);
  zp.n2 := <font color="blue">if </font>n2 &gt; 0<font color="blue"> then </font>n2Matrix<font color="blue"> else </font><font color="red">fill</font>(
      0,
      0,
      2);
  zp.d1 := <font color="blue">if </font>d1 &gt; 0<font color="blue"> then </font>d1Vector<font color="blue"> else </font><font color="red">fill</font>(0, 0);
  zp.d2 := <font color="blue">if </font>d2 &gt; 0<font color="blue"> then </font>d2Matrix<font color="blue"> else </font><font color="red">fill</font>(
      0,
      0,
      2);

<font color="blue">end </font>fromFile_pc;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE fromFile_zp<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.ZerosAndPoles.Internal.fromFile_zp"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal"
>Modelica_LinearSystems2.ZerosAndPoles.Internal</A>.fromFile_zp</H2>
<B>Generate a zeros and poles data record by reading poles and zeros from a file (default file name is zp.mat)</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>fileName</TD><TD>&quot;zp.mat&quot;</TD><TD>Name of the zeros and poles data file</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A></TD><TD>zp</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> fromFile_zp <font color="darkgreen">
  &quot;Generate a zeros and poles data record by reading poles and zeros from a file (default file name is zp.mat)&quot;</font>

    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

  <font color="blue">input </font>String fileName=&quot;zp.mat&quot; <font color="darkgreen">&quot;Name of the zeros and poles data file&quot;</font>;
<font color="blue">protected </font>
  <font color="blue">input </font>Integer n1n2d1d2[4]=
      <font color="red">ZerosAndPoles.Internal.numberOfRealZerosAndPoles_zp</font>(fileName);
  <font color="blue">input </font>Integer n1=n1n2d1d2[1];
  <font color="blue">input </font>Integer n2=n1n2d1d2[2];
  <font color="blue">input </font>Integer d1=n1n2d1d2[3];
  <font color="blue">input </font>Integer d2=n1n2d1d2[4];
  <font color="blue">input </font>Integer zSize=n1n2d1d2[1] + 2*n1n2d1d2[2];
  <font color="blue">input </font>Integer pSize=n1n2d1d2[3] + 2*n1n2d1d2[4];
<font color="blue">public </font>
  <font color="blue">output </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp(
    n1=<font color="red">fill</font>(0, n1),
    n2=<font color="red">fill</font>(
          0,
          n2,
          2),
    d1=<font color="red">fill</font>(0, d1),
    d2=<font color="red">fill</font>(
          0,
          d2,
          2));

<font color="blue">protected </font>
  Integer z_2=<font color="blue">if </font>zSize &gt; 0<font color="blue"> then </font>2<font color="blue"> else </font>0 <font color="darkgreen">&quot;second dimension of zeros-matrix&quot;</font>;
  Integer p_2=<font color="blue">if </font>pSize &gt; 0<font color="blue"> then </font>2<font color="blue"> else </font>0 <font color="darkgreen">&quot;second dimension of poles-matrix&quot;</font>;

  Real k=<font color="red">scalar</font>(<font color="red">readMatrix</font>(
        fileName,
        &quot;k&quot;,
        1,
        1));
  Real zerosMatrix[zSize,z_2]=<font color="red">readMatrix</font>(
        fileName,
        &quot;z&quot;,
        zSize,
        z_2) <font color="darkgreen">&quot;zeros in rows of real parts and imaginary parts&quot;</font>;
  Real polesMatrix[pSize,p_2]=<font color="red">readMatrix</font>(
        fileName,
        &quot;p&quot;,
        pSize,
        p_2) <font color="darkgreen">&quot;poles in rows of real parts and imaginary parts&quot;</font>;
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> zeros[:]=<font color="blue">if </font>zSize &gt; 0<font color="blue"> then </font><font color="red">ZerosAndPoles.Internal.fromRealAndImag</font>(
      zerosMatrix[:, 1], zerosMatrix[:, z_2])<font color="blue"> else </font><font color="red">fill</font>(<font color="red">Complex</font>(0), 0);
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> poles[:]=<font color="blue">if </font>pSize &gt; 0<font color="blue"> then </font><font color="red">ZerosAndPoles.Internal.fromRealAndImag</font>(
      polesMatrix[:, 1], polesMatrix[:, p_2])<font color="blue"> else </font><font color="red">fill</font>(<font color="red">Complex</font>(0), 0);

<font color="blue">algorithm </font>
  zp :=<font color="red"> ZerosAndPoles</font>(
      k=k,
      z=zeros,
      p=poles);
<font color="blue">end </font>fromFile_zp;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE checkRepresentation<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.ZerosAndPoles.Internal.checkRepresentation"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal"
>Modelica_LinearSystems2.ZerosAndPoles.Internal</A>.checkRepresentation</H2>
<B>checks whether the system on file is represented by zeros and poles (z, p) or first and second order polynomials (n1, n2, d1, d2)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
The function output is true if the system is given in zeros and poles representation.
Therefore, it is assumend that the used array names are "z" and "p" or "n1, n2, d1" and "d2" respectively.
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>fileName</TD><TD>&quot;zp.mat&quot;</TD><TD>Name of the zeros and poles data file</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Boolean</TD><TD>iszp</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> checkRepresentation <font color="darkgreen">
  &quot;checks whether the system on file is represented by zeros and poles (z, p) or first and second order polynomials (n1, n2, d1, d2)&quot;</font>
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal"
>Modelica_LinearSystems2.ZerosAndPoles.Internal</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
  <font color="blue">input </font>String fileName=&quot;zp.mat&quot; <font color="darkgreen">&quot;Name of the zeros and poles data file&quot;</font>;
  <font color="blue">output </font>Boolean iszp=true;
<font color="blue">protected </font>
  Integer m=0;

<font color="blue">algorithm </font>
  m :=<font color="red"> Internal.findMatrixName</font>(fileName, &quot;z&quot;);
  m := m +<font color="red"> Internal.findMatrixName</font>(fileName, &quot;p&quot;);
  iszp := m == 2;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>checkRepresentation;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE sameVectorElements<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.ZerosAndPoles.Internal.sameVectorElements"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal"
>Modelica_LinearSystems2.ZerosAndPoles.Internal</A>.sameVectorElements</H2>
<B>Determine identical elements of a vector</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>v[:]</TD><TD>&nbsp;</TD><TD>Vector</TD></TR>
<TR><TD>Integer</TD><TD>startIndex</TD><TD>1</TD><TD>Start index</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>endIndex</TD><TD>startIndex:endIndex are identical elements in v</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> sameVectorElements <font color="darkgreen">
  &quot;Determine identical elements of a vector&quot;</font>

  <font color="blue">input </font>Real v[:] <font color="darkgreen">&quot;Vector&quot;</font>;
  <font color="blue">input </font>Integer startIndex=1 <font color="darkgreen">&quot;Start index&quot;</font>;
  <font color="blue">output </font>Integer endIndex=startIndex <font color="darkgreen">
    &quot;startIndex:endIndex are identical elements in v&quot;</font>;
<font color="blue">protected </font>
  Integer nv=<font color="red">size</font>(v, 1);
  Integer i=startIndex + 1;
  Real v0=v[startIndex];
<font color="blue">algorithm </font>
  <font color="blue">while </font>i &lt;= nv<font color="blue"> loop</font>
    <font color="blue">if </font>v[i] == v0<font color="blue"> then</font>
      endIndex := i;
      i := i + 1;
    <font color="blue">else</font>
      i := nv + 1;
    <font color="blue">end if</font>;
  <font color="blue">end while</font>;
<font color="blue">end </font>sameVectorElements;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE fromRealAndImag<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.ZerosAndPoles.Internal.fromRealAndImag"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal"
>Modelica_LinearSystems2.ZerosAndPoles.Internal</A>.fromRealAndImag</H2>
<B>Generate a complex vector from a real part vector and imaginary part vector </B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>real[:]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>imag[size(real, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>result[size(real, 1)]</TD><TD>Number of real zeros</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> fromRealAndImag <font color="darkgreen">
  &quot;Generate a complex vector from a real part vector and imaginary part vector &quot;</font>

  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

  <font color="blue">input </font>Real real[:];
  <font color="blue">input </font>Real imag[<font color="red">size</font>(real, 1)];
  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> result[<font color="red">size</font>(real, 1)] <font color="darkgreen">&quot;Number of real zeros&quot;</font>;
<font color="blue">algorithm </font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(real, 1)<font color="blue"> loop</font>
    result[i].re := real[i];
    result[i].im := imag[i];
  <font color="blue">end for</font>;
<font color="blue">end </font>fromRealAndImag;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE sameMatrixRows<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.ZerosAndPoles.Internal.sameMatrixRows"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal"
>Modelica_LinearSystems2.ZerosAndPoles.Internal</A>.sameMatrixRows</H2>
<B>Determine identical rows of a [:,2] matrix</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>M[:, 2]</TD><TD>&nbsp;</TD><TD>Matrix</TD></TR>
<TR><TD>Integer</TD><TD>startIndex</TD><TD>1</TD><TD>Start index</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>endIndex</TD><TD>startIndex:endIndex are identical rows in M</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> sameMatrixRows <font color="darkgreen">&quot;Determine identical rows of a [:,2] matrix&quot;</font>

  <font color="blue">input </font>Real M[:,2] <font color="darkgreen">&quot;Matrix&quot;</font>;
  <font color="blue">input </font>Integer startIndex=1 <font color="darkgreen">&quot;Start index&quot;</font>;
  <font color="blue">output </font>Integer endIndex=startIndex <font color="darkgreen">
    &quot;startIndex:endIndex are identical rows in M&quot;</font>;
<font color="blue">protected </font>
  Integer n=<font color="red">size</font>(M, 1);
  Integer i=startIndex + 1;
  Real v0[<font color="red">size</font>(M, 2)]=M[startIndex, :];
<font color="blue">algorithm </font>
  <font color="blue">while </font>i &lt;= n<font color="blue"> loop</font>
    <font color="blue">if </font>M[i, 1] == v0[1]<font color="blue"> and </font>M[i, 2] == v0[2]<font color="blue"> then</font>
      endIndex := i;
      i := i + 1;
    <font color="blue">else</font>
      i := n + 1;
    <font color="blue">end if</font>;
  <font color="blue">end while</font>;
<font color="blue">end </font>sameMatrixRows;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE firstOrderToString<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.ZerosAndPoles.Internal.firstOrderToString"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal"
>Modelica_LinearSystems2.ZerosAndPoles.Internal</A>.firstOrderToString</H2>
<B>Transform vector of coefficients of normalized first order polynomials to a string representation</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>c[:]</TD><TD>&nbsp;</TD><TD>p^0 coefficients of normalized first order polynomials</TD></TR>
<TR><TD>Integer</TD><TD>significantDigits</TD><TD>6</TD><TD>Number of significant digits that are shown</TD></TR>
<TR><TD>String</TD><TD>name</TD><TD>&quot;p&quot;</TD><TD>Independent variable name used for printing</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>s</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> firstOrderToString <font color="darkgreen">
  &quot;Transform vector of coefficients of normalized first order polynomials to a string representation&quot;</font>
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Vectors.html#Modelica_LinearSystems2.Math.Vectors"
>Modelica_LinearSystems2.Math.Vectors</A>;

  <font color="blue">input </font>Real c[:] <font color="darkgreen">&quot;p^0 coefficients of normalized first order polynomials&quot;</font>;
  <font color="blue">input </font>Integer significantDigits=6 <font color="darkgreen">
    &quot;Number of significant digits that are shown&quot;</font>;
  <font color="blue">input </font>String name=&quot;p&quot; <font color="darkgreen">&quot;Independent variable name used for printing&quot;</font>;
  <font color="blue">output </font>String s=&quot;&quot;;
<font color="blue">protected </font>
  Integer nc=<font color="red">size</font>(c, 1);
  Real cs[nc]=<font color="red">Modelica.Math.Vectors.sort</font>(c);
  Real cc[nc];
  Integer i;
  Integer j;
  Integer nj;
  Integer k;
  Boolean found=false;
<font color="blue">algorithm </font>
  <font color="darkgreen">// Move coefficients with zero to the beginning</font>
  i := 1;
  <font color="blue">while </font>i &lt;= nc<font color="blue"> loop</font>
    <font color="blue">if </font>cs[i] == 0<font color="blue"> then</font>
      found := true;
      k := i;
      i := nc + 1;
    <font color="blue">else</font>
      i := i + 1;
    <font color="blue">end if</font>;
  <font color="blue">end while</font>;

  <font color="blue">if </font>found<font color="blue"> then</font>
    j :=<font color="red"> sameVectorElements</font>(cs, k);
    cc :=<font color="red"> cat</font>(
          1,
          cs[k:j],
          cs[1:k - 1],
          cs[j + 1:<font color="blue">end</font>]);
  <font color="blue">else</font>
    cc := cs;
  <font color="blue">end if</font>;

  <font color="darkgreen">// Transform coefficients to string</font>
  i := 1;
  <font color="blue">while </font>i &lt;= nc<font color="blue"> loop</font>
    <font color="blue">if </font>i &lt;&gt; 1<font color="blue"> then</font>
      s := s + &quot;*&quot;;
    <font color="blue">end if</font>;
    <font color="blue">if </font>cc[i] == 0<font color="blue"> then</font>
      s := s + name;
    <font color="blue">else</font>
      <font color="blue">if </font>cc[i] &gt; 0<font color="blue"> then</font>
        s := s + &quot;(&quot; + name + &quot; + &quot;;
      <font color="blue">else</font>
        s := s + &quot;(&quot; + name;
      <font color="blue">end if</font>;
      s := s +<font color="red"> String</font>(cc[i], significantDigits=significantDigits) + &quot;)&quot;;
    <font color="blue">end if</font>;
    j :=<font color="red"> sameVectorElements</font>(cc, i);
    nj := j - i + 1;
    <font color="blue">if </font>nj &gt; 1<font color="blue"> then</font>
      s := s + &quot;^&quot; +<font color="red"> String</font>(nj);
    <font color="blue">end if</font>;
    i := j + 1;
  <font color="blue">end while</font>;
<font color="blue">end </font>firstOrderToString;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE secondOrderToString<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.ZerosAndPoles.Internal.secondOrderToString"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal"
>Modelica_LinearSystems2.ZerosAndPoles.Internal</A>.secondOrderToString</H2>
<B>Transform vector of coefficients of normalized second order polynomials to a string representation</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>c[:, 2]</TD><TD>&nbsp;</TD><TD>[p,p^0] coefficients of normalized second order polynomials</TD></TR>
<TR><TD>Integer</TD><TD>significantDigits</TD><TD>6</TD><TD>Number of significant digits that are shown</TD></TR>
<TR><TD>String</TD><TD>name</TD><TD>&quot;p&quot;</TD><TD>Independent variable name used for printing</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>s</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> secondOrderToString <font color="darkgreen">
  &quot;Transform vector of coefficients of normalized second order polynomials to a string representation&quot;</font>
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;

  <font color="blue">input </font>Real c[:,2] <font color="darkgreen">
    &quot;[p,p^0] coefficients of normalized second order polynomials&quot;</font>;
  <font color="blue">input </font>Integer significantDigits=6 <font color="darkgreen">
    &quot;Number of significant digits that are shown&quot;</font>;
  <font color="blue">input </font>String name=&quot;p&quot; <font color="darkgreen">&quot;Independent variable name used for printing&quot;</font>;
  <font color="blue">output </font>String s=&quot;&quot;;
<font color="blue">protected </font>
  Integer nc=<font color="red">size</font>(c, 1);
  Real cc[nc,2]=<font color="red">Modelica.Math.Matrices.sort</font>(c);
  Integer i=1;
  Integer j;
  Integer nj;
<font color="blue">algorithm </font>
  <font color="blue">while </font>i &lt;= nc<font color="blue"> loop</font>
    <font color="blue">if </font>i &lt;&gt; 1<font color="blue"> then</font>
      s := s + &quot;*&quot;;
    <font color="blue">end if</font>;
    j :=<font color="red"> sameMatrixRows</font>(cc, i);
    nj := j - i + 1;
    <font color="blue">if </font>cc[i, 1] == 0<font color="blue"> and </font>cc[i, 2] == 0<font color="blue"> then</font>
      <font color="darkgreen">  // case p^2</font>
      s := s + name + &quot;^&quot; +<font color="red"> String</font>(2*nj);
    <font color="blue">else</font>
      s := s + &quot;(&quot; + name + &quot;^2&quot;;

      <font color="darkgreen">  // b*p term</font>
      <font color="blue">if </font>cc[i, 1] == 1<font color="blue"> then</font>
        s := s + &quot;+&quot; + name;
      <font color="blue">elseif </font>cc[i, 1] == -1<font color="blue"> then</font>
        s := s + &quot; - &quot; + name;
      <font color="blue">elseif </font>cc[i, 1] &lt;&gt; 0<font color="blue"> then</font>
        <font color="blue">if </font>cc[i, 1] &gt; 0<font color="blue"> then</font>
          s := s + &quot; + &quot;;
        <font color="blue">end if</font>;
        s := s +<font color="red"> String</font>(cc[i, 1], significantDigits=significantDigits) +
          &quot;*&quot; + name;
      <font color="blue">end if</font>;

      <font color="darkgreen">  // a*p^0 term</font>
      <font color="blue">if </font>cc[i, 2] &gt; 0<font color="blue"> then</font>
        s := s + &quot; + &quot;;
      <font color="blue">end if</font>;
      s := s +<font color="red"> String</font>(cc[i, 2], significantDigits=significantDigits) + &quot;)&quot;;
      <font color="blue">if </font>nj &gt; 1<font color="blue"> then</font>
        s := s + &quot;^&quot; +<font color="red"> String</font>(nj);
      <font color="blue">end if</font>;
    <font color="blue">end if</font>;
    i := j + 1;
  <font color="blue">end while</font>;
<font color="blue">end </font>secondOrderToString;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE normalizationFactor<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.ZerosAndPoles.Internal.normalizationFactor"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal"
>Modelica_LinearSystems2.ZerosAndPoles.Internal</A>.normalizationFactor</H2>
<B>Compute correction factor of low pass filter such that amplitude at cut-off frequency is 1/sqrt(2) (= 3db)</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>c1[:]</TD><TD>&nbsp;</TD><TD>[p] coefficients of denominator polynomials (a*p + 1)</TD></TR>
<TR><TD>Real</TD><TD>c2[:, 2]</TD><TD>&nbsp;</TD><TD>[p^2, p] coefficients of denominator polynomials (b*p^2 + a*p + 1)</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>alpha</TD><TD>Correction factor (replace p by alpha*p)</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> normalizationFactor <font color="darkgreen">
  &quot;Compute correction factor of low pass filter such that amplitude at cut-off frequency is 1/sqrt(2) (= 3db)&quot;</font>
  <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams"
>Modelica.Utilities.Streams</A>;

  <font color="blue">input </font>Real c1[:] <font color="darkgreen">&quot;[p] coefficients of denominator polynomials (a*p + 1)&quot;</font>;
  <font color="blue">input </font>Real c2[:,2] <font color="darkgreen">
    &quot;[p^2, p] coefficients of denominator polynomials (b*p^2 + a*p + 1)&quot;</font>;
  <font color="blue">output </font>Real alpha <font color="darkgreen">&quot;Correction factor (replace p by alpha*p)&quot;</font>;
<font color="blue">protected </font>
  Real oldAlpha=1.0;
  Integer counter=0;
  Integer counterMax=100;
  Boolean iterating=true;
  Real residue;
  Real der_residue;

  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.ZerosAndPoles.Internal.normalizationFactor.normalizationFactorResidues"><font color="blue">encapsulated </font><font color="blue">function</font> normalizationFactorResidues <font color="darkgreen">
    &quot;Residue and residue derivative for Newton iteration of correction factor computation&quot;</font>
    <font color="blue">input </font>Real c1[:] <font color="darkgreen">&quot;[p] coefficients of denominator polynomials (a*p + 1)&quot;</font>;
    <font color="blue">input </font>Real c2[:,2] <font color="darkgreen">
      &quot;[p^2, p] coefficients of denominator polynomials (b*p^2 + a*p + 1)&quot;</font>;
    <font color="blue">input </font>Real alpha;
    <font color="blue">output </font>Real residue;
    <font color="blue">output </font>Real der_residue;
  <font color="blue">protected </font>
    Real beta=2;<font color="darkgreen">  //beta = 10^(3/10);</font>
    Real cc1;
    Real cc2;
    Real p;
    Real pd;
    Real alpha2=alpha*alpha;
    Real alpha4=alpha2*alpha2;
    Real A2=1.0;
    Real fac=0.0;
  <font color="blue">algorithm </font>
    <font color="blue">if </font><font color="red">size</font>(c1, 1) == 1<font color="blue"> then</font>
      cc1 := c1[1]*c1[1];
      p := 1 + cc1*alpha2;
      pd := cc1;
      fac := fac + pd/p;
      A2 := A2*p;
    <font color="blue">end if</font>;
    <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(c2, 1)<font color="blue"> loop</font>
      cc1 := c2[i, 2]*c2[i, 2] - 2*c2[i, 1];
      cc2 := c2[i, 1]*c2[i, 1];
      p := 1 + cc1*alpha2 + cc2*alpha4;
      pd := cc1 + 2*cc2*alpha2;
      fac := fac + pd/p;
      A2 := A2*p;
    <font color="blue">end for</font>;
    residue := A2 - beta;
    der_residue := 2*alpha*A2*fac;
  <font color="blue">end </font>normalizationFactorResidues</textblock>;
<font color="blue">algorithm </font>
  <font color="darkgreen"> // Simple Newton iteration</font>
  <font color="blue">while </font>iterating<font color="blue"> loop</font>
    counter := counter + 1;
    (residue,der_residue) :=<font color="red"> normalizationFactorResidues</font>(
          c1,
          c2,
          oldAlpha);
    alpha := oldAlpha - residue/der_residue;
    <font color="blue">if </font><font color="red">abs</font>(alpha - oldAlpha) &lt;= 100*Modelica.Constants.eps<font color="blue"> then</font>
      iterating := false;
    <font color="blue">elseif </font>counter &gt; counterMax<font color="blue"> then</font>
      <font color="red">Streams.error</font>(&quot;Numerical problems when computing cutoff frequency\n&quot;
         + &quot;correction factor of filter (use option normalized=false)&quot;);
    <font color="blue">else</font>
      oldAlpha := alpha;
    <font color="blue">end if</font>;
  <font color="blue">end while</font>;
  <font color="red">assert</font>(alpha &gt; 0.0,
    &quot;Numerical problems when computing cutoff frequency\n&quot; +
    &quot;correction factor of filter (alpha = &quot; +<font color="red"> String</font>(alpha) + &quot;)\n&quot; +
    &quot;(use option normalized=false)&quot;);
<font color="blue">end </font>normalizationFactor;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE BesselCoefficients<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.ZerosAndPoles.Internal.BesselCoefficients"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal"
>Modelica_LinearSystems2.ZerosAndPoles.Internal</A>.BesselCoefficients</H2>
<B>Return coefficients of normalized low pass Bessel filter (= gain at cut-off frequency 1 rad/s is decreased 3dB</B><p>
<P><H3>Information</H3></P>
<PRE></pre> The transfer function H(p) of a <i>n</i> 'th order Bessel filter is given by
 
<blockquote><pre>
         Bn(0)
 H(p) = -------
         Bn(p)
 </pre>
</blockquote> with the denominator polynomial
 
<blockquote><pre>
          n             n  (2n - k)!       p^k
 Bn(p) = sum c_k*p^k = sum ----------- * -------   (1)
         k=0           k=0 (n - k)!k!    2^(n-k)
</pre></blockquote>
 
and the numerator
 
<blockquote><pre>
               (2n)!     1
Bn(0) = c_0 = ------- * ---- .                     (2)
                n!      2^n
 </pre></blockquote>
 
Although the coefficients c_k are integer numbers, it is not advisable to use the
polynomials in an unfactorized form because the coefficients are fast growing with order
n (c_0 is approximately 0.3e24 and 0.8e59 for order n=20 and order n=40
respectively).<br>
 
Therefore, the polynomial Bn(p) is factorized to first and second order polynomials with
real coefficients corresponding to zeros and poles representation that is used in this library. 
<p>
The function returns the coefficients which resulted from factorization of the normalized transfer function
 
<blockquote><pre>
H'(p') = H(p),  p' = p/w0
</pre></blockquote>
as well as
<blockquote><pre>
alpha = 1/w0
</pre></blockquote>
the reciprocal of the cut of frequency w0 where the gain of the transfer function is
decreased 3dB.<p>
 
Both, coefficients and cut off frequency were calculated symbolically and were eventually evaluated
with high precision calculation. The results were stored in this function as real
numbers.<p>
 
<br><br><b>Calculation of normalized Bessel filter coefficients</b><br><br>
 
Equation <blockquote><pre>
   abs(H(j*w0)) = abs(Bn(0)/Bn(j*w0)) = 10^(-3/20)
 </pre></blockquote>
which must be fulfilled for cut off frequency w = w0 leads to
<blockquote><pre>
   [Re(Bn(j*w0))]^2 + [Im(Bn(j*w0))]^2 - (Bn(0)^2)*10^(3/10) = 0
</pre></blockquote>
which has exactly one real solution w0 for each order n. This solutions of w0 are
calculated symbolically first and evaluated by using high precise values of the
coefficients c_k calculated by following (1) and (2). <br>
 
With w0, the coefficients of the factorized polynomial can be computed by calculating the
zeros of the denominator polynomial
 
<blockquote><pre>
         n
 Bn(p) = sum w0^k*c_k*(p/w0)^k
         k=0
</pre></blockquote>
 
of the normalized transfer function H'(p'). There exist n/2 of conjugate complex
pairs of zeros (beta +-j*gamma) if n is even and one additional real zero (alpha) if n is
odd. Finally, the coefficients a, b1_k, b2_k of the polynomials
 
<blockquote><pre> a*p + 1,  n is odd </pre></blockquote> and
 
<blockquote><pre> b2_k*p^2 + b1_k*p + 1,   k = 1,... div(n,2) </pre></blockquote>
 
results from <blockquote><pre> a = -1/alpha </pre></blockquote> and
<blockquote><pre> b2_k = 1/(beta_k^2 + gamma_k^2) b1_k = -2*beta_k/(beta_k^2 + gamma_k^2)
</pre></blockquote>
</p>
 
 
<pre>
</PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>order</TD><TD>&nbsp;</TD><TD>Order of filter in the range 1..41</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>c1[mod(order, 2)]</TD><TD>[p] coefficients of Bessel denominator polynomials (a*p + 1)</TD></TR>
<TR><TD>Real</TD><TD>c2[integer(order/2), 2]</TD><TD>[p^2, p] coefficients of Bessel denominator polynomials (b2*p^2 + b1*p + 1)</TD></TR>
<TR><TD>Real</TD><TD>alpha</TD><TD>Normalization factor</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> BesselCoefficients <font color="darkgreen">
  &quot;Return coefficients of normalized low pass Bessel filter (= gain at cut-off frequency 1 rad/s is decreased 3dB&quot;</font>

  <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams"
>Modelica.Utilities.Streams</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
  <font color="blue">input </font>Integer order <font color="darkgreen">&quot;Order of filter in the range 1..41&quot;</font>;
  <font color="blue">output </font>Real c1[<font color="red">mod</font>(order, 2)] <font color="darkgreen">
    &quot;[p] coefficients of Bessel denominator polynomials (a*p + 1)&quot;</font>;
  <font color="blue">output </font>Real c2[<font color="red">integer</font>(order/2),2] <font color="darkgreen">
    &quot;[p^2, p] coefficients of Bessel denominator polynomials (b2*p^2 + b1*p + 1)&quot;</font>;
  <font color="blue">output </font>Real alpha <font color="darkgreen">&quot;Normalization factor&quot;</font>;
<font color="blue">algorithm </font>
  <font color="blue">if </font>order == 1<font color="blue"> then</font>
    alpha := 1.002377293007601;
    c1[1] := 0.9976283451109835;
  <font color="blue">elseif </font>order == 2<font color="blue"> then</font>
    alpha := 0.7356641785819585;
    c2[1, 1] := 0.6159132201783791;
    c2[1, 2] := 1.359315879600889;
  <font color="blue">elseif </font>order == 3<font color="blue"> then</font>
    alpha := 0.5704770156982642;
    c1[1] := 0.7548574865985343;
    c2[1, 1] := 0.4756958028827457;
    c2[1, 2] := 0.9980615136104388;
  <font color="blue">elseif </font>order == 4<font color="blue"> then</font>
    alpha := 0.4737978580281427;
    c2[1, 1] := 0.4873729247240677;
    c2[1, 2] := 1.337564170455762;
    c2[2, 1] := 0.3877724315741958;
    c2[2, 2] := 0.7730405590839861;
  <font color="blue">elseif </font>order == 5<font color="blue"> then</font>
    alpha := 0.4126226974763408;
    c1[1] := 0.6645723262620757;
    c2[1, 1] := 0.4115231900614016;
    c2[1, 2] := 1.138349926728708;
    c2[2, 1] := 0.3234938702877912;
    c2[2, 2] := 0.6205992985771313;
  <font color="blue">elseif </font>order == 6<font color="blue"> then</font>
    alpha := 0.3705098000736233;
    c2[1, 1] := 0.3874508649098960;
    c2[1, 2] := 1.219740879520741;
    c2[2, 1] := 0.3493298843155746;
    c2[2, 2] := 0.9670265529381365;
    c2[3, 1] := 0.2747419229514599;
    c2[3, 2] := 0.5122165075105700;
  <font color="blue">elseif </font>order == 7<font color="blue"> then</font>
    alpha := 0.3393452623586350;
    c1[1] := 0.5927147125821412;
    c2[1, 1] := 0.3383379423919174;
    c2[1, 2] := 1.092630816438030;
    c2[2, 1] := 0.3001025788696046;
    c2[2, 2] := 0.8289928256598656;
    c2[3, 1] := 0.2372867471539579;
    c2[3, 2] := 0.4325128641920154;
  <font color="blue">elseif </font>order == 8<font color="blue"> then</font>
    alpha := 0.3150267393795002;
    c2[1, 1] := 0.3151115975207653;
    c2[1, 2] := 1.109403015460190;
    c2[2, 1] := 0.2969344839572762;
    c2[2, 2] := 0.9737455812222699;
    c2[3, 1] := 0.2612545921889538;
    c2[3, 2] := 0.7190394712068573;
    c2[4, 1] := 0.2080523342974281;
    c2[4, 2] := 0.3721456473047434;
  <font color="blue">elseif </font>order == 9<font color="blue"> then</font>
    alpha := 0.2953310177184124;
    c1[1] := 0.5377196679501422;
    c2[1, 1] := 0.2824689124281034;
    c2[1, 2] := 1.022646191567475;
    c2[2, 1] := 0.2626824161383468;
    c2[2, 2] := 0.8695626454762596;
    c2[3, 1] := 0.2302781917677917;
    c2[3, 2] := 0.6309047553448520;
    c2[4, 1] := 0.1847991729757028;
    c2[4, 2] := 0.3251978031287202;
  <font color="blue">elseif </font>order == 10<font color="blue"> then</font>
    alpha := 0.2789426890619463;
    c2[1, 1] := 0.2640769908255582;
    c2[1, 2] := 1.019788132875305;
    c2[2, 1] := 0.2540802639216947;
    c2[2, 2] := 0.9377020417760623;
    c2[3, 1] := 0.2343577229427963;
    c2[3, 2] := 0.7802229808216112;
    c2[4, 1] := 0.2052193139338624;
    c2[4, 2] := 0.5594176813008133;
    c2[5, 1] := 0.1659546953748916;
    c2[5, 2] := 0.2878349616233292;
  <font color="blue">elseif </font>order == 11<font color="blue"> then</font>
    alpha := 0.2650227766037203;
    c1[1] := 0.4950265498954191;
    c2[1, 1] := 0.2411858478546218;
    c2[1, 2] := 0.9567800996387417;
    c2[2, 1] := 0.2296849355380925;
    c2[2, 2] := 0.8592523717113126;
    c2[3, 1] := 0.2107851705677406;
    c2[3, 2] := 0.7040216048898129;
    c2[4, 1] := 0.1846461385164021;
    c2[4, 2] := 0.5006729207276717;
    c2[5, 1] := 0.1504217970817433;
    c2[5, 2] := 0.2575070491320295;
  <font color="blue">elseif </font>order == 12<font color="blue"> then</font>
    alpha := 0.2530051198547209;
    c2[1, 1] := 0.2268294941204543;
    c2[1, 2] := 0.9473116570034053;
    c2[2, 1] := 0.2207657387793729;
    c2[2, 2] := 0.8933728946287606;
    c2[3, 1] := 0.2087600700376653;
    c2[3, 2] := 0.7886236252756229;
    c2[4, 1] := 0.1909959101492760;
    c2[4, 2] := 0.6389263649257017;
    c2[5, 1] := 0.1675208146048472;
    c2[5, 2] := 0.4517847275162215;
    c2[6, 1] := 0.1374257286372761;
    c2[6, 2] := 0.2324699157474680;
  <font color="blue">elseif </font>order == 13<font color="blue"> then</font>
    alpha := 0.2424910397561007;
    c1[1] := 0.4608848369928040;
    c2[1, 1] := 0.2099813050274780;
    c2[1, 2] := 0.8992478823790660;
    c2[2, 1] := 0.2027250423101359;
    c2[2, 2] := 0.8328117484224146;
    c2[3, 1] := 0.1907635894058731;
    c2[3, 2] := 0.7257379204691213;
    c2[4, 1] := 0.1742280397887686;
    c2[4, 2] := 0.5830640944868014;
    c2[5, 1] := 0.1530858190490478;
    c2[5, 2] := 0.4106192089751885;
    c2[6, 1] := 0.1264090712880446;
    c2[6, 2] := 0.2114980230156001;
  <font color="blue">elseif </font>order == 14<font color="blue"> then</font>
    alpha := 0.2331902368695848;
    c2[1, 1] := 0.1986162311411235;
    c2[1, 2] := 0.8876961808055535;
    c2[2, 1] := 0.1946683341271615;
    c2[2, 2] := 0.8500754229171967;
    c2[3, 1] := 0.1868331332895056;
    c2[3, 2] := 0.7764629313723603;
    c2[4, 1] := 0.1752118757862992;
    c2[4, 2] := 0.6699720402924552;
    c2[5, 1] := 0.1598906457908402;
    c2[5, 2] := 0.5348446712848934;
    c2[6, 1] := 0.1407810153019944;
    c2[6, 2] := 0.3755841316563539;
    c2[7, 1] := 0.1169627966707339;
    c2[7, 2] := 0.1937088226304455;
  <font color="blue">elseif </font>order == 15<font color="blue"> then</font>
    alpha := 0.2248854870552422;
    c1[1] := 0.4328492272335646;
    c2[1, 1] := 0.1857292591004588;
    c2[1, 2] := 0.8496337061962563;
    c2[2, 1] := 0.1808644178280136;
    c2[2, 2] := 0.8020517898136011;
    c2[3, 1] := 0.1728264404199081;
    c2[3, 2] := 0.7247449729331105;
    c2[4, 1] := 0.1616970125901954;
    c2[4, 2] := 0.6205369315943097;
    c2[5, 1] := 0.1475257264578426;
    c2[5, 2] := 0.4929612162355906;
    c2[6, 1] := 0.1301861023357119;
    c2[6, 2] := 0.3454770708040735;
    c2[7, 1] := 0.1087810777120188;
    c2[7, 2] := 0.1784526655428406;
  <font color="blue">elseif </font>order == 16<font color="blue"> then</font>
    alpha := 0.2174105053474761;
    c2[1, 1] := 0.1765637967473151;
    c2[1, 2] := 0.8377453068635511;
    c2[2, 1] := 0.1738525357503125;
    c2[2, 2] := 0.8102988957433199;
    c2[3, 1] := 0.1684627004613343;
    c2[3, 2] := 0.7563265923413258;
    c2[4, 1] := 0.1604519074815815;
    c2[4, 2] := 0.6776082294687619;
    c2[5, 1] := 0.1498828607802206;
    c2[5, 2] := 0.5766417034027680;
    c2[6, 1] := 0.1367764717792823;
    c2[6, 2] := 0.4563528264410489;
    c2[7, 1] := 0.1209810465419295;
    c2[7, 2] := 0.3193782657322374;
    c2[8, 1] := 0.1016312648007554;
    c2[8, 2] := 0.1652419227369036;
  <font color="blue">elseif </font>order == 17<font color="blue"> then</font>
    alpha := 0.2106355148193306;
    c1[1] := 0.4093223608497299;
    c2[1, 1] := 0.1664014345826274;
    c2[1, 2] := 0.8067173752345952;
    c2[2, 1] := 0.1629839591538256;
    c2[2, 2] := 0.7712924931447541;
    c2[3, 1] := 0.1573277802512491;
    c2[3, 2] := 0.7134213666303411;
    c2[4, 1] := 0.1494828185148637;
    c2[4, 2] := 0.6347841731714884;
    c2[5, 1] := 0.1394948812681826;
    c2[5, 2] := 0.5375594414619047;
    c2[6, 1] := 0.1273627583380806;
    c2[6, 2] := 0.4241608926375478;
    c2[7, 1] := 0.1129187258461290;
    c2[7, 2] := 0.2965752009703245;
    c2[8, 1] := 0.9533357359908857e-1;
    c2[8, 2] := 0.1537041700889585;
  <font color="blue">elseif </font>order == 18<font color="blue"> then</font>
    alpha := 0.2044575288651841;
    c2[1, 1] := 0.1588768571976356;
    c2[1, 2] := 0.7951914263212913;
    c2[2, 1] := 0.1569357024981854;
    c2[2, 2] := 0.7744529690772538;
    c2[3, 1] := 0.1530722206358810;
    c2[3, 2] := 0.7335304425992080;
    c2[4, 1] := 0.1473206710524167;
    c2[4, 2] := 0.6735038935387268;
    c2[5, 1] := 0.1397225420331520;
    c2[5, 2] := 0.5959151542621590;
    c2[6, 1] := 0.1303092459809849;
    c2[6, 2] := 0.5026483447894845;
    c2[7, 1] := 0.1190627367060072;
    c2[7, 2] := 0.3956893824587150;
    c2[8, 1] := 0.1058058030798994;
    c2[8, 2] := 0.2765091830730650;
    c2[9, 1] := 0.8974708108800873e-1;
    c2[9, 2] := 0.1435505288284833;
  <font color="blue">elseif </font>order == 19<font color="blue"> then</font>
    alpha := 0.1987936248083529;
    c1[1] := 0.3892259966869526;
    c2[1, 1] := 0.1506640012172225;
    c2[1, 2] := 0.7693121733774260;
    c2[2, 1] := 0.1481728062796673;
    c2[2, 2] := 0.7421133586741549;
    c2[3, 1] := 0.1440444668388838;
    c2[3, 2] := 0.6975075386214800;
    c2[4, 1] := 0.1383101628540374;
    c2[4, 2] := 0.6365464378910025;
    c2[5, 1] := 0.1310032283190998;
    c2[5, 2] := 0.5606211948462122;
    c2[6, 1] := 0.1221431166405330;
    c2[6, 2] := 0.4713530424221445;
    c2[7, 1] := 0.1116991161103884;
    c2[7, 2] := 0.3703717538617073;
    c2[8, 1] := 0.9948917351196349e-1;
    c2[8, 2] := 0.2587371155559744;
    c2[9, 1] := 0.8475989238107367e-1;
    c2[9, 2] := 0.1345537894555993;
  <font color="blue">elseif </font>order == 20<font color="blue"> then</font>
    alpha := 0.1935761760416219;
    c2[1, 1] := 0.1443871348337404;
    c2[1, 2] := 0.7584165598446141;
    c2[2, 1] := 0.1429501891353184;
    c2[2, 2] := 0.7423000962318863;
    c2[3, 1] := 0.1400877384920004;
    c2[3, 2] := 0.7104185332215555;
    c2[4, 1] := 0.1358210369491446;
    c2[4, 2] := 0.6634599783272630;
    c2[5, 1] := 0.1301773703034290;
    c2[5, 2] := 0.6024175491895959;
    c2[6, 1] := 0.1231826501439148;
    c2[6, 2] := 0.5285332736326852;
    c2[7, 1] := 0.1148465498575254;
    c2[7, 2] := 0.4431977385498628;
    c2[8, 1] := 0.1051289462376788;
    c2[8, 2] := 0.3477444062821162;
    c2[9, 1] := 0.9384622797485121e-1;
    c2[9, 2] := 0.2429038300327729;
    c2[10, 1] := 0.8028211612831444e-1;
    c2[10, 2] := 0.1265329974009533;
  <font color="blue">elseif </font>order == 21<font color="blue"> then</font>
    alpha := 0.1887494014766075;
    c1[1] := 0.3718070668941645;
    c2[1, 1] := 0.1376151928386445;
    c2[1, 2] := 0.7364290859445481;
    c2[2, 1] := 0.1357438914390695;
    c2[2, 2] := 0.7150167318935022;
    c2[3, 1] := 0.1326398453462415;
    c2[3, 2] := 0.6798001808470175;
    c2[4, 1] := 0.1283231214897678;
    c2[4, 2] := 0.6314663440439816;
    c2[5, 1] := 0.1228169159777534;
    c2[5, 2] := 0.5709353626166905;
    c2[6, 1] := 0.1161406100773184;
    c2[6, 2] := 0.4993087153571335;
    c2[7, 1] := 0.1082959649233524;
    c2[7, 2] := 0.4177766148584385;
    c2[8, 1] := 0.9923596957485723e-1;
    c2[8, 2] := 0.3274257287232124;
    c2[9, 1] := 0.8877776108724853e-1;
    c2[9, 2] := 0.2287218166767916;
    c2[10, 1] := 0.7624076527736326e-1;
    c2[10, 2] := 0.1193423971506988;
  <font color="blue">elseif </font>order == 22<font color="blue"> then</font>
    alpha := 0.1842668221199706;
    c2[1, 1] := 0.1323053462701543;
    c2[1, 2] := 0.7262446126765204;
    c2[2, 1] := 0.1312121721769772;
    c2[2, 2] := 0.7134286088450949;
    c2[3, 1] := 0.1290330911166814;
    c2[3, 2] := 0.6880287870435514;
    c2[4, 1] := 0.1257817990372067;
    c2[4, 2] := 0.6505015800059301;
    c2[5, 1] := 0.1214765261983008;
    c2[5, 2] := 0.6015107185211451;
    c2[6, 1] := 0.1161365140967959;
    c2[6, 2] := 0.5418983553698413;
    c2[7, 1] := 0.1097755171533100;
    c2[7, 2] := 0.4726370779831614;
    c2[8, 1] := 0.1023889478519956;
    c2[8, 2] := 0.3947439506537486;
    c2[9, 1] := 0.9392485861253800e-1;
    c2[9, 2] := 0.3090996703083202;
    c2[10, 1] := 0.8420273775456455e-1;
    c2[10, 2] := 0.2159561978556017;
    c2[11, 1] := 0.7257600023938262e-1;
    c2[11, 2] := 0.1128633732721116;
  <font color="blue">elseif </font>order == 23<font color="blue"> then</font>
    alpha := 0.1800893554453722;
    c1[1] := 0.3565232673929280;
    c2[1, 1] := 0.1266275171652706;
    c2[1, 2] := 0.7072778066734162;
    c2[2, 1] := 0.1251865227648538;
    c2[2, 2] := 0.6900676345785905;
    c2[3, 1] := 0.1227944815236645;
    c2[3, 2] := 0.6617011100576023;
    c2[4, 1] := 0.1194647013077667;
    c2[4, 2] := 0.6226432315773119;
    c2[5, 1] := 0.1152132989252356;
    c2[5, 2] := 0.5735222810625359;
    c2[6, 1] := 0.1100558598478487;
    c2[6, 2] := 0.5151027978024605;
    c2[7, 1] := 0.1040013558214886;
    c2[7, 2] := 0.4482410942032739;
    c2[8, 1] := 0.9704014176512626e-1;
    c2[8, 2] := 0.3738049984631116;
    c2[9, 1] := 0.8911683905758054e-1;
    c2[9, 2] := 0.2925028692588410;
    c2[10, 1] := 0.8005438265072295e-1;
    c2[10, 2] := 0.2044134600278901;
    c2[11, 1] := 0.6923832296800832e-1;
    c2[11, 2] := 0.1069984887283394;
  <font color="blue">elseif </font>order == 24<font color="blue"> then</font>
    alpha := 0.1761838665838427;
    c2[1, 1] := 0.1220804912720132;
    c2[1, 2] := 0.6978026874156063;
    c2[2, 1] := 0.1212296762358897;
    c2[2, 2] := 0.6874139794926736;
    c2[3, 1] := 0.1195328372961027;
    c2[3, 2] := 0.6667954259551859;
    c2[4, 1] := 0.1169990987333593;
    c2[4, 2] := 0.6362602049901176;
    c2[5, 1] := 0.1136409040480130;
    c2[5, 2] := 0.5962662188435553;
    c2[6, 1] := 0.1094722001757955;
    c2[6, 2] := 0.5474001634109253;
    c2[7, 1] := 0.1045052832229087;
    c2[7, 2] := 0.4903523180249535;
    c2[8, 1] := 0.9874509806025907e-1;
    c2[8, 2] := 0.4258751523524645;
    c2[9, 1] := 0.9217799943472177e-1;
    c2[9, 2] := 0.3547079765396403;
    c2[10, 1] := 0.8474633796250476e-1;
    c2[10, 2] := 0.2774145482392767;
    c2[11, 1] := 0.7627722381240495e-1;
    c2[11, 2] := 0.1939329108084139;
    c2[12, 1] := 0.6618645465422745e-1;
    c2[12, 2] := 0.1016670147947242;
  <font color="blue">elseif </font>order == 25<font color="blue"> then</font>
    alpha := 0.1725220521949266;
    c1[1] := 0.3429735385896000;
    c2[1, 1] := 0.1172525033170618;
    c2[1, 2] := 0.6812327932576614;
    c2[2, 1] := 0.1161194585333535;
    c2[2, 2] := 0.6671566071153211;
    c2[3, 1] := 0.1142375145794466;
    c2[3, 2] := 0.6439167855053158;
    c2[4, 1] := 0.1116157454252308;
    c2[4, 2] := 0.6118378416180135;
    c2[5, 1] := 0.1082654809459177;
    c2[5, 2] := 0.5713609763370088;
    c2[6, 1] := 0.1041985674230918;
    c2[6, 2] := 0.5230289949762722;
    c2[7, 1] := 0.9942439308123559e-1;
    c2[7, 2] := 0.4674627926041906;
    c2[8, 1] := 0.9394453593830893e-1;
    c2[8, 2] := 0.4053226688298811;
    c2[9, 1] := 0.8774221237222533e-1;
    c2[9, 2] := 0.3372372276379071;
    c2[10, 1] := 0.8075839512216483e-1;
    c2[10, 2] := 0.2636485508005428;
    c2[11, 1] := 0.7282483286646764e-1;
    c2[11, 2] := 0.1843801345273085;
    c2[12, 1] := 0.6338571166846652e-1;
    c2[12, 2] := 0.9680153764737715e-1;
  <font color="blue">elseif </font>order == 26<font color="blue"> then</font>
    alpha := 0.1690795702796737;
    c2[1, 1] := 0.1133168695796030;
    c2[1, 2] := 0.6724297955493932;
    c2[2, 1] := 0.1126417845769961;
    c2[2, 2] := 0.6638709519790540;
    c2[3, 1] := 0.1112948749545606;
    c2[3, 2] := 0.6468652038763624;
    c2[4, 1] := 0.1092823986944244;
    c2[4, 2] := 0.6216337070799265;
    c2[5, 1] := 0.1066130386697976;
    c2[5, 2] := 0.5885011413992190;
    c2[6, 1] := 0.1032969057045413;
    c2[6, 2] := 0.5478864278297548;
    c2[7, 1] := 0.9934388184210715e-1;
    c2[7, 2] := 0.5002885306054287;
    c2[8, 1] := 0.9476081523436283e-1;
    c2[8, 2] := 0.4462644847551711;
    c2[9, 1] := 0.8954648464575577e-1;
    c2[9, 2] := 0.3863930785049522;
    c2[10, 1] := 0.8368166847159917e-1;
    c2[10, 2] := 0.3212074592527143;
    c2[11, 1] := 0.7710664731701103e-1;
    c2[11, 2] := 0.2510470347119383;
    c2[12, 1] := 0.6965807988411425e-1;
    c2[12, 2] := 0.1756419294111342;
    c2[13, 1] := 0.6080674930548766e-1;
    c2[13, 2] := 0.9234535279274277e-1;
  <font color="blue">elseif </font>order == 27<font color="blue"> then</font>
    alpha := 0.1658353543067995;
    c1[1] := 0.3308543720638957;
    c2[1, 1] := 0.1091618578712746;
    c2[1, 2] := 0.6577977071169651;
    c2[2, 1] := 0.1082549561495043;
    c2[2, 2] := 0.6461121666520275;
    c2[3, 1] := 0.1067479247890451;
    c2[3, 2] := 0.6267937760991321;
    c2[4, 1] := 0.1046471079537577;
    c2[4, 2] := 0.6000750116745808;
    c2[5, 1] := 0.1019605976654259;
    c2[5, 2] := 0.5662734183049320;
    c2[6, 1] := 0.9869726954433709e-1;
    c2[6, 2] := 0.5257827234948534;
    c2[7, 1] := 0.9486520934132483e-1;
    c2[7, 2] := 0.4790595019077763;
    c2[8, 1] := 0.9046906518775348e-1;
    c2[8, 2] := 0.4266025862147336;
    c2[9, 1] := 0.8550529998276152e-1;
    c2[9, 2] := 0.3689188223512328;
    c2[10, 1] := 0.7995282239306020e-1;
    c2[10, 2] := 0.3064589322702932;
    c2[11, 1] := 0.7375174596252882e-1;
    c2[11, 2] := 0.2394754504667310;
    c2[12, 1] := 0.6674377263329041e-1;
    c2[12, 2] := 0.1676223546666024;
    c2[13, 1] := 0.5842458027529246e-1;
    c2[13, 2] := 0.8825044329219431e-1;
  <font color="blue">elseif </font>order == 28<font color="blue"> then</font>
    alpha := 0.1627710671942929;
    c2[1, 1] := 0.1057232656113488;
    c2[1, 2] := 0.6496161226860832;
    c2[2, 1] := 0.1051786825724864;
    c2[2, 2] := 0.6424661279909941;
    c2[3, 1] := 0.1040917964935006;
    c2[3, 2] := 0.6282470268918791;
    c2[4, 1] := 0.1024670101953951;
    c2[4, 2] := 0.6071189030701136;
    c2[5, 1] := 0.1003105109519892;
    c2[5, 2] := 0.5793175191747016;
    c2[6, 1] := 0.9762969425430802e-1;
    c2[6, 2] := 0.5451486608855443;
    c2[7, 1] := 0.9443223803058400e-1;
    c2[7, 2] := 0.5049796971628137;
    c2[8, 1] := 0.9072460982036488e-1;
    c2[8, 2] := 0.4592270546572523;
    c2[9, 1] := 0.8650956423253280e-1;
    c2[9, 2] := 0.4083368605952977;
    c2[10, 1] := 0.8178165740374893e-1;
    c2[10, 2] := 0.3527525188880655;
    c2[11, 1] := 0.7651838885868020e-1;
    c2[11, 2] := 0.2928534570013572;
    c2[12, 1] := 0.7066010532447490e-1;
    c2[12, 2] := 0.2288185204390681;
    c2[13, 1] := 0.6405358596145789e-1;
    c2[13, 2] := 0.1602396172588190;
    c2[14, 1] := 0.5621780070227172e-1;
    c2[14, 2] := 0.8447589564915071e-1;
  <font color="blue">elseif </font>order == 29<font color="blue"> then</font>
    alpha := 0.1598706626277596;
    c1[1] := 0.3199314513011623;
    c2[1, 1] := 0.1021101032532951;
    c2[1, 2] := 0.6365758882240111;
    c2[2, 1] := 0.1013729819392774;
    c2[2, 2] := 0.6267495975736321;
    c2[3, 1] := 0.1001476175660628;
    c2[3, 2] := 0.6104876178266819;
    c2[4, 1] := 0.9843854640428316e-1;
    c2[4, 2] := 0.5879603139195113;
    c2[5, 1] := 0.9625164534591696e-1;
    c2[5, 2] := 0.5594012291050210;
    c2[6, 1] := 0.9359356960417668e-1;
    c2[6, 2] := 0.5251016150410664;
    c2[7, 1] := 0.9047086748649986e-1;
    c2[7, 2] := 0.4854024475590397;
    c2[8, 1] := 0.8688856407189167e-1;
    c2[8, 2] := 0.4406826457109709;
    c2[9, 1] := 0.8284779224069856e-1;
    c2[9, 2] := 0.3913408089298914;
    c2[10, 1] := 0.7834154620997181e-1;
    c2[10, 2] := 0.3377643999400627;
    c2[11, 1] := 0.7334628941928766e-1;
    c2[11, 2] := 0.2802710651919946;
    c2[12, 1] := 0.6780290487362146e-1;
    c2[12, 2] := 0.2189770008083379;
    c2[13, 1] := 0.6156321231528423e-1;
    c2[13, 2] := 0.1534235999306070;
    c2[14, 1] := 0.5416797446761512e-1;
    c2[14, 2] := 0.8098664736760292e-1;
  <font color="blue">elseif </font>order == 30<font color="blue"> then</font>
    alpha := 0.1571200296252450;
    c2[1, 1] := 0.9908074847842124e-1;
    c2[1, 2] := 0.6289618807831557;
    c2[2, 1] := 0.9863509708328196e-1;
    c2[2, 2] := 0.6229164525571278;
    c2[3, 1] := 0.9774542692037148e-1;
    c2[3, 2] := 0.6108853364240036;
    c2[4, 1] := 0.9641490581986484e-1;
    c2[4, 2] := 0.5929869253412513;
    c2[5, 1] := 0.9464802912225441e-1;
    c2[5, 2] := 0.5693960175547550;
    c2[6, 1] := 0.9245027206218041e-1;
    c2[6, 2] := 0.5403402396359503;
    c2[7, 1] := 0.8982754584112941e-1;
    c2[7, 2] := 0.5060948065875106;
    c2[8, 1] := 0.8678535291732599e-1;
    c2[8, 2] := 0.4669749797983789;
    c2[9, 1] := 0.8332744242052199e-1;
    c2[9, 2] := 0.4233249626334694;
    c2[10, 1] := 0.7945356393775309e-1;
    c2[10, 2] := 0.3755006094498054;
    c2[11, 1] := 0.7515543969833788e-1;
    c2[11, 2] := 0.3238400339292700;
    c2[12, 1] := 0.7040879901685638e-1;
    c2[12, 2] := 0.2686072427439079;
    c2[13, 1] := 0.6515528854010540e-1;
    c2[13, 2] := 0.2098650589782619;
    c2[14, 1] := 0.5925168237177876e-1;
    c2[14, 2] := 0.1471138832654873;
    c2[15, 1] := 0.5225913954211672e-1;
    c2[15, 2] := 0.7775248839507864e-1;
  <font color="blue">elseif </font>order == 31<font color="blue"> then</font>
    alpha := 0.1545067022920929;
    c1[1] := 0.3100206996451866;
    c2[1, 1] := 0.9591020358831668e-1;
    c2[1, 2] := 0.6172474793293396;
    c2[2, 1] := 0.9530301275601203e-1;
    c2[2, 2] := 0.6088916323460413;
    c2[3, 1] := 0.9429332655402368e-1;
    c2[3, 2] := 0.5950511595503025;
    c2[4, 1] := 0.9288445429894548e-1;
    c2[4, 2] := 0.5758534119053522;
    c2[5, 1] := 0.9108073420087422e-1;
    c2[5, 2] := 0.5514734636081183;
    c2[6, 1] := 0.8888719137536870e-1;
    c2[6, 2] := 0.5221306199481831;
    c2[7, 1] := 0.8630901440239650e-1;
    c2[7, 2] := 0.4880834248148061;
    c2[8, 1] := 0.8335074993373294e-1;
    c2[8, 2] := 0.4496225358496770;
    c2[9, 1] := 0.8001502494376102e-1;
    c2[9, 2] := 0.4070602306679052;
    c2[10, 1] := 0.7630041338037624e-1;
    c2[10, 2] := 0.3607139804818122;
    c2[11, 1] := 0.7219760885744920e-1;
    c2[11, 2] := 0.3108783301229550;
    c2[12, 1] := 0.6768185077153345e-1;
    c2[12, 2] := 0.2577706252514497;
    c2[13, 1] := 0.6269571766328638e-1;
    c2[13, 2] := 0.2014081375889921;
    c2[14, 1] := 0.5710081766945065e-1;
    c2[14, 2] := 0.1412581515841926;
    c2[15, 1] := 0.5047740914807019e-1;
    c2[15, 2] := 0.7474725873250158e-1;
  <font color="blue">elseif </font>order == 32<font color="blue"> then</font>
    alpha := 0.1520196210848210;
    c2[1, 1] := 0.9322163554339406e-1;
    c2[1, 2] := 0.6101488690506050;
    c2[2, 1] := 0.9285233997694042e-1;
    c2[2, 2] := 0.6049832320721264;
    c2[3, 1] := 0.9211494244473163e-1;
    c2[3, 2] := 0.5946969295569034;
    c2[4, 1] := 0.9101176786042449e-1;
    c2[4, 2] := 0.5793791854364477;
    c2[5, 1] := 0.8954614071360517e-1;
    c2[5, 2] := 0.5591619969234026;
    c2[6, 1] := 0.8772216763680164e-1;
    c2[6, 2] := 0.5342177994699602;
    c2[7, 1] := 0.8554440426912734e-1;
    c2[7, 2] := 0.5047560942986598;
    c2[8, 1] := 0.8301735302045588e-1;
    c2[8, 2] := 0.4710187048140929;
    c2[9, 1] := 0.8014469519188161e-1;
    c2[9, 2] := 0.4332730387207936;
    c2[10, 1] := 0.7692807528893225e-1;
    c2[10, 2] := 0.3918021436411035;
    c2[11, 1] := 0.7336507157284898e-1;
    c2[11, 2] := 0.3468890521471250;
    c2[12, 1] := 0.6944555312763458e-1;
    c2[12, 2] := 0.2987898029050460;
    c2[13, 1] := 0.6514446669420571e-1;
    c2[13, 2] := 0.2476810747407199;
    c2[14, 1] := 0.6040544477732702e-1;
    c2[14, 2] := 0.1935412053397663;
    c2[15, 1] := 0.5509478650672775e-1;
    c2[15, 2] := 0.1358108994174911;
    c2[16, 1] := 0.4881064725720192e-1;
    c2[16, 2] := 0.7194819894416505e-1;
  <font color="blue">elseif </font>order == 33<font color="blue"> then</font>
    alpha := 0.1496489351138032;
    c1[1] := 0.3009752799176432;
    c2[1, 1] := 0.9041725460994505e-1;
    c2[1, 2] := 0.5995521047364046;
    c2[2, 1] := 0.8991117804113002e-1;
    c2[2, 2] := 0.5923764112099496;
    c2[3, 1] := 0.8906941547422532e-1;
    c2[3, 2] := 0.5804822013853129;
    c2[4, 1] := 0.8789442491445575e-1;
    c2[4, 2] := 0.5639663528946501;
    c2[5, 1] := 0.8638945831033775e-1;
    c2[5, 2] := 0.5429623519607796;
    c2[6, 1] := 0.8455834602616358e-1;
    c2[6, 2] := 0.5176379938389326;
    c2[7, 1] := 0.8240517431382334e-1;
    c2[7, 2] := 0.4881921474066189;
    c2[8, 1] := 0.7993380417355076e-1;
    c2[8, 2] := 0.4548502528082586;
    c2[9, 1] := 0.7714713890732801e-1;
    c2[9, 2] := 0.4178579388038483;
    c2[10, 1] := 0.7404596598181127e-1;
    c2[10, 2] := 0.3774715722484659;
    c2[11, 1] := 0.7062702339160462e-1;
    c2[11, 2] := 0.3339432938810453;
    c2[12, 1] := 0.6687952672391507e-1;
    c2[12, 2] := 0.2874950693388235;
    c2[13, 1] := 0.6277828912909767e-1;
    c2[13, 2] := 0.2382680702894708;
    c2[14, 1] := 0.5826808305383988e-1;
    c2[14, 2] := 0.1862073169968455;
    c2[15, 1] := 0.5321974125363517e-1;
    c2[15, 2] := 0.1307323751236313;
    c2[16, 1] := 0.4724820282032780e-1;
    c2[16, 2] := 0.6933542082177094e-1;
  <font color="blue">elseif </font>order == 34<font color="blue"> then</font>
    alpha := 0.1473858373968463;
    c2[1, 1] := 0.8801537152275983e-1;
    c2[1, 2] := 0.5929204288972172;
    c2[2, 1] := 0.8770594341007476e-1;
    c2[2, 2] := 0.5884653382247518;
    c2[3, 1] := 0.8708797598072095e-1;
    c2[3, 2] := 0.5795895850253119;
    c2[4, 1] := 0.8616320590689187e-1;
    c2[4, 2] := 0.5663615383647170;
    c2[5, 1] := 0.8493413175570858e-1;
    c2[5, 2] := 0.5488825092350877;
    c2[6, 1] := 0.8340387368687513e-1;
    c2[6, 2] := 0.5272851839324592;
    c2[7, 1] := 0.8157596213131521e-1;
    c2[7, 2] := 0.5017313864372913;
    c2[8, 1] := 0.7945402670834270e-1;
    c2[8, 2] := 0.4724089864574216;
    c2[9, 1] := 0.7704133559556429e-1;
    c2[9, 2] := 0.4395276256463053;
    c2[10, 1] := 0.7434009635219704e-1;
    c2[10, 2] := 0.4033126590648964;
    c2[11, 1] := 0.7135035113853376e-1;
    c2[11, 2] := 0.3639961488919042;
    c2[12, 1] := 0.6806813160738834e-1;
    c2[12, 2] := 0.3218025212900124;
    c2[13, 1] := 0.6448214312000864e-1;
    c2[13, 2] := 0.2769235521088158;
    c2[14, 1] := 0.6056719318430530e-1;
    c2[14, 2] := 0.2294693573271038;
    c2[15, 1] := 0.5626925196925040e-1;
    c2[15, 2] := 0.1793564218840015;
    c2[16, 1] := 0.5146352031547277e-1;
    c2[16, 2] := 0.1259877129326412;
    c2[17, 1] := 0.4578069074410591e-1;
    c2[17, 2] := 0.6689147319568768e-1;
  <font color="blue">elseif </font>order == 35<font color="blue"> then</font>
    alpha := 0.1452224267615486;
    c1[1] := 0.2926764667564367;
    c2[1, 1] := 0.8551731299267280e-1;
    c2[1, 2] := 0.5832758214629523;
    c2[2, 1] := 0.8509109732853060e-1;
    c2[2, 2] := 0.5770596582643844;
    c2[3, 1] := 0.8438201446671953e-1;
    c2[3, 2] := 0.5667497616665494;
    c2[4, 1] := 0.8339191981579831e-1;
    c2[4, 2] := 0.5524209816238369;
    c2[5, 1] := 0.8212328610083385e-1;
    c2[5, 2] := 0.5341766459916322;
    c2[6, 1] := 0.8057906332198853e-1;
    c2[6, 2] := 0.5121470053512750;
    c2[7, 1] := 0.7876247299954955e-1;
    c2[7, 2] := 0.4864870722254752;
    c2[8, 1] := 0.7667670879950268e-1;
    c2[8, 2] := 0.4573736721705665;
    c2[9, 1] := 0.7432449556218945e-1;
    c2[9, 2] := 0.4250013835198991;
    c2[10, 1] := 0.7170742126011575e-1;
    c2[10, 2] := 0.3895767735915445;
    c2[11, 1] := 0.6882488171701314e-1;
    c2[11, 2] := 0.3513097926737368;
    c2[12, 1] := 0.6567231746957568e-1;
    c2[12, 2] := 0.3103999917596611;
    c2[13, 1] := 0.6223804362223595e-1;
    c2[13, 2] := 0.2670123611280899;
    c2[14, 1] := 0.5849696460782910e-1;
    c2[14, 2] := 0.2212298104867592;
    c2[15, 1] := 0.5439628409499822e-1;
    c2[15, 2] := 0.1729443731341637;
    c2[16, 1] := 0.4981540179136920e-1;
    c2[16, 2] := 0.1215462157134930;
    c2[17, 1] := 0.4439981033536435e-1;
    c2[17, 2] := 0.6460098363520967e-1;
  <font color="blue">elseif </font>order == 36<font color="blue"> then</font>
    alpha := 0.1431515914458580;
    c2[1, 1] := 0.8335881847130301e-1;
    c2[1, 2] := 0.5770670512160201;
    c2[2, 1] := 0.8309698922852212e-1;
    c2[2, 2] := 0.5731929100172432;
    c2[3, 1] := 0.8257400347039723e-1;
    c2[3, 2] := 0.5654713811993058;
    c2[4, 1] := 0.8179117911600136e-1;
    c2[4, 2] := 0.5539556343603020;
    c2[5, 1] := 0.8075042173126963e-1;
    c2[5, 2] := 0.5387245649546684;
    c2[6, 1] := 0.7945413151258206e-1;
    c2[6, 2] := 0.5198817177723069;
    c2[7, 1] := 0.7790506514288866e-1;
    c2[7, 2] := 0.4975537629595409;
    c2[8, 1] := 0.7610613635339480e-1;
    c2[8, 2] := 0.4718884193866789;
    c2[9, 1] := 0.7406012816626425e-1;
    c2[9, 2] := 0.4430516443136726;
    c2[10, 1] := 0.7176927060205631e-1;
    c2[10, 2] := 0.4112237708115829;
    c2[11, 1] := 0.6923460172504251e-1;
    c2[11, 2] := 0.3765940116389730;
    c2[12, 1] := 0.6645495833489556e-1;
    c2[12, 2] := 0.3393522147815403;
    c2[13, 1] := 0.6342528888937094e-1;
    c2[13, 2] := 0.2996755899575573;
    c2[14, 1] := 0.6013361864949449e-1;
    c2[14, 2] := 0.2577053294053830;
    c2[15, 1] := 0.5655503081322404e-1;
    c2[15, 2] := 0.2135004731531631;
    c2[16, 1] := 0.5263798119559069e-1;
    c2[16, 2] := 0.1669320999865636;
    c2[17, 1] := 0.4826589873626196e-1;
    c2[17, 2] := 0.1173807590715484;
    c2[18, 1] := 0.4309819397289806e-1;
    c2[18, 2] := 0.6245036108880222e-1;
  <font color="blue">elseif </font>order == 37<font color="blue"> then</font>
    alpha := 0.1411669104782917;
    c1[1] := 0.2850271036215707;
    c2[1, 1] := 0.8111958235023328e-1;
    c2[1, 2] := 0.5682412610563970;
    c2[2, 1] := 0.8075727567979578e-1;
    c2[2, 2] := 0.5628142923227016;
    c2[3, 1] := 0.8015440554413301e-1;
    c2[3, 2] := 0.5538087696879930;
    c2[4, 1] := 0.7931239302677386e-1;
    c2[4, 2] := 0.5412833323304460;
    c2[5, 1] := 0.7823314328639347e-1;
    c2[5, 2] := 0.5253190555393968;
    c2[6, 1] := 0.7691895211595101e-1;
    c2[6, 2] := 0.5060183741977191;
    c2[7, 1] := 0.7537237072011853e-1;
    c2[7, 2] := 0.4835036020049034;
    c2[8, 1] := 0.7359601294804538e-1;
    c2[8, 2] := 0.4579149413954837;
    c2[9, 1] := 0.7159227884849299e-1;
    c2[9, 2] := 0.4294078049978829;
    c2[10, 1] := 0.6936295002846032e-1;
    c2[10, 2] := 0.3981491350382047;
    c2[11, 1] := 0.6690857785828917e-1;
    c2[11, 2] := 0.3643121502867948;
    c2[12, 1] := 0.6422751692085542e-1;
    c2[12, 2] := 0.3280684291406284;
    c2[13, 1] := 0.6131430866206096e-1;
    c2[13, 2] := 0.2895750997170303;
    c2[14, 1] := 0.5815677249570920e-1;
    c2[14, 2] := 0.2489521814805720;
    c2[15, 1] := 0.5473023527947980e-1;
    c2[15, 2] := 0.2062377435955363;
    c2[16, 1] := 0.5098441033167034e-1;
    c2[16, 2] := 0.1612849131645336;
    c2[17, 1] := 0.4680658811093562e-1;
    c2[17, 2] := 0.1134672937045305;
    c2[18, 1] := 0.4186928031694695e-1;
    c2[18, 2] := 0.6042754777339966e-1;
  <font color="blue">elseif </font>order == 38<font color="blue"> then</font>
    alpha := 0.1392625697140030;
    c2[1, 1] := 0.7916943373658329e-1;
    c2[1, 2] := 0.5624158631591745;
    c2[2, 1] := 0.7894592250257840e-1;
    c2[2, 2] := 0.5590219398777304;
    c2[3, 1] := 0.7849941672384930e-1;
    c2[3, 2] := 0.5522551628416841;
    c2[4, 1] := 0.7783093084875645e-1;
    c2[4, 2] := 0.5421574325808380;
    c2[5, 1] := 0.7694193770482690e-1;
    c2[5, 2] := 0.5287909941093643;
    c2[6, 1] := 0.7583430534712885e-1;
    c2[6, 2] := 0.5122376814029880;
    c2[7, 1] := 0.7451020436122948e-1;
    c2[7, 2] := 0.4925978555548549;
    c2[8, 1] := 0.7297197617673508e-1;
    c2[8, 2] := 0.4699889739625235;
    c2[9, 1] := 0.7122194706992953e-1;
    c2[9, 2] := 0.4445436860615774;
    c2[10, 1] := 0.6926216260386816e-1;
    c2[10, 2] := 0.4164072786327193;
    c2[11, 1] := 0.6709399961255503e-1;
    c2[11, 2] := 0.3857341621868851;
    c2[12, 1] := 0.6471757977022456e-1;
    c2[12, 2] := 0.3526828388476838;
    c2[13, 1] := 0.6213084287116965e-1;
    c2[13, 2] := 0.3174082831364342;
    c2[14, 1] := 0.5932799638550641e-1;
    c2[14, 2] := 0.2800495563550299;
    c2[15, 1] := 0.5629672408524944e-1;
    c2[15, 2] := 0.2407078154782509;
    c2[16, 1] := 0.5301264751544952e-1;
    c2[16, 2] := 0.1994026830553859;
    c2[17, 1] := 0.4942673259817896e-1;
    c2[17, 2] := 0.1559719194038917;
    c2[18, 1] := 0.4542996716979947e-1;
    c2[18, 2] := 0.1097844277878470;
    c2[19, 1] := 0.4070720755433961e-1;
    c2[19, 2] := 0.5852181110523043e-1;
  <font color="blue">elseif </font>order == 39<font color="blue"> then</font>
    alpha := 0.1374332900196804;
    c1[1] := 0.2779468246419593;
    c2[1, 1] := 0.7715084161825772e-1;
    c2[1, 2] := 0.5543001331300056;
    c2[2, 1] := 0.7684028301163326e-1;
    c2[2, 2] := 0.5495289890712267;
    c2[3, 1] := 0.7632343924866024e-1;
    c2[3, 2] := 0.5416083298429741;
    c2[4, 1] := 0.7560141319808483e-1;
    c2[4, 2] := 0.5305846713929198;
    c2[5, 1] := 0.7467569064745969e-1;
    c2[5, 2] := 0.5165224112570647;
    c2[6, 1] := 0.7354807648551346e-1;
    c2[6, 2] := 0.4995030679271456;
    c2[7, 1] := 0.7222060351121389e-1;
    c2[7, 2] := 0.4796242430956156;
    c2[8, 1] := 0.7069540462458585e-1;
    c2[8, 2] := 0.4569982440368368;
    c2[9, 1] := 0.6897453353492381e-1;
    c2[9, 2] := 0.4317502624832354;
    c2[10, 1] := 0.6705970959388781e-1;
    c2[10, 2] := 0.4040159353969854;
    c2[11, 1] := 0.6495194541066725e-1;
    c2[11, 2] := 0.3739379843169939;
    c2[12, 1] := 0.6265098412417610e-1;
    c2[12, 2] := 0.3416613843816217;
    c2[13, 1] := 0.6015440984955930e-1;
    c2[13, 2] := 0.3073260166338746;
    c2[14, 1] := 0.5745615876877304e-1;
    c2[14, 2] := 0.2710546723961181;
    c2[15, 1] := 0.5454383762391338e-1;
    c2[15, 2] := 0.2329316824061170;
    c2[16, 1] := 0.5139340231935751e-1;
    c2[16, 2] := 0.1929604256043231;
    c2[17, 1] := 0.4795705862458131e-1;
    c2[17, 2] := 0.1509655259246037;
    c2[18, 1] := 0.4412933231935506e-1;
    c2[18, 2] := 0.1063130748962878;
    c2[19, 1] := 0.3960672309405603e-1;
    c2[19, 2] := 0.5672356837211527e-1;
  <font color="blue">elseif </font>order == 40<font color="blue"> then</font>
    alpha := 0.1356742655825434;
    c2[1, 1] := 0.7538038374294594e-1;
    c2[1, 2] := 0.5488228264329617;
    c2[2, 1] := 0.7518806529402738e-1;
    c2[2, 2] := 0.5458297722483311;
    c2[3, 1] := 0.7480383050347119e-1;
    c2[3, 2] := 0.5398604576730540;
    c2[4, 1] := 0.7422847031965465e-1;
    c2[4, 2] := 0.5309482987446206;
    c2[5, 1] := 0.7346313704205006e-1;
    c2[5, 2] := 0.5191429845322307;
    c2[6, 1] := 0.7250930053201402e-1;
    c2[6, 2] := 0.5045099368431007;
    c2[7, 1] := 0.7136868456879621e-1;
    c2[7, 2] := 0.4871295553902607;
    c2[8, 1] := 0.7004317764946634e-1;
    c2[8, 2] := 0.4670962098860498;
    c2[9, 1] := 0.6853470921527828e-1;
    c2[9, 2] := 0.4445169164956202;
    c2[10, 1] := 0.6684507689945471e-1;
    c2[10, 2] := 0.4195095960479698;
    c2[11, 1] := 0.6497570123412630e-1;
    c2[11, 2] := 0.3922007419030645;
    c2[12, 1] := 0.6292726794917847e-1;
    c2[12, 2] := 0.3627221993494397;
    c2[13, 1] := 0.6069918741663154e-1;
    c2[13, 2] := 0.3312065181294388;
    c2[14, 1] := 0.5828873983769410e-1;
    c2[14, 2] := 0.2977798532686911;
    c2[15, 1] := 0.5568964389813015e-1;
    c2[15, 2] := 0.2625503293999835;
    c2[16, 1] := 0.5288947816690705e-1;
    c2[16, 2] := 0.2255872486520188;
    c2[17, 1] := 0.4986456327645859e-1;
    c2[17, 2] := 0.1868796731919594;
    c2[18, 1] := 0.4656832613054458e-1;
    c2[18, 2] := 0.1462410193532463;
    c2[19, 1] := 0.4289867647614935e-1;
    c2[19, 2] := 0.1030361558710747;
    c2[20, 1] := 0.3856310684054106e-1;
    c2[20, 2] := 0.5502423832293889e-1;
  <font color="blue">elseif </font>order == 41<font color="blue"> then</font>
    alpha := 0.1339811106984253;
    c1[1] := 0.2713685065531391;
    c2[1, 1] := 0.7355140275160984e-1;
    c2[1, 2] := 0.5413274778282860;
    c2[2, 1] := 0.7328319082267173e-1;
    c2[2, 2] := 0.5371064088294270;
    c2[3, 1] := 0.7283676160772547e-1;
    c2[3, 2] := 0.5300963437270770;
    c2[4, 1] := 0.7221298133014343e-1;
    c2[4, 2] := 0.5203345998371490;
    c2[5, 1] := 0.7141302173623395e-1;
    c2[5, 2] := 0.5078728971879841;
    c2[6, 1] := 0.7043831559982149e-1;
    c2[6, 2] := 0.4927768111819803;
    c2[7, 1] := 0.6929049381827268e-1;
    c2[7, 2] := 0.4751250308594139;
    c2[8, 1] := 0.6797129849758392e-1;
    c2[8, 2] := 0.4550083840638406;
    c2[9, 1] := 0.6648246325101609e-1;
    c2[9, 2] := 0.4325285673076087;
    c2[10, 1] := 0.6482554675958526e-1;
    c2[10, 2] := 0.4077964789091151;
    c2[11, 1] := 0.6300169683004558e-1;
    c2[11, 2] := 0.3809299858742483;
    c2[12, 1] := 0.6101130648543355e-1;
    c2[12, 2] := 0.3520508315700898;
    c2[13, 1] := 0.5885349417435808e-1;
    c2[13, 2] := 0.3212801560701271;
    c2[14, 1] := 0.5652528148656809e-1;
    c2[14, 2] := 0.2887316252774887;
    c2[15, 1] := 0.5402021575818373e-1;
    c2[15, 2] := 0.2545001287790888;
    c2[16, 1] := 0.5132588802608274e-1;
    c2[16, 2] := 0.2186415296842951;
    c2[17, 1] := 0.4841900639702602e-1;
    c2[17, 2] := 0.1811322622296060;
    c2[18, 1] := 0.4525419574485134e-1;
    c2[18, 2] := 0.1417762065404688;
    c2[19, 1] := 0.4173260173087802e-1;
    c2[19, 2] := 0.9993834530966510e-1;
    c2[20, 1] := 0.3757210572966463e-1;
    c2[20, 2] := 0.5341611499960143e-1;
  <font color="blue">else</font>
    <font color="red">Streams.error</font>(&quot;Input argument order (= &quot; +<font color="red"> String</font>(order) +
      &quot;) of Bessel filter is not in the range 1..41&quot;);
  <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>BesselCoefficients;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE 'p+a'<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.ZerosAndPoles.Internal.'p+a'"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal"
>Modelica_LinearSystems2.ZerosAndPoles.Internal</A>.'p+a'</H2>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>p</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>a</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>c</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> &#39;p+a&#39;
  <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> p;
  <font color="blue">input </font>Real a;
  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> c;
<font color="blue">protected </font>
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> j =<font color="red"> Modelica_LinearSystems2.Math.Complex.j</font>();
<font color="blue">algorithm </font>
  c := p.re + p.im*j +a;
<font color="blue">end </font>&#39;p+a&#39;;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE 'p^2+k[1]*p+k[2]'<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.ZerosAndPoles.Internal.'p^2+k[1]*p+k[2]'"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal"
>Modelica_LinearSystems2.ZerosAndPoles.Internal</A>.'p^2+k[1]*p+k[2]'</H2>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>p</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>k[2]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>c</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> &#39;p^2+k[1]*p+k[2]&#39;
  <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
  <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams.print"
>Modelica.Utilities.Streams.print</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> p;
  <font color="blue">input </font>Real k[2];
  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> c;
<font color="blue">protected </font>
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> c1;
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> c2;
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> c3;
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> c4;
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> j =<font color="red"> Modelica_LinearSystems2.Math.Complex.j</font>();
<font color="blue">algorithm </font>
  c := p.re^2 - p.im^2 + k[1]*p.re + k[2]+p.im*(2*p.re + k[1])*j;

<font color="blue">end </font>&#39;p^2+k[1]*p+k[2]&#39;;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE roots<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.ZerosAndPoles.Internal.roots"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal"
>Modelica_LinearSystems2.ZerosAndPoles.Internal</A>.roots</H2>
<B>Determine zeros of factorized polynomial</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>poly1[:]</TD><TD>&nbsp;</TD><TD>[p^0] coefficients of first order polynomials</TD></TR>
<TR><TD>Real</TD><TD>poly2[:, 2]</TD><TD>&nbsp;</TD><TD>[p, p^0] coefficients of second order polynomials</TD></TR>
<TR><TD>Integer</TD><TD>n_real</TD><TD>&nbsp;</TD><TD>Number of real zeros computed with Internal.numberOfRealZeros</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>realZeros[n_real]</TD><TD>All real zeros of poly1 and poly2</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>complexZeros[:]</TD><TD>All complex zeros of poly1 and poly2; for a complex conjugate pair, only one zero is stored</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> roots <font color="darkgreen">&quot;Determine zeros of factorized polynomial&quot;</font>
  <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

  <font color="blue">input </font>Real poly1[:] <font color="darkgreen">&quot;[p^0] coefficients of first order polynomials&quot;</font>;
  <font color="blue">input </font>Real poly2[:,2] <font color="darkgreen">&quot;[p, p^0] coefficients of second order polynomials&quot;</font>;
  <font color="blue">input </font>Integer n_real <font color="darkgreen">
    &quot;Number of real zeros computed with Internal.numberOfRealZeros&quot;</font>;
  <font color="blue">output </font>Real realZeros[n_real] <font color="darkgreen">&quot;All real zeros of poly1 and poly2&quot;</font>;
  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> complexZeros[:]=<font color="red">fill</font>(<font color="red">Complex</font>(0, 0),<font color="red"> integer</font>((<font color="red">size</font>(poly1, 1)
       + 2*<font color="red">size</font>(poly2, 1) - n_real)/2)) <font color="darkgreen">
    &quot;All complex zeros of poly1 and poly2; for a complex conjugate pair, only one zero is stored&quot;</font>;
<font color="blue">protected </font>
  Integer np1=<font color="red">size</font>(poly1, 1);
  Integer np2=<font color="red">size</font>(poly2, 1);
  Real D;
  Real D2;
  Real b;
  Integer j1;
  Integer j2;
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> j =<font color="red"> Modelica_LinearSystems2.Math.Complex.j</font>();

<font color="blue">algorithm </font>
  <font color="red">assert</font>(np1 &lt;= n_real, &quot;Size of poly1 = &quot; +<font color="red"> String</font>(np1) + &quot; &gt; n_real &quot; +
    &quot; (= &quot; +<font color="red"> String</font>(n_real) + &quot;).&quot;);
  <font color="blue">for </font>i<font color="blue"> in </font>1:np1<font color="blue"> loop</font>
    realZeros[i] := -poly1[i];
  <font color="blue">end for</font>;

  j1 := np1 + 1;
  j2 := 1;
  <font color="blue">for </font>i<font color="blue"> in </font>1:np2<font color="blue"> loop</font>
    b := poly2[i, 1]/2;
    D := b*b - poly2[i, 2];
    D2 :=<font color="red"> sqrt</font>(<font color="red">abs</font>(D));
    <font color="blue">if </font>D &gt;= 0<font color="blue"> then</font>
      realZeros[j1] := -b + D2;
      realZeros[j1 + 1] := -b - D2;
      j1 := j1 + 2;
    <font color="blue">else</font>
      complexZeros[j2] := -b+D2*j;
      j2 := j2 + 1;
    <font color="blue">end if</font>;
  <font color="blue">end for</font>;
<font color="blue">end </font>roots;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE frequencyRange<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.ZerosAndPoles.Internal.frequencyRange"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal"
>Modelica_LinearSystems2.ZerosAndPoles.Internal</A>.frequencyRange</H2>
<B>Determine min. and max. resonance frequencies</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>poly1[:]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>poly2[:, 2]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Boolean</TD><TD>w_found</TD><TD>&nbsp;</TD></TR>
<TR><TD><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>AngularVelocity</A></TD><TD>w_min</TD><TD>[rad/s]</TD></TR>
<TR><TD><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>AngularVelocity</A></TD><TD>w_max</TD><TD>[rad/s]</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> frequencyRange <font color="darkgreen">
  &quot;Determine min. and max. resonance frequencies&quot;</font>
  <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

  <font color="blue">input </font>Real poly1[:];
  <font color="blue">input </font>Real poly2[:,2];
  <font color="blue">output </font>Boolean w_found=false;
  <font color="blue">output </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>Modelica.SIunits.AngularVelocity</A> w_min;
  <font color="blue">output </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>Modelica.SIunits.AngularVelocity</A> w_max;
<font color="blue">protected </font>
  Integer order=<font color="red">size</font>(poly1, 1) + 2*<font color="red">size</font>(poly2, 1);
  Integer n_real=<font color="red">numberOfRealZeros</font>(poly1, poly2);
  Real zeros1[n_real];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> zeros2[:]=<font color="red">fill</font>(<font color="red">Complex</font>(0, 0),<font color="red"> integer</font>((order - n_real)/2));
  Real w;
<font color="blue">algorithm </font>
  <font color="darkgreen">// Compute zeros</font>
  (zeros1,zeros2) :=<font color="red"> roots</font>(
        poly1,
        poly2,
        n_real);

  <font color="darkgreen">// Compute resonance frequencies</font>
  w_min := Modelica.Constants.inf;
  w_max := -Modelica.Constants.inf;
  <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(zeros1, 1)<font color="blue"> loop</font>
    <font color="blue">if </font>zeros1[i] &lt;&gt; 0<font color="blue"> then</font>
      w :=<font color="red"> abs</font>(zeros1[i]);
      w_min :=<font color="red"> min</font>(w_min, w);
      w_max :=<font color="red"> max</font>(w_max, w);
      w_found := true;
    <font color="blue">end if</font>;
  <font color="blue">end for</font>;

  <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(zeros2, 1)<font color="blue"> loop</font>
    w :=<font color="red"> Complex.&#39;abs&#39;</font>(zeros2[i]);
    w_min :=<font color="red"> min</font>(w_min, w);
    w_max :=<font color="red"> max</font>(w_max, w);
    w_found := true;
  <font color="blue">end for</font>;
<font color="blue">end </font>frequencyRange;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE frequencyRangeBode<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.ZerosAndPoles.Internal.frequencyRangeBode"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal"
>Modelica_LinearSystems2.ZerosAndPoles.Internal</A>.frequencyRangeBode</H2>
<B>Determine min. and max. frequencies for Bode plot</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A></TD><TD>tf</TD><TD>&nbsp;</TD><TD>ZerosAndPoles transfer function</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>AngularVelocity</A></TD><TD>w_min</TD><TD>[rad/s]</TD></TR>
<TR><TD><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>AngularVelocity</A></TD><TD>w_max</TD><TD>[rad/s]</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> frequencyRangeBode <font color="darkgreen">
  &quot;Determine min. and max. frequencies for Bode plot&quot;</font>
  <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> tf <font color="darkgreen">&quot;ZerosAndPoles transfer function&quot;</font>;
  <font color="blue">output </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>Modelica.SIunits.AngularVelocity</A> w_min;
  <font color="blue">output </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_SIunits.html#Modelica.SIunits.AngularVelocity"
>Modelica.SIunits.AngularVelocity</A> w_max;
<font color="blue">protected </font>
  Real phi_min=<font color="red">Modelica.SIunits.Conversions.from_deg</font>(3);
  Real real_min=1.0e-4;
  Real pi=Modelica.Constants.pi;
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> numZeros[:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> denZeros[:];
  Integer n_num;
  Integer n_den;
  Real w_min1;
  Real w_min2;
  Real w_max1;
  Real w_max2;
<font color="blue">algorithm </font>
  <font color="darkgreen">// Compute zeros and poles</font>
  (numZeros,denZeros) :=<font color="red"> ZerosAndPoles.Analysis.zerosAndPoles</font>(tf);

  <font color="darkgreen">// Compute frequencies for numerator</font>
  n_num :=<font color="red"> size</font>(numZeros, 1);
  <font color="blue">if </font>n_num &gt; 0<font color="blue"> then</font>
    (w_min1,w_max1) :=<font color="red"> Modelica_LinearSystems2.Internal.frequencyRangeZeros</font>(
          numZeros,
          phi_min,
          real_min);
  <font color="blue">end if</font>;

  <font color="darkgreen">// Compute frequencies for denominator</font>
  n_den :=<font color="red"> size</font>(denZeros, 1);
  <font color="blue">if </font>n_den &gt; 0<font color="blue"> then</font>
    (w_min2,w_max2) :=<font color="red"> Modelica_LinearSystems2.Internal.frequencyRangeZeros</font>(
          denZeros,
          phi_min,
          real_min);
  <font color="blue">end if</font>;

  <font color="darkgreen">// Use largest range</font>
  <font color="blue">if </font>n_num == 0<font color="blue"> and </font>n_den == 0<font color="blue"> then</font>
    w_min := 0.1;
    w_max := 10;
  <font color="blue">elseif </font>n_num == 0<font color="blue"> then</font>
    w_min := w_min2;
    w_max := w_max2;
  <font color="blue">elseif </font>n_den == 0<font color="blue"> then</font>
    w_min := w_min1;
    w_max := w_max1;
  <font color="blue">else</font>
    w_min :=<font color="red"> min</font>(w_min1, w_min2);
    w_max :=<font color="red"> max</font>(w_max1, w_max2);
  <font color="blue">end if</font>;
<font color="blue">end </font>frequencyRangeBode;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE filterToNormalized<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.ZerosAndPoles.Internal.filterToNormalized"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal"
>Modelica_LinearSystems2.ZerosAndPoles.Internal</A>.filterToNormalized</H2>
<B>Given [p^2,p] and [p] coefficients, transform to normalized form with highest power of p equal 1</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>c1[:]</TD><TD>&nbsp;</TD><TD>[p] coefficients of polynomials (a*p + 1)</TD></TR>
<TR><TD>Real</TD><TD>c2[:, 2]</TD><TD>&nbsp;</TD><TD>[p^2, p] coefficients of polynomials (b*p^2 + a*p + 1)</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>n1[size(c1, 1)]</TD><TD>[p^0] coefficients of polynomials a*(p+1/a)</TD></TR>
<TR><TD>Real</TD><TD>n2[size(c2, 1), 2]</TD><TD>[p, p^0] coefficients of polynomials b*(p^2 + (a/b)*p + (1/b))</TD></TR>
<TR><TD>Real</TD><TD>k</TD><TD>Gain (product(1/a)*(1/b)</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> filterToNormalized <font color="darkgreen">
  &quot;Given [p^2,p] and [p] coefficients, transform to normalized form with highest power of p equal 1&quot;</font>

  <font color="blue">input </font>Real c1[:] <font color="darkgreen">&quot;[p] coefficients of polynomials (a*p + 1)&quot;</font>;
  <font color="blue">input </font>Real c2[:,2] <font color="darkgreen">&quot;[p^2, p] coefficients of polynomials (b*p^2 + a*p + 1)&quot;</font>;
  <font color="blue">output </font>Real n1[<font color="red">size</font>(c1, 1)] <font color="darkgreen">&quot;[p^0] coefficients of polynomials a*(p+1/a)&quot;</font>;
  <font color="blue">output </font>Real n2[<font color="red">size</font>(c2, 1),2] <font color="darkgreen">
    &quot;[p, p^0] coefficients of polynomials b*(p^2 + (a/b)*p + (1/b))&quot;</font>;
  <font color="blue">output </font>Real k <font color="darkgreen">&quot;Gain (product(1/a)*(1/b)&quot;</font>;
<font color="blue">algorithm </font>
  k := 1.0;
  <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(c1, 1)<font color="blue"> loop</font>
    k := k*c1[i];
    n1[i] := 1/c1[i];
  <font color="blue">end for</font>;

  <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(c2, 1)<font color="blue"> loop</font>
    k := k*c2[i, 1];
    n2[i, 1] := c2[i, 2]/c2[i, 1];
    n2[i, 2] := 1/c2[i, 1];
  <font color="blue">end for</font>;
<font color="blue">end </font>filterToNormalized;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE numberOfRealZeros<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.ZerosAndPoles.Internal.numberOfRealZeros"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal"
>Modelica_LinearSystems2.ZerosAndPoles.Internal</A>.numberOfRealZeros</H2>
<B>Calculate number of real zeros</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>poly1[:]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>poly2[:, 2]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>result</TD><TD>Number of real zeros</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> numberOfRealZeros <font color="darkgreen">
  &quot;Calculate number of real zeros&quot;</font>
  <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;

  <font color="blue">input </font>Real poly1[:];
  <font color="blue">input </font>Real poly2[:,2];
  <font color="blue">output </font>Integer result <font color="darkgreen">&quot;Number of real zeros&quot;</font>;
<font color="blue">protected </font>
  Real D;
<font color="blue">algorithm </font>
  result :=<font color="red"> size</font>(poly1, 1);
  <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(poly2, 1)<font color="blue"> loop</font>
    D := (poly2[i, 1]/2)^2 - poly2[i, 2];
    <font color="blue">if </font>D &gt;= 0<font color="blue"> then</font>
      <font color="darkgreen">  // two real zeros</font>
      result := result + 2;
    <font color="blue">end if</font>;
  <font color="blue">end for</font>;
<font color="blue">end </font>numberOfRealZeros;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE numberOfRealZeros2<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.ZerosAndPoles.Internal.numberOfRealZeros2"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal"
>Modelica_LinearSystems2.ZerosAndPoles.Internal</A>.numberOfRealZeros2</H2>
<B>Calculate number of real zeros</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A></TD><TD>tf</TD><TD>&nbsp;</TD><TD>TransferFunction</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>result</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> numberOfRealZeros2 <font color="darkgreen">&quot;Calculate number of real zeros&quot;</font>
  <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Modelica_LinearSystems2.Math.Polynomial</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf <font color="darkgreen">&quot;TransferFunction&quot;</font>;
  <font color="blue">output </font>Integer result=<font color="red">Internal.numberOfRealZeros</font>(<font color="red">Polynomial.roots</font>(<font color="red">Polynomial</font>(tf.n)));
<font color="blue">algorithm </font>
<font color="blue">end </font>numberOfRealZeros2;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE numberOfRealPoles<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.ZerosAndPoles.Internal.numberOfRealPoles"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal"
>Modelica_LinearSystems2.ZerosAndPoles.Internal</A>.numberOfRealPoles</H2>
<B>Calculate number of real poles</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A></TD><TD>tf</TD><TD>&nbsp;</TD><TD>TransferFunction</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>result</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> numberOfRealPoles <font color="darkgreen">&quot;Calculate number of real poles&quot;</font>
  <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>Modelica_LinearSystems2.TransferFunction</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Polynomial"
>Modelica_LinearSystems2.Math.Polynomial</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.TransferFunction"
>TransferFunction</A> tf <font color="darkgreen">&quot;TransferFunction&quot;</font>;
<font color="blue">output </font>Integer result=<font color="red">Internal.numberOfRealZeros</font>(<font color="red">Polynomial.roots</font>(<font color="red">Polynomial</font>(tf.d)));
<font color="blue">algorithm </font>
<font color="blue">end </font>numberOfRealPoles;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE isRoot<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.ZerosAndPoles.Internal.isRoot"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal"
>Modelica_LinearSystems2.ZerosAndPoles.Internal</A>.isRoot</H2>
<B>check if frequency is an element of the complex vector zeros</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>zeros[:]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>p</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>eps</TD><TD>0</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Boolean</TD><TD>result</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> isRoot <font color="darkgreen">
  &quot;check if frequency is an element of the complex vector zeros&quot;</font>

  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
  <font color="darkgreen">//import Modelica_LinearSystems2;</font>

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> zeros[:];
  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> p;
<font color="darkgreen">//Never used</font>
  <font color="blue">input </font>Real eps(min=0) = 0;
  <font color="blue">output </font>Boolean result;

<font color="blue">protected </font>
  Integer sz=<font color="red">size</font>(zeros, 1);
  Integer i;

<font color="blue">algorithm </font>
  i := 1;
  result := false;
  <font color="blue">while </font>i &lt;= sz<font color="blue"> and </font><font color="blue">not </font>result<font color="blue"> loop</font>

<font color="darkgreen">//The implementation of Complex.&#39;==&#39; does not take a third parameter.</font>
    result := p == zeros[i];
    i := i + 1;
  <font color="blue">end while</font>;

<font color="blue">end </font>isRoot;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE numberOfRealZerosAndPoles_zp<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.ZerosAndPoles.Internal.numberOfRealZerosAndPoles_zp"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal"
>Modelica_LinearSystems2.ZerosAndPoles.Internal</A>.numberOfRealZerosAndPoles_zp</H2>
<B>Get the number of first oder polynomials (n1, d1) and second order polynomials (n2, d2) of zeros and poles from zeros and poles written in a MAT-file</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>fileName</TD><TD>DataDir + &quot;/zp.mat&quot;</TD><TD>Name of the zeros and poles data file</TD></TR>
<TR><TD>Real</TD><TD>eps</TD><TD>Modelica.Constants.eps</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>n1n2d1d2[4]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> numberOfRealZerosAndPoles_zp <font color="darkgreen">
  &quot;Get the number of first oder polynomials (n1, d1) and second order polynomials (n2, d2) of zeros and poles from zeros and poles written in a MAT-file&quot;</font>

  <font color="blue">import </font>Modelica_LinearSystems2.DataDir;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal"
>Modelica_LinearSystems2.Internal</A>;

  <font color="blue">input </font>String fileName=DataDir + &quot;/zp.mat&quot; <font color="darkgreen">
    &quot;Name of the zeros and poles data file&quot;</font>;
  <font color="blue">input </font>Real eps=Modelica.Constants.eps;

  <font color="blue">output </font>Integer n1n2d1d2[4];

<font color="blue">protected </font>
  Integer n1;
  Integer d1;

  Integer zSize[2]=<font color="red">readMatrixSize</font>(fileName, &quot;z&quot;);
  Integer pSize[2]=<font color="red">readMatrixSize</font>(fileName, &quot;p&quot;);

  Real zerosMatrix[zSize[1],zSize[2]]=<font color="red">readMatrix</font>(
          fileName,
          &quot;z&quot;,
          zSize[1],
          zSize[2]) <font color="darkgreen">&quot;zeros in rows of real parts and imaginary parts&quot;</font>;
  Real polesMatrix[pSize[1],pSize[2]]=<font color="red">readMatrix</font>(
          fileName,
          &quot;p&quot;,
          pSize[1],
          pSize[2]) <font color="darkgreen">&quot;poles in rows of real parts and imaginary parts&quot;</font>;

<font color="blue">algorithm </font>
  n1 := zSize[1];
  d1 := pSize[1];
  <font color="blue">for </font>i<font color="blue"> in </font>1:zSize[1]<font color="blue"> loop</font>
    <font color="blue">if </font><font color="red">abs</font>(zerosMatrix[i, 2]) &gt;= eps<font color="blue"> then</font>
      n1 := n1 - 1;
    <font color="blue">end if</font>;
  <font color="blue">end for</font>;
  <font color="blue">for </font>i<font color="blue"> in </font>1:pSize[1]<font color="blue"> loop</font>
    <font color="blue">if </font><font color="red">abs</font>(polesMatrix[i, 2]) &gt;= eps<font color="blue"> then</font>
      d1 := d1 - 1;
    <font color="blue">end if</font>;
  <font color="blue">end for</font>;
  n1n2d1d2[1] := n1;
  n1n2d1d2[2] :=<font color="red"> div</font>((zSize[1] - n1), 2);
  n1n2d1d2[3] := d1;
  n1n2d1d2[4] :=<font color="red"> div</font>((pSize[1] - d1), 2);

<font color="blue">end </font>numberOfRealZerosAndPoles_zp;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE numberOfRealZerosAndPoles_pc<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.ZerosAndPoles.Internal.numberOfRealZerosAndPoles_pc"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal"
>Modelica_LinearSystems2.ZerosAndPoles.Internal</A>.numberOfRealZerosAndPoles_pc</H2>
<B>Generate a zeros and poles data record by reading the polynomial coefficients from a file (default file name is zp.mat)</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>fileName</TD><TD>&quot;pc.mat&quot;</TD><TD>Name of the zeros and poles data file</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>n1n2d1d2[4]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> numberOfRealZerosAndPoles_pc <font color="darkgreen">
  &quot;Generate a zeros and poles data record by reading the polynomial coefficients from a file (default file name is zp.mat)&quot;</font>
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
  <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;

  <font color="blue">input </font>String fileName=&quot;pc.mat&quot; <font color="darkgreen">&quot;Name of the zeros and poles data file&quot;</font>;
  <font color="blue">output </font>Integer n1n2d1d2[4];

<font color="blue">protected </font>
  Integer n1Size[2]=<font color="red">readMatrixSize</font>(fileName, &quot;n1&quot;);
  Integer n2Size[2]=<font color="red">readMatrixSize</font>(fileName, &quot;n2&quot;);
  Integer d1Size[2]=<font color="red">readMatrixSize</font>(fileName, &quot;d1&quot;);
  Integer d2Size[2]=<font color="red">readMatrixSize</font>(fileName, &quot;d2&quot;);

<font color="blue">algorithm </font>
  n1n2d1d2[1] := n1Size[1];
  n1n2d1d2[2] := n2Size[1];
  n1n2d1d2[3] := d1Size[1];
  n1n2d1d2[4] := d2Size[1];

<font color="blue">end </font>numberOfRealZerosAndPoles_pc;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE isControllableAndObservableSISO<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.ZerosAndPoles.Internal.isControllableAndObservableSISO"></A><A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.ZerosAndPoles.Internal"
>Modelica_LinearSystems2.ZerosAndPoles.Internal</A>.isControllableAndObservableSISO</H2>
<B>To check whether a SISO system is controllable and observable</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A></TD><TD>zp</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Boolean</TD><TD>controllableAndObservable</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">function</font> isControllableAndObservableSISO <font color="darkgreen">
  &quot;To check whether a SISO system is controllable and observable&quot;</font>

  <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>Modelica_LinearSystems2.ZerosAndPoles</A>;

<font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.ZerosAndPoles"
>ZerosAndPoles</A> zp;

  <font color="blue">output </font>Boolean controllableAndObservable;
<font color="blue">protected </font>
  <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss=<font color="red">StateSpace</font>(zp);

<font color="blue">algorithm </font>
  controllableAndObservable :=<font color="red"> StateSpace.Internal.isControllableAndObservableSISO</font>(ss=ss);

<font color="blue">end </font>isControllableAndObservableSISO;
</PRE>
<HR>
<address>HTML-documentation generated by <a href="http://www.Dymola.com/">Dymola</a> Fri Jan 15 12:29:00 2010.
</address></BODY>
</HTML>
