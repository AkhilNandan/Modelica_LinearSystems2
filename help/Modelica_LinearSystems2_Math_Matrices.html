<HTML>
<HEAD>
<TITLE>Modelica_LinearSystems2.Math.Matrices</TITLE>
<META name="HTML-Generator" content="Dymola">
<META name="description" content="&quot;Additional functions for Modelica.Math&quot;">
<style type="text/css">
*       { font-size: 10pt; font-family: Arial,sans-serif; }
pre     { font-size:  9pt; font-family: Courier,monospace;}
h4      { font-size: 10pt; font-weight: bold; color: green; }
h3      { font-size: 11pt; font-weight: bold; color: green; }
h2      { font-size: 13pt; font-weight: bold; color: green; }
address {                  font-weight: normal} 
td      { solid #000; vertical-align:top; }
th      { solid #000; vertical-align:top; font-weight: bold; }
table   { solid #000; border-collapse: collapse;}
</style>
</HEAD>
<BODY><P>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Matrices<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices"></A><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math"
>Modelica_LinearSystems2.Math</A>.Matrices</H2>
<B>Additional functions for Modelica.Math</B>
<P>
<P><H3>Information</H3></P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons_Library.html#Modelica.Icons.Library"
>Modelica.Icons.Library</A> (Icon for library).
<P><H3>Package Content</H3><p>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 >
<TR><TH >Name</TH><TH>Description</TH></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.LAPACKS.png" ALT="Modelica_LinearSystems2.Math.Matrices.LAPACK" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>LAPACK</A>
</TD><TD>&nbsp;</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.LAPACKS.png" ALT="Modelica_LinearSystems2.Math.Matrices.Examples" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices_Examples.html#Modelica_LinearSystems2.Math.Matrices.Examples"
>Examples</A>
</TD><TD>&nbsp;</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.careS.png" ALT="Modelica_LinearSystems2.Math.Matrices.care" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.care"
>care</A>
</TD><TD>Solution of continuous-time algebraic Riccati equations</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.careS.png" ALT="Modelica_LinearSystems2.Math.Matrices.dare" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.dare"
>dare</A>
</TD><TD>Solution of discrete-time algebraic Riccati equations</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.conditionNumberS.png" ALT="Modelica_LinearSystems2.Math.Matrices.conditionNumber" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.conditionNumber"
>conditionNumber</A>
</TD><TD>Calculate the condition number norm(A)*norm(inv(A))</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.conditionNumberS.png" ALT="Modelica_LinearSystems2.Math.Matrices.det" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.det"
>det</A>
</TD><TD>Determinant of a matrix (computed by LU decomposition)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.conditionNumberS.png" ALT="Modelica_LinearSystems2.Math.Matrices.eigenValues" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.eigenValues"
>eigenValues</A>
</TD><TD>Compute eigenvalues and eigenvectors for a real, nonsymmetric matrix</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.conditionNumberS.png" ALT="Modelica_LinearSystems2.Math.Matrices.equalityLeastSquares" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.equalityLeastSquares"
>equalityLeastSquares</A>
</TD><TD>Solve a linear equality constrained least squares problem</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.fliplrS.png" ALT="Modelica_LinearSystems2.Math.Matrices.fliplr" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.fliplr"
>fliplr</A>
</TD><TD>flip the columns of a matrix in left/right direction</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.fliplrS.png" ALT="Modelica_LinearSystems2.Math.Matrices.flipud" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.flipud"
>flipud</A>
</TD><TD>flip the columns of a matrix in up/down direction</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.fliplrS.png" ALT="Modelica_LinearSystems2.Math.Matrices.fromFile" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.fromFile"
>fromFile</A>
</TD><TD>Read matrix from a matlab file</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.fliplrS.png" ALT="Modelica_LinearSystems2.Math.Matrices.generalizedEigenvaluesTriangular" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.generalizedEigenvaluesTriangular"
>generalizedEigenvaluesTriangular</A>
</TD><TD>Compute invariant zeros of linear state space system with a genralized system matrix [A, B, C, D] which is of upper Hessenberg form</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.fliplrS.png" ALT="Modelica_LinearSystems2.Math.Matrices.hessenberg" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.hessenberg"
>hessenberg</A>
</TD><TD>Compute an upper Hessenberg matrix by repeatedly applicated householder similarity transformation</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.fliplrS.png" ALT="Modelica_LinearSystems2.Math.Matrices.householderReflexion" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.householderReflexion"
>householderReflexion</A>
</TD><TD>reflect each of the vectors ai of matrix  A=[a1, a2, ..., an] on a plane with orthogonal vector u</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.fliplrS.png" ALT="Modelica_LinearSystems2.Math.Matrices.householderSimilarityTransformation" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.householderSimilarityTransformation"
>householderSimilarityTransformation</A>
</TD><TD>Calculate the similarity transformation SAS of matrix A with householder matrix S = I - 2u*u&#39;</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.leastSquaresS.png" ALT="Modelica_LinearSystems2.Math.Matrices.leastSquares" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.leastSquares"
>leastSquares</A>
</TD><TD>Solve overdetermined or underdetermined real system of linear equations A*x=b in a least squares sense (A may be rank deficient)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.leastSquaresS.png" ALT="Modelica_LinearSystems2.Math.Matrices.LU" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.LU"
>LU</A>
</TD><TD>LU decomposition of square or rectangular matrix</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.leastSquaresS.png" ALT="Modelica_LinearSystems2.Math.Matrices.LU_solve" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.LU_solve"
>LU_solve</A>
</TD><TD>Solve real system of linear equations P*L*U*x=b with a b vector and an LU decomposition (from LU(..))</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.LU_solve2S.png" ALT="Modelica_LinearSystems2.Math.Matrices.LU_solve2" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.LU_solve2"
>LU_solve2</A>
</TD><TD>Solve real system of linear equations P*L*U*X=B with a B vector and an LU decomposition (from LU(..))</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.LU_solve2S.png" ALT="Modelica_LinearSystems2.Math.Matrices.lyapunov" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.lyapunov"
>lyapunov</A>
</TD><TD>Solution of continuous-time Lyapunov equation X*A + A&#39;*X = C</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.normS.png" ALT="Modelica_LinearSystems2.Math.Matrices.norm" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.norm"
>norm</A>
</TD><TD>Returns the norm of a matrix</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.normS.png" ALT="Modelica_LinearSystems2.Math.Matrices.nullspace" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.nullspace"
>nullspace</A>
</TD><TD>Orthonormal nullspace of a matrix</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.orthogonalQS.png" ALT="Modelica_LinearSystems2.Math.Matrices.orthogonalQ" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.orthogonalQ"
>orthogonalQ</A>
</TD><TD>generates a real orthogonal matrix Q which is defined as the product of IHI-ILO elementary reflectors of order N, as returned by DGEHRD</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.orthogonalQS.png" ALT="Modelica_LinearSystems2.Math.Matrices.printMatrix" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.printMatrix"
>printMatrix</A>
</TD><TD>print matrix</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.orthogonalQS.png" ALT="Modelica_LinearSystems2.Math.Matrices.QR" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.QR"
>QR</A>
</TD><TD>QR decomposition of a square matrix without column pivoting (A = Q*R)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.rcondS.png" ALT="Modelica_LinearSystems2.Math.Matrices.rcond" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.rcond"
>rcond</A>
</TD><TD>Reciprocal condition number</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.rsfS.png" ALT="Modelica_LinearSystems2.Math.Matrices.rsf" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.rsf"
>rsf</A>
</TD><TD>Computes the real Schur form (RSF) of a square matrix</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.rsfS.png" ALT="Modelica_LinearSystems2.Math.Matrices.rsf2" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.rsf2"
>rsf2</A>
</TD><TD>Computes the real Schur form (RSF) of a square matrix but uses lapack.dgees</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.solveS.png" ALT="Modelica_LinearSystems2.Math.Matrices.solve" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.solve"
>solve</A>
</TD><TD>Solve real system of linear equations A*x=b with a b vector (Gaussian elemination with partial pivoting)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.solveS.png" ALT="Modelica_LinearSystems2.Math.Matrices.solve2" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.solve2"
>solve2</A>
</TD><TD>Solve real system of linear equations A*X=B with a B matrix (Gaussian elemination with partial pivoting)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.sylvesterS.png" ALT="Modelica_LinearSystems2.Math.Matrices.sylvester" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.sylvester"
>sylvester</A>
</TD><TD>Solution of continuous-time Sylvester equation A*X + X*B = C</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.sylvesterS.png" ALT="Modelica_LinearSystems2.Math.Matrices.toUpperHessenberg" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.toUpperHessenberg"
>toUpperHessenberg</A>
</TD><TD>transform a real general matrix A to upper Hessenberg form H by an orthogonal similarity transformation:  Q&#39; * A * Q = H</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.traceS.png" ALT="Modelica_LinearSystems2.Math.Matrices.trace" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.trace"
>trace</A>
</TD><TD>tarce(A) is the sum of the diagonal elements of A</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.InternalS.png" ALT="Modelica_LinearSystems2.Math.Matrices.Internal" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices_Internal.html#Modelica_LinearSystems2.Math.Matrices.Internal"
>Internal</A>
</TD><TD>&nbsp;</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE care<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.care"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.care</H2>
<B>Solution of continuous-time algebraic Riccati equations</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
 
 
Function <b>care</b> computes the solution <b>X</b> of the continuous-time algebraic Riccati equation
<blockquote><pre>
 <b>Q</b> + <b>A</b>'*<b>X</b> + <b>X</b>*<b>A</b> - <b>X</b>*<b>G</b>*<b>X</b> = <b>0</b> 
</pre></blockquote>
with
<blockquote><pre>
       -1
<b>G</b> = <b>B</b>*<b>R</b> *<b>B</b>' 
</pre>
</blockquote>
using the Schur vector approach proposed by Laub [1].
<p>
It is assumed that <b>Q</b> is symmetric and positve semidefinite and <b>R</b> is symmetric, nonsingular and positive definite,
(<b>A</b>,<b>B</b>) is stabilizable and (<b>A</b>,<b>Q</b>) is detectable.
<p><b>
The assumptions are not checked in this function
</b>
<p>
The assumptions guarantee that Hamiltonian matrix 
<blockquote><pre>
<b>H</b> = [<b>A</b>, -<b>G</b>; -<b>Q</b>, -<b>A</b>']
</pre></blockquote>
has no pure imaginary eigenvalue and can be put
to an ordered real Schur form 
<blockquote><pre>
<b>U</b>'*<b>H</b>*<b>U</b> = <b>S</b> = [<b>S</b>11, <b>S</b>12; <b>0</b>, <b>S</b>22]
</pre></blockquote>
with orthogonal similarity transformation <b>U</b>. <b>S</b> is ordered in such a way,
that <b>S11</b> contains the n stable eigenvalues of the closed loop system with system matrix
<blockquote><pre>
       -1
<b>A</b> - <b>B</b>*<b>R</b> *<b>B</b>'*<b>X</b>
</pre></blockquote>
If <b>U</b> is partitioned to 
<blockquote><pre>
<b>U</b> = [<b>U</b>11, <b>U</b>12; <b>U</b>21, <b>U</b>22]
</pre></blockquote>
with dimenstions according to <b>S</b>, the solution <b>X</b> can be calculated by
<blockquote><pre>
<b>X</b>*<b>U</b>11 = <b>U</b>21.
</pre></blockquote>
 
The algorithm uses LAPACK routines dgehrd (to compute the upper Hessenberg matrix of <b>H</b>), dorghr (to calculate the orthogonal
matrix from the elementary reflectors as returned from dgehrd), dhseqr (to put transformed <b>H</b> to Schur form and to calculate the eigenvalues 
of the closed loop system) and dtrsen (to compute the ordered real Schur form and matrix <b>U</b>).
 
<p>
 
 
<A name="References"><B><FONT SIZE="+1">References</FONT></B></A>
<PRE>
  [1] Laub, A.J.
      A Schur Method for Solving Algebraic Riccati equations.
      IEEE Trans. Auto. Contr., AC-24, pp. 913-921, 1979.
</PRE>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>B[size(A, 1), :]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>R[size(B, 2), size(B, 2)]</TD><TD>identity(size(B, 2))</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>Q[size(A, 1), size(A, 1)]</TD><TD>identity(size(A, 1))</TD><TD>&nbsp;</TD></TR>
<TR><TD>Boolean</TD><TD>refine</TD><TD>false</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>X[size(A, 1), size(A, 2)]</TD><TD>stabilizing solution of CARE</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>ev[size(A, 1)]</TD><TD>eigenvalues of the closed loop system</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> care <font color="darkgreen">
  &quot;Solution of continuous-time algebraic Riccati equations&quot;</font>
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

  <font color="blue">input </font>Real A[:,<font color="red">size</font>(A, 1)];
  <font color="blue">input </font>Real B[<font color="red">size</font>(A, 1),:];
  <font color="blue">input </font>Real R[<font color="red">size</font>(B, 2),<font color="red">size</font>(B, 2)]=<font color="red">identity</font>(<font color="red">size</font>(B, 2));
  <font color="blue">input </font>Real Q[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 1)]=<font color="red">identity</font>(<font color="red">size</font>(A, 1));
  <font color="blue">input </font>Boolean refine = false;
<font color="blue">protected </font>
  Integer n=<font color="red">size</font>(A, 1);
  Real G[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 1)]=B*<font color="red">Modelica.Math.Matrices.solve2</font>(R,<font color="red"> transpose</font>(B));
  Real H[:,:]=[A,-G; -Q,-<font color="red">transpose</font>(A)];
  Real H_RSF[:,:]=H;
  Real Z[<font color="red">size</font>(H, 1),<font color="red">size</font>(H, 2)];
  Real Z11[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)];
  Real Z21[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)];
  Real alphaReal[<font color="red">size</font>(H, 1)] <font color="darkgreen">&quot;Real part of eigenvalue=alphaReal+i*alphaImag&quot;</font>;
  Real alphaImag[<font color="red">size</font>(H, 1)] <font color="darkgreen">
    &quot;Imaginary part of eigenvalue=(alphaReal+i*alphaImag&quot;</font>;
  Integer info;
  Integer evSize;
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> xc[2];
<font color="blue">public </font>
  <font color="blue">output </font>Real X[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)] <font color="darkgreen">&quot;stabilizing solution of CARE&quot;</font>;
  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> ev[<font color="red">size</font>(A, 1)] <font color="darkgreen">&quot;eigenvalues of the closed loop system&quot;</font>;

<font color="blue">algorithm </font>
  <font color="blue">if </font>n &gt; 1<font color="blue"> then</font>
    (H_RSF,Z,alphaReal,alphaImag) :=<font color="red"> Matrices.rsf</font>(H);
    (H_RSF,Z,alphaReal,alphaImag) :=<font color="red"> Matrices.Internal.reorderRSF</font>(
      true,
      H_RSF,
      Z,
      alphaReal,
      alphaImag);

    evSize :=<font color="red"> size</font>(ev, 1);
    <font color="blue">for </font>i<font color="blue"> in </font>1:evSize<font color="blue"> loop</font>
      ev[i] :=<font color="red"> Complex</font>(alphaReal[i], alphaImag[i]);
    <font color="blue">end for</font>;

    Z11 := Z[1:n, 1:n];
    Z21 := Z[n + 1:2*n, 1:n];
    <font color="blue">if </font><font color="red">size</font>(Z11, 1) &gt; 0<font color="blue"> then</font>
<font color="darkgreen">//  X := transpose(Matrices.solve2(transpose(Z11), transpose(Z21)));</font>
      (X,info) :=<font color="red"> Matrices.LAPACK.dgesvx</font>(Z11,<font color="red"> transpose</font>(Z21));
      <font color="darkgreen">//this function does not need to transpose Z11 as solve2 does</font>
      X :=<font color="red"> transpose</font>(X);
      <font color="red">assert</font>(info == 0,
        &quot;Solving a linear system of equations with function \&quot;Matrices.LAPACK.dgesvx\&quot; is not possible, because the system has either no or infinitely many solutions (input A is singular).&quot;);
      <font color="blue">if </font>refine<font color="blue"> then</font>
        X :=<font color="red"> Matrices.Internal.carenls</font>(A, B, R, Q, X);
      <font color="blue">end if</font>;
    <font color="blue">else</font>
      X :=<font color="red"> fill</font>(
        0,
        <font color="red">size</font>(Z21, 1),
        <font color="red">size</font>(Z11, 1));
    <font color="blue">end if</font>;

  <font color="blue">elseif </font>n == 1<font color="blue"> then</font>
    xc :=<font color="red"> Polynomial.roots</font>(<font color="red">Polynomial</font>({-G[1, 1],2*A[1, 1],Q[1, 1]}));
    X :=<font color="red"> matrix</font>(-<font color="red">abs</font>(xc[1].re));
  <font color="blue">else</font>
    X :=<font color="red"> fill</font>(0, 0, 0);
  <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>care;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE dare<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.dare"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.dare</H2>
<B>Solution of discrete-time algebraic Riccati equations</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
Function <b>dare</b> computes the solution <b>X</b> of the discrete-time algebraic Riccati equation
<blockquote><pre>
                                 -1
 <b>X</b> = <b>A</b>'*<b>X</b>*<b>A</b> - <b>A</b>'*<b>X</b>*<b>B</b>*(<b>R</b> + <b>B</b>'*<b>X</b>*<b>B</b>)  *<b>B</b>'*<b>X</b>*<b>A</b> + <b>Q</b>
</pre>
</blockquote>
using the Schur vector approach proposed by Laub [1].
<p>
It is assumed that <b>Q</b> is symmetric and positve semidefinite and <b>R</b> is symmetric, nonsingular and positive definite,
(<b>A</b>,<b>B</b>) is stabilizable and (<b>A</b>,<b>Q</b>) is detectable.
<p><b>
The assumptions are not checked in this function
</b>
 
<p>
The assumptions guarantee that the Hamiltonian matrix 
<blockquote><pre>
      -1  -1       -1        -1
<b>H</b> = [<b>A</b>, -<b>A</b>  *<b>G</b>; <b>Q</b>*<b>A</b>, <b>A</b>' + <b>Q</b>*<b>A</b>  *<b>G</b> ]
</pre></blockquote>
with
<blockquote><pre>
       -1
<b>G</b> = <b>B</b>*<b>R</b> *<b>B</b>' 
</pre>
</blockquote>
has no eigenvalue on the unit circle and can be put
to an ordered real Schur form 
<blockquote><pre>
<b>U</b>'*<b>H</b>*<b>U</b> = <b>S</b> = [<b>S11</b>, <b>S12</b>; <b>0</b>, <b>S22</b>]
</pre></blockquote>
with orthogonal similarity transformation <b>U</b>. <b>S</b> is ordered in such a way,
that <b>S11</b> contains the n stable eigenvalues of the closed loop system with system matrix
<blockquote><pre>
                  -1
<b>A</b> - <b>B</b>*(<b>R</b> + <b>B</b>'*<b>X</b>*<b>B</b>)  *<b>B</b>'*<b>X</b>*<b>A</b>
</pre>
</blockquote>
If <b>U</b> is partitioned to 
<blockquote><pre>
<b>U</b> = [<b>U11</b>, <b>U12</b>; <b>U21</b>, <b>U22</b>]
</pre></blockquote>
according to <b>S</b>, the solution <b>X</b> can be calculated by
<blockquote><pre>
<b>X</b>*<b>U11</b> = <b>U21</b>.
</pre></blockquote>
 
The algorithm uses LAPACK routines dgehrd (to compute the upper Hessenberg matrix of <b>H</b>), dorghr (to calculate the orthogonal
matrix from the elementary reflectors as returned from dgehrd), dhseqr (to put transformed <b>H</b> to Schur form and to calculate the eigenvalues 
of the closed loop system) and dtrsen (to compute the ordered real Schur form and matrix <b>U</b>).
<p>
 
<A name="References"><B><FONT SIZE="+1">References</FONT></B></A>
<PRE>
  [1] Laub, A.J.
      A Schur Method for Solving Algebraic Riccati equations.
      IEEE Trans. Auto. Contr., AC-24, pp. 913-921, 1979.
</PRE>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>B[size(A, 1), :]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>R[size(B, 2), size(B, 2)]</TD><TD>identity(size(B, 2))</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>Q[size(A, 1), size(A, 1)]</TD><TD>identity(size(A, 1))</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>S[size(A, 1), size(A, 2)]</TD><TD>orthogonal matrix of the Schur vectors associated to ordered rsf</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>ev[size(A, 1)]</TD><TD>eigenvalues of the closed loop system</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> dare <font color="darkgreen">&quot;Solution of discrete-time algebraic Riccati equations&quot;</font>
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;

  <font color="blue">input </font>Real A[:,<font color="red">size</font>(A, 1)];
  <font color="blue">input </font>Real B[<font color="red">size</font>(A, 1),:];
  <font color="blue">input </font>Real R[<font color="red">size</font>(B, 2),<font color="red">size</font>(B, 2)]=<font color="red">identity</font>(<font color="red">size</font>(B, 2));
  <font color="blue">input </font>Real Q[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 1)]=<font color="red">identity</font>(<font color="red">size</font>(A, 1));
<font color="blue">protected </font>
  Integer n=<font color="red">size</font>(A, 1);
  Real G[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 1)]=B*<font color="red">Modelica.Math.Matrices.solve2</font>(R,<font color="red"> transpose</font>(B));
  Real invAT[:,:]=<font color="red">transpose</font>(<font color="red">Modelica.Math.Matrices.inv</font>(A));
  Real H[:,:]=[A + G*invAT*Q,-G*invAT; -invAT*Q,invAT];
  Real H_RSF[:,:]=H;
  Real Z[<font color="red">size</font>(H, 1),<font color="red">size</font>(H, 2)];
  Real Z11[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)];
  Real Z21[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)];
  Real alphaReal[<font color="red">size</font>(H, 1)] <font color="darkgreen">&quot;Real part of eigenvalue=alphaReal+i*alphaImag&quot;</font>;
  Real alphaImag[<font color="red">size</font>(H, 1)] <font color="darkgreen">
    &quot;Imaginary part of eigenvalue=(alphaReal+i*alphaImag&quot;</font>;

  Integer info;
  Integer evSize;
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> j =<font color="red"> Modelica_LinearSystems2.Math.Complex.j</font>();
<font color="blue">public </font>
  <font color="blue">output </font>Real S[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)] <font color="darkgreen">
    &quot;orthogonal matrix of the Schur vectors associated to ordered rsf&quot;</font>;
  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> ev[<font color="red">size</font>(A, 1)] <font color="darkgreen">&quot;eigenvalues of the closed loop system&quot;</font>;

<font color="blue">algorithm </font>
  (H_RSF,Z,alphaReal,alphaImag) :=<font color="red"> Matrices.rsf</font>(H);<font color="darkgreen">// put H to Schur form</font>
  (H_RSF,Z,alphaReal,alphaImag) :=<font color="red"> Matrices.Internal.reorderRSF</font>(
    false,
    H_RSF,
    Z,
    alphaReal,
    alphaImag);<font color="darkgreen">// ordered Schur form</font>
    evSize :=<font color="red"> size</font>(ev, 1);
  <font color="blue">for </font>i<font color="blue"> in </font>1:evSize<font color="blue"> loop</font>
    ev[i] := alphaReal[i] + j*alphaImag[i];
  <font color="blue">end for</font>;

  Z11 := Z[1:n, 1:n];
  Z21 := Z[n + 1:2*n, 1:n];
  <font color="blue">if </font><font color="red">size</font>(Z11, 1) &gt; 0<font color="blue"> then</font>
<font color="darkgreen">//  S := transpose(Matrices.solve2(transpose(Z11), transpose(Z21)));</font>
    (S,info) :=<font color="red"> Matrices.LAPACK.dgesvx</font>(Z11,<font color="red"> transpose</font>(Z21));<font color="darkgreen">//function does not need to transpose Z11 as solve2 does</font>
    S :=<font color="red"> transpose</font>(S);
    <font color="red">assert</font>(info == 0, &quot;Solving a linear system of equations with function
\&quot;Matrices.LAPACK.dgesvx\&quot; is not possible, because the system has either 
no or infinitely many solutions (input A is singular).&quot;);
  <font color="blue">else</font>
    S :=<font color="red"> fill</font>(
      0,
      <font color="red">size</font>(Z21, 1),
      <font color="red">size</font>(Z11, 1));
  <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>dare;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE conditionNumber<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Math.Matrices.conditionNumberI.png" ALT="Modelica_LinearSystems2.Math.Matrices.conditionNumber" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.conditionNumber"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.conditionNumber</H2>
<B>Calculate the condition number norm(A)*norm(inv(A))</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
  <h4>Syntax</h4>
<blockquote><pre>
r = Matrices.<b>conditionNumber</b>(A);
</pre></blockquote>
<h4>Description</h4>
<p>
This function calculates the the condition number (norm(A) * norm(inv(A))) of a general real matrix A, in either the 1-norm, 2-norm or the infinity-norm.
In the case of 2-norm the result is he ratio of the largest to the smallest singular value to A.
</p>
<p>
<h4>Example</h4>
<blockquote><pre>
  A = [1, 2
       2, 1];
  r = conditionNumber(A);
  
  results in:
  
  r = 3.0
</pre></blockquote>
</p>
<h4>See also</h4>
<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.rcond"
>Matrices.rcond</a>
<pre></PRE><P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, :]</TD><TD>&nbsp;</TD><TD>Input matrix</TD></TR>
<TR><TD>Real</TD><TD>p</TD><TD>2</TD><TD>Type of p-norm (only allowed: 1, 2 or Modelica.Constants.inf)</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>result</TD><TD>p-norm of matrix A</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> conditionNumber <font color="darkgreen">
  &quot;Calculate the condition number norm(A)*norm(inv(A))&quot;</font>
  <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;

  <font color="blue">input </font>Real A[:,:] <font color="darkgreen">&quot;Input matrix&quot;</font>;
  <font color="blue">input </font>Real p(min=1) = 2 <font color="darkgreen">
    &quot;Type of p-norm (only allowed: 1, 2 or Modelica.Constants.inf)&quot;</font>;
  <font color="blue">output </font>Real result=0.0 <font color="darkgreen">&quot;p-norm of matrix A&quot;</font>;

<font color="blue">protected </font>
  Real eps=1e-25;
  Real s[<font color="red">size</font>(A, 1)] <font color="darkgreen">&quot;singular values&quot;</font>;

<font color="blue">algorithm </font>
  <font color="blue">if </font>p == 2<font color="blue"> then</font>
    s :=<font color="red"> Modelica.Math.Matrices.singularValues</font>(A);
    <font color="blue">if </font><font color="red">min</font>(s) &lt; eps<font color="blue"> then</font>
result := Modelica.Constants.inf;
    <font color="blue">else</font>
result :=<font color="red"> max</font>(s)/<font color="red">min</font>(s);
    <font color="blue">end if</font>;
  <font color="blue">else</font>
    result :=<font color="red"> Modelica.Math.Matrices.norm</font>(A, p)*<font color="red">Modelica.Math.Matrices.norm</font>(
      <font color="red">Modelica.Math.Matrices.inv</font>(A), p);
  <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>conditionNumber;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE det<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Math.Matrices.conditionNumberI.png" ALT="Modelica_LinearSystems2.Math.Matrices.det" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.det"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.det</H2>
<B>Determinant of a matrix (computed by LU decomposition)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>det</b>(A);
</pre></blockquote>
<h4>Description</h4>
<p>
This function call returns the determinant of matrix A
computed by a LU decomposition.
Usally, this function should never be used, because
there are nearly always better numerical algorithms
as by computing the determinant. E.g., use function
<A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Math_Matrices.html#Modelica.Math.Matrices.rank"
>Matrices.rank</a>
to compute the rank of a matrix.
<h4>See also</h4>
<A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Math_Matrices.html#Modelica.Math.Matrices.rank"
>Matrices.rank</a>,
<A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve"
>Matrices.solve</a>
<pre></PRE><P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>result</TD><TD>Determinant of matrix A</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> det <font color="darkgreen">&quot;Determinant of a matrix (computed by LU decomposition)&quot;</font>

  <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>Real A[:,<font color="red">size</font>(A, 1)];
  <font color="blue">output </font>Real result <font color="darkgreen">&quot;Determinant of matrix A&quot;</font>;
<font color="blue">protected </font>
  Real LU[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 1)];
  Integer pivots[<font color="red">size</font>(A, 1)];

<font color="blue">algorithm </font>
  <font color="blue">if </font><font color="red">size</font>(LU, 1) &gt; 0<font color="blue"> then</font>
    (LU,pivots) :=<font color="red"> Modelica_LinearSystems2.Math.Matrices.LU</font>(A);
    result :=<font color="red"> product</font>(LU[i, i] <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(A, 1))*<font color="red">product</font>(<font color="blue">if </font>pivots[i] == i<font color="blue"> then </font>
            1<font color="blue"> else </font>-1 <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(pivots, 1));
  <font color="blue">else</font>
    result := -1e100;
  <font color="blue">end if</font>;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>det;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE eigenValues<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Math.Matrices.conditionNumberI.png" ALT="Modelica_LinearSystems2.Math.Matrices.eigenValues" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.eigenValues"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.eigenValues</H2>
<B>Compute eigenvalues and eigenvectors for a real, nonsymmetric matrix</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
                eigenvalues = Matrices.<b>eigenValues</b>(A);
(eigenvalues, eigenvectors) = Matrices.<b>eigenValues</b>(A);
</pre></blockquote>
<h4>Description</h4>
<p>
This function call returns the eigenvalues and 
optionally the (right) eigenvectors of a square matrix 
<b>A</b>. The first column of "eigenvalues" contains the real and the
second column contains the imaginary part of the eigenvalues.
If the i-th eigenvalue has no imaginary part, then eigenvectors[:,i] is
the corresponding real eigenvector. If the i-th eigenvalue
has an imaginary part, then eigenvalues[i+1,:] is the conjugate complex
eigenvalue and eigenvectors[:,i] is the real and eigenvectors[:,i+1] is the
imaginary part of the eigenvector of the i-th eigenvalue.
With function 
<A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Math_Matrices.html#Modelica.Math.Matrices.eigenValueMatrix"
>Matrices.eigenValueMatrix</a>,
a real block diagonal matrix is constructed from the eigenvalues 
such that 
</p>
<blockquote>
<pre>
A = eigenvectors * eigenValueMatrix(eigenvalues) * inv(eigenvectors)
</pre>
</blockquote>
<p>
provided the eigenvector matrix "eigenvectors" can be inverted
(an inversion is possible, if all eigenvalues are different
and no eigenvalue is zero).
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3; 
                 3,4,5;
                 2,1,4];
  Real eval;
<b>algorithm</b>
  eval := Matrices.eigenValues(A);  // eval = [-0.618, 0; 
                                    //          8.0  , 0;
                                    //          1.618, 0];
</pre>
</blockquote>
<p>
i.e., matrix A has the 3 real eigenvalues -0.618, 8, 1.618.
</p>
</pre></blockquote>
<h4>See also</h4>
<A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Math_Matrices.html#Modelica.Math.Matrices.eigenValueMatrix"
>Matrices.eigenValueMatrix</a>,
<A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Math_Matrices.html#Modelica.Math.Matrices.singularValues"
>Matrices.singularValues</a>
<pre>
</PRE><P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>Matrix</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>eigenvalues[size(A, 1), 2]</TD><TD>Eigenvalues of matrix A (Re: first column, Im: second column)</TD></TR>
<TR><TD>Real</TD><TD>leftEigenvectors[size(A, 1), size(A, 2)]</TD><TD>Real-valued eigenvector matrix</TD></TR>
<TR><TD>Real</TD><TD>rightEigenvectors[size(A, 1), size(A, 2)]</TD><TD>Real-valued eigenvector matrix</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> eigenValues <font color="darkgreen">
  &quot;Compute eigenvalues and eigenvectors for a real, nonsymmetric matrix&quot;</font>

  <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;

  <font color="blue">input </font>Real A[:,<font color="red"> size</font>(A, 1)] <font color="darkgreen">&quot;Matrix&quot;</font>;
  <font color="blue">output </font>Real eigenvalues[<font color="red">size</font>(A, 1), 2] <font color="darkgreen">
    &quot;Eigenvalues of matrix A (Re: first column, Im: second column)&quot;</font>;

  <font color="blue">output </font>Real leftEigenvectors[<font color="red">size</font>(A,1),<font color="red"> size</font>(A,2)] <font color="darkgreen">
    &quot;Real-valued eigenvector matrix&quot;</font>;
 <font color="blue">output </font>Real rightEigenvectors[<font color="red">size</font>(A,1),<font color="red"> size</font>(A,2)] <font color="darkgreen">
    &quot;Real-valued eigenvector matrix&quot;</font>;

<font color="blue">protected </font>
  Integer info;
  Boolean onlyEigenvalues = false;
<font color="blue">algorithm </font>
<font color="blue">if </font><font color="red">size</font>(A,1) &gt; 0<font color="blue"> then</font>
  <font color="blue">if </font>onlyEigenvalues<font color="blue"> then</font>
      (eigenvalues[:, 1],eigenvalues[:, 2],info) :=
        <font color="red">Modelica.Math.Matrices.LAPACK.dgeev_eigenValues</font>(A);
     rightEigenvectors :=<font color="red">zeros</font>(<font color="red">size</font>(A, 1),<font color="red"> size</font>(A, 1));
     leftEigenvectors :=<font color="red">zeros</font>(<font color="red">size</font>(A, 1),<font color="red"> size</font>(A, 1));
  <font color="blue">else</font>
      (eigenvalues[:, 1],eigenvalues[:, 2],leftEigenvectors,rightEigenvectors,info) :=<font color="red"> Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeev</font>(A);
  <font color="blue">end if</font>;
  <font color="red">assert</font>(info == 0, &quot;Calculating the eigenvalues with function
\&quot;Matrices.eigenvalues\&quot; is not possible, since the
numerical algorithm does not converge.&quot;);
<font color="blue">end if</font>;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>eigenValues;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE equalityLeastSquares<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Math.Matrices.conditionNumberI.png" ALT="Modelica_LinearSystems2.Math.Matrices.equalityLeastSquares" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.equalityLeastSquares"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.equalityLeastSquares</H2>
<B>Solve a linear equality constrained least squares problem</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
x = Matrices.<b>equalityLeastSquares</b>(A,a,B,b);
</pre></blockquote>
<h4>Description</h4>
<p>
This function returns the
solution <b>x</b> of the linear equality-constrained least squares problem:
</p>
<blockquote>
<p>
min|<b>A</b>*<b>x</b> - <b>a</b>|^2 over <b>x</b>, subject to <b>B</b>*<b>x</b> = <b>b</b>
</p>
</blockquote>
 
<p>
It is required that the dimensions of A and B fulfill the following
relationship:
</p>
 
<blockquote>
size(B,1) &le; size(A,2) &le; size(A,1) + size(B,1)
</blockquote>
 
<p>
Note, the solution is computed with the LAPACK function "dgglse"
using the generalized RQ factorization under the assumptions that
B has full row rank (= size(B,1)) and the matrix [A;B] has
full column rank (= size(A,2)). In this case, the problem
has a unique solution.
</p>
<pre></PRE><P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, :]</TD><TD>&nbsp;</TD><TD>Minimize |A*x - a|^2</TD></TR>
<TR><TD>Real</TD><TD>a[size(A, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>B[:, size(A, 2)]</TD><TD>&nbsp;</TD><TD>subject to B*x=b</TD></TR>
<TR><TD>Real</TD><TD>b[size(B, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>x[size(A, 2)]</TD><TD>solution vector</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> equalityLeastSquares <font color="darkgreen">
  &quot;Solve a linear equality constrained least squares problem&quot;</font>
  <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>Real A[:,:] <font color="darkgreen">&quot;Minimize |A*x - a|^2&quot;</font>;
  <font color="blue">input </font>Real a[<font color="red">size</font>(A, 1)];
  <font color="blue">input </font>Real B[:,<font color="red">size</font>(A, 2)] <font color="darkgreen">&quot;subject to B*x=b&quot;</font>;
  <font color="blue">input </font>Real b[<font color="red">size</font>(B, 1)];
  <font color="blue">output </font>Real x[<font color="red">size</font>(A, 2)] <font color="darkgreen">&quot;solution vector&quot;</font>;

<font color="blue">protected </font>
  Integer info;
<font color="blue">algorithm </font>
  <font color="blue">if </font><font color="red">Modelica.Math.Matrices.rank</font>(<font color="red">cat</font>(
      1,
      A,
      B)) ==<font color="red"> size</font>(A, 2)<font color="blue"> and </font><font color="red">min</font>(<font color="red">size</font>(A)) &gt; 0<font color="blue"> then</font>

    (x,info) :=<font color="red"> Modelica.Math.Matrices.LAPACK.dgglse_vec</font>(
      A,
      a,
      B,
      b);

    <font color="red">assert</font>(info == 0, &quot;Solving a linear equality-constrained least squares problem 
with function \&quot;Matrices.equalityLeastSquares\&quot; failed.&quot;);
  <font color="blue">else</font>
    <font color="blue">if </font><font color="red">size</font>(A, 2) == 0<font color="blue"> then</font>
      x :=<font color="red"> fill</font>(0, 0);
    <font color="blue">else</font>
      x :=<font color="red"> Modelica_LinearSystems2.Math.Matrices.leastSquares</font>(<font color="red">cat</font>(
        1,
        A,
        B),<font color="red"> cat</font>(
        1,
        a,
        b));
    <font color="blue">end if</font>;
  <font color="blue">end if</font>;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>equalityLeastSquares;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE fliplr<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.fliplr"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.fliplr</H2>
<B>flip the columns of a matrix in left/right direction</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, :]</TD><TD>&nbsp;</TD><TD>Matrix to be fliped</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>Aflip[size(A, 1), size(A, 2)]</TD><TD>fliped matrix</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> fliplr <font color="darkgreen">
  &quot;flip the columns of a matrix in left/right direction&quot;</font>
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;

  <font color="blue">input </font>Real A[:,:] <font color="darkgreen">&quot;Matrix to be fliped&quot;</font>;
  <font color="blue">output </font>Real Aflip[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)] <font color="darkgreen">&quot;fliped matrix&quot;</font>;
<font color="blue">algorithm </font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(A, 2)<font color="blue"> loop</font>
    Aflip[:, i] := A[:,<font color="red"> size</font>(A, 2) + 1 - i];
  <font color="blue">end for</font>;
<font color="blue">end </font>fliplr;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE flipud<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.flipud"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.flipud</H2>
<B>flip the columns of a matrix in up/down direction</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, :]</TD><TD>&nbsp;</TD><TD>Matrix to be fliped</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>Aflip[size(A, 1), size(A, 2)]</TD><TD>fliped matrix</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> flipud <font color="darkgreen">&quot;flip the columns of a matrix in up/down direction&quot;</font>
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;

  <font color="blue">input </font>Real A[:,:] <font color="darkgreen">&quot;Matrix to be fliped&quot;</font>;
  <font color="blue">output </font>Real Aflip[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)] <font color="darkgreen">&quot;fliped matrix&quot;</font>;
<font color="blue">algorithm </font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(A, 2)<font color="blue"> loop</font>
    Aflip[i,:] := A[<font color="red">size</font>(A, 2) + 1 - i,:];
  <font color="blue">end for</font>;
<font color="blue">end </font>flipud;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE fromFile<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.fromFile"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.fromFile</H2>
<B>Read matrix from a matlab file</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>fileName</TD><TD>DataDir + &quot;m.mat&quot;</TD><TD>&nbsp;</TD></TR>
<TR><TD>String</TD><TD>matrixName</TD><TD>&quot;m&quot;</TD><TD>Name of the matrix</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[n, m]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> fromFile <font color="darkgreen">&quot;Read matrix from a matlab file&quot;</font>
  <font color="blue">input </font>String fileName=DataDir + &quot;m.mat&quot;;
  <font color="blue">input </font>String matrixName=&quot;m&quot; <font color="darkgreen">&quot;Name of the matrix&quot;</font>;

<font color="blue">protected </font>
  <font color="blue">input </font>Integer Msizes[2]=<font color="red">readMatrixSize</font>(fileName, matrixName);
  <font color="blue">input </font>Integer n=Msizes[1];
  <font color="blue">input </font>Integer m=Msizes[2];
  Real M[n,m]=<font color="red">readMatrix</font>(
      fileName,
      matrixName,
      n,
      m);

<font color="blue">public </font>
  <font color="blue">output </font>Real A[n,m]=M;
<font color="blue">algorithm </font>

<font color="blue">end </font>fromFile;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE generalizedEigenvaluesTriangular<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.generalizedEigenvaluesTriangular"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.generalizedEigenvaluesTriangular</H2>
<B>Compute invariant zeros of linear state space system with a genralized system matrix [A, B, C, D] which is of upper Hessenberg form</B><p>
<P><H3>Information</H3></P>
<PRE>This function is an interface to LAPACK routine DHGEQZ to calculate invariant
zeros of systems with generalized system matrices of upper Hessenberg form.
DHGEQZ is described below:
 
 
 
     Purpose  
   ==========================================================
 
   DHGEQZ implements a single-/double-shift version of the QZ method for  
   finding the generalized eigenvalues  
 
   w(j)=(ALPHAR(j) + i*ALPHAI(j))/BETAR(j)   of the equation  
 
        det( A - w(i) B ) = 0  
 
   In addition, the pair A,B may be reduced to generalized Schur form:  
   B is upper triangular, and A is block upper triangular, where the  
   diagonal blocks are either 1-by-1 or 2-by-2, the 2-by-2 blocks having  
   complex generalized eigenvalues (see the description of the argument  
   JOB.)  
 
   If JOB=&#39;S&#39;, then the pair (A,B) is simultaneously reduced to Schur  
   form by applying one orthogonal tranformation (usually called Q) on  
   the left and another (usually called Z) on the right.  The 2-by-2  
   upper-triangular diagonal blocks of B corresponding to 2-by-2 blocks  
   of A will be reduced to positive diagonal matrices.  (I.e.,  
   if A(j+1,j) is non-zero, then B(j+1,j)=B(j,j+1)=0 and B(j,j) and  
   B(j+1,j+1) will be positive.)  
 
   If JOB=&#39;E&#39;, then at each iteration, the same transformations  
   are computed, but they are only applied to those parts of A and B  
   which are needed to compute ALPHAR, ALPHAI, and BETAR.  
 
   If JOB=&#39;S&#39; and COMPQ and COMPZ are &#39;V&#39; or &#39;I&#39;, then the orthogonal  
   transformations used to reduce (A,B) are accumulated into the arrays  
   Q and Z s.t.:  
 
        Q(in) A(in) Z(in)* = Q(out) A(out) Z(out)*  
        Q(in) B(in) Z(in)* = Q(out) B(out) Z(out)*  
 
   Ref: C.B. Moler &amp; G.W. Stewart, &quot;An Algorithm for Generalized Matrix  
        Eigenvalue Problems&quot;, SIAM J. Numer. Anal., 10(1973),  
        pp. 241--256.  
 
   Arguments  
   =========  
 
   JOB     (input) CHARACTER*1  
           = &#39;E&#39;: compute only ALPHAR, ALPHAI, and BETA.  A and B will  
                  not necessarily be put into generalized Schur form.  
           = &#39;S&#39;: put A and B into generalized Schur form, as well  
                  as computing ALPHAR, ALPHAI, and BETA.  
 
   COMPQ   (input) CHARACTER*1  
           = &#39;N&#39;: do not modify Q.  
           = &#39;V&#39;: multiply the array Q on the right by the transpose of  
                  the orthogonal tranformation that is applied to the  
                  left side of A and B to reduce them to Schur form.  
           = &#39;I&#39;: like COMPQ=&#39;V&#39;, except that Q will be initialized to  
                  the identity first.  
 
   COMPZ   (input) CHARACTER*1  
           = &#39;N&#39;: do not modify Z.  
           = &#39;V&#39;: multiply the array Z on the right by the orthogonal  
                  tranformation that is applied to the right side of  
                  A and B to reduce them to Schur form.  
           = &#39;I&#39;: like COMPZ=&#39;V&#39;, except that Z will be initialized to  
                  the identity first.  
 
   N       (input) INTEGER  
           The order of the matrices A, B, Q, and Z.  N &gt;= 0.  
 
   ILO     (input) INTEGER  
   IHI     (input) INTEGER  
           It is assumed that A is already upper triangular in rows and  
           columns 1:ILO-1 and IHI+1:N.  
           1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0; ILO=1 and IHI=0, if N=0.  
 
   A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)  
           On entry, the N-by-N upper Hessenberg matrix A.  Elements  
           below the subdiagonal must be zero.  
           If JOB=&#39;S&#39;, then on exit A and B will have been  
              simultaneously reduced to generalized Schur form.  
           If JOB=&#39;E&#39;, then on exit A will have been destroyed.  
              The diagonal blocks will be correct, but the off-diagonal  
              portion will be meaningless.  
 
   LDA     (input) INTEGER  
           The leading dimension of the array A.  LDA &gt;= max( 1, N ).  
 
   B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)  
           On entry, the N-by-N upper triangular matrix B.  Elements  
           below the diagonal must be zero.  2-by-2 blocks in B  
           corresponding to 2-by-2 blocks in A will be reduced to  
           positive diagonal form.  (I.e., if A(j+1,j) is non-zero,  
           then B(j+1,j)=B(j,j+1)=0 and B(j,j) and B(j+1,j+1) will be  
           positive.)  
           If JOB=&#39;S&#39;, then on exit A and B will have been  
              simultaneously reduced to Schur form.  
           If JOB=&#39;E&#39;, then on exit B will have been destroyed.  
              Elements corresponding to diagonal blocks of A will be  
              correct, but the off-diagonal portion will be meaningless.  
 
   LDB     (input) INTEGER  
           The leading dimension of the array B.  LDB &gt;= max( 1, N ).  
 
   ALPHAR  (output) DOUBLE PRECISION array, dimension (N)  
           ALPHAR(1:N) will be set to real parts of the diagonal  
           elements of A that would result from reducing A and B to  
           Schur form and then further reducing them both to triangular  
           form using unitary transformations s.t. the diagonal of B  
           was non-negative real.  Thus, if A(j,j) is in a 1-by-1 block  
           (i.e., A(j+1,j)=A(j,j+1)=0), then ALPHAR(j)=A(j,j).  
           Note that the (real or complex) values  
           (ALPHAR(j) + i*ALPHAI(j))/BETA(j), j=1,...,N, are the  
           generalized eigenvalues of the matrix pencil A - wB.  
 
   ALPHAI  (output) DOUBLE PRECISION array, dimension (N)  
           ALPHAI(1:N) will be set to imaginary parts of the diagonal  
           elements of A that would result from reducing A and B to  
           Schur form and then further reducing them both to triangular  
           form using unitary transformations s.t. the diagonal of B  
           was non-negative real.  Thus, if A(j,j) is in a 1-by-1 block  
           (i.e., A(j+1,j)=A(j,j+1)=0), then ALPHAR(j)=0.  
           Note that the (real or complex) values  
           (ALPHAR(j) + i*ALPHAI(j))/BETA(j), j=1,...,N, are the  
           generalized eigenvalues of the matrix pencil A - wB.  
 
   BETA    (output) DOUBLE PRECISION array, dimension (N)  
           BETA(1:N) will be set to the (real) diagonal elements of B  
           that would result from reducing A and B to Schur form and  
           then further reducing them both to triangular form using  
           unitary transformations s.t. the diagonal of B was  
           non-negative real.  Thus, if A(j,j) is in a 1-by-1 block  
           (i.e., A(j+1,j)=A(j,j+1)=0), then BETA(j)=B(j,j).  
           Note that the (real or complex) values  
           (ALPHAR(j) + i*ALPHAI(j))/BETA(j), j=1,...,N, are the  
           generalized eigenvalues of the matrix pencil A - wB.  
           (Note that BETA(1:N) will always be non-negative, and no  
           BETAI is necessary.)  
 
   Q       (input/output) DOUBLE PRECISION array, dimension (LDQ, N)  
           If COMPQ=&#39;N&#39;, then Q will not be referenced.  
           If COMPQ=&#39;V&#39; or &#39;I&#39;, then the transpose of the orthogonal  
              transformations which are applied to A and B on the left  
              will be applied to the array Q on the right.  
 
   LDQ     (input) INTEGER  
           The leading dimension of the array Q.  LDQ &gt;= 1.  
           If COMPQ=&#39;V&#39; or &#39;I&#39;, then LDQ &gt;= N.  
 
   Z       (input/output) DOUBLE PRECISION array, dimension (LDZ, N)  
           If COMPZ=&#39;N&#39;, then Z will not be referenced.  
           If COMPZ=&#39;V&#39; or &#39;I&#39;, then the orthogonal transformations  
              which are applied to A and B on the right will be applied  
              to the array Z on the right.  
 
   LDZ     (input) INTEGER  
           The leading dimension of the array Z.  LDZ &gt;= 1.  
           If COMPZ=&#39;V&#39; or &#39;I&#39;, then LDZ &gt;= N.  
 
   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)  
           On exit, if INFO &gt;= 0, WORK(1) returns the optimal LWORK.  
 
   LWORK   (input) INTEGER  
           The dimension of the array WORK.  LWORK &gt;= max(1,N).  
 
           If LWORK = -1, then a workspace query is assumed; the routine  
           only calculates the optimal size of the WORK array, returns  
           this value as the first entry of the WORK array, and no error  
           message related to LWORK is issued by XERBLA.  
 
   INFO    (output) INTEGER  
           = 0: successful exit  
           &lt; 0: if INFO = -i, the i-th argument had an illegal value  
           = 1,...,N: the QZ iteration did not converge.  (A,B) is not  
                      in Schur form, but ALPHAR(i), ALPHAI(i), and  
                      BETA(i), i=INFO+1,...,N should be correct.  
           = N+1,...,2*N: the shift calculation failed.  (A,B) is not  
                      in Schur form, but ALPHAR(i), ALPHAI(i), and  
                      BETA(i), i=INFO-N+1,...,N should be correct.  
           &gt; 2*N:     various &quot;impossible&quot; errors.  
 
   Further Details  
   ===============  
 
   Iteration counters:  
 
   JITER  -- counts iterations.  
   IITER  -- counts iterations run since ILAST was last  
             changed.  This is therefore reset only when a 1-by-1 or  
             2-by-2 block deflates off the bottom.  
 
   =====================================================================  
</PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>B[size(A, 1), size(A, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>alphaReal[size(A, 1)]</TD><TD>Real part of alpha (eigenvalue=(alphaReal+i*alphaImag)/beta)</TD></TR>
<TR><TD>Real</TD><TD>alphaImag[size(A, 1)]</TD><TD>Imaginary part of alpha</TD></TR>
<TR><TD>Real</TD><TD>beta[size(A, 1)]</TD><TD>Denominator of eigenvalue</TD></TR>
<TR><TD>Integer</TD><TD>info</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> generalizedEigenvaluesTriangular <font color="darkgreen">
  &quot;Compute invariant zeros of linear state space system with a genralized system matrix [A, B, C, D] which is of upper Hessenberg form&quot;</font>

  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>;
  <font color="blue">input </font>Real A[:,<font color="red">size</font>(A, 1)];
  <font color="blue">input </font>Real B[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 1)];
  <font color="blue">output </font>Real alphaReal[<font color="red">size</font>(A, 1)] <font color="darkgreen">
    &quot;Real part of alpha (eigenvalue=(alphaReal+i*alphaImag)/beta)&quot;</font>;
  <font color="blue">output </font>Real alphaImag[<font color="red">size</font>(A, 1)] <font color="darkgreen">&quot;Imaginary part of alpha&quot;</font>;
  <font color="blue">output </font>Real beta[<font color="red">size</font>(A, 1)] <font color="darkgreen">&quot;Denominator of eigenvalue&quot;</font>;

  <font color="blue">output </font>Integer info;

<font color="blue">algorithm </font>
  (alphaReal,alphaImag,beta,info) :=<font color="red"> LAPACK.dhgeqz</font>(A, B);
  <font color="red">assert</font>(info == 0, &quot;Failed to compute eigenvalues with function dhgeqz(..)&quot;);
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>generalizedEigenvaluesTriangular;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE hessenberg<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.hessenberg"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.hessenberg</H2>
<B>Compute an upper Hessenberg matrix by repeatedly applicated householder similarity transformation</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
 
This function computes the Hessenberg matrix of matrix <b>A</b> by repetitive application of Householder similarity transformation 
 <pre>
    <b>A</b>i+1 = (<b>I</b>-2*<b>u</b>_i*<b>u</b>_i')*<b>A</b>i*(<b>I</b>-2*<b>u</b>_i*<b>u</b>_i')
</pre>
with Householder vector <b>u</b>_i.
<p>
The elementary transformations can be subsumed under
 <pre> <b>A</b> -> <b>Q</b>*<b>A</b>*<b>Q</b>
</pre>
and <b>Q</b>*<b>A</b>*<b>Q</b> is Hessenberg matrix.
<p>
<b>Modelica_LinearSystems2.Math.Matrices.hess</b> uses LAPACK routine dgehrd. In contrast to this function <b>Modelica_LinearSystems2.Math.Matrices.Internal.hessenberg</b> does not use any LAPACK routine.
 
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>H[size(H, 1), size(H, 2)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>Ht[size(H, 1), size(H, 2)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> hessenberg <font color="darkgreen">
  &quot;Compute an upper Hessenberg matrix by repeatedly applicated householder similarity transformation&quot;</font>
  <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Vectors.html#Modelica_LinearSystems2.Math.Vectors"
>Modelica_LinearSystems2.Math.Vectors</A>;

  <font color="blue">input </font>Real H[<font color="red">size</font>(H, 1),<font color="red">size</font>(H, 2)];

  <font color="blue">output </font>Real Ht[<font color="red">size</font>(H, 1),<font color="red">size</font>(H, 2)];

<font color="blue">protected </font>
  Integer q=<font color="red">size</font>(H, 1);
  Real u[q] <font color="darkgreen">&quot;householder vector&quot;</font>;
  Integer ll;

<font color="blue">algorithm </font>
  Ht :=<font color="red"> Modelica_LinearSystems2.Math.Matrices.toUpperHessenberg</font>(
    H,
    1,
    <font color="red">size</font>(H, 1));

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>hessenberg;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE householderReflexion<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.householderReflexion"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.householderReflexion</H2>
<B>reflect each of the vectors ai of matrix  A=[a1, a2, ..., an] on a plane with orthogonal vector u</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, :]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>u[size(A, 1)]</TD><TD>&nbsp;</TD><TD>householder vector</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>RA[size(A, 1), size(A, 2)]</TD><TD>reflexion of A</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> householderReflexion <font color="darkgreen">
  &quot;reflect each of the vectors ai of matrix  A=[a1, a2, ..., an] on a plane with orthogonal vector u&quot;</font>
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Vectors.html#Modelica_LinearSystems2.Math.Vectors"
>Modelica_LinearSystems2.Math.Vectors</A>;

  <font color="blue">input </font>Real A[:,:];
  <font color="blue">input </font>Real u[<font color="red">size</font>(A, 1)] <font color="darkgreen">&quot;householder vector&quot;</font>;

  <font color="blue">output </font>Real RA[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)] <font color="darkgreen">&quot;reflexion of A&quot;</font>;

<font color="blue">protected </font>
  Integer n=<font color="red">size</font>(A, 2);
  Real h;
  Real lu=<font color="red">Vectors.length</font>(u)*<font color="red">Vectors.length</font>(u);

<font color="blue">algorithm </font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:n<font color="blue"> loop</font>
    h :=<font color="red"> scalar</font>(2*<font color="red">transpose</font>(<font color="red">matrix</font>(u))*A[:, i]/lu);
    RA[:, i] := A[:, i] - h*u;
  <font color="blue">end for</font>;
<font color="blue">end </font>householderReflexion;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE householderSimilarityTransformation<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.householderSimilarityTransformation"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.householderSimilarityTransformation</H2>
<B>Calculate the similarity transformation SAS of matrix A with householder matrix S = I - 2u*u&#39;</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>u[size(A, 1)]</TD><TD>&nbsp;</TD><TD>householder vector</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>SAS[size(A, 1), size(A, 1)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> householderSimilarityTransformation <font color="darkgreen">
  &quot;Calculate the similarity transformation SAS of matrix A with householder matrix S = I - 2u*u&#39;&quot;</font>

  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Vectors.html#Modelica_LinearSystems2.Math.Vectors"
>Modelica_LinearSystems2.Math.Vectors</A>;

  <font color="blue">input </font>Real A[:,<font color="red">size</font>(A, 1)];
  <font color="blue">input </font>Real u[<font color="red">size</font>(A, 1)] <font color="darkgreen">&quot;householder vector&quot;</font>;
  <font color="blue">output </font>Real SAS[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 1)];

<font color="blue">protected </font>
  Integer na=<font color="red">size</font>(A, 1);
  Real S[:,:]=-2*<font color="red">matrix</font>(u)*<font color="red">transpose</font>(<font color="red">matrix</font>(u))/(<font color="red">Vectors.length</font>(u)*
      <font color="red">Vectors.length</font>(u));
  Integer i;
<font color="blue">algorithm </font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:na<font color="blue"> loop</font>
    <font color="darkgreen">               //S=I-2u*u&#39;</font>
    S[i, i] := 1.0 + S[i, i];
  <font color="blue">end for</font>;
  SAS := S*A*S;

<font color="blue">end </font>householderSimilarityTransformation;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE leastSquares<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Math.Matrices.leastSquaresI.png" ALT="Modelica_LinearSystems2.Math.Matrices.leastSquares" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.leastSquares"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.leastSquares</H2>
<B>Solve overdetermined or underdetermined real system of linear equations A*x=b in a least squares sense (A may be rank deficient)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
x = Matrices.<b>leastSquares</b>(A,b);
</pre></blockquote>
<h4>Description</h4>
<p>
A linear system of equations A*x = b has no solutions or infinitely
many solutions if A is not square. Function "leastSquares" returns
a solution in a least squarse sense:
</p>
<pre>
  size(A,1) &gt; size(A,2):  returns x such that |A*x - b|^2 is a minimum
  size(A,1) = size(A,2):  returns x such that A*x = b
  size(A,1) &lt; size(A,2):  returns x such that |x|^2 is a minimum for all 
                          vectors x that fulfill A*x = b
</pre>
<p>
Note, the solution is computed with the LAPACK function "dgelsx",
i.e., QR or LQ factorization of A with column pivoting. 
If A does not have full rank,
the solution is not unique and from the infinitely many solutions
the one is selected that minimizes both |x|^2 and |A*x - b|^2.
</p>
<pre></PRE><P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, :]</TD><TD>&nbsp;</TD><TD>Matrix A</TD></TR>
<TR><TD>Real</TD><TD>b[size(A, 1)]</TD><TD>&nbsp;</TD><TD>Vector b</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>x[size(A, 2)]</TD><TD>Vector x such that min|A*x-b|^2 if size(A,1) &gt;= size(A,2) or min|x|^2 and A*x=b, if size(A,1) &lt; size(A,2)</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> leastSquares <font color="darkgreen">
  &quot;Solve overdetermined or underdetermined real system of linear equations A*x=b in a least squares sense (A may be rank deficient)&quot;</font>
  <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>Real A[:,:] <font color="darkgreen">&quot;Matrix A&quot;</font>;
  <font color="blue">input </font>Real b[<font color="red">size</font>(A, 1)] <font color="darkgreen">&quot;Vector b&quot;</font>;
  <font color="blue">output </font>Real x[<font color="red">size</font>(A, 2)] <font color="darkgreen">
    &quot;Vector x such that min|A*x-b|^2 if size(A,1) &gt;= size(A,2) or min|x|^2 and A*x=b, if size(A,1) &lt; size(A,2)&quot;</font>;

<font color="blue">protected </font>
  Integer info;
  Integer rank;
  Real xx[<font color="red">max</font>(<font color="red">size</font>(A, 1),<font color="red"> size</font>(A, 2))];
<font color="blue">algorithm </font>
  <font color="blue">if </font><font color="red">min</font>(<font color="red">size</font>(A)) &gt; 0<font color="blue"> then</font>
    (xx,info,rank) :=<font color="red"> Modelica.Math.Matrices.LAPACK.dgelsx_vec</font>(
      A,
      b,
      100*Modelica.Constants.eps);
    x := xx[1:<font color="red">size</font>(A, 2)];
    <font color="red">assert</font>(info == 0, &quot;Solving an overdetermined or underdetermined linear system of 
equations with function \&quot;Matrices.leastSquares\&quot; failed.&quot;);
  <font color="blue">else</font>
    x :=<font color="red"> fill</font>(0,<font color="red"> size</font>(A, 2));
  <font color="blue">end if</font>;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>leastSquares;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE LU<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Math.Matrices.leastSquaresI.png" ALT="Modelica_LinearSystems2.Math.Matrices.LU" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.LU"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.LU</H2>
<B>LU decomposition of square or rectangular matrix</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
(LU, pivots)       = Matrices.<b>LU</b>(A);
(LU, pivots, info) = Matrices.<b>LU</b>(A);
</pre></blockquote>
<h4>Description</h4>
<p>
This function call returns the
LU decomposition of a "Real[m,n]" matrix A, i.e.,
</p>
<blockquote>
<p>
<b>P</b>*<b>L</b>*<b>U</b> = <b>A</b>
</p>
</blockquote>
<p>
where <b>P</b> is a permutation matrix (implicitely
defined by vector <code>pivots</code>),
<b>L</b> is a lower triangular matrix with unit
diagonal elements (lower trapezoidal if m &gt; n), and
<b>U</b> is an upper triangular matrix (upper trapezoidal if m &lt; n).
Matrices <b>L</b> and <b>U</b> are stored in the returned
matrix <code>LU</code> (the diagonal of <b>L</b> is not stored).
With the companion function 
<A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU_solve"
>Matrices.LU_solve</a>,
this decomposition can be used to solve
linear systems (<b>P</b>*<b>L</b>*<b>U</b>)*<b>x</b> = <b>b</b> with different right
hand side vectors <b>b</b>. If a linear system of equations with
just one right hand side vector <b>b</b> shall be solved, it is
more convenient to just use the function
<A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve"
>Matrices.solve</a>.
</p>
<p>
The optional third (Integer) output argument has the following meaning:
<table border=0 cellspacing=0 cellpadding=2>
  <tr><td valign="top">info = 0:</td
      <td valign="top">successful exit</td></tr>
  <tr><td valign="top">info &gt; 0:</td>
      <td valign="top">if info = i, U[i,i] is exactly zero. The factorization
          has been completed, <br> 
          but the factor U is exactly
          singular, and division by zero will occur<br> if it is used
          to solve a system of equations.</td></tr>
</table>
</p>
<p>
The LU factorization is computed
with the LAPACK function "dgetrf",
i.e., by Gaussian elemination using partial pivoting
with row interchanges. Vector "pivots" are the
pivot indices, i.e., for 1 &le; i &le; min(m,n), row i of 
matrix A was interchanged with row pivots[i].
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3; 
                 3,4,5;
                 2,1,4];
  Real b1[3] = {10,22,12};
  Real b2[3] = { 7,13,10};
  Real    LU[3,3];
  Integer pivots[3];
  Real    x1[3];
  Real    x2[3];
<b>algorithm</b>
  (LU, pivots) := Matrices.LU(A);
  x1 := Matrices.LU_solve(LU, pivots, b1);  // x1 = {3,2,1}
  x2 := Matrices.LU_solve(LU, pivots, b2);  // x2 = {1,0,2}
</pre></blockquote>
<h4>See also</h4>
<A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU_solve"
>Matrices.LU_solve</a>, 
<A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve"
>Matrices.solve</a>,
<pre></PRE><P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, :]</TD><TD>&nbsp;</TD><TD>Square or rectangular matrix</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>LU[size(A, 1), size(A, 2)]</TD><TD>L,U factors (used with LU_solve(..))</TD></TR>
<TR><TD>Integer</TD><TD>pivots[min(size(A, 1), size(A, 2))]</TD><TD>pivot indices (used with LU_solve(..))</TD></TR>
<TR><TD>Integer</TD><TD>info</TD><TD>Information</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> LU <font color="darkgreen">&quot;LU decomposition of square or rectangular matrix&quot;</font>
  <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>Real A[:,:] <font color="darkgreen">&quot;Square or rectangular matrix&quot;</font>;
  <font color="blue">output </font>Real LU[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)]=A <font color="darkgreen">
    &quot;L,U factors (used with LU_solve(..))&quot;</font>;
  <font color="blue">output </font>Integer pivots[<font color="red">min</font>(<font color="red">size</font>(A, 1),<font color="red"> size</font>(A, 2))] <font color="darkgreen">
    &quot;pivot indices (used with LU_solve(..))&quot;</font>;
  <font color="blue">output </font>Integer info <font color="darkgreen">&quot;Information&quot;</font>;

<font color="blue">algorithm </font>
  <font color="blue">if </font><font color="red">min</font>(<font color="red">size</font>(A)) &gt; 0<font color="blue"> then</font>
    (LU,pivots,info) :=<font color="red"> Modelica.Math.Matrices.LAPACK.dgetrf</font>(A);
  <font color="blue">else</font>
    LU :=<font color="red"> fill</font>(
      0,
      <font color="red">size</font>(A, 1),
      <font color="red">size</font>(A, 2));
    pivots :=<font color="red"> fill</font>(0,<font color="red"> min</font>(<font color="red">size</font>(A, 1),<font color="red"> size</font>(A, 2)));
    info := 0;
  <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>LU;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE LU_solve<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Math.Matrices.leastSquaresI.png" ALT="Modelica_LinearSystems2.Math.Matrices.LU_solve" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.LU_solve"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.LU_solve</H2>
<B>Solve real system of linear equations P*L*U*x=b with a b vector and an LU decomposition (from LU(..))</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>LU_solve</b>(LU, pivots, b);
</pre></blockquote>
<h4>Description</h4>
<p>
This function call returns the
solution <b>x</b> of the linear systems of equations
</p>
<blockquote>
<p>
<b>P</b>*<b>L</b>*<b>U</b>*<b>x</b> = <b>b</b>;
</p>
</blockquote>
<p>
where <b>P</b> is a permutation matrix (implicitely
defined by vector <code>pivots</code>),
<b>L</b> is a lower triangular matrix with unit
diagonal elements (lower trapezoidal if m &gt; n), and
<b>U</b> is an upper triangular matrix (upper trapezoidal if m &lt; n).
The matrices of this decomposition are computed with function
<A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU"
>Matrices.LU</a> that
returns arguments <code>LU</code> and <code>pivots</code>
used as input arguments of <code>Matrices.LU_solve</code>.
With <code>Matrices.LU</code> and <code>Matrices.LU_solve</code>
it is possible to efficiently solve linear systems
with different right hand side vectors. If a linear system of equations with
just one right hand side vector shall be solved, it is
more convenient to just use the function
<A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve"
>Matrices.solve</a>.
</p>
<p>
If a unique solution <b>x</b> does not exist (since the 
LU decomposition is singular), an exception is raised.
</p>
<p>
The LU factorization is computed
with the LAPACK function "dgetrf",
i.e., by Gaussian elemination using partial pivoting
with row interchanges. Vector "pivots" are the
pivot indices, i.e., for 1 &le; i &le; min(m,n), row i of 
matrix A was interchanged with row pivots[i].
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3; 
                 3,4,5;
                 2,1,4];
  Real b1[3] = {10,22,12};
  Real b2[3] = { 7,13,10};
  Real    LU[3,3];
  Integer pivots[3];
  Real    x1[3];
  Real    x2[3];
<b>algorithm</b>
  (LU, pivots) := Matrices.LU(A);
  x1 := Matrices.LU_solve(LU, pivots, b1);  // x1 = {3,2,1}
  x2 := Matrices.LU_solve(LU, pivots, b2);  // x2 = {1,0,2}
</pre></blockquote>
<h4>See also</h4>
<A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU"
>Matrices.LU</a>, 
<A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve"
>Matrices.solve</a>,
<pre></PRE><P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>LU[:, size(LU, 1)]</TD><TD>&nbsp;</TD><TD>L,U factors of Matrices.LU(..) for a square matrix</TD></TR>
<TR><TD>Integer</TD><TD>pivots[size(LU, 1)]</TD><TD>&nbsp;</TD><TD>Pivots indices of Matrices.LU(..)</TD></TR>
<TR><TD>Real</TD><TD>b[size(LU, 1)]</TD><TD>&nbsp;</TD><TD>Right hand side vector of P*L*U*x=b</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>x[size(b, 1)]</TD><TD>Solution vector such that P*L*U*x = b</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> LU_solve <font color="darkgreen">
  &quot;Solve real system of linear equations P*L*U*x=b with a b vector and an LU decomposition (from LU(..))&quot;</font>

  <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>Real LU[:,<font color="red">size</font>(LU, 1)] <font color="darkgreen">
    &quot;L,U factors of Matrices.LU(..) for a square matrix&quot;</font>;
  <font color="blue">input </font>Integer pivots[<font color="red">size</font>(LU, 1)] <font color="darkgreen">&quot;Pivots indices of Matrices.LU(..)&quot;</font>;
  <font color="blue">input </font>Real b[<font color="red">size</font>(LU, 1)] <font color="darkgreen">&quot;Right hand side vector of P*L*U*x=b&quot;</font>;
  <font color="blue">output </font>Real x[<font color="red">size</font>(b, 1)] <font color="darkgreen">&quot;Solution vector such that P*L*U*x = b&quot;</font>;

<font color="blue">algorithm </font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(LU, 1)<font color="blue"> loop</font>
    <font color="red">assert</font>(LU[i, i] &lt;&gt; 0, &quot;Solving a linear system of equations with function
\&quot;Matrices.LU_solve\&quot; is not possible, since the LU decomposition
is singular, i.e., no unique solution exists.&quot;);
  <font color="blue">end for</font>;
  <font color="blue">if </font><font color="red">size</font>(LU, 1) &gt; 0<font color="blue"> then</font>
    x :=<font color="red"> Modelica.Math.Matrices.LAPACK.dgetrs_vec</font>(
      LU,
      pivots,
      b);
  <font color="blue">else</font>
    x :=<font color="red"> fill</font>(0, 0);
  <font color="blue">end if</font>;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>LU_solve;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE LU_solve2<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.LU_solve2"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.LU_solve2</H2>
<B>Solve real system of linear equations P*L*U*X=B with a B vector and an LU decomposition (from LU(..))</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4><font color="#008000">Syntax</font></h4>
<blockquote><pre>
Matrices.<b>LU_solve</b>(LU, pivots, B);
</pre></blockquote>
<h4><font color="#008000">Description</font></h4>
<p>
This function call returns the
solution <b>x</b> of the linear systems of equations
</p>
<blockquote>
<p>
<b>P</b>*<b>L</b>*<b>U</b>*<b>X</b> = <b>B</b>;
</p>
</blockquote>
<p>
where <b>P</b> is a permutation matrix (implicitely
defined by vector <code>pivots</code>),
<b>L</b> is a lower triangular matrix with unit
diagonal elements (lower trapezoidal if m &gt; n), and
<b>U</b> is an upper triangular matrix (upper trapezoidal if m &lt; n).
The matrices of this decomposition are computed with function
<A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU"
>Matrices.LU</a> that
returns arguments <code>LU</code> and <code>pivots</code>
used as input arguments of <code>Matrices.LU_solve</code>.
With <code>Matrices.LU</code> and <code>Matrices.LU_solve</code>
it is possible to efficiently solve linear systems
with different right hand side <b>matrices</b>. If a linear system of equations with
just one right hand side matrix shall be solved, it is
more convenient to just use the function
<A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve2"
>Matrices.solve2</a>.
</p>
<p>
If a unique solution <b>X</b> does not exist (since the 
LU decomposition is singular), an exception is raised.
</p>
<p>
The LU factorization is computed
with the LAPACK function "dgetrf",
i.e., by Gaussian elemination using partial pivoting
with row interchanges. Vector "pivots" are the
pivot indices, i.e., for 1 &le; i &le; min(m,n), row i of 
matrix A was interchanged with row pivots[i].
</p>
<h4><font color="#008000">Example</font></h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3; 
                 3,4,5;
                 2,1,4];
  Real B1[3] = [10, 20;
                22, 44;
                12, 24];
  Real B2[3] = [ 7, 14;
                13, 26;
                10, 20];
  Real    LU[3,3];
  Integer pivots[3];
  Real    X1[3,2];
  Real    X2[3,2];
<b>algorithm</b>
  (LU, pivots) := Matrices.LU(A);
  X1 := Matrices.LU_solve2(LU, pivots, B1);  /* X1 = [3, 6;
                                                      2, 4;
                                                      1, 2] */
  X2 := Matrices.LU_solve2(LU, pivots, B2);  /* X2 = [1, 2;
                                                      0, 0;
                                                      2, 4] */
</pre></blockquote>
<h4><font color="#008000">See also</font></h4>
<A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU"
>Matrices.LU</a>, 
<A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve2"
>Matrices.solve2</a>,
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>LU[:, size(LU, 1)]</TD><TD>&nbsp;</TD><TD>L,U factors of Matrices.LU(..) for a square matrix</TD></TR>
<TR><TD>Integer</TD><TD>pivots[size(LU, 1)]</TD><TD>&nbsp;</TD><TD>Pivots indices of Matrices.LU(..)</TD></TR>
<TR><TD>Real</TD><TD>B[size(LU, 1), :]</TD><TD>&nbsp;</TD><TD>Right hand side matrix of P*L*U*X=B</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>X[size(B, 1), size(B, 2)]</TD><TD>Solution matrix such that P*L*U*X = B</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> LU_solve2 <font color="darkgreen">
  &quot;Solve real system of linear equations P*L*U*X=B with a B vector and an LU decomposition (from LU(..))&quot;</font>

  <font color="blue">input </font>Real LU[:,<font color="red">size</font>(LU, 1)] <font color="darkgreen">
    &quot;L,U factors of Matrices.LU(..) for a square matrix&quot;</font>;
  <font color="blue">input </font>Integer pivots[<font color="red">size</font>(LU, 1)] <font color="darkgreen">&quot;Pivots indices of Matrices.LU(..)&quot;</font>;
  <font color="blue">input </font>Real B[<font color="red">size</font>(LU, 1),:] <font color="darkgreen">&quot;Right hand side matrix of P*L*U*X=B&quot;</font>;
  <font color="blue">output </font>Real X[<font color="red">size</font>(B, 1),<font color="red">size</font>(B, 2)] <font color="darkgreen">&quot;Solution matrix such that P*L*U*X = B&quot;</font>;

<font color="blue">algorithm </font>
  <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(LU, 1)<font color="blue"> loop</font>
    <font color="red">assert</font>(LU[i, i] &lt;&gt; 0, &quot;Solving a linear system of equations with function
\&quot;Matrices.LU_solve\&quot; is not possible, since the LU decomposition
is singular, i.e., no unique solution exists.&quot;);
  <font color="blue">end for</font>;
  <font color="blue">if </font><font color="red">size</font>(LU, 1) &gt; 0<font color="blue"> then</font>
    X :=<font color="red"> LAPACK.dgetrs</font>(
      LU,
      pivots,
      B);
  <font color="blue">else</font>
    X :=<font color="red"> fill</font>(
      0,
      <font color="red">size</font>(B, 1),
      <font color="red">size</font>(B, 2));
  <font color="blue">end if</font>;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>LU_solve2;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE lyapunov<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.lyapunov"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.lyapunov</H2>
<B>Solution of continuous-time Lyapunov equation X*A + A&#39;*X = C</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
 
 
Function <b>laypunov</b> computes the solution <b>X</b> of the continuous-time Lyapunov equation
<blockquote><pre>
 <b>X</b><b>A</b> + <b>A</b>'*<b>X</b> = <b>C</b>.
</pre></blockquote>
using the Schur method for Lyapunov equations proposed by Bartels and Stewart [1].
<p>
<A name="References"><B><FONT SIZE="+1">References</FONT></B></A>
<PRE>
  [1] Bartels, R.H. and Stewart G.W.
      Algorithm 432: Solution of the matrix equation AX + XB = C.
      Comm. ACM., Vol. 15, pp. 820-826, 1972.
</PRE>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>C[size(A, 1), size(A, 2)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>eps</TD><TD>Modelica.Math.Matrices.norm(...</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>X[size(A, 1), size(A, 2)]</TD><TD>solution of the Lyapunov equation</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> lyapunov <font color="darkgreen">
  &quot;Solution of continuous-time Lyapunov equation X*A + A&#39;*X = C&quot;</font>
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;

  <font color="blue">input </font>Real A[:,<font color="red">size</font>(A, 1)];
  <font color="blue">input </font>Real C[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)];
  <font color="blue">input </font>Real eps=<font color="red">Modelica.Math.Matrices.norm</font>(A,1)*10*Modelica.Constants.eps;

<font color="blue">protected </font>
  Integer n=<font color="red">size</font>(A, 1);
  Real R[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)] <font color="darkgreen">&quot;rsf of A&#39;, i.e. R=U&#39;A&#39;U&quot;</font>;
  Real U[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)] <font color="darkgreen">&quot;transformation matrix U for R=U&#39;A&#39;U&quot;</font>;
  Real C2[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)];
  Real R11[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)];
  Real R22[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)];
  Real R12[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)];
  Real R21[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)];
  Real R2[2*<font color="red">size</font>(A, 1),2*<font color="red">size</font>(A, 2)];
  Real I[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 1)]=<font color="red">identity</font>(<font color="red">size</font>(A, 1));
  Real x[2*<font color="red">size</font>(A,1)];
  Real c[2*<font color="red">size</font>(A,1)];
  Real CC[<font color="red">size</font>(A,1),2];
  Integer k;

<font color="blue">public </font>
  <font color="blue">output </font>Real X[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)] <font color="darkgreen">&quot;solution of the Lyapunov equation&quot;</font>;

<font color="blue">algorithm </font>
  <font color="blue">if </font>n &gt; 1<font color="blue"> then</font>
    (R,U) :=<font color="red"> Matrices.rsf</font>(<font color="red">transpose</font>(A));
    C2 :=<font color="red"> transpose</font>(U)*C*U;
    X :=<font color="red"> zeros</font>(n, n);

<font color="darkgreen">// Calculate the last 1 or 2 columns of X</font>
    R22 := R;
    <font color="blue">for </font>i1<font color="blue"> in </font>1:n<font color="blue"> loop</font>
      R22[i1, i1] := R[i1, i1] + R[n, n];
    <font color="blue">end for</font>;
    <font color="blue">if </font><font color="red">abs</font>(R[n, n - 1]) &lt; eps<font color="blue"> then</font>
      X[:, n] :=<font color="red"> Matrices.solve</font>(R22, C2[:, n]);
      k := n - 1;
    <font color="blue">else</font>
      R11 := R;
      R12 :=<font color="red"> zeros</font>(n, n);
      R21 :=<font color="red"> zeros</font>(n, n);
      <font color="blue">for </font>i1<font color="blue"> in </font>1:n<font color="blue"> loop</font>
        R11[i1, i1] := R[i1, i1] + R[n - 1, n - 1];
        R12[i1, i1] := R[n - 1, n];
        R21[i1, i1] := R[n, n - 1];
      <font color="blue">end for</font>;

<font color="darkgreen">// solve 2nx2n equation for 2x2 Schur bump with Kronecker product and vec operator approach</font>
      R2 := [R11,R12; R21,R22];
      c :=<font color="red"> cat</font>(1, C2[:, n - 1], C2[:, n]);
      x :=<font color="red"> Matrices.solve</font>(R2, c);
      X[:, n - 1] := x[1:n];
      X[:, n] := x[n + 1:2*n];
      k := n - 2;
    <font color="blue">end if</font>;

<font color="darkgreen">// Calculate the rest of X</font>

    <font color="blue">while </font>k &gt; 1<font color="blue"> loop</font>
      R22 := R;
      <font color="blue">for </font>i1<font color="blue"> in </font>1:n<font color="blue"> loop</font>
        R22[i1, i1] := R[i1, i1] + R[k, k];
      <font color="blue">end for</font>;
      <font color="blue">if </font><font color="red">abs</font>(R[k, k - 1]) &lt; eps<font color="blue"> then</font>
        <font color="darkgreen">//real eigenvalue</font>
<font color="darkgreen">//        X[:, k] := Matrices.solve(R22, C2[:, k] - vector(X[:, k + 1:n]*transpose(matrix(R[k, k + 1:n]))));</font>
        X[:, k] :=<font color="red"> Matrices.solve</font>(R22, C2[:, k] -<font color="red"> vector</font>(X[:, k + 1:n]*<font color="red">matrix</font>(R[k, k + 1:n])));
        k := k - 1;
      <font color="blue">else</font>
       <font color="darkgreen">// conjugated complex eigenvalues</font>
        R11 := R;
        R12 :=<font color="red"> zeros</font>(n, n);
        R21 :=<font color="red"> zeros</font>(n, n);
        <font color="blue">for </font>i1<font color="blue"> in </font>1:n<font color="blue"> loop</font>
          R11[i1, i1] := R[i1, i1] + R[k - 1, k - 1];
          R12[i1, i1] := R[k - 1, k];
          R21[i1, i1] := R[k, k - 1];
        <font color="blue">end for</font>;
        R2 := [R11,R12; R21,R22];
        CC := C2[:,k-1:k] - X[:,k+1:n]*<font color="red">transpose</font>(R[k-1:k,k+1:n]);
        c :=<font color="red"> cat</font>(1, CC[:, 1], CC[:, 2]);
        x :=<font color="red"> Matrices.solve</font>(R2, c);
        X[:, k - 1] := x[1:n];
        X[:, k] := x[n + 1:2*n];

        k := k - 2;
      <font color="blue">end if</font>;
    <font color="blue">end while</font>;<font color="darkgreen">// k=1 or k=0</font>

<font color="darkgreen">// if k=1 the first column (if there exist a real eigenvalue) has to be calculated separately</font>
    <font color="blue">if </font>k == 1<font color="blue"> then</font>
      R22 := R;
      <font color="blue">for </font>i1<font color="blue"> in </font>1:n<font color="blue"> loop</font>
        R22[i1, i1] := R[i1, i1] + R[1, 1];
      <font color="blue">end for</font>;
      X[:, 1] :=<font color="red"> Matrices.solve</font>(R22, C2[:, 1] -<font color="red"> vector</font>(X[:, 2:n]*<font color="red">matrix</font>(R[1, 2:n])));
    <font color="blue">end if</font>;

<font color="darkgreen">// transform X corresponding to the original form</font>
    X := U*X*<font color="red">transpose</font>(U);

  <font color="blue">elseif </font>n == 1<font color="blue"> then</font>
    X[1, 1] := C[1, 1]/(2*A[1, 1]);
  <font color="blue">else</font>
    X :=<font color="red"> fill</font>(0, 0, 0);
  <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>lyapunov;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE norm<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Math.Matrices.normI.png" ALT="Modelica_LinearSystems2.Math.Matrices.norm" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.norm"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.norm</H2>
<B>Returns the norm of a matrix</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>norm</b>(A);
Matrices.<b>norm</b>(A, p=2);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call "<code>Matrices.norm(A)</code>" returns the
2-norm of matrix A, i.e., the largest singular value of A.<br>
The function call "<code>Matrices.norm(A, p)</code>" returns the
p-norm of matrix A. The only allowed values for p are</p>
<ul>
<li> "p=1": the largest column sum of A</li>
<li> "p=2": the largest singular value of A</li> 
<li> "p=Modelica.Constants.inf": the largest row sum of A</li>
</ul>
<p>
Note, for any matrices A1, A2 the following inequality holds:
</p>
<blockquote><pre>
Matrices.<b>norm</b>(A1+A2,p) &le; Matrices.<b>norm</b>(A1,p) + Matrices.<b>norm</b>(A2,p)
</pre></blockquote>
<p>
Note, for any matrix A and vector v the following inequality holds:
</p>
<blockquote><pre>
Vectors.<b>norm</b>(A*v,p) &le; Matrices.<b>norm</b>(A,p)*Vectors.<b>norm</b>(A,p)
</pre></blockquote>
<pre></PRE><P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, :]</TD><TD>&nbsp;</TD><TD>Input matrix</TD></TR>
<TR><TD>Real</TD><TD>p</TD><TD>2</TD><TD>Type of p-norm (only allowed: 1, 2 or Modelica.Constants.inf)</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>result</TD><TD>p-norm of matrix A</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> norm <font color="darkgreen">&quot;Returns the norm of a matrix&quot;</font>
  <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>Real A[:,:] <font color="darkgreen">&quot;Input matrix&quot;</font>;
  <font color="blue">input </font>Real p(min=1) = 2 <font color="darkgreen">
    &quot;Type of p-norm (only allowed: 1, 2 or Modelica.Constants.inf)&quot;</font>;
  <font color="blue">output </font>Real result=0.0 <font color="darkgreen">&quot;p-norm of matrix A&quot;</font>;

<font color="blue">algorithm </font>
  <font color="blue">if </font>p == 1<font color="blue"> then</font>
    <font color="darkgreen">// column sum norm</font>
    <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(A, 2)<font color="blue"> loop</font>
      result :=<font color="red"> max</font>(result,<font color="red"> sum</font>(<font color="red">abs</font>(A[:, i])));
    <font color="blue">end for</font>;
  <font color="blue">elseif </font>p == 2<font color="blue"> then</font>
    <font color="darkgreen">// largest singular value</font>
    result := <font color="blue">if </font><font color="red">min</font>(<font color="red">size</font>(A)) &gt; 0<font color="blue"> then </font><font color="red">max</font>(
      <font color="red">Modelica.Math.Matrices.singularValues</font>(A))<font color="blue"> else </font>0;
  <font color="blue">elseif </font>p == 3<font color="blue"> then</font>
    <font color="darkgreen">// Frobenius norm</font>
    result :=<font color="red">   Modelica_LinearSystems2.Math.Matrices.Internal.frobeniusNorm</font>(A);
  <font color="blue">elseif </font>p == Modelica.Constants.inf<font color="blue"> then</font>
    <font color="darkgreen">// row sum norm</font>
    <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(A, 1)<font color="blue"> loop</font>
      result :=<font color="red"> max</font>(result,<font color="red"> sum</font>(<font color="red">abs</font>(A[i, :])));
    <font color="blue">end for</font>;
  <font color="blue">else</font>
    <font color="red">assert</font>(false, &quot;Optional argument \&quot;p\&quot; of function \&quot;norm\&quot; must be 
1, 2 or Modelica.Constants.inf&quot;);
  <font color="blue">end if</font>;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>norm;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE nullspace<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Math.Matrices.normI.png" ALT="Modelica_LinearSystems2.Math.Matrices.nullspace" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.nullspace"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.nullspace</H2>
<B>Orthonormal nullspace of a matrix</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
  <h4>Syntax</h4>
<blockquote><pre>
Z = Matrices.<b>nullspace</b>(A);<br>
(Z, nullity) = Matrices.<b>nullspace</b>(A);
</pre></blockquote>
<h4>Description</h4>
<p>
This function calculates a orthonormal basis Z=[z_1, z_2, ...] of the nullspace of a matrix A, i.e. A*z_i=0.
</p>
The nullspace is obtained by svd method. That is, matrix A is dcomposed into the matrices S, U, V: 
<blockquote><pre>
        T
 <b>A</b> = <b>U</b><b>S</b><b>V</b>
</pre></blockquote>
with the orthonormal matrices U and V and the matrix S with
<blockquote><pre>
 <b>S</b> = [<b>S</b>1, <b>0</b>]
 <b>S</b>1 = [diag(s); <b>0</b>]
</pre></blockquote>
with the singular values s={s1, s2, ..., sr} of A and r=rank(A). Note, that S has the same size as A. Since, U and V are orthonormal, we may write
<blockquote><pre>
  T
 <b>U</b>*A*V = [<b>S</b>1, <b>0</b>].
</pre></blockquote>
Matrix S1 obviously has full column rank and therefore, the left n-r rows (n is the number of columns of A or S) of matrix V span a nullspace of A.
</p>
<p>
The nullity of matrix A is the dimension of the nullspace of A. In view of the above, it becomes clear that nullity holds
<blockquote><pre>
 nullity = n - r
</pre></blockquote>
with
<blockquote><pre>
 n = number of columns of matrix A
 r = rank(A)
</pre></blockquote>

</p>
<p>
<h4>Example</h4>
<blockquote><pre>
  A = [1, 2,  3, 1;
       3, 4,  5, 2;
      -1, 2, -3, 3];
  (Z, nullity) = nullspace(A);
  
  results in:
  
  Z=[0.1715;
    -0.686;
     0.1715;
     0.686]
     
  nullity = 1
</pre></blockquote>
</p>
<h4>See also</h4>
<A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Math_Matrices.html#Modelica.Math.Matrices.singularValues"
>Matrices.singularValues</a>
<pre></PRE><P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, :]</TD><TD>&nbsp;</TD><TD>input matrix</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>Z[size(A, 2), :]</TD><TD>orthonormal nullspace of matrix A</TD></TR>
<TR><TD>Integer</TD><TD>nullity</TD><TD>nullity, i.e. the dimension of the nullspace</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> nullspace <font color="darkgreen">&quot;Orthonormal nullspace of a matrix&quot;</font>
  <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;

  <font color="blue">input </font>Real A[:,:] <font color="darkgreen">&quot;input matrix&quot;</font>;
  <font color="blue">output </font>Real Z[<font color="red">size</font>(A, 2),:] <font color="darkgreen">&quot;orthonormal nullspace of matrix A&quot;</font>;
  <font color="blue">output </font>Integer nullity <font color="darkgreen">&quot;nullity, i.e. the dimension of the nullspace&quot;</font>;

<font color="blue">protected </font>
  Real V[<font color="red">size</font>(A, 2),<font color="red">size</font>(A, 2)] <font color="darkgreen">&quot;Right orthogonal matrix &quot;</font>;
  Real sigma[<font color="red">min</font>(<font color="red">size</font>(A, 1),<font color="red"> size</font>(A, 2))] <font color="darkgreen">&quot;singular values&quot;</font>;
  Integer rank <font color="darkgreen">&quot;rank of matrix A&quot;</font>;
  Real eps <font color="darkgreen">&quot;tolerance for rank determination&quot;</font>;
  Integer n=<font color="red">min</font>(<font color="red">size</font>(A, 1),<font color="red"> size</font>(A, 2));
  Integer i=n;

<font color="blue">algorithm </font>
  (sigma,,V) :=<font color="red"> Modelica.Math.Matrices.singularValues</font>(A);
  V :=<font color="red"> transpose</font>(V);
  <font color="darkgreen">// rank computation</font>
  eps :=<font color="red"> max</font>(<font color="red">size</font>(A, 1),<font color="red"> size</font>(A, 2))*<font color="red">max</font>(sigma)*Modelica.Constants.eps;
  rank := 0;
  <font color="blue">if </font>n &gt; 0<font color="blue"> then</font>
    <font color="blue">while </font>i &gt; 0<font color="blue"> loop</font>
      <font color="blue">if </font>sigma[i] &gt; eps<font color="blue"> then</font>
        rank := i;
        i := 0;
      <font color="blue">end if</font>;
      i := i - 1;
    <font color="blue">end while</font>;
  <font color="blue">end if</font>;
  Z := V[:,rank + 1:<font color="red">size</font>(A,2)];<font color="darkgreen">// nullspace computation</font>
  nullity :=<font color="red"> size</font>(A,2) - rank;<font color="darkgreen">// nullity</font>

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>nullspace;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE orthogonalQ<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.orthogonalQ"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.orthogonalQ</H2>
<B>generates a real orthogonal matrix Q which is defined as the product of IHI-ILO elementary reflectors of order N, as returned by DGEHRD</B><p>
<P><H3>Information</H3></P>
<PRE>   Purpose  
/*  ======= */
 
/*  DORGHR generates a real orthogonal matrix Q which is defined as the */
/*  product of IHI-ILO elementary reflectors of order N, as returned by */
/*  DGEHRD: */
 
/*  Q = H(ilo) H(ilo+1) . . . H(ihi-1). */
 
/*  Arguments */
/*  ========= */
 
/*  N       (input) INTEGER */
/*          The order of the matrix Q. N &gt;= 0. */
 
/*  ILO     (input) INTEGER */
/*  IHI     (input) INTEGER */
/*          ILO and IHI must have the same values as in the previous call */
/*          of DGEHRD. Q is equal to the unit matrix except in the */
/*          submatrix Q(ilo+1:ihi,ilo+1:ihi). */
/*          1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0; ILO=1 and IHI=0, if N=0. */
 
/*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N) */
/*          On entry, the vectors which define the elementary reflectors, */
/*          as returned by DGEHRD. */
/*          On exit, the N-by-N orthogonal matrix Q. */
 
/*  LDA     (input) INTEGER */
/*          The leading dimension of the array A. LDA &gt;= max(1,N). */
 
/*  TAU     (input) DOUBLE PRECISION array, dimension (N-1) */
/*          TAU(i) must contain the scalar factor of the elementary */
/*          reflector H(i), as returned by DGEHRD. */
 
/*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK) */
/*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. */
 
/*  LWORK   (input) INTEGER */
/*          The dimension of the array WORK. LWORK &gt;= IHI-ILO. */
/*          For optimum performance LWORK &gt;= (IHI-ILO)*NB, where NB is */
/*          the optimal blocksize. */
 
/*          If LWORK = -1, then a workspace query is assumed; the routine */
/*          only calculates the optimal size of the WORK array, returns */
/*          this value as the first entry of the WORK array, and no error */
/*          message related to LWORK is issued by XERBLA. */
 
/*  INFO    (output) INTEGER */
/*          = 0:  successful exit */
/*          &lt; 0:  if INFO = -i, the i-th argument had an illegal value */
 
/*  ===================================================================== */</PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>tau[size(A, 1) - 1]</TD><TD>&nbsp;</TD><TD>scalar factors of the elementary reflectors</TD></TR>
<TR><TD>Integer</TD><TD>ilo</TD><TD>1</TD><TD>lowest index where the original matrix had been Hessenbergform - ilo must have the same value as in the previous call of DGEHRD</TD></TR>
<TR><TD>Integer</TD><TD>ihi</TD><TD>&nbsp;</TD><TD>highest index where the original matrix had been Hessenbergform  - ihi must have the same value as in the previous call of DGEHRD</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>Q[size(A, 1), size(A, 2)]</TD><TD>Orthogonal matrix as a result of elementary reflectors</TD></TR>
<TR><TD>Integer</TD><TD>info</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> orthogonalQ <font color="darkgreen">
  &quot;generates a real orthogonal matrix Q which is defined as the product of IHI-ILO elementary reflectors of order N, as returned by DGEHRD&quot;</font>
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>;
  <font color="blue">input </font>Real A[:,<font color="red">size</font>(A, 1)];
  <font color="blue">input </font>Real tau[<font color="red">size</font>(A, 1) - 1] <font color="darkgreen">&quot;scalar factors of the elementary reflectors&quot;</font>;
  <font color="blue">input </font>Integer ilo=1 <font color="darkgreen">
    &quot;lowest index where the original matrix had been Hessenbergform - ilo must have the same value as in the previous call of DGEHRD&quot;</font>;
  <font color="blue">input </font>Integer ihi <font color="darkgreen">
    &quot;highest index where the original matrix had been Hessenbergform  - ihi must have the same value as in the previous call of DGEHRD&quot;</font>;

  <font color="blue">output </font>Real Q[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)] <font color="darkgreen">
    &quot;Orthogonal matrix as a result of elementary reflectors&quot;</font>;
  <font color="blue">output </font>Integer info;

<font color="blue">algorithm </font>
  (Q,info) :=<font color="red"> LAPACK.dorghr</font>(
    A,
    ilo,
    ihi,
    tau);
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>orthogonalQ;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE printMatrix<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.printMatrix"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.printMatrix</H2>
<B>print matrix</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>M[:, :]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Integer</TD><TD>significantDigits</TD><TD>6</TD><TD>Number of significant digits that are shown</TD></TR>
<TR><TD>String</TD><TD>name</TD><TD>&quot;M&quot;</TD><TD>Independent variable name used for printing</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>s</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> printMatrix <font color="darkgreen">&quot;print matrix&quot;</font>
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
  <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Strings.html#Modelica.Utilities.Strings"
>Modelica.Utilities.Strings</A>;

  <font color="blue">input </font>Real M[:,:];
  <font color="blue">input </font>Integer significantDigits=6 <font color="darkgreen">
    &quot;Number of significant digits that are shown&quot;</font>;
  <font color="blue">input </font>String name=&quot;M&quot; <font color="darkgreen">&quot;Independent variable name used for printing&quot;</font>;
  <font color="blue">output </font>String s=&quot;&quot;;
<font color="blue">protected </font>
  String blanks=<font color="red">Strings.repeat</font>(significantDigits);
  String space=<font color="red">Strings.repeat</font>(8);
  String space2=<font color="red">Strings.repeat</font>(3);
  Integer r=<font color="red">size</font>(M, 1);
  Integer c=<font color="red">size</font>(M, 2);

<font color="blue">algorithm </font>
  <font color="blue">if </font>r == 0<font color="blue"> or </font>c == 0<font color="blue"> then</font>
    s := name + &quot; = []&quot;;
  <font color="blue">else</font>
    s := &quot;\n&quot; + name + &quot; = \n&quot;;
    <font color="blue">for </font>i<font color="blue"> in </font>1:r<font color="blue"> loop</font>
      s := s + space;
      <font color="blue">for </font>j<font color="blue"> in </font>1:c<font color="blue"> loop</font>
        <font color="blue">if </font>M[i, j] &gt;= 0<font color="blue"> then</font>
          s := s + &quot; &quot;;
        <font color="blue">end if</font>;
        s := s +<font color="red"> String</font>(M[i, j], significantDigits=significantDigits) +
          <font color="red">Strings.repeat</font>(significantDigits + 8 -<font color="red"> Strings.length</font>(<font color="red">String</font>(<font color="red">abs</font>(M[i,j]))));

      <font color="blue">end for</font>;
      s := s + &quot;\n&quot;;
    <font color="blue">end for</font>;

  <font color="blue">end if</font>;
<font color="blue">end </font>printMatrix;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE QR<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.QR"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.QR</H2>
<B>QR decomposition of a square matrix without column pivoting (A = Q*R)</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, :]</TD><TD>&nbsp;</TD><TD>Rectangular matrix with size(A,1) &gt;= size(A,2)</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>Q[size(A, 1), size(A, 2)]</TD><TD>Rectangular matrix with orthonormal columns such that Q*R=A[:,p]</TD></TR>
<TR><TD>Real</TD><TD>R[min(size(A, 1), size(A, 2)), size(A, 2)]</TD><TD>Square upper triangular matrix</TD></TR>
<TR><TD>Real</TD><TD>tau[min(size(A, 1), size(A, 2))]</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>Q2[:, :]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> QR <font color="darkgreen">
  &quot;QR decomposition of a square matrix without column pivoting (A = Q*R)&quot;</font>

  <font color="blue">input </font>Real A[:,:] <font color="darkgreen">&quot;Rectangular matrix with size(A,1) &gt;= size(A,2)&quot;</font>;
  <font color="blue">output </font>Real Q[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)] <font color="darkgreen">
    &quot;Rectangular matrix with orthonormal columns such that Q*R=A[:,p]&quot;</font>;
  <font color="blue">output </font>Real R[<font color="red">min</font>(<font color="red">size</font>(A,1),<font color="red">size</font>(A, 2)),<font color="red">size</font>(A, 2)] <font color="darkgreen">
    &quot;Square upper triangular matrix&quot;</font>;

  <font color="blue">output </font>Real tau[<font color="red">min</font>(<font color="red">size</font>(A, 1),<font color="red"> size</font>(A, 2))];
  <font color="blue">output </font>Real Q2[:,:];

<font color="blue">protected </font>
  Integer nrow=<font color="red">size</font>(A, 1);
  Integer ncol=<font color="red">size</font>(A, 2);
  Integer minrowcol=<font color="red">min</font>(nrow,ncol);
  Integer lwork=<font color="red">Internal.dgeqrf_workdim</font>(A);

<font color="blue">algorithm </font>
  <font color="blue">if </font>minrowcol &gt; 0<font color="blue"> then</font>

    (Q,tau) :=<font color="red"> Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeqrf</font>(A, lwork);

  <font color="darkgreen">// determine R</font>
    R :=<font color="red"> zeros</font>(minrowcol, ncol);
    <font color="blue">for </font>i<font color="blue"> in </font>1:minrowcol<font color="blue"> loop</font>
      <font color="blue">for </font>j<font color="blue"> in </font>i:ncol<font color="blue"> loop</font>
        R[i, j] := Q[i, j];
      <font color="blue">end for</font>;
    <font color="blue">end for</font>;

<font color="darkgreen">//  Q2 := Modelica.Math.Matrices.LAPACK.dorgqr(Q, tau);</font>
<font color="darkgreen">//  Q2 := Modelica_LinearSystems2.Math.Matrices.LAPACK.dorgqr(Q, tau);</font>
    Q2 :=<font color="red"> Modelica_LinearSystems2.Math.Matrices.LAPACK.dorgqr_x</font>(Q, tau);
  <font color="blue">else</font>
<font color="darkgreen">//    Q := fill(1, size(A, 1), 0);</font>
    Q :=<font color="red"> fill</font>(1,<font color="red"> size</font>(A, 1),<font color="red"> size</font>(A, 2));
<font color="darkgreen">//    R := fill(0, 0, 0);</font>
    R :=<font color="red"> fill</font>(0,<font color="red"> min</font>(<font color="red">size</font>(A,1),<font color="red">size</font>(A, 2)),<font color="red">size</font>(A, 2));
  <font color="blue">end if</font>;
<font color="blue">end </font>QR;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE rcond<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Math.Matrices.rcondI.png" ALT="Modelica_LinearSystems2.Math.Matrices.rcond" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.rcond"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.rcond</H2>
<B>Reciprocal condition number</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
  <h4>Syntax</h4>
<blockquote><pre>
r = Matrices.<b>rcond</b>(A);
</pre></blockquote>
<h4>Description</h4>
<p>
This function estimates the reciprocal of the condition number (norm(A) * norm(inv(A))) of a general real matrix A, in either the 1-norm or the infinity-norm, using the LAPACK function DGECON.   
</p>
<p>
<h4>Example</h4>
<blockquote><pre>
  A = [1, 2
       2, 1];
  r = rcond(A);
  
  results in:
  
  r = 0.3333
</pre></blockquote>
</p>
<h4>See also</h4>
<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.conditionNumber"
>Matrices.conditionNumber</a>
<pre></PRE><P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>Square real matrix</TD></TR>
<TR><TD>Boolean</TD><TD>inf</TD><TD>false</TD><TD>Is true if infinity norm is used and false for 1-norm</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>rcond</TD><TD>Reciprocal condition number of A</TD></TR>
<TR><TD>Integer</TD><TD>info</TD><TD>Information</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> rcond <font color="darkgreen">&quot;Reciprocal condition number&quot;</font>
  <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>Real A[:,<font color="red">size</font>(A,1)] <font color="darkgreen">&quot;Square real matrix&quot;</font>;
  <font color="blue">input </font>Boolean inf = false <font color="darkgreen">
    &quot;Is true if infinity norm is used and false for 1-norm&quot;</font>;
  <font color="blue">output </font>Real rcond <font color="darkgreen">&quot;Reciprocal condition number of A&quot;</font>;
  <font color="blue">output </font>Integer info <font color="darkgreen">&quot;Information&quot;</font>;
<font color="blue">protected </font>
  Real LU[:,:] <font color="darkgreen">&quot;LU factorization of matrix A, returned by dgetrf&quot;</font>;
  Real anorm <font color="darkgreen">&quot;Norm of matrix A&quot;</font>;
  String normspec= <font color="blue">if </font>inf<font color="blue"> then </font>&quot;I&quot;<font color="blue"> else </font>&quot;1&quot; <font color="darkgreen">&quot;specifies the norm 1 or inf&quot;</font>;

<font color="blue">algorithm </font>
  <font color="blue">if </font><font color="red">min</font>(<font color="red">size</font>(A)) &gt; 0<font color="blue"> then</font>
    (LU,,info) :=<font color="red"> Modelica.Math.Matrices.LAPACK.dgetrf</font>(A);
    anorm :=<font color="red"> Modelica_LinearSystems2.Math.Matrices.LAPACK.dlange</font>(A,normspec);
    (rcond,info) :=<font color="red"> Modelica_LinearSystems2.Math.Matrices.LAPACK.dgecon</font>(LU,inf,anorm);
  <font color="blue">else</font>
    rcond := Modelica.Constants.inf;
    info := 0;
  <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>rcond;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE rsf<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.rsf"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.rsf</H2>
<B>Computes the real Schur form (RSF) of a square matrix</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4><font color="#008000">Syntax</font></h4>()
<table>
<tr> <td align=right>  (T, Z, alphaReal, alphaImag) </td><td align=center> =  </td>  <td> Modelica_LinearSystems2.Math.Matrices.<b<rsf</b>(A)  </td> </tr>
</table>
<h4><font color="#008000">Description</font></h4>
<p>
Function <b>rsf</b> (real Schur form) calculates the real Schur form af a real square matrix <b>A</b>, i.e.
<blockquote><pre>
         T
A = Z*T*Z

</pre></blockquote>
with the real nxn matrices <b>T</b> and <b>Z</b>. <b>Z</b> is an orthogonal matrix.  <b>T</b> is an block upper triangular matrix with 1x1 and 2x2 blocks in the diagonal.The 1x1 blocks contains the real eigenvalues of a. The 2x2 blocks are matrices with the conjugated complex pairs of eigenvalues, whereas the real parts of the eigenvalues are the elements of the diagonal.
<p>
The calculation is performed stepwise using several lapack routines. First, lapack.dgehrd reduces matrix <b>A</b> is to upper Hessenberg form <b>H</b>=<b>Q'AQ</b>, whereas <b>Q</b> is computed by lapack.dodrghr.Finally, lapack.dhseqr transforms <b>H</b> to <b>T</b>. The eigenvalues of <b>A</b> are calculated straightforward from <b>T</b>.
<p>
Function <b>rsf</b> does not apply lapack.dgees, a routine to directly compute the real Schur from. See also
<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.rsf2"
>Math.Matrices.rsf2</a>
</p>


<h4><font color="#008000">Example</font></h4>
<blockquote><pre>
   Real A[3,3] = [1, 2, 3; 4, 5, 6; 7, 8, 9];
   Real T[3,3];
   Real Z[3,3];
   Real alphaReal[3];
   Real alphaImag[3];

<b>algorithm</b>
  (T, Z, alphaReal, alphaImag):=Modelica_LinearSystems2.Math.Matrices.rsf(A);
//   T = [16.12, 4.9,   1.59E-015;
//        0,    -1.12, -1.12E-015;
//        0,     0,    -1.30E-015]
//   Z = [-0.23,  -0.88,   0.41;
//        -0.52,  -0.24,  -0.82;
//        -0.82,   0.4,    0.41]
//alphaReal = {16.12, -1.12, -1.32E-015}
//alphaImag = {0, 0, 0}

</pre></blockquote>
<pre> </PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>T[size(A, 1), size(A, 2)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>Z[size(A, 1), size(A, 2)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>alphaReal[size(A, 1)]</TD><TD>Real part of eigenvalue=alphaReal+i*alphaImag</TD></TR>
<TR><TD>Real</TD><TD>alphaImag[size(A, 1)]</TD><TD>Imaginary part of eigenvalue=(alphaReal+i*alphaImag</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> rsf <font color="darkgreen">&quot;Computes the real Schur form (RSF) of a square matrix&quot;</font>
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices_Internal.html#Modelica_LinearSystems2.Math.Matrices.Internal"
>Modelica_LinearSystems2.Math.Matrices.Internal</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>;
  <font color="blue">input </font>Real A[:,<font color="red">size</font>(A, 1)];

<font color="blue">protected </font>
  Integer n=<font color="red">size</font>(A, 1);
  Integer i;
  Integer lwork;
  Real tau[<font color="red">max</font>(0,<font color="red"> size</font>(A, 1) - 1)];

  Real Aout[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)];
  Real H[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)] <font color="darkgreen">&quot;upper Hessenberg form of A&quot;</font>;
  Real Q[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)] <font color="darkgreen">
    &quot;represents the Hessenberg transformation as a product of the elementary reflectors&quot;</font>;
  Integer info1;
  Integer info2;

<font color="blue">public </font>
  <font color="blue">output </font>Real T[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)];
  <font color="blue">output </font>Real Z[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)];
  <font color="blue">output </font>Real alphaReal[<font color="red">size</font>(A, 1)] <font color="darkgreen">
    &quot;Real part of eigenvalue=alphaReal+i*alphaImag&quot;</font>;
  <font color="blue">output </font>Real alphaImag[<font color="red">size</font>(A, 1)] <font color="darkgreen">
    &quot;Imaginary part of eigenvalue=(alphaReal+i*alphaImag&quot;</font>;

<font color="blue">algorithm </font>
  <font color="blue">if </font><font color="red">size</font>(A, 1) &gt; 1<font color="blue"> then</font>

<font color="darkgreen">// dgehrd reduces a real matrix A to upper Hessenberg form Aout by an orthogonal</font>
<font color="darkgreen">// similarity transformation:  Q&#39; * A * Q = Aout. Q can be computed from</font>
<font color="darkgreen">// Aout and tau (dorghr)</font>

    (Aout,tau,info1) :=<font color="red"> LAPACK.dgehrd</font>(
      A,
      1,
      n);
    <font color="red">assert</font>(info1 == 0, &quot;The &quot; +<font color="red"> String</font>(-info1) +
      &quot;&#39;th argument of LAPACK.dgehrd had an illegal value&quot;);
<font color="darkgreen">// dorghr to compute Q</font>

    (Q,info1) :=<font color="red"> LAPACK.dorghr</font>(
      Aout,
      1,
      n,
      tau);
    <font color="red">assert</font>(info1 == 0, &quot;The &quot; +<font color="red"> String</font>(-info1) +
      &quot;&#39;th argument of LAPACK.dorghr had an illegal value&quot;);

    H[1:2, :] := Aout[1:2, :];
    <font color="blue">for </font>i<font color="blue"> in </font>3:n<font color="blue"> loop</font>
      H[i, i - 1:n] := Aout[i, i - 1:n];
    <font color="blue">end for</font>;
<font color="darkgreen">// dhseqr computes the eigenvalues of a real upper Hessenberg matrix H,</font>
<font color="darkgreen">// the Schur form T of H that is also the Schur form of A as well as the matrix</font>
<font color="darkgreen">// Z containing the Schur vectors to get A = Q*H*Q&#39; = (Z)*T*(Z)&#39;</font>

    lwork :=<font color="red"> max</font>(<font color="red">Internal.dhseqr_workdim</font>(H), 1);
    (alphaReal,alphaImag,info2,T,Z) :=<font color="red"> LAPACK.dhseqr</font>(
      H,
      lwork,
      false,
      &quot;V&quot;,
      Q);
    <font color="red">assert</font>(info2 == 0, &quot;The output info of LAPACK.dhseqr should be zero, else if\n
     info &lt; 0:  if info = -i, the i-th argument of LAPACK.dhseqr had an illegal value\n
     info &gt; 0:  if INFO = i, LAPACK.dhseqr failed to compute all of the  
                 eigenvalues in a total of 30*n iterations;\n  
                 elements 1:n-1 and i+1:n of WR and WI contain those  
                 eigenvalues which have been successfully computed.\n&quot;);
  <font color="blue">else</font>
    T := A;
    <font color="blue">if </font><font color="red">size</font>(A, 1) &gt; 0<font color="blue"> then</font>
      Z := [1];
      alphaReal := {1};
      alphaImag := {0};
    <font color="blue">else</font>
      Z :=<font color="red"> fill</font>(
        1,
        0,
        0);
      alphaReal :=<font color="red"> fill</font>(1, 0);
      alphaImag :=<font color="red"> fill</font>(0, 0);
    <font color="blue">end if</font>;
  <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>rsf;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE rsf2<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.rsf2"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.rsf2</H2>
<B>Computes the real Schur form (RSF) of a square matrix but uses lapack.dgees</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4><font color="#008000">Syntax</font></h4>()
<table>
<tr> <td align=right>  (T, Z, alphaReal, alphaImag) </td><td align=center> =  </td>  <td> Modelica_LinearSystems2.Math.Matrices.<b<rsf2</b>(A)  </td> </tr>
</table>
<h4><font color="#008000">Description</font></h4>
<p>
Function <b>rsf2</b> (real Schur form) calculates the real Schur form af a real square matrix <b>A</b>, i.e.
<blockquote><pre>
         T
A = Z*T*Z

</pre></blockquote>
with the real nxn matrices <b>T</b> and <b>Z</b>. <b>Z</b> is an orthogonal matrix.  <b>T</b> is an block upper triangular matrix with 1x1 and 2x2 blocks in the diagonal.The 1x1 blocks contains the real eigenvalues of a. The 2x2 blocks are matrices with the conjugated complex pairs of eigenvalues, whereas the real parts of the eigenvalues are the elements of the diagonal.
<p>
The calculation is performed stepwise using lapack.dgees, i.e. usng the internal mehtods of balacing and scaling of dgees.
<p>
See also <A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.rsf"
>Math.Matrices.rsf</a>
</p>


<h4><font color="#008000">Example</font></h4>
<blockquote><pre>
   Real A[3,3] = [1, 2, 3; 4, 5, 6; 7, 8, 9];
   Real T[3,3];
   Real Z[3,3];
   Real alphaReal[3];
   Real alphaImag[3];

<b>algorithm</b>
  (T, Z, alphaReal, alphaImag):=Modelica_LinearSystems2.Math.Matrices.rsf2(A);
//   T = [16.12, 4.9,   1.59E-015;
//        0,    -1.12, -1.12E-015;
//        0,     0,    -1.30E-015]
//   Z = [-0.23,  -0.88,   0.41;
//        -0.52,  -0.24,  -0.82;
//        -0.82,   0.4,    0.41]
//alphaReal = {16.12, -1.12, -1.32E-015}
//alphaImag = {0, 0, 0}

</pre></blockquote>
<pre> </PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>S[size(A, 1), size(A, 2)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>QZ[size(A, 1), size(A, 2)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>alphaReal[size(A, 1)]</TD><TD>Real part of eigenvalue=alphaReal+i*alphaImag</TD></TR>
<TR><TD>Real</TD><TD>alphaImag[size(A, 1)]</TD><TD>Imaginary part of eigenvalue=(alphaReal+i*alphaImag</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> rsf2 <font color="darkgreen">
  &quot;Computes the real Schur form (RSF) of a square matrix but uses lapack.dgees&quot;</font>
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices_Internal.html#Modelica_LinearSystems2.Math.Matrices.Internal"
>Modelica_LinearSystems2.Math.Matrices.Internal</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>;

  <font color="blue">input </font>Real A[:,<font color="red">size</font>(A, 1)];

<font color="blue">public </font>
  <font color="blue">output </font>Real S[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)];
  <font color="blue">output </font>Real QZ[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)];
  <font color="blue">output </font>Real alphaReal[<font color="red">size</font>(A, 1)] <font color="darkgreen">
    &quot;Real part of eigenvalue=alphaReal+i*alphaImag&quot;</font>;
  <font color="blue">output </font>Real alphaImag[<font color="red">size</font>(A, 1)] <font color="darkgreen">
    &quot;Imaginary part of eigenvalue=(alphaReal+i*alphaImag&quot;</font>;

<font color="blue">protected </font>
  Integer info;

<font color="blue">algorithm </font>
  <font color="blue">if </font><font color="red">size</font>(A, 1) &gt; 1<font color="blue"> then</font>
    (S, QZ, alphaReal, alphaImag, info) :=<font color="red"> Modelica_LinearSystems2.Math.Matrices.LAPACK.dgees</font>(A);
    <font color="red"> assert</font>(info == 0, &quot;The output info of LAPACK.dgees should be zero, else if\n
     info &lt; 0:  if info = -i, the i-th argument of dgees had an illegal value\n
     info &gt; 0:  if INFO = i, and i is   
               &lt;= N: the QR algorithm failed to compute all the   
                     eigenvalues; elements 1:ILO-1 and i+1:N of WR and WI   
                     contain those eigenvalues which have converged; if   
                     JOBVS = &#39;V&#39;, VS contains the matrix which reduces A   
                     to its partially converged Schur form.\n&quot;);
  <font color="blue">else</font>
    S := A;
    <font color="blue">if </font><font color="red">size</font>(A, 1) &gt; 0<font color="blue"> then</font>
      QZ := [1];
      alphaReal := {1};
      alphaImag := {0};
    <font color="blue">else</font>
      QZ :=<font color="red"> fill</font>(
        1,
        0,
        0);
      alphaReal :=<font color="red"> fill</font>(1, 0);
      alphaImag :=<font color="red"> fill</font>(0, 0);
    <font color="blue">end if</font>;
  <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>rsf2;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE solve<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Math.Matrices.solveI.png" ALT="Modelica_LinearSystems2.Math.Matrices.solve" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.solve"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.solve</H2>
<B>Solve real system of linear equations A*x=b with a b vector (Gaussian elemination with partial pivoting)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>solve</b>(A,b);
</pre></blockquote>
<h4>Description</h4>
<p>
This function call returns the
solution <b>x</b> of the linear system of equations
</p>
<blockquote>
<p>
<b>A</b>*<b>x</b> = <b>b</b>
</p>
</blockquote>
<p>
If a unique solution <b>x</b> does not exist (since <b>A</b> is singular),
an exception is raised.
</p>
<p>
Note, the solution is computed with the LAPACK function "dgesv",
i.e., by Gaussian elemination with partial pivoting.
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3; 
                 3,4,5;
                 2,1,4];
  Real b[3] = {10,22,12};
  Real x[3];
<b>algorithm</b>
  x := Matrices.solve(A,b);  // x = {3,2,1}
</pre></blockquote>
<h4>See also</h4>
<A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU"
>Matrices.LU</a>,
<A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU_solve"
>Matrices.LU_solve</a>
<pre></PRE><P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>Matrix A of A*x = b</TD></TR>
<TR><TD>Real</TD><TD>b[size(A, 1)]</TD><TD>&nbsp;</TD><TD>Vector b of A*x = b</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>x[size(b, 1)]</TD><TD>Vector x such that A*x = b</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> solve <font color="darkgreen">
  &quot;Solve real system of linear equations A*x=b with a b vector (Gaussian elemination with partial pivoting)&quot;</font>

  <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>Real A[:,<font color="red">size</font>(A, 1)] <font color="darkgreen">&quot;Matrix A of A*x = b&quot;</font>;
  <font color="blue">input </font>Real b[<font color="red">size</font>(A, 1)] <font color="darkgreen">&quot;Vector b of A*x = b&quot;</font>;
  <font color="blue">output </font>Real x[<font color="red">size</font>(b, 1)] <font color="darkgreen">&quot;Vector x such that A*x = b&quot;</font>;

<font color="blue">protected </font>
  Integer info;
<font color="blue">algorithm </font>
  <font color="blue">if </font><font color="red">size</font>(A, 1) &gt; 0<font color="blue"> then</font>
    (x,info) :=<font color="red"> Modelica.Math.Matrices.LAPACK.dgesv_vec</font>(A, b);
    <font color="red">assert</font>(info == 0, &quot;Solving a linear system of equations with function
\&quot;Matrices.solve\&quot; is not possible, because the system has either 
no or infinitely many solutions (A is singular).&quot;);
  <font color="blue">else</font>
    x :=<font color="red"> fill</font>(0, 0);
  <font color="blue">end if</font>;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>solve;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE solve2<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Math.Matrices.solveI.png" ALT="Modelica_LinearSystems2.Math.Matrices.solve2" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.solve2"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.solve2</H2>
<B>Solve real system of linear equations A*X=B with a B matrix (Gaussian elemination with partial pivoting)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>solve2</b>(A,b);
</pre></blockquote>
<h4>Description</h4>
<p>
This function call returns the
solution <b>X</b> of the linear system of equations
</p>
<blockquote>
<p>
<b>A</b>*<b>X</b> = <b>B</b>
</p>
</blockquote>
<p>
If a unique solution <b>X</b> does not exist (since <b>A</b> is singular),
an exception is raised.
</p>
<p>
Note, the solution is computed with the LAPACK function "dgesv",
i.e., by Gaussian elemination with partial pivoting.
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3; 
                 3,4,5;
                 2,1,4];
  Real B[3,2] = [10, 20;
                 22, 44;
                 12, 24];
  Real X[3,2];
<b>algorithm</b>
  (LU, pivots) := Matrices.LU(A);
  X := Matrices.solve2(A, B1);  /* X = [3, 6;
                                        2, 4;
                                        1, 2] */
</pre></blockquote>
 
<h4>See also</h4>
<A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU"
>Matrices.LU</a>,
<A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU_solve2"
>Matrices.LU_solve2</a>
<pre></PRE><P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>Matrix A of A*X = B</TD></TR>
<TR><TD>Real</TD><TD>B[size(A, 1), :]</TD><TD>&nbsp;</TD><TD>Matrix B of A*X = B</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>X[size(B, 1), size(B, 2)]</TD><TD>Matrix X such that A*X = B</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> solve2 <font color="darkgreen">
  &quot;Solve real system of linear equations A*X=B with a B matrix (Gaussian elemination with partial pivoting)&quot;</font>

  <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>Real A[:,<font color="red">size</font>(A, 1)] <font color="darkgreen">&quot;Matrix A of A*X = B&quot;</font>;
  <font color="blue">input </font>Real B[<font color="red">size</font>(A, 1),:] <font color="darkgreen">&quot;Matrix B of A*X = B&quot;</font>;
  <font color="blue">output </font>Real X[<font color="red">size</font>(B, 1),<font color="red">size</font>(B, 2)] <font color="darkgreen">&quot;Matrix X such that A*X = B&quot;</font>;

<font color="blue">protected </font>
  Integer info;
<font color="blue">algorithm </font>
  <font color="blue">if </font><font color="red">size</font>(A, 1) &gt; 0<font color="blue"> then</font>
    (X,info) :=<font color="red"> Modelica.Math.Matrices.LAPACK.dgesv</font>(A, B);
    <font color="red">assert</font>(info == 0, &quot;Solving a linear system of equations with function
\&quot;Matrices.solve2\&quot; is not possible, because the system has either 
no or infinitely many solutions (A is singular).&quot;);
  <font color="blue">else</font>
    X :=<font color="red"> fill</font>(
      0,
      <font color="red">size</font>(B, 1),
      <font color="red">size</font>(B, 2));
  <font color="blue">end if</font>;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>solve2;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE sylvester<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.sylvester"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.sylvester</H2>
<B>Solution of continuous-time Sylvester equation A*X + X*B = C</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
 
 
Function <b>sylvester</b> computes the solution <b>X</b> of the continuous-time Sylvester equation
<blockquote><pre>
 <b>A</b>*<b>X</b> + <b>X</b>*<b>B</b> = <b>C</b>.
</pre></blockquote>
using the Schur method for Sylvester equations proposed by Bartels and Stewart [1].
<p>
<A name="References"><B><FONT SIZE="+1">References</FONT></B></A>
<PRE>
  [1] Bartels, R.H. and Stewart G.W.
      Algorithm 432: Solution of the matrix equation AX + XB = C.
      Comm. ACM., Vol. 15, pp. 820-826, 1972.
</PRE>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, :]</TD><TD>&nbsp;</TD><TD>Matrix A</TD></TR>
<TR><TD>Real</TD><TD>B[:, :]</TD><TD>&nbsp;</TD><TD>Matrix B</TD></TR>
<TR><TD>Real</TD><TD>C[size(A, 1), size(B, 2)]</TD><TD>&nbsp;</TD><TD>Matrix C</TD></TR>
<TR><TD>Boolean</TD><TD>aIsSchur</TD><TD>false</TD><TD>True if A has already real Schur form</TD></TR>
<TR><TD>Boolean</TD><TD>bIsSchur</TD><TD>false</TD><TD>True if B has already real Schur form</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>X[size(A, 1), size(B, 2)]</TD><TD>Solution of Sylvester equation</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> sylvester <font color="darkgreen">
  &quot;Solution of continuous-time Sylvester equation A*X + X*B = C&quot;</font>
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;

  <font color="blue">input </font>Real A[:,:] <font color="darkgreen">&quot;Matrix A&quot;</font>;
  <font color="blue">input </font>Real B[:,:] <font color="darkgreen">&quot;Matrix B&quot;</font>;
  <font color="blue">input </font>Real C[<font color="red">size</font>(A, 1),<font color="red">size</font>(B, 2)] <font color="darkgreen">&quot;Matrix C&quot;</font>;
  <font color="blue">input </font>Boolean aIsSchur=false <font color="darkgreen">&quot;True if A has already real Schur form&quot;</font>;
  <font color="blue">input </font>Boolean bIsSchur=false <font color="darkgreen">&quot;True if B has already real Schur form&quot;</font>;
  <font color="blue">output </font>Real X[<font color="red">size</font>(A, 1),<font color="red">size</font>(B, 2)] <font color="darkgreen">&quot;Solution of Sylvester equation&quot;</font>;

<font color="blue">protected </font>
  Integer n=<font color="red">size</font>(A, 1);
  Integer m=<font color="red">size</font>(B, 1);
  Real S[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)];
  Real T[<font color="red">size</font>(B, 1),<font color="red">size</font>(B, 2)];
  Real U[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 1)];
  Real V[<font color="red">size</font>(B, 1),<font color="red">size</font>(B, 1)];
  Real Chat[<font color="red">size</font>(C, 1),<font color="red">size</font>(C, 2)];
  Real scale;
  Integer info;

<font color="blue">algorithm </font>
  <font color="blue">if </font>n &gt; 1<font color="blue"> and </font>m &gt; 1<font color="blue"> then</font>
    <font color="blue">if </font>aIsSchur<font color="blue"> then</font>
      S := A;
      U :=<font color="red"> identity</font>(n);
    <font color="blue">else</font>
      (S,U) :=<font color="red"> Matrices.rsf2</font>(A);
    <font color="blue">end if</font>;
    <font color="blue">if </font>bIsSchur<font color="blue"> then</font>
      T := B;
      V :=<font color="red"> identity</font>(m);
    <font color="blue">else</font>
      (T,V) :=<font color="red"> Matrices.rsf2</font>(B);
    <font color="blue">end if</font>;

    Chat := <font color="blue">if </font>aIsSchur<font color="blue"> and </font>bIsSchur<font color="blue"> then </font>C<font color="blue"> else </font><font color="blue">if </font>aIsSchur<font color="blue"> then </font>C*V<font color="blue"> else </font><font color="blue">if </font>
      bIsSchur<font color="blue"> then </font><font color="red">transpose</font>(U)*C<font color="blue"> else </font><font color="red">transpose</font>(U)*C*V;
    (X,scale,info) :=<font color="red"> Matrices.LAPACK.dtrsyl</font>(S, T, Chat);
    <font color="red">assert</font>(info == 0, &quot;Solving of Sylvester equation with Matrices.sylvester was not sucessfull.\n
                    The value of info is &quot; +<font color="red"> String</font>(info) + &quot;, but should be zero. A value unequal to zero means:\n
            &lt; 0: if INFO = -i, the i-th argument had an illegal value\n
            = 1: A and B have common or very close eigenvalues; perturbed   
                 values were used to solve the equation (but the matrices   
                 A and B are unchanged).&quot;);
    X := <font color="blue">if </font>aIsSchur<font color="blue"> and </font>bIsSchur<font color="blue"> then </font>scale*X<font color="blue"> else </font><font color="blue">if </font>aIsSchur<font color="blue"> then </font>scale*X*
      <font color="red">transpose</font>(V)<font color="blue"> else </font><font color="blue">if </font>bIsSchur<font color="blue"> then </font>scale*U*X<font color="blue"> else </font>scale*U*X*<font color="red">transpose</font>(V);
  <font color="blue">else</font>
    X :=<font color="red"> fill</font>(0, n, m);
  <font color="blue">end if</font>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>sylvester;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE toUpperHessenberg<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.toUpperHessenberg"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.toUpperHessenberg</H2>
<B>transform a real general matrix A to upper Hessenberg form H by an orthogonal similarity transformation:  Q&#39; * A * Q = H</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<b>This function uses DGEHRD-LAPACK routine to calculate a real general matrix A to upper Hessenberg form H by an orthogonal similarity transformation:  Q' * A * Q = H.</b>
<p>
Inputs are
<ul>
<li> square matrix A 
<li> indices ilo and ihi. See DGHRD description for further details of ilo and ihi
</ul>
</p>
<p>
Outputs are
<ul>
<li> Hessenberg matrix H = Q' * A * Q
<li> matrix V which contains the (Householder) vectors vi to perform the elementary reflectors Hi = I - tau * v * v' which finally define the matrix Q = product(Hi)
<li> vector tau with scalar weighting factors of the elementary reflectors
</ul>
</p>
 
<pre>
 
 
   =====================================================================  
    -- LAPACK routine (version 3.0) --  
      Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,  
      Courant Institute, Argonne National Lab, and Rice University  
      June 30, 1999  
 
  
   Purpose  
   =======  
 
   DGEHRD reduces a real general matrix A to upper Hessenberg form H by  
   an orthogonal similarity transformation:  Q&#39; * A * Q = H .  
 
   Arguments  
   =========  
 
   N       (input) INTEGER  
           The order of the matrix A.  N &gt;= 0.  
 
   ILO     (input) INTEGER  
   IHI     (input) INTEGER  
           It is assumed that A is already upper triangular in rows  
           and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally  
           set by a previous call to DGEBAL; otherwise they should be  
           set to 1 and N respectively. See Further Details.  
           1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0; ILO=1 and IHI=0, if N=0.  
 
   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)  
           On entry, the N-by-N general matrix to be reduced.  
           On exit, the upper triangle and the first subdiagonal of A  
           are overwritten with the upper Hessenberg matrix H, and the  
           elements below the first subdiagonal, with the array TAU,  
           represent the orthogonal matrix Q as a product of elementary  
           reflectors. See Further Details.  
 
   LDA     (input) INTEGER  
           The leading dimension of the array A.  LDA &gt;= max(1,N).  
 
   TAU     (output) DOUBLE PRECISION array, dimension (N-1)  
           The scalar factors of the elementary reflectors (see Further  
           Details). Elements 1:ILO-1 and IHI:N-1 of TAU are set to  
           zero.  
 
   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)  
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.  
 
   LWORK   (input) INTEGER  
           The length of the array WORK.  LWORK &gt;= max(1,N).  
           For optimum performance LWORK &gt;= N*NB, where NB is the  
           optimal blocksize.  
 
           If LWORK = -1, then a workspace query is assumed; the routine  
           only calculates the optimal size of the WORK array, returns  
           this value as the first entry of the WORK array, and no error  
           message related to LWORK is issued by XERBLA.  
 
   INFO    (output) INTEGER  
           = 0:  successful exit  
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value.  
 
   Further Details  
   ===============  
 
   The matrix Q is represented as a product of (ihi-ilo) elementary  
   reflectors  
 
      Q = H(ilo) H(ilo+1) . . . H(ihi-1).  
 
   Each H(i) has the form  
 
      H(i) = I - tau * v * v&#39;  
 
   where tau is a real scalar, and v is a real vector with  
   v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on  
   exit in A(i+2:ihi,i), and tau in TAU(i).  
 
   The contents of A are illustrated by the following example, with  
   n = 7, ilo = 2 and ihi = 6:  
 
   on entry,                        on exit,  
 
   ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )  
   (     a   a   a   a   a   a )    (      a   h   h   h   h   a )  
   (     a   a   a   a   a   a )    (      h   h   h   h   h   h )  
   (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )  
   (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )  
   (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )  
   (                         a )    (                          a )  
 
   where a denotes an element of the original matrix A, h denotes a  
   modified element of the upper Hessenberg matrix H, and vi denotes an  
   element of the vector defining H(i).  
 
   =====================================================================  
</PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Integer</TD><TD>ilo</TD><TD>1</TD><TD>lowest index where the original matrix had been Hessenbergform</TD></TR>
<TR><TD>Integer</TD><TD>ihi</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>H[size(A, 1), size(A, 2)]</TD><TD>Upper Hessenberg form</TD></TR>
<TR><TD>Real</TD><TD>V[size(A, 1), size(A, 2)]</TD><TD>V=[v1,v2,..vn-1,0] with vi are vectors which define the elementary reflectors</TD></TR>
<TR><TD>Real</TD><TD>tau[size(A, 1) - 1]</TD><TD>&nbsp;</TD></TR>
<TR><TD>Integer</TD><TD>info</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> toUpperHessenberg <font color="darkgreen">
  &quot;transform a real general matrix A to upper Hessenberg form H by an orthogonal similarity transformation:  Q&#39; * A * Q = H&quot;</font>
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>;
  <font color="blue">input </font>Real A[:,<font color="red">size</font>(A, 1)];
  <font color="blue">input </font>Integer ilo=1 <font color="darkgreen">
    &quot;lowest index where the original matrix had been Hessenbergform&quot;</font>;
  <font color="blue">input </font>Integer ihi;<font color="darkgreen">//=size(A, 1) &quot;highest index where the original matrix had been Hessenbergform&quot;;</font>
  <font color="blue">output </font>Real H[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)] <font color="darkgreen">&quot;Upper Hessenberg form&quot;</font>;
  <font color="blue">output </font>Real V[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)] <font color="darkgreen">
    &quot;V=[v1,v2,..vn-1,0] with vi are vectors which define the elementary reflectors&quot;</font>;

  <font color="blue">output </font>Real tau[<font color="red">size</font>(A, 1) - 1];
  <font color="blue">output </font>Integer info;

<font color="blue">protected </font>
  Integer n=<font color="red">size</font>(A, 1);
  Real Aout[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)];
  Integer i;

<font color="blue">algorithm </font>
  (Aout,tau,info) :=<font color="red"> LAPACK.dgehrd</font>(
    A,
    ilo,
    ihi);
  H[1:2, 1:ihi] := Aout[1:2, 1:ihi];
  H[1:2, ihi + 1:n] := A[1:2, ihi + 1:n];

  <font color="blue">for </font>i<font color="blue"> in </font>3:n<font color="blue"> loop</font>
    H[i, i - 1:ihi] := Aout[i, i - 1:ihi];
    H[i, ihi + 1:n] := A[i, ihi + 1:n];
  <font color="blue">end for</font>;

  <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">min</font>(n - 2, ihi)<font color="blue"> loop</font>
    V[i + 1, i] := 1.0;
    V[i + 2:n, i] := Aout[i + 2:n, i];

  <font color="blue">end for</font>;
  V[n, n - 1] := 1;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>toUpperHessenberg;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE trace<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Math.Matrices.traceI.png" ALT="Modelica_LinearSystems2.Math.Matrices.trace" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.trace"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.trace</H2>
<B>tarce(A) is the sum of the diagonal elements of A</B><p>
<P><H3>Information</H3></P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>result</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> trace <font color="darkgreen">&quot;tarce(A) is the sum of the diagonal elements of A&quot;</font>
  <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;

  <font color="blue">input </font>Real A[:,<font color="red">size</font>(A, 1)];
  <font color="blue">output </font>Real result;

<font color="blue">protected </font>
  Integer n=<font color="red">size</font>(A, 1);
  Real r;

<font color="blue">algorithm </font>
  r := 0;
  <font color="blue">if </font>n &gt; 0<font color="blue"> then</font>
    <font color="blue">for </font>i<font color="blue"> in </font>1:n<font color="blue"> loop</font>
      r := r + A[i, i];
    <font color="blue">end for</font>;
  <font color="blue">end if</font>;
  result := r;
<font color="blue">end </font>trace;
</PRE>
<HR>
<address>HTML-documentation generated by <a href="http://www.Dymola.com/">Dymola</a> Fri Jan 15 12:28:54 2010.
</address></BODY>
</HTML>
