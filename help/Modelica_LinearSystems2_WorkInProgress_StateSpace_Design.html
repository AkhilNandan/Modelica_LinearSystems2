<HTML>
<HEAD>
<TITLE>Modelica_LinearSystems2.WorkInProgress.StateSpace.Design</TITLE>
<META name="HTML-Generator" content="Dymola">
<style type="text/css">
*       { font-size: 10pt; font-family: Arial,sans-serif; }
pre     { font-size:  9pt; font-family: Courier,monospace;}
h4      { font-size: 10pt; font-weight: bold; color: green; }
h3      { font-size: 11pt; font-weight: bold; color: green; }
h2      { font-size: 13pt; font-weight: bold; color: green; }
address {                  font-weight: normal} 
td      { solid #000; vertical-align:top; }
th      { solid #000; vertical-align:top; font-weight: bold; }
table   { solid #000; border-collapse: collapse;}
</style>
</HEAD>
<BODY><P>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Design<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.WorkInProgress.StateSpace.Design"></A><A HREF="Modelica_LinearSystems2_WorkInProgress_StateSpace.html#Modelica_LinearSystems2.WorkInProgress.StateSpace"
>Modelica_LinearSystems2.WorkInProgress.StateSpace</A>.Design</H2>
<P><H3>Package Content</H3><p>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 >
<TR><TH >Name</TH><TH>Description</TH></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.WorkInProgress.StateSpace.Design.assignPolesMI2S.png" ALT="Modelica_LinearSystems2.WorkInProgress.StateSpace.Design.assignPolesMI2" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_WorkInProgress_StateSpace_Design.html#Modelica_LinearSystems2.WorkInProgress.StateSpace.Design.assignPolesMI2"
>assignPolesMI2</A>
</TD><TD>Pole assigment design algorithm for multi input systems</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.WorkInProgress.StateSpace.Design.assignPolesMI2S.png" ALT="Modelica_LinearSystems2.WorkInProgress.StateSpace.Design.assignPolesMI" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_WorkInProgress_StateSpace_Design.html#Modelica_LinearSystems2.WorkInProgress.StateSpace.Design.assignPolesMI"
>assignPolesMI</A>
</TD><TD>Pole assigment design algorithm for multi input systems</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE assignPolesMI2<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.WorkInProgress.StateSpace.Design.assignPolesMI2"></A><A HREF="Modelica_LinearSystems2_WorkInProgress_StateSpace_Design.html#Modelica_LinearSystems2.WorkInProgress.StateSpace.Design"
>Modelica_LinearSystems2.WorkInProgress.StateSpace.Design</A>.assignPolesMI2</H2>
<B>Pole assigment design algorithm for multi input systems</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4><font color="#008000">Syntax</font></h4>
<table>
<tr> <td align=right>  (K, S, po, nfp, nap, nup) </td><td align=center> =  </td>  <td> StateSpace.Design.<b>assignPolesMI</b>(ss, gamma, np, alpha, tol)  </td> </tr>
</table>
<h4><font color="#008000">Description</font></h4>
<p>
The purpose of this function is to determine the state feedback matrix <b>K</b> for a
given time invariant multi input state system (<b>A</b>,<b>B</b>) such that the
closed-loop state matrix <b>A</b>-<b>B</b>*<b>K</b> has specified eigenvalues. The
feedback matrix <b>K</b> is calculated by factorization following [1]. The algorithm
modifies the eigenvalues sequentially and also allows partial eigenvalue assignment.<br>
<br>


 At the beginning of the algorithm, the feedback matrix <b>K</b> is set to zero (<b>K</b> = <b>0</b>) and the matrix <b>A</b> is
 reduced to an ordered real Schur form by separating its spectrum in two parts

<blockquote><pre>
              | <b>F</b>1  <b>F</b>3|
 <b>F</b> = <b>Q</b>*<b>A</b>*<b>Q</b>' = |       |
              | <b>0</b>   <b>F</b>2|
 </pre>
</blockquote> in such a way, that <b>F</b>1 contains the eigenvalues that will be
retained and <b>F</b>3 contains the eigenvalues going to be modified. On the suggestion
of [1] the eigenvalues <i>evr</i> to be retained are chosen as
 <blockquote><pre>
  evr = {s in C: Re(s) &lt -alpha, alpha &gt =0}
 </pre> </blockquote>
but other specification are conceivable of course.<br>
<br>

Let
 <blockquote><pre>
  <b>G</b> = [<b>G</b>1;<b>G</b>2] = <b>Q</b>*<b>B</b>
 </pre> </blockquote>
with an appropriate partition according to <b>F</b>2. (<b>F</b>2, <b>G</b>2) has to be
controllable.<br>

If the feedback matrix <b>K</b> is taken in a form <blockquote><pre> <b>K</b> = [0, <b>K</b>2]
</pre></blockquote> the special structure of <b>F</b> and <b>K</b> results in a closed loop state
matrix <blockquote><pre>
          |<b>F</b>1 <b>F</b>3 - <b>G</b>1*<b>K</b>2|
<b>F</b> - <b>G</b>*<b>K</b> = |             |
          |0  <b>F</b>2 - <b>G</b>2*<b>K</b>2|
</pre></blockquote> with only the eigenvalues of <b>F</b>2 are modified. This approach to modify
separated eigenvalues is used to sequentially shift one real eigenvalue ore two
complex conjugated eigenvalues stepwise until all assigned eigenvalues are placed.
Therefore, at each step i always the (two) lower right eingenvalue(s) are modified by an
appropriate feedback matrix <b>K</b>i. The matrix <b>F</b> - <b>G</b>*<b>K</b>i remains in real Schur form. The
assigned eigenvalue(s) is (are) then moved to another diagonal position of the real Schur
form using reordering techniques <b>F</b> &lt -- <b>Q</b>i*<b>F</b>*<b>Q</b>i'  and a new block is transferred to the
lower right diagonal position. The transformations are accumulated in <b>Q</b>i and are also
applicated to the matrices <blockquote><pre> <b>G</b> &lt - <b>Q</b>i*<b>G</b> <b>Q</b> &lt - <b>Q</b>i*<b>Q</b> </pre></blockquote>
The eigenvalue(s) to be assigned at  each step is (are) chosen such that the norm of each <b>K</b>i is minimized [1].
<p>



</p>

<h4><font color="#008000">Example</font></h4>
<blockquote><pre>
   Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
      A=[-1, 1, 1;0, 1, 1;0, 0, 1],
      B=[0; 0; 1],
      C=[0, 1, 0],
      D=[0]);

   Real Q[3,3];

<b>algorithm</b>
  Q := Modelica_LinearSystems2.StateSpace.Analysis.observabilityMatrix(ss);
// Q = [0, 1, 0; 0, 1, 1; 1, 1, 2]
</pre></blockquote>


<h4><font color="#008000">References</font></h4>
<table>
<tr> <td align=right>  [1] </td><td align=center>  Varga A.  </td>  <td> "A Schur method for pole assignment"  </td> <td> IEEE Trans. Autom. Control, Vol. AC-26, pp. 517-519, 1981 </td></tr>
</table>

<pre> </PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>ss</TD><TD>state space system</TD></TR>
<TR><TD>gamma[:]</TD><TD>Designed Poles</TD></TR>
<TR><TD>np</TD><TD>number of given eigenvalues to assign</TD></TR>
<TR><TD>giveEigenvalues</TD><TD>Boolean parameter to display the order of the eigenvalues</TD></TR>
<TR><TD>alpha</TD><TD>maximum admissible value for real parts(continuous) or for moduli (discrete) of the eigenvalues of A which will not be modified by the eigenvalue assignment algorithm</TD></TR>
<TR><TD>tolerance</TD><TD>The tolerance to be used in determining the controllability of (A,B)</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>K[size(ss.B, 2), size(ss.A, 1)]</TD><TD>State feedback matrix assigning the desired poles</TD></TR>
<TR><TD>S[:, :]</TD><TD>Closed loop System matrix</TD></TR>
<TR><TD>po[size(ss.A, 1)]</TD><TD>poles of the closed loop system</TD></TR>
<TR><TD>nfp</TD><TD>number of eigenvalues that are not modified with respect to alpha</TD></TR>
<TR><TD>nap</TD><TD>number of assigned eigenvalues</TD></TR>
<TR><TD>nup</TD><TD>number of uncontrollable eigenvalues</TD></TR>
<TR><TD>X[size(ss.A, 1), size(ss.A, 1)]</TD><TD>eigenvectors of the closed loop system</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE assignPolesMI<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.WorkInProgress.StateSpace.Design.assignPolesMI"></A><A HREF="Modelica_LinearSystems2_WorkInProgress_StateSpace_Design.html#Modelica_LinearSystems2.WorkInProgress.StateSpace.Design"
>Modelica_LinearSystems2.WorkInProgress.StateSpace.Design</A>.assignPolesMI</H2>
<B>Pole assigment design algorithm for multi input systems</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4><font color="#008000">Syntax</font></h4>
<table>
<tr> <td align=right>  (K, S, po, nfp, nap, nup) </td><td align=center> =  </td>  <td> StateSpace.Design.<b>assignPolesMI</b>(ss, gamma, np, tol, calculateEigenvectors)  </td> </tr>
</table>
<h4><font color="#008000">Description</font></h4>
<p>
The purpose of this function is to determine the state feedback matrix <b>K</b> for a
given time invariant multi input state system (<b>A</b>,<b>B</b>) such that the
closed-loop state matrix <b>A</b>-<b>B</b>*<b>K</b> has specified eigenvalues. The
feedback matrix <b>K</b> is calculated by factorization following [1]. The algorithm
modifies the eigenvalues sequentially and also allows partial eigenvalue assignment.<br>
<br>


 At the beginning of the algorithm, the feedback matrix <b>K</b> is set to zero (<b>K</b> = <b>0</b>) and the matrix <b>A</b> is
 reduced to an ordered real Schur form by separating its spectrum in two parts

<blockquote><pre>
              | <b>F</b>1  <b>F</b>3|
 <b>F</b> = <b>Q</b>*<b>A</b>*<b>Q</b>' = |       |
              | <b>0</b>   <b>F</b>2|
 </pre>
</blockquote> in such a way, that <b>F</b>1 contains the eigenvalues that will be
retained and <b>F</b>3 contains the eigenvalues going to be modified. On the suggestion
of [1] the eigenvalues <i>evr</i> to be retained are chosen as
 <blockquote><pre>
  evr = {s in C: Re(s) &lt -alpha, alpha &gt =0}
 </pre> </blockquote>
but other specification are conceivable of course.<br>
<br>

Let
 <blockquote><pre>
  <b>G</b> = [<b>G</b>1;<b>G</b>2] = <b>Q</b>*<b>B</b>
 </pre> </blockquote>
with an appropriate partition according to <b>F</b>2. (<b>F</b>2, <b>G</b>2) has to be
controllable.<br>

If the feedback matrix <b>K</b> is taken in a form <blockquote><pre> <b>K</b> = [0, <b>K</b>2]
</pre></blockquote> the special structure of <b>F</b> and <b>K</b> results in a closed loop state
matrix <blockquote><pre>
          |<b>F</b>1 <b>F</b>3 - <b>G</b>1*<b>K</b>2|
<b>F</b> - <b>G</b>*<b>K</b> = |             |
          |0  <b>F</b>2 - <b>G</b>2*<b>K</b>2|
</pre></blockquote> with only the eigenvalues of <b>F</b>2 are modified. This approach to modify
separated eigenvalues is used to sequentially shift one real eigenvalue ore two
complex conjugated eigenvalues stepwise until all assigned eigenvalues are placed.
Therefore, at each step i always the (two) lower right eigenvalue(s) are modified by an
appropriate feedback matrix <b>K</b>i. The matrix <b>F</b> - <b>G</b>*<b>K</b>i remains in real Schur form. The
assigned eigenvalue(s) is (are) then moved to another diagonal position of the real Schur
form using reordering techniques <b>F</b> &lt -- <b>Q</b>i*<b>F</b>*<b>Q</b>i'  and a new block is transferred to the
lower right diagonal position. The transformations are accumulated in <b>Q</b>i and are also
applicated to the matrices <blockquote><pre> <b>G</b> &lt - <b>Q</b>i*<b>G</b> <b>Q</b> &lt - <b>Q</b>i*<b>Q</b> </pre></blockquote>
The eigenvalue(s) to be assigned at  each step is (are) chosen such that the norm of each <b>K</b>i is minimized [1].
<p>



</p>

<h4><font color="#008000">Example</font></h4>
<blockquote><pre>
   Modelica_LinearSystems2.StateSpace ss=Modelica_LinearSystems2.StateSpace(
      A=[-1, 1, 1;0, 1, 1;0, 0, 1],
      B=[0; 0; 1],
      C=[0, 1, 0],
      D=[0]);

   Real Q[3,3];

<b>algorithm</b>
  Q := Modelica_LinearSystems2.StateSpace.Analysis.observabilityMatrix(ss);
// Q = [0, 1, 0; 0, 1, 1; 1, 1, 2]
</pre></blockquote>


<h4><font color="#008000">References</font></h4>
<table>
<tr> <td align=right>  [1] </td><td align=center>  Varga A.  </td>  <td> "A Schur method for pole assignment"  </td> <td> IEEE Trans. Autom. Control, Vol. AC-26, pp. 517-519, 1981 </td></tr>
</table>

<pre> </PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>ss</TD><TD>state space system</TD></TR>
<TR><TD>gamma[:]</TD><TD>Designed Poles</TD></TR>
<TR><TD>alpha</TD><TD>maximum admissible value for real parts(continuous) or for moduli (discrete) of the eigenvalues of A which will not be modified by the eigenvalue assignment algorithm</TD></TR>
<TR><TD>tolerance</TD><TD>The tolerance to be used in determining the controllability of (A,B)</TD></TR>
<TR><TD>calculateEigenvectors</TD><TD>Calculate the eigenvectors X of the closed loop system when true</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>K[size(ss.B, 2), size(ss.A, 1)]</TD><TD>State feedback matrix assigning the desired poles</TD></TR>
<TR><TD>S[:, :]</TD><TD>Closed loop System matrix</TD></TR>
<TR><TD>po[size(ss.A, 1)]</TD><TD>poles of the closed loop system</TD></TR>
<TR><TD>nfp</TD><TD>number of eigenvalues that are not modified with respect to alpha</TD></TR>
<TR><TD>nap</TD><TD>number of assigned eigenvalues</TD></TR>
<TR><TD>nup</TD><TD>number of uncontrollable eigenvalues</TD></TR>
<TR><TD>X[size(ss.A, 1), size(ss.A, 1)]</TD><TD>eigenvectors of the closed loop system</TD></TR>
</TABLE>
<address>HTML-documentation generated by <a href="http://www.Dymola.com/">Dymola</a> Wed Oct 27 10:53:51 2010.
</address></BODY>
</HTML>
