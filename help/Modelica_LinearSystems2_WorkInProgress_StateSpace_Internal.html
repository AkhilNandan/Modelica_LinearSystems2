<HTML>
<HEAD>
<TITLE>Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal</TITLE>
<META name="HTML-Generator" content="Dymola">
<style type="text/css">
*       { font-size: 10pt; font-family: Arial,sans-serif; }
pre     { font-size:  9pt; font-family: Courier,monospace;}
h4      { font-size: 10pt; font-weight: bold; color: green; }
h3      { font-size: 11pt; font-weight: bold; color: green; }
h2      { font-size: 13pt; font-weight: bold; color: green; }
address {                  font-weight: normal} 
td      { solid #000; vertical-align:top; }
th      { solid #000; vertical-align:top; font-weight: bold; }
table   { solid #000; border-collapse: collapse;}
</style>
</HEAD>
<BODY><P>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Internal<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal"></A><A HREF="Modelica_LinearSystems2_WorkInProgress_StateSpace.html#Modelica_LinearSystems2.WorkInProgress.StateSpace"
>Modelica_LinearSystems2.WorkInProgress.StateSpace</A>.Internal</H2>
<P><H3>Package Content</H3><p>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 >
<TR><TH >Name</TH><TH>Description</TH></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.assignPolesMI_rob_oldS.png" ALT="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.assignPolesMI_rob_old" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_WorkInProgress_StateSpace_Internal.html#Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.assignPolesMI_rob_old"
>assignPolesMI_rob_old</A>
</TD><TD>&nbsp;</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.wrapper_modifyX_oldS.png" ALT="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.wrapper_modifyX_old" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_WorkInProgress_StateSpace_Internal.html#Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.wrapper_modifyX_old"
>wrapper_modifyX_old</A>
</TD><TD>Contains a C sub routine of robust pole assignment to modify the eigenvector matrix X according to Kautsky algorithm</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.wrapper_modifyX_oldS.png" ALT="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.modifyX_old" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_WorkInProgress_StateSpace_Internal.html#Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.modifyX_old"
>modifyX_old</A>
</TD><TD>Contains a C sub routine of robust pole assignment to modify the eigenvector matrix X according to Kautsky algorithm</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.assignPolesMI_robS.png" ALT="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.assignPolesMI_rob" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_WorkInProgress_StateSpace_Internal.html#Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.assignPolesMI_rob"
>assignPolesMI_rob</A>
</TD><TD>Modified KNV algorithm. Works like MATLAB&#39;s place.m</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.assignPolesMI_robS.png" ALT="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.assignPolesMI_rob2" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_WorkInProgress_StateSpace_Internal.html#Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.assignPolesMI_rob2"
>assignPolesMI_rob2</A>
</TD><TD>Modified KNV algorithm. Works like MATLAB&#39;s place.m</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.assignPolesMI_robS.png" ALT="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.assignPolesSI_rq" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_WorkInProgress_StateSpace_Internal.html#Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.assignPolesSI_rq"
>assignPolesSI_rq</A>
</TD><TD>RQ implementation of a recursiv single-input pole assignment problem</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.xBaseS.png" ALT="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.xBase" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_WorkInProgress_StateSpace_Internal.html#Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.xBase"
>xBase</A>
</TD><TD>Compute the eigenvector bases according to Kautsky algorithm</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.xBaseS.png" ALT="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.calcK" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_WorkInProgress_StateSpace_Internal.html#Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.calcK"
>calcK</A>
</TD><TD>Computes the feedback matrix from the assigned eigenvalues, closed loop eigenvectors and the B matrix factorization</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.xBaseS.png" ALT="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.modifyX" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_WorkInProgress_StateSpace_Internal.html#Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.modifyX"
>modifyX</A>
</TD><TD>Contains a C sub routine of robust pole assignment to modify the eigenvector matrix X according to Kautsky algorithm</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.xBaseS.png" ALT="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.wrapper_calcK" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_WorkInProgress_StateSpace_Internal.html#Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.wrapper_calcK"
>wrapper_calcK</A>
</TD><TD>Computes the feedback matrix from the assigned eigenvalues, closed loop eigenvectors and the B matrix factorization</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.xBaseS.png" ALT="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.wrapper_modifyX" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_WorkInProgress_StateSpace_Internal.html#Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.wrapper_modifyX"
>wrapper_modifyX</A>
</TD><TD>Contains a C sub routine of robust pole assignment to modify the eigenvector matrix X according to Kautsky algorithm</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.xBaseS.png" ALT="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.wrapper_xBase" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_WorkInProgress_StateSpace_Internal.html#Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.wrapper_xBase"
>wrapper_xBase</A>
</TD><TD>Compute the eigenvector bases according to Kautsky algorithm</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE assignPolesMI_rob_old<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.assignPolesMI_rob_oldI.png" ALT="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.assignPolesMI_rob_old" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.assignPolesMI_rob_old"></A><A HREF="Modelica_LinearSystems2_WorkInProgress_StateSpace_Internal.html#Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal"
>Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal</A>.assignPolesMI_rob_old</H2>
<P><H3>Information</H3></P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>system matrix</TD></TR>
<TR><TD>Real</TD><TD>B[size(A, 1), :]</TD><TD>&nbsp;</TD><TD>control input matrix</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>gamma[size(A, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Boolean</TD><TD>IniX</TD><TD>false</TD><TD>Initial values of X are provided</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>Xini[size(A, 1), size(A, 1)]</TD><TD>fill(Complex(0), size(A, 1),...</TD><TD>Initial values of the eigenvectors X</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>K[size(B, 2), size(A, 1)]</TD><TD>feedback matrix</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>evX[:, :]</TD><TD>eigen vectors of the closed loop system</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> assignPolesMI_rob_old
  <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;

  <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
  <font color="blue">import </font>matMul = <A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Complex.Matrices.matMatMul"
>Modelica_LinearSystems2.Math.Complex.Matrices.matMatMul</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Complex.Matrices.matVecMul"
>Modelica_LinearSystems2.Math.Complex.Matrices.matVecMul</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Internal.html#Modelica_LinearSystems2.Math.Complex.Internal.C_transpose"
>Modelica_LinearSystems2.Math.Complex.Internal.C_transpose</A>;
  <font color="blue">import </font>Re = <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex.real"
>Modelica_LinearSystems2.Math.Complex.real</A>;
  <font color="blue">import </font>Im = <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex.imag"
>Modelica_LinearSystems2.Math.Complex.imag</A>;
  <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams.print"
>Modelica.Utilities.Streams.print</A>;

  <font color="blue">input </font>Real A[:,<font color="red">size</font>(A, 1)] <font color="darkgreen">&quot;system matrix&quot;</font>;
  <font color="blue">input </font>Real B[<font color="red">size</font>(A, 1),:] <font color="darkgreen">&quot;control input matrix&quot;</font>;
  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> gamma[<font color="red">size</font>(A, 1)];
  <font color="blue">input </font>Boolean IniX=false <font color="darkgreen">&quot;Initial values of X are provided&quot;</font>;
  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> Xini[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 1)]=<font color="red">fill</font>(<font color="red">Complex</font>(0),<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 1)) <font color="darkgreen">
    &quot;Initial values of the eigenvectors X&quot;</font>;

  <font color="blue">output </font>Real K[<font color="red">size</font>(B, 2),<font color="red">size</font>(A, 1)] <font color="darkgreen">&quot;feedback matrix&quot;</font>;
  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> evX[:,:] <font color="darkgreen">&quot;eigen vectors of the closed loop system&quot;</font>;
<font color="blue">protected </font>
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> AC[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)]=<font color="red">Complex</font>(1)*A;
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> Lambda[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 1)];
  Real Ur[:,:];
  Real Vr[:,:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> U0[:,:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> U1[:,:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> U1T[:,:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> X[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)]=Xini;
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> Xj[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 1)-1];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> XC[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> XC2[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> Z[:,:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> M[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 1)];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> KC[:,:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> QX[:,:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> C[:,:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> Cc[:,:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> Sr[:,:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> ST[:,:];

  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> gammaSorted[<font color="red">size</font>(gamma, 1)];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> gammaSorted2[<font color="red">size</font>(gamma, 1)];
  Real sigmaB[:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> ev[<font color="red">size</font>(A, 1)];

  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> y[:];

  Real condX2;
  Real norm_y;
  Integer rankB;
  Integer nx=<font color="red">size</font>(A, 1);
  Integer numberOfRealEigenvalues;
  Integer numberOfComplexPairs;
  Integer i;
  Integer l1;
  Integer l2;
  Integer k;
  Integer idx;
  Real eps=Modelica.Constants.eps;
  Integer maxSteps=3;

  <A HREF="Modelica_LinearSystems2_WorkInProgress_StateSpace_Internal.html#Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.assignPolesMI_rob_old.subSpace"
>Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.assignPolesMI_rob_old.subSpace</A>
    subS[<font color="red">                                                                         size</font>(gamma,1)];

  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> a;
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> MM[:,:];
  Integer cnt;
  <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss=<font color="red">StateSpace</font>(A=A, B=B, C=<font color="red">zeros</font>(1,nx), D=<font color="red">zeros</font>(1,<font color="red">size</font>(B,2)));

<font color="blue">algorithm </font>
  <font color="darkgreen">//check controllability</font>
  <font color="red">assert</font>(<font color="red">StateSpace.Analysis.isControllable</font>(ss),&quot;Poles cannot be placed since system is not controllable&quot;);

  <font color="darkgreen">// sort eigenvalues to [real ev, complex ev(im&gt;0), conj(complex ev(im&gt;0))]</font>
  (gammaSorted2,numberOfRealEigenvalues) :=
    <font color="red">Modelica_LinearSystems2.Internal.reorderZeros</font>(gamma);
  gammaSorted := gammaSorted2;
  numberOfComplexPairs :=<font color="red"> integer</font>((nx - numberOfRealEigenvalues)/2);
  <font color="blue">for </font>i<font color="blue"> in </font>numberOfRealEigenvalues + 1:numberOfRealEigenvalues + numberOfComplexPairs<font color="blue"> loop</font>
    gammaSorted[i] := <font color="blue">if </font><font color="red">Im</font>(gammaSorted2[2*i-numberOfRealEigenvalues-1]) &gt; 0<font color="blue"> then </font>gammaSorted2[2*i-numberOfRealEigenvalues-1]<font color="blue"> else </font><font color="red">Complex.conj</font>(gammaSorted2[2*i-numberOfRealEigenvalues-1]);
    gammaSorted[i + numberOfComplexPairs] :=<font color="red"> Complex.conj</font>(gammaSorted[i]);
  <font color="blue">end for</font>;

  <font color="blue">for </font>i<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
    Lambda[i, i] := gammaSorted[i];
  <font color="blue">end for</font>;

<font color="darkgreen">//   (sigmaB,Q,R) := Matrices.C_singularValues(BC);</font>
<font color="darkgreen">//   rankB := 0;</font>
<font color="darkgreen">//   i := size(sigmaB, 1);</font>
<font color="darkgreen">//   while i &gt; 0 loop</font>
<font color="darkgreen">//     if sigmaB[i] &gt; 1e-10 then</font>
<font color="darkgreen">//       rankB := i;</font>
<font color="darkgreen">//       i := 0;</font>
<font color="darkgreen">//     end if;</font>
<font color="darkgreen">//     i := i - 1;</font>
<font color="darkgreen">//   end while;</font>

  (sigmaB,Ur,Vr) :=<font color="red"> Modelica.Math.Matrices.singularValues</font>(B);
  rankB := 0;
  i :=<font color="red"> size</font>(sigmaB, 1);
  <font color="blue">while </font>i &gt; 0<font color="blue"> loop</font>
    <font color="blue">if </font>sigmaB[i] &gt; 1e-10<font color="blue"> then</font>
      rankB := i;
      i := 0;
    <font color="blue">end if</font>;
    i := i - 1;
  <font color="blue">end while</font>;

<font color="darkgreen">//    R := C_transpose(R);</font>
<font color="darkgreen">//    Z := R[1:rankB, 1:size(B, 2)];</font>
<font color="darkgreen">//   for l1 in 1:rankB loop</font>
<font color="darkgreen">//     for l2 in 1:size(B, 2) loop</font>
<font color="darkgreen">//       Z[l1, l2] := Z[l1, l2]/sigmaB[l2];</font>
<font color="darkgreen">//     end for;</font>
<font color="darkgreen">//   end for;</font>

   Z :=<font color="red"> fill</font>(<font color="red">Complex</font>(0),<font color="red"> size</font>(B, 2), rankB);
   <font color="blue">for </font>l1<font color="blue"> in </font>1:rankB<font color="blue"> loop</font>
     <font color="blue">for </font>l2<font color="blue"> in </font>1:<font color="red">size</font>(B, 2)<font color="blue"> loop</font>
<font color="darkgreen">//       Z[l1, l2] := Complex.conj(R[l2, l1])/sigmaB[l2];</font>
       Z[l1, l2] :=<font color="red"> Complex</font>((Vr[l2, l1])/sigmaB[l2]);
     <font color="blue">end for</font>;
   <font color="blue">end for</font>;

<font color="darkgreen">//   U0 := Q[:, 1:rankB];</font>
<font color="darkgreen">//   U1 := Q[:, rankB + 1:nx];</font>
<font color="darkgreen">//   U1T := C_transpose(U1);</font>

  U0 :=<font color="red"> Complex</font>(1)*Ur[:, 1:rankB];
  U1 :=<font color="red"> Complex</font>(1)*Ur[:, rankB + 1:nx];
  U1T :=<font color="red"> Complex</font>(1)*<font color="red">transpose</font>(Ur[:, rankB + 1:nx]);

  condX2 := eps + 1;

  <font color="blue">if </font>numberOfComplexPairs &gt; 0<font color="blue"> then</font>
<font color="darkgreen">//      (sigmaM,Qu,Ru) := Matrices.C_singularValues([U1T;  matMul(U1T,Complex(1)*A)]);</font>
<font color="darkgreen">//       rank_ := 0;</font>
<font color="darkgreen">//          i := size(sigmaM,1);</font>
<font color="darkgreen">//        while i &gt; 0 loop</font>
<font color="darkgreen">//          if sigmaM[i] &gt; 1e-10 then</font>
<font color="darkgreen">//            rank_ := i;</font>
<font color="darkgreen">//            i := 0;</font>
<font color="darkgreen">//          end if;</font>
<font color="darkgreen">//          i := i - 1;</font>
<font color="darkgreen">//        end while;</font>
<font color="darkgreen">//      Ru := C_transpose(Ru);</font>
<font color="darkgreen">//      Sr := Ru[:,rank_+1:nx];</font>

     Sr :=<font color="red">  Modelica_LinearSystems2.WorkInProgress.Math.Matrices.C_nullspace</font>(
                                 [U1T;<font color="red">  matMul</font>(U1T,<font color="red">Complex</font>(1)*A)]);
<font color="darkgreen">// Modelica_LinearSystems2.Math.Matrices.printMatrix(Re(Sr),6,&quot;ReSr&quot;);</font>
<font color="darkgreen">// Modelica_LinearSystems2.Math.Matrices.printMatrix(Im(Sr),6,&quot;ImSr&quot;);</font>
  <font color="blue">else</font>
    Sr :=<font color="red"> fill</font>(<font color="red">Complex</font>(0),nx,0);
  <font color="blue">end if</font>;

  <font color="blue">for </font>l1<font color="blue"> in </font>1:nx - numberOfComplexPairs<font color="blue"> loop</font>

    AC :=<font color="red"> Complex</font>(-1)*A;

    <font color="blue">for </font>l2<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
      AC[l2, l2] := AC[l2, l2] + gammaSorted[l1];
    <font color="blue">end for</font>;

    C :=<font color="red"> matMul</font>(U1T, AC);

    Cc :=<font color="red"> Modelica_LinearSystems2.WorkInProgress.Math.Matrices.C_nullspace</font>(
                               [C;<font color="red"> C_transpose</font>(Sr)]);

<font color="darkgreen">//     if numberOfComplexPairs &gt; 0 and l1 &gt; numberOfRealEigenvalues then</font>
<font color="darkgreen">// //       (sigmaC,QC,RC) := Matrices.C_singularValues([C; C_transpose(Sr)]);</font>
<font color="darkgreen">// //       rankC := 0;</font>
<font color="darkgreen">// //       i := size(sigmaC, 1);</font>
<font color="darkgreen">// //       while i &gt; 0 loop</font>
<font color="darkgreen">// //         if sigmaC[i] &gt; 1e-10 then</font>
<font color="darkgreen">// //           rankC := i;</font>
<font color="darkgreen">// //           i := 0;</font>
<font color="darkgreen">// //         end if;</font>
<font color="darkgreen">// //         i := i - 1;</font>
<font color="darkgreen">// //       end while;</font>
<font color="darkgreen">// //       RC := C_transpose(RC);</font>
<font color="darkgreen">// //       subS[l1].S := [RC[:, rankC + 1:nx],Sr];</font>
<font color="darkgreen">//</font>
<font color="darkgreen">//       RC := Matrices.C_nullspace([C; C_transpose(Sr)]);</font>
<font color="darkgreen">//       subS[l1].S := [RC,Sr];</font>
<font color="darkgreen">//     else</font>
<font color="darkgreen">// //       (sigmaC,QC,RC) := Modelica_LinearSystems2.Math.Matrices.C_singularValues(C);</font>
<font color="darkgreen">// //       rankC := 0;</font>
<font color="darkgreen">// //       i := size(sigmaC, 1);</font>
<font color="darkgreen">// //       while i &gt; 0 loop</font>
<font color="darkgreen">// //         if sigmaC[i] &gt; 1e-10 then</font>
<font color="darkgreen">// //           rankC := i;</font>
<font color="darkgreen">// //           i := 0;</font>
<font color="darkgreen">// //         end if;</font>
<font color="darkgreen">// //         i := i - 1;</font>
<font color="darkgreen">// //       end while;</font>
<font color="darkgreen">// //       RC := C_transpose(RC);</font>
<font color="darkgreen">// //       subS[l1].S := RC[:, rankC + 1:nx];</font>
<font color="darkgreen">//</font>
<font color="darkgreen">//       subS[l1].S := Matrices.C_nullspace(C);</font>
<font color="darkgreen">//     end if;</font>

    subS[l1].S := <font color="blue">if </font>l1 &gt; numberOfRealEigenvalues<font color="blue"> then </font>[<font color="red">Modelica_LinearSystems2.WorkInProgress.Math.Matrices.C_nullspace</font>(
                                                                             [C;<font color="red"> C_transpose</font>(Sr)]),Sr]<font color="blue"> else </font><font color="red">Modelica_LinearSystems2.WorkInProgress.Math.Matrices.C_nullspace</font>(
                                                                                                    C);

<font color="darkgreen">//    subS[l1].S := Matrices.C_nullspace(C);</font>
<font color="darkgreen">// Modelica_LinearSystems2.Math.Matrices.printMatrix(Re(subS[l1].S),6,&quot;ResubS[l1].S&quot;);</font>
<font color="darkgreen">// Modelica_LinearSystems2.Math.Matrices.printMatrix(Im(subS[l1].S),6,&quot;ImsubS[l1].S&quot;);</font>

<font color="darkgreen">// MM := matMul(C,Complex.conj(Matrices.C_nullspace(Cc)));</font>
<font color="darkgreen">// Modelica_LinearSystems2.Math.Matrices.printMatrix(Re(MM),6,&quot;ReMM&quot;);</font>
<font color="darkgreen">// Modelica_LinearSystems2.Math.Matrices.printMatrix(Im(MM),6,&quot;ImMM&quot;);</font>

<font color="darkgreen">// MM := matMul(C,Sr);</font>
<font color="darkgreen">// //MM := matMul(C_transpose(Sr),Cc);</font>
<font color="darkgreen">// Modelica_LinearSystems2.Math.Matrices.printMatrix(Re(MM),6,&quot;ReMM&quot;);</font>
<font color="darkgreen">// Modelica_LinearSystems2.Math.Matrices.printMatrix(Im(MM),6,&quot;ImMM&quot;);</font>
<font color="blue">end for</font>;

<font color="blue">if </font><font color="blue">not </font>IniX<font color="blue"> then</font>
<font color="darkgreen">// initialization of X according to Byers</font>
  <font color="blue">for </font>l1<font color="blue"> in </font>1:nx - numberOfComplexPairs<font color="blue"> loop</font>
    y :=<font color="red"> fill</font>(<font color="red">Complex</font>(0), nx);
    <font color="blue">for </font>l2<font color="blue"> in </font>1:<font color="red">size</font>(subS[l1].S, 2)<font color="blue"> loop</font>
      y := X[:, l1] + X[:, l1] + subS[l1].S[:, l2];
    <font color="blue">end for</font>;
    y := y/<font color="red">Complex.Vectors.norm</font>(y);
    <font color="blue">for </font>l2<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
      X[l2, l1] := y[l2];
    <font color="blue">end for</font>;
  <font color="blue">end for</font>;
  <font color="blue">for </font>l1<font color="blue"> in </font>1:numberOfComplexPairs<font color="blue"> loop</font>
    <font color="blue">for </font>l2<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
      X[l2, numberOfRealEigenvalues + numberOfComplexPairs + l1] :=
        <font color="red">Complex.conj</font>(X[l2, numberOfRealEigenvalues + l1]);
    <font color="blue">end for</font>;
  <font color="blue">end for</font>;

 <font color="darkgreen">// initialization of X according to place.m</font>
   <font color="blue">for </font>l1<font color="blue"> in </font>1:nx - numberOfComplexPairs<font color="blue"> loop</font>
     <font color="blue">for </font>l2<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
       X[l2, l1] := subS[l1].S[l2, 1];
     <font color="blue">end for</font>;
   <font color="blue">end for</font>;
   <font color="blue">for </font>l1<font color="blue"> in </font>1:numberOfComplexPairs<font color="blue"> loop</font>
     <font color="blue">for </font>l2<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
       X[l2, numberOfRealEigenvalues + numberOfComplexPairs + l1] :=
         <font color="red">Complex.conj</font>(X[l2, numberOfRealEigenvalues + l1]);
     <font color="blue">end for</font>;
   <font color="blue">end for</font>;
<font color="blue">end if</font>;
<font color="darkgreen">// eigenvector modification</font>
  k := 0;
  <font color="blue">while </font>(k &lt; maxSteps)<font color="blue"> loop</font>
    k := k + 1;

    <font color="blue">for </font>l1<font color="blue"> in </font>1:nx - numberOfComplexPairs<font color="blue"> loop</font>
      <font color="blue">if </font>l1 == 1<font color="blue"> then</font>
        <font color="blue">for </font>l2<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
          <font color="blue">for </font>l3<font color="blue"> in </font>1:nx - 1<font color="blue"> loop</font>
            Xj[l2, l3] := X[l2, l3 + 1];
          <font color="blue">end for</font>;
        <font color="blue">end for</font>;
      <font color="blue">else</font>
        <font color="blue">for </font>l2<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
          <font color="blue">for </font>l3<font color="blue"> in </font>1:l1 - 1<font color="blue"> loop</font>
            Xj[l2, l3] := X[l2, l3];
          <font color="blue">end for</font>;
          <font color="blue">for </font>l3<font color="blue"> in </font>l1:nx - 1<font color="blue"> loop</font>
            Xj[l2, l3] := X[l2, l3 + 1];
          <font color="blue">end for</font>;
        <font color="blue">end for</font>;
      <font color="blue">end if</font>;

      QX :=<font color="red"> Modelica_LinearSystems2.WorkInProgress.Math.Matrices.C_QR2</font>(
                                                        Xj);
      ST :=<font color="red"> C_transpose</font>(subS[l1].S);
      y :=<font color="red"> matVecMul</font>(ST, QX[:, nx]);
      norm_y :=<font color="red"> Complex.Vectors.norm</font>(y);
      y :=<font color="red"> matVecMul</font>(subS[l1].S, y)/norm_y;

<font color="darkgreen">//        if l1 &gt; numberOfRealEigenvalues and Complex.&#39;abs&#39;(Complex.Vectors.multiply(y,Complex.conj(y)))&gt;0.9 then</font>
<font color="darkgreen">//          idx := 1 + rem(k, size(subS[l1].S, 2) - size(Sr, 2));</font>
<font color="darkgreen">//          print(&quot; k = &quot;+String(k)+&quot;, l1 = &quot;+String(l1)+&quot;, idx = &quot; + String(idx));</font>
<font color="darkgreen">//          y := (y + subS[l1].S[:, idx])/sqrt(2);</font>
<font color="darkgreen">//        end if;</font>

      <font color="blue">for </font>l2<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
        X[l2, l1] := y[l2];
      <font color="blue">end for</font>;

      <font color="blue">if </font>l1 &gt; numberOfRealEigenvalues<font color="blue"> then</font>
        <font color="blue">for </font>l2<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
          X[l2, l1 + numberOfComplexPairs] :=<font color="red"> Complex.conj</font>(y[l2]);
        <font color="blue">end for</font>;
      <font color="blue">end if</font>;

        <font color="blue">end for</font>;
condX2 :=<font color="red"> Modelica_LinearSystems2.WorkInProgress.Math.Complex.Matrices.conditionNumber</font>(
                                           X);

<font color="darkgreen">//print(&quot;\ncondX2 = &quot;+String(condX2));</font>
  <font color="blue">end while</font>;

  XC :=<font color="red"> C_transpose</font>(X);
  XC2 :=<font color="red"> C_transpose</font>(<font color="red">matMul</font>(X, Lambda));
  M :=<font color="red"> Modelica_LinearSystems2.WorkInProgress.Math.Matrices.C_solve2</font>(
                                                      XC, XC2);
  M :=<font color="red"> C_transpose</font>(M);

  <font color="blue">for </font>l2<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
    <font color="blue">for </font>l3<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
      M[l2, l3] := M[l2, l3] - A[l2, l3];
    <font color="blue">end for</font>;
  <font color="blue">end for</font>;

  KC :=<font color="red"> matMul</font>(Z,<font color="red"> matMul</font>(<font color="red">C_transpose</font>(U0), M));
  K := -<font color="red">Re</font>(KC);
  evX := X;

  ev :=<font color="red"> Complex.eigenValues</font>(A - B*K);
<font color="darkgreen">//    Complex.Vectors.print(&quot;gammaSorted&quot;, gammaSorted);</font>
<font color="darkgreen">//    Complex.Vectors.print(&quot;ev&quot;, ev);</font>

<font color="blue">public </font>
  <textblock type="model" expanded="false" path="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.assignPolesMI_rob_old.subSpace"><font color="blue">encapsulated </font><font color="blue">record</font> subSpace
    <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
    <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
    <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Record"
>Modelica.Icons.Record</A>;
    <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A> S[:,:];
  <font color="blue">end </font>subSpace</textblock>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>assignPolesMI_rob_old;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE wrapper_modifyX_old<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.wrapper_modifyX_old"></A><A HREF="Modelica_LinearSystems2_WorkInProgress_StateSpace_Internal.html#Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal"
>Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal</A>.wrapper_modifyX_old</H2>
<B>Contains a C sub routine of robust pole assignment to modify the eigenvector matrix X according to Kautsky algorithm</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>X_real[:, size(X_real, 1)]</TD><TD>&nbsp;</TD><TD>Eigenvector matrix, real part</TD></TR>
<TR><TD>Real</TD><TD>X_imag[size(X_real, 1), size(X_real, 2)]</TD><TD>&nbsp;</TD><TD>Eigenvector matrix, imaginary part</TD></TR>
<TR><TD>Integer</TD><TD>n</TD><TD>&nbsp;</TD><TD>Order of X</TD></TR>
<TR><TD>Real</TD><TD>S_real[size(X_real, 1), :]</TD><TD>&nbsp;</TD><TD>Eigenvector bases, real part</TD></TR>
<TR><TD>Real</TD><TD>S_imag[size(S_real, 1), size(S_real, 2)]</TD><TD>&nbsp;</TD><TD>Eigenvector bases, imaginary part</TD></TR>
<TR><TD>Integer</TD><TD>m</TD><TD>&nbsp;</TD><TD>Rank of the system input matrix B; S_real and S_imag must have n*m columns</TD></TR>
<TR><TD>Integer</TD><TD>ncp</TD><TD>&nbsp;</TD><TD>number of complex pairs</TD></TR>
<TR><TD>Integer</TD><TD>steps</TD><TD>&nbsp;</TD><TD>Number of iterations</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>Xm_real[size(X_real, 1), size(X_real, 2)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>Xm_imag[size(X_imag, 1), size(X_imag, 2)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> wrapper_modifyX_old <font color="darkgreen">
  &quot;Contains a C sub routine of robust pole assignment to modify the eigenvector matrix X according to Kautsky algorithm&quot;</font>
  <font color="blue">input </font>Real X_real[:,<font color="red">size</font>(X_real, 1)] <font color="darkgreen">&quot;Eigenvector matrix, real part&quot;</font>;
  <font color="blue">input </font>Real X_imag[<font color="red">size</font>(X_real, 1),<font color="red">size</font>(X_real, 2)] <font color="darkgreen">
    &quot;Eigenvector matrix, imaginary part&quot;</font>;
  <font color="blue">input </font>Integer n <font color="darkgreen">&quot;Order of X&quot;</font>;
  <font color="blue">input </font>Real S_real[<font color="red">size</font>(X_real, 1),:] <font color="darkgreen">&quot;Eigenvector bases, real part&quot;</font>;
  <font color="blue">input </font>Real S_imag[<font color="red">size</font>(S_real, 1),<font color="red">size</font>(S_real, 2)] <font color="darkgreen">
    &quot;Eigenvector bases, imaginary part&quot;</font>;
  <font color="blue">input </font>Integer m <font color="darkgreen">
    &quot;Rank of the system input matrix B; S_real and S_imag must have n*m columns&quot;</font>;
  <font color="blue">input </font>Integer ncp <font color="darkgreen">&quot;number of complex pairs&quot;</font>;
  <font color="blue">input </font>Integer steps <font color="darkgreen">&quot;Number of iterations&quot;</font>;

  <font color="blue">output </font>Real Xm_real[<font color="red">size</font>(X_real, 1),<font color="red">size</font>(X_real, 2)]=X_real;
  <font color="blue">output </font>Real Xm_imag[<font color="red">size</font>(X_imag, 1),<font color="red">size</font>(X_imag, 2)]=X_imag;

<font color="blue">external</font>&quot;FORTRAN 77&quot; <font color="red">c_inter_modifyX</font>(
    Xm_real,
    Xm_imag,
    n,
    S_real,
    S_imag,
    m,
    ncp,
    steps);

<textblock type="annotcomp" expanded="false">
<font color="blue">end </font>wrapper_modifyX_old;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE modifyX_old<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.modifyX_old"></A><A HREF="Modelica_LinearSystems2_WorkInProgress_StateSpace_Internal.html#Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal"
>Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal</A>.modifyX_old</H2>
<B>Contains a C sub routine of robust pole assignment to modify the eigenvector matrix X according to Kautsky algorithm</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>X[:, size(X, 1)]</TD><TD>&nbsp;</TD><TD>Complex eigenvector matrix</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>S[size(X, 1), :]</TD><TD>&nbsp;</TD><TD>Complex eigenvector matrix</TD></TR>
<TR><TD>Integer</TD><TD>m</TD><TD>&nbsp;</TD><TD>Rank of the system input matrix B; S_real and S_imag must have n*m columns</TD></TR>
<TR><TD>Integer</TD><TD>ncp</TD><TD>&nbsp;</TD><TD>number of complex pairs</TD></TR>
<TR><TD>Integer</TD><TD>steps</TD><TD>&nbsp;</TD><TD>Number of iterations</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>Xm[size(X, 1), size(X, 2)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> modifyX_old <font color="darkgreen">
  &quot;Contains a C sub routine of robust pole assignment to modify the eigenvector matrix X according to Kautsky algorithm&quot;</font>

  <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
  <font color="blue">import </font>Re = <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex.real"
>Modelica_LinearSystems2.Math.Complex.real</A>;
  <font color="blue">import </font>Im = <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex.imag"
>Modelica_LinearSystems2.Math.Complex.imag</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> X[:,<font color="red">size</font>(X,1)] <font color="darkgreen">&quot;Complex eigenvector matrix&quot;</font>;
  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> S[<font color="red">size</font>(X,1),:] <font color="darkgreen">&quot;Complex eigenvector matrix&quot;</font>;
  <font color="blue">input </font>Integer m <font color="darkgreen">
    &quot;Rank of the system input matrix B; S_real and S_imag must have n*m columns&quot;</font>;
  <font color="blue">input </font>Integer ncp <font color="darkgreen">&quot;number of complex pairs&quot;</font>;
  <font color="blue">input </font>Integer steps <font color="darkgreen">&quot;Number of iterations&quot;</font>;

  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> Xm[<font color="red">size</font>(X, 1),<font color="red">size</font>(X, 2)];

<font color="blue">protected </font>
   <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> j=<font color="red">Modelica_LinearSystems2.Math.Complex.j</font>();
   Integer n=<font color="red">size</font>(X,1);
   Real X_real[n,n]=<font color="red">Re</font>(X) <font color="darkgreen">&quot;Eigenvector matrix, real part&quot;</font>;
   Real X_imag[n,n]=<font color="red">Im</font>(X) <font color="darkgreen">&quot;Eigenvector matrix, imaginary part&quot;</font>;
   Real S_real[n,m*(n-ncp)]=<font color="red">Re</font>(S) <font color="darkgreen">&quot;Eigenvector bases, real part&quot;</font>;
   Real S_imag[n,m*(n-ncp)]=<font color="red">Im</font>(S) <font color="darkgreen">&quot;Eigenvector bases, imaginary part&quot;</font>;

  Real Xm_real[n,n];
  Real Xm_imag[n,n];

  Integer i;
  Integer ii;

<font color="blue">algorithm </font>
  (Xm_real, Xm_imag) :=<font color="red">Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.wrapper_modifyX_old</font>(
                                                                                   X_real, X_imag, n, S_real, S_imag, m, ncp, steps);
  <font color="blue">for </font>i<font color="blue"> in </font>1:n<font color="blue"> loop</font>
    <font color="blue">for </font>ii<font color="blue"> in </font>1:n<font color="blue"> loop</font>
      Xm[i,ii] :=<font color="red"> Complex</font>(Xm_real[i,ii],Xm_imag[i,ii]);
    <font color="blue">end for</font>;
  <font color="blue">end for</font>;
<font color="blue">end </font>modifyX_old;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE assignPolesMI_rob<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.assignPolesMI_robI.png" ALT="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.assignPolesMI_rob" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.assignPolesMI_rob"></A><A HREF="Modelica_LinearSystems2_WorkInProgress_StateSpace_Internal.html#Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal"
>Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal</A>.assignPolesMI_rob</H2>
<B>Modified KNV algorithm. Works like MATLAB&#39;s place.m</B><p>
<P><H3>Information</H3></P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>system matrix</TD></TR>
<TR><TD>Real</TD><TD>B[size(A, 1), :]</TD><TD>&nbsp;</TD><TD>control input matrix</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>gamma[size(A, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Boolean</TD><TD>IniX</TD><TD>false</TD><TD>Initial values of X are provided</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>Xini[size(A, 1), size(A, 1)]</TD><TD>fill(Complex(0), size(A, 1),...</TD><TD>Initial values of the eigenvectors X</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>K[size(B, 2), size(A, 1)]</TD><TD>feedback matrix</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>X[size(A, 1), size(A, 2)]</TD><TD>eigen vectors of the closed loop system</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> assignPolesMI_rob <font color="darkgreen">
  &quot;Modified KNV algorithm. Works like MATLAB&#39;s place.m&quot;</font>
  <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;

  <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
  <font color="blue">import </font>matMul = <A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Complex.Matrices.matMatMul"
>Modelica_LinearSystems2.Math.Complex.Matrices.matMatMul</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Complex.Matrices.matVecMul"
>Modelica_LinearSystems2.Math.Complex.Matrices.matVecMul</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Internal.html#Modelica_LinearSystems2.Math.Complex.Internal.C_transpose"
>Modelica_LinearSystems2.Math.Complex.Internal.C_transpose</A>;
  <font color="blue">import </font>Re = <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex.real"
>Modelica_LinearSystems2.Math.Complex.real</A>;
  <font color="blue">import </font>Im = <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex.imag"
>Modelica_LinearSystems2.Math.Complex.imag</A>;
  <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams.print"
>Modelica.Utilities.Streams.print</A>;

  <font color="blue">input </font>Real A[:,<font color="red">size</font>(A, 1)] <font color="darkgreen">&quot;system matrix&quot;</font>;
  <font color="blue">input </font>Real B[<font color="red">size</font>(A, 1),:] <font color="darkgreen">&quot;control input matrix&quot;</font>;
  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> gamma[<font color="red">size</font>(A, 1)];
  <font color="blue">input </font>Boolean IniX=false <font color="darkgreen">&quot;Initial values of X are provided&quot;</font>;
  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> Xini[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 1)]=<font color="red">fill</font>(<font color="red">Complex</font>(0),<font color="red"> size</font>(A, 1),<font color="red"> size</font>(A, 1)) <font color="darkgreen">
    &quot;Initial values of the eigenvectors X&quot;</font>;

  <font color="blue">output </font>Real K[<font color="red">size</font>(B, 2),<font color="red">size</font>(A, 1)] <font color="darkgreen">&quot;feedback matrix&quot;</font>;
  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> X[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)]=Xini <font color="darkgreen">
    &quot;eigen vectors of the closed loop system&quot;</font>;

<font color="blue">protected </font>
  Real U0[:,:];
  Real Z[:,:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> S[:,:];
  Integer maxSteps=5;
  Integer numberOfComplexPairs;
  Integer rankB;

<font color="darkgreen">//   Complex AC[size(A, 1),size(A, 2)]=Complex(1)*A;</font>
<font color="darkgreen">//   Complex Lambda[size(A, 1),size(A, 1)];</font>
<font color="darkgreen">//   Real Ur[:,:];</font>
<font color="darkgreen">//   Real Vr[:,:];</font>
<font color="darkgreen">//   Complex U1T[:,:];</font>
<font color="darkgreen">//   Complex Xjj[size(A, 1),size(A, 1)];</font>
<font color="darkgreen">//    Complex XC[size(A, 1),size(A, 2)];</font>
<font color="darkgreen">//    Complex XC2[size(A, 1),size(A, 2)];</font>
<font color="darkgreen">//    Complex MM[size(A, 1),size(A, 1)];</font>
<font color="darkgreen">//    Real M[size(A, 1),size(A, 1)];</font>
<font color="darkgreen">//   Complex KC[:,:];</font>
<font color="darkgreen">//   Complex QX[:,:];</font>
<font color="darkgreen">//   Complex C[:,:];</font>
<font color="darkgreen">//   Complex Cc[:,:];</font>
<font color="darkgreen">//   Complex Sr[:,:];</font>
<font color="darkgreen">//   Real Srr[:,:];</font>
<font color="darkgreen">//   Real U1Tr[:,:];</font>
<font color="darkgreen">//   Complex ST[:,:];</font>

<font color="darkgreen">//  Complex S2[size(A, 1),size(B, 2)];</font>
<font color="darkgreen">//  Real sigmaB[:];</font>

<font color="darkgreen">//  Complex y[:];</font>
<font color="darkgreen">//  Modelica_LinearSystems2.StateSpace.Internal.assignPolesMI_rob.subSpace subS[size(gamma,1)];</font>

<font color="darkgreen">//  Complex a;</font>
<font color="darkgreen">//  Integer cnt;</font>

  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> gammaSorted[<font color="red">size</font>(gamma, 1)];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> gammaSorted2[<font color="red">size</font>(gamma, 1)];

  Real condX2;
  Real norm_y;

  Integer nx=<font color="red">size</font>(A, 1);
  Integer numberOfRealEigenvalues;

  Integer i;
  Integer l1;
  Integer l2;
  Integer k;
  Integer idx;
  Real eps=Modelica.Constants.eps;

  <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss=<font color="red">StateSpace</font>(
      A=A,
      B=B,
      C=<font color="red">zeros</font>(1, nx),
      D=<font color="red">zeros</font>(1,<font color="red"> size</font>(B, 2)));

<font color="blue">algorithm </font>
  <font color="darkgreen">//check controllability. To be omitted, since computationally expensive? It would be better to analyze the dimension of the nullspace of C</font>
  <font color="red">assert</font>(<font color="red">StateSpace.Internal.isControllableMIMO</font>(ss), &quot;Poles cannot be placed since system is not controllable&quot;);

  <font color="darkgreen">// sort eigenvalues to [real ev, complex ev(im&gt;0), conj(complex ev(im&gt;0))]</font>
  (gammaSorted2,numberOfRealEigenvalues) :=
    <font color="red">Modelica_LinearSystems2.Internal.reorderZeros</font>(gamma);
  gammaSorted := gammaSorted2;

  numberOfComplexPairs :=<font color="red"> integer</font>((nx - numberOfRealEigenvalues)/2);
  <font color="blue">for </font>i<font color="blue"> in </font>numberOfRealEigenvalues + 1:numberOfRealEigenvalues +
      numberOfComplexPairs<font color="blue"> loop</font>
    gammaSorted[i] := <font color="blue">if </font><font color="red">Im</font>(gammaSorted2[2*i - numberOfRealEigenvalues - 1]) &gt; 0<font color="blue"> then </font>
            gammaSorted2[2*i - numberOfRealEigenvalues - 1]<font color="blue"> else </font><font color="red">Complex.conj</font>(
      gammaSorted2[2*i - numberOfRealEigenvalues - 1]);
    gammaSorted[i + numberOfComplexPairs] :=<font color="red"> Complex.conj</font>(gammaSorted[i]);
  <font color="blue">end for</font>;

  S :=<font color="red"> fill</font>(<font color="red">Complex</font>(0), nx,<font color="red"> size</font>(B, 2)*(nx - numberOfComplexPairs));<font color="darkgreen">// set dimension of S</font>
  (U0, Z, S, rankB) :=<font color="red"> Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.xBase</font>(
                                                                         A, B, gammaSorted, numberOfComplexPairs);<font color="darkgreen">// calculation of S, bases of X</font>
  X :=<font color="red"> Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.modifyX</font>(
                                                            X,S,rankB,numberOfComplexPairs,maxSteps,IniX);<font color="darkgreen">// X modification, search optimal closed loop eigenvectors</font>
  K :=<font color="red"> Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.calcK</font>(
                                                         A,U0,Z,gammaSorted,X,numberOfRealEigenvalues);<font color="darkgreen">// calcualte feedbackmatrix K</font>

<font color="darkgreen">//    for i in 1:nx loop</font>
<font color="darkgreen">//      Lambda[i, i] := gammaSorted[i];</font>
<font color="darkgreen">//    end for;</font>
<font color="darkgreen">//   (sigmaB,Ur,Vr) := Modelica.Math.Matrices.singularValues(B);</font>
<font color="darkgreen">//   rankB := 0;</font>
<font color="darkgreen">//   i := size(sigmaB, 1);</font>
<font color="darkgreen">//   while i &gt; 0 loop</font>
<font color="darkgreen">//     if sigmaB[i] &gt; 1e-10 then</font>
<font color="darkgreen">//       rankB := i;</font>
<font color="darkgreen">//       i := 0;</font>
<font color="darkgreen">//     end if;</font>
<font color="darkgreen">//     i := i - 1;</font>
<font color="darkgreen">//   end while;</font>
<font color="darkgreen">//</font>
<font color="darkgreen">//  // ############  Calculation of S (bases of X)  begin</font>
<font color="darkgreen">//   Z := fill(0, size(B, 2), rankB);</font>
<font color="darkgreen">//   for l1 in 1:rankB loop</font>
<font color="darkgreen">//     for l2 in 1:size(B, 2) loop</font>
<font color="darkgreen">//       Z[l1, l2] := Vr[l2, l1]/sigmaB[l2];</font>
<font color="darkgreen">//     end for;</font>
<font color="darkgreen">//   end for;</font>
<font color="darkgreen">//   U0 := Ur[:, 1:rankB];</font>
<font color="darkgreen">//</font>
<font color="darkgreen">//    if nx&gt;rankB then</font>
<font color="darkgreen">//   U1T := Complex(1)*transpose(Ur[:, rankB + 1:nx]);</font>
<font color="darkgreen">//   U1Tr := transpose(Ur[:, rankB + 1:nx]);</font>
<font color="darkgreen">//   condX2 := eps + 1;</font>
<font color="darkgreen">//</font>
<font color="darkgreen">//   if numberOfComplexPairs &gt; 0 and 2*rankB - nx &gt; 0 then</font>
<font color="darkgreen">//     Srr := Matrices.nullspace([U1Tr; U1Tr*A]);</font>
<font color="darkgreen">//   else</font>
<font color="darkgreen">//     Srr := fill(0, nx, 0);</font>
<font color="darkgreen">//   end if;</font>
<font color="darkgreen">//   Sr := Complex(1)*Srr;</font>
<font color="darkgreen">//</font>
<font color="darkgreen">//   //Computation of the nullspaces, i.e. the bases of the eigenvectors</font>
<font color="darkgreen">//   AC := Complex(-1)*A;</font>
<font color="darkgreen">//   for l1 in 1:nx - numberOfComplexPairs loop</font>
<font color="darkgreen">//     for l2 in 1:nx loop</font>
<font color="darkgreen">//       AC[l2, l2] := Complex(-A[l2, l2]) + gammaSorted[l1];</font>
<font color="darkgreen">//     end for;</font>
<font color="darkgreen">//</font>
<font color="darkgreen">//     C := matMul(U1T, AC);</font>
<font color="darkgreen">//</font>
<font color="darkgreen">//     S2 := if l1 &gt; numberOfRealEigenvalues and 2*rankB - nx &gt; 0 then [Matrices.C_nullspace([C; C_transpose(Sr)]),Sr] else Matrices.C_nullspace(C);</font>
<font color="darkgreen">//     for l2 in 1:nx loop</font>
<font color="darkgreen">//       for l3 in 1:rankB loop</font>
<font color="darkgreen">//         S[l2, rankB*(l1 - 1) + l3] := S2[l2, l3];</font>
<font color="darkgreen">//       end for;</font>
<font color="darkgreen">//     end for;</font>
<font color="darkgreen">//   end for;</font>
<font color="darkgreen">// // ############  Calculation of S (bases of X)  end</font>

<font color="darkgreen">// eigenvector modification</font>

<font color="darkgreen">//   if not IniX and rankB&gt;1 then</font>
<font color="darkgreen">// // // initialization of X according to Byers</font>
<font color="darkgreen">// //   for l1 in 1:nx - numberOfComplexPairs loop</font>
<font color="darkgreen">// //     y := fill(Complex(0), nx);</font>
<font color="darkgreen">// //     for l2 in 1:rankB loop</font>
<font color="darkgreen">// // //      y := X[:, l1] + X[:, l1] + subS[l1].S[:, l2];</font>
<font color="darkgreen">// //       y := X[:, l1] + X[:, l1] + S[:, rankB*(l1-1)+l2];</font>
<font color="darkgreen">// //     end for;</font>
<font color="darkgreen">// //     y := y/Complex.Vectors.norm(y);</font>
<font color="darkgreen">// //     for l2 in 1:nx loop</font>
<font color="darkgreen">// //       X[l2, l1] := y[l2];</font>
<font color="darkgreen">// //     end for;</font>
<font color="darkgreen">// //   end for;</font>
<font color="darkgreen">// //   for l1 in 1:numberOfComplexPairs loop</font>
<font color="darkgreen">// //     for l2 in 1:nx loop</font>
<font color="darkgreen">// //       X[l2, numberOfRealEigenvalues + numberOfComplexPairs + l1] :=</font>
<font color="darkgreen">// //         Complex.conj(X[l2, numberOfRealEigenvalues + l1]);</font>
<font color="darkgreen">// //     end for;</font>
<font color="darkgreen">// //   end for;</font>
<font color="darkgreen">//</font>
<font color="darkgreen">//  // initialization of X according to place.m</font>
<font color="darkgreen">//     for l1 in 1:nx - numberOfComplexPairs loop</font>
<font color="darkgreen">//       for l2 in 1:nx loop</font>
<font color="darkgreen">//         X[l2, l1] := S[l2, rankB*(l1 - 1) + 1];</font>
<font color="darkgreen">//       end for;</font>
<font color="darkgreen">//     end for;</font>
<font color="darkgreen">//     for l1 in 1:numberOfComplexPairs loop</font>
<font color="darkgreen">//       for l2 in 1:nx loop</font>
<font color="darkgreen">//         X[l2, numberOfRealEigenvalues + numberOfComplexPairs + l1] :=</font>
<font color="darkgreen">//           Complex.conj(X[l2, numberOfRealEigenvalues + l1]);</font>
<font color="darkgreen">//       end for;</font>
<font color="darkgreen">//     end for;</font>
<font color="darkgreen">//   end if;</font>

<font color="darkgreen">//   if rankB==1 then //X=S</font>
<font color="darkgreen">//     for l1 in 1:nx - numberOfComplexPairs loop</font>
<font color="darkgreen">//       for l2 in 1:nx loop</font>
<font color="darkgreen">//         X[l2, l1] := S[l2, rankB*(l1 - 1) + 1];</font>
<font color="darkgreen">//       end for;</font>
<font color="darkgreen">//     end for;</font>
<font color="darkgreen">//     for l1 in 1:numberOfComplexPairs loop</font>
<font color="darkgreen">//       for l2 in 1:nx loop</font>
<font color="darkgreen">//         X[l2, numberOfRealEigenvalues + numberOfComplexPairs + l1] :=</font>
<font color="darkgreen">//           Complex.conj(X[l2, numberOfRealEigenvalues + l1]);</font>
<font color="darkgreen">//       end for;</font>
<font color="darkgreen">//     end for;</font>
<font color="darkgreen">//     end if;</font>

<font color="darkgreen">//  if rankB&gt;1 then</font>
<font color="darkgreen">//   k := 0;</font>
<font color="darkgreen">//   while (k &lt; maxSteps) loop</font>
<font color="darkgreen">//     k := k + 1;</font>
<font color="darkgreen">//</font>
<font color="darkgreen">//     for l1 in 1:nx - numberOfComplexPairs loop</font>
<font color="darkgreen">//       if l1 == 1 then</font>
<font color="darkgreen">//         for l2 in 1:nx loop</font>
<font color="darkgreen">//           for l3 in 1:nx - 1 loop</font>
<font color="darkgreen">//             Xjj[l2, l3] := X[l2, l3 + 1];</font>
<font color="darkgreen">//           end for;</font>
<font color="darkgreen">//         end for;</font>
<font color="darkgreen">//       else</font>
<font color="darkgreen">//         for l2 in 1:nx loop</font>
<font color="darkgreen">//           for l3 in 1:l1 - 1 loop</font>
<font color="darkgreen">//             Xjj[l2, l3] := X[l2, l3];</font>
<font color="darkgreen">//           end for;</font>
<font color="darkgreen">//           for l3 in l1:nx - 1 loop</font>
<font color="darkgreen">//             Xjj[l2, l3] := X[l2, l3 + 1];</font>
<font color="darkgreen">//           end for;</font>
<font color="darkgreen">//         end for;</font>
<font color="darkgreen">//       end if;</font>
<font color="darkgreen">//</font>
<font color="darkgreen">//       QX := Modelica_LinearSystems2.Math.Matrices.C_QR(Xjj);</font>
<font color="darkgreen">//</font>
<font color="darkgreen">//       ST := C_transpose(S[:, rankB*(l1 - 1) + 1:rankB*l1]);</font>
<font color="darkgreen">//       y := matVecMul(ST, QX[:, nx]);</font>
<font color="darkgreen">//</font>
<font color="darkgreen">//       norm_y := Complex.Vectors.norm(y);</font>
<font color="darkgreen">//       y := matVecMul(S[:, rankB*(l1 - 1) + 1:rankB*l1], y)/norm_y;</font>
<font color="darkgreen">//</font>
<font color="darkgreen">//       if l1 &gt; numberOfRealEigenvalues and Complex.&#39;abs&#39;(</font>
<font color="darkgreen">//           Complex.Vectors.multiply(y, Complex.conj(y))) &gt; 0.9 then</font>
<font color="darkgreen">//         idx := 1 + rem(k, rankB - size(Sr, 2));</font>
<font color="darkgreen">//         y := (y + S[:, (l1 - 1)*rankB + idx])/sqrt(2);</font>
<font color="darkgreen">//       end if;</font>
<font color="darkgreen">//</font>
<font color="darkgreen">//       for l2 in 1:nx loop</font>
<font color="darkgreen">//         X[l2, l1] := y[l2];</font>
<font color="darkgreen">//       end for;</font>
<font color="darkgreen">//</font>
<font color="darkgreen">//       if l1 &gt; numberOfRealEigenvalues then</font>
<font color="darkgreen">//         for l2 in 1:nx loop</font>
<font color="darkgreen">//           X[l2, l1 + numberOfComplexPairs] := Complex.conj(y[l2]);</font>
<font color="darkgreen">//         end for;</font>
<font color="darkgreen">//       end if;</font>
<font color="darkgreen">//     end for;</font>
<font color="darkgreen">//     condX2 := Complex.Matrices.conditionNumber(X);</font>
<font color="darkgreen">//   end while;</font>
<font color="darkgreen">// end if;</font>
<font color="darkgreen">// Computation of the feedback matrix K</font>
<font color="darkgreen">//    XC := C_transpose(X);</font>
<font color="darkgreen">//    XC2 := C_transpose(matMul(X, Lambda));</font>
<font color="darkgreen">//    MM := Modelica_LinearSystems2.Math.Matrices.C_solve2(XC, XC2);</font>
<font color="darkgreen">//    M := Re(MM);</font>
<font color="darkgreen">//    M := transpose(M);</font>
<font color="darkgreen">//</font>
<font color="darkgreen">//    for l2 in 1:nx loop</font>
<font color="darkgreen">//      for l3 in 1:nx loop</font>
<font color="darkgreen">//        M[l2, l3] := M[l2, l3] - A[l2, l3];</font>
<font color="darkgreen">//      end for;</font>
<font color="darkgreen">//    end for;</font>
<font color="darkgreen">//  else//nx&gt;rankB</font>
<font color="darkgreen">//      X:=fill(Complex(0),nx,nx);</font>
<font color="darkgreen">//     for i in 1:numberOfRealEigenvalues loop</font>
<font color="darkgreen">//       M[i,i]:=Re(gammaSorted[i]);</font>
<font color="darkgreen">//       X[i,i] := Complex(1);</font>
<font color="darkgreen">//     end for;</font>
<font color="darkgreen">//     for i in 1:numberOfComplexPairs loop</font>
<font color="darkgreen">//           M[numberOfRealEigenvalues+2*i-1,numberOfRealEigenvalues+2*i] := Im(gammaSorted[numberOfRealEigenvalues + 2*i - 1]);</font>
<font color="darkgreen">//           M[numberOfRealEigenvalues+2*i,numberOfRealEigenvalues+2*i-1] := -Im(gammaSorted[numberOfRealEigenvalues + 2*i - 1]);</font>
<font color="darkgreen">//           M[numberOfRealEigenvalues+2*i-1,numberOfRealEigenvalues+2*i-1] := Re(gammaSorted[numberOfRealEigenvalues + 2*i - 1]);</font>
<font color="darkgreen">//           M[numberOfRealEigenvalues+2*i,numberOfRealEigenvalues+2*i] := Re(gammaSorted[numberOfRealEigenvalues + 2*i - 1]);</font>
<font color="darkgreen">//           Modelica_LinearSystems2.Math.Matrices.printMatrix(M,6,&quot;M&quot;);</font>
<font color="darkgreen">//           X[numberOfRealEigenvalues+2*i-1,numberOfRealEigenvalues+2*i-1] := Complex(0.5);</font>
<font color="darkgreen">//           X[numberOfRealEigenvalues+2*i,numberOfRealEigenvalues+2*i] := Complex(0,0.5);</font>
<font color="darkgreen">//           X[numberOfRealEigenvalues+2*i-1,numberOfRealEigenvalues+2*i] := Complex(0,-0.5);</font>
<font color="darkgreen">//           X[numberOfRealEigenvalues+2*i,numberOfRealEigenvalues+2*i-1] := Complex(0.5);</font>
<font color="darkgreen">//     end for;</font>
<font color="darkgreen">//     M:=M-A;</font>

<font color="darkgreen">// end if;//nx&gt;rankB</font>
<font color="darkgreen">//    K := -Z*transpose(U0)*M;</font>

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>assignPolesMI_rob;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE assignPolesMI_rob2<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.assignPolesMI_robI.png" ALT="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.assignPolesMI_rob2" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.assignPolesMI_rob2"></A><A HREF="Modelica_LinearSystems2_WorkInProgress_StateSpace_Internal.html#Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal"
>Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal</A>.assignPolesMI_rob2</H2>
<B>Modified KNV algorithm. Works like MATLAB&#39;s place.m</B><p>
<P><H3>Information</H3></P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>system matrix</TD></TR>
<TR><TD>Real</TD><TD>B[size(A, 1), :]</TD><TD>&nbsp;</TD><TD>control input matrix</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>gamma[size(A, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Boolean</TD><TD>IniX</TD><TD>false</TD><TD>Initial values of X are provided</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>Xini[size(A, 1), size(A, 1)]</TD><TD>fill(Complex(0), size(A, 1),...</TD><TD>Initial values of the eigenvectors X</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>K[size(B, 2), size(A, 1)]</TD><TD>feedback matrix</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>X[size(A, 1), size(A, 2)]</TD><TD>eigen vectors of the closed loop system</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> assignPolesMI_rob2 <font color="darkgreen">
  &quot;Modified KNV algorithm. Works like MATLAB&#39;s place.m&quot;</font>
  <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;

  <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
  <font color="blue">import </font>matMul = <A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Complex.Matrices.matMatMul"
>Modelica_LinearSystems2.Math.Complex.Matrices.matMatMul</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Complex.Matrices.matVecMul"
>Modelica_LinearSystems2.Math.Complex.Matrices.matVecMul</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Internal.html#Modelica_LinearSystems2.Math.Complex.Internal.C_transpose"
>Modelica_LinearSystems2.Math.Complex.Internal.C_transpose</A>;
  <font color="blue">import </font>Re = <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex.real"
>Modelica_LinearSystems2.Math.Complex.real</A>;
  <font color="blue">import </font>Im = <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex.imag"
>Modelica_LinearSystems2.Math.Complex.imag</A>;
  <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams.print"
>Modelica.Utilities.Streams.print</A>;

  <font color="blue">input </font>Real A[:,<font color="red">size</font>(A, 1)] <font color="darkgreen">&quot;system matrix&quot;</font>;
  <font color="blue">input </font>Real B[<font color="red">size</font>(A, 1),:] <font color="darkgreen">&quot;control input matrix&quot;</font>;
  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> gamma[<font color="red">size</font>(A, 1)];
  <font color="blue">input </font>Boolean IniX=false <font color="darkgreen">&quot;Initial values of X are provided&quot;</font>;
  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> Xini[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 1)]=<font color="red">fill</font>(<font color="red">Complex</font>(0),<font color="red"> size</font>(A, 1),<font color="red"> size</font>(A, 1)) <font color="darkgreen">
    &quot;Initial values of the eigenvectors X&quot;</font>;

  <font color="blue">output </font>Real K[<font color="red">size</font>(B, 2),<font color="red">size</font>(A, 1)] <font color="darkgreen">&quot;feedback matrix&quot;</font>;
  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> X[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)]=Xini <font color="darkgreen">
    &quot;eigen vectors of the closed loop system&quot;</font>;
<font color="blue">protected </font>
  Real U0[:,:];
  Real Z[:,:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> S[:,:];
  Integer maxSteps=5;
  Integer numberOfComplexPairs;
  Integer rankB;

  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> AC[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)]=<font color="red">Complex</font>(1)*A;
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> Lambda[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 1)];
  Real Ur[:,:];
  Real Vr[:,:];

  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> U1T[:,:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> Xjj[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 1)];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> XC[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> XC2[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> MM[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 1)];
  Real M[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 1)];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> KC[:,:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> QX[:,:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> C[:,:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> Cc[:,:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> Sr[:,:];
  Real Srr[:,:];
  Real U1Tr[:,:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> ST[:,:];

  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> S2[<font color="red">size</font>(A, 1),<font color="red">size</font>(B, 2)];

  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> gammaSorted[<font color="red">size</font>(gamma, 1)];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> gammaSorted2[<font color="red">size</font>(gamma, 1)];
  Real sigmaB[:];
<font color="darkgreen">//  Complex ev[size(A, 1)];</font>

  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> y[:];
  Real condX2;
  Real norm_y;

  Integer nx=<font color="red">size</font>(A, 1);
  Integer numberOfRealEigenvalues;

  Integer i;
  Integer l1;
  Integer l2;
  Integer k;
  Integer idx;
  Real eps=Modelica.Constants.eps;

<font color="darkgreen">//  Modelica_LinearSystems2.StateSpace.Internal.assignPolesMI_rob.subSpace subS[size(gamma,1)];</font>

<font color="darkgreen">//  Complex a;</font>
<font color="darkgreen">//  Integer cnt;</font>
  <A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss=<font color="red">StateSpace</font>(
      A=A,
      B=B,
      C=<font color="red">zeros</font>(1, nx),
      D=<font color="red">zeros</font>(1,<font color="red"> size</font>(B, 2)));

   <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> XX[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 2)];

<font color="blue">algorithm </font>
  <font color="darkgreen">//check controllability</font>
  <font color="red">assert</font>(<font color="red">StateSpace.Analysis.isControllable</font>(ss), &quot;Poles cannot be placed since system is not controllable&quot;);

  <font color="darkgreen">// sort eigenvalues to [real ev, complex ev(im&gt;0), conj(complex ev(im&gt;0))]</font>
  (gammaSorted2,numberOfRealEigenvalues) :=
    <font color="red">Modelica_LinearSystems2.Internal.reorderZeros</font>(gamma);
  gammaSorted := gammaSorted2;
  numberOfComplexPairs :=<font color="red"> integer</font>((nx - numberOfRealEigenvalues)/2);
  <font color="blue">for </font>i<font color="blue"> in </font>numberOfRealEigenvalues + 1:numberOfRealEigenvalues +
      numberOfComplexPairs<font color="blue"> loop</font>
    gammaSorted[i] := <font color="blue">if </font><font color="red">Im</font>(gammaSorted2[2*i - numberOfRealEigenvalues - 1]) &gt; 0<font color="blue"> then </font>
            gammaSorted2[2*i - numberOfRealEigenvalues - 1]<font color="blue"> else </font><font color="red">Complex.conj</font>(
      gammaSorted2[2*i - numberOfRealEigenvalues - 1]);
    gammaSorted[i + numberOfComplexPairs] :=<font color="red"> Complex.conj</font>(gammaSorted[i]);
  <font color="blue">end for</font>;

  <font color="blue">for </font>i<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
    Lambda[i, i] := gammaSorted[i];
  <font color="blue">end for</font>;

   (sigmaB,Ur,Vr) :=<font color="red"> Modelica.Math.Matrices.singularValues</font>(B);
   rankB := 0;
   i :=<font color="red"> size</font>(sigmaB, 1);
   <font color="blue">while </font>i &gt; 0<font color="blue"> loop</font>
     <font color="blue">if </font>sigmaB[i] &gt; 1e-10<font color="blue"> then</font>
       rankB := i;
       i := 0;
     <font color="blue">end if</font>;
     i := i - 1;
   <font color="blue">end while</font>;

  <font color="darkgreen">// ############  Calculation of S (bases of X)  begin</font>
   Z :=<font color="red"> fill</font>(0,<font color="red"> size</font>(B, 2), rankB);
   <font color="blue">for </font>l1<font color="blue"> in </font>1:rankB<font color="blue"> loop</font>
     <font color="blue">for </font>l2<font color="blue"> in </font>1:<font color="red">size</font>(B, 2)<font color="blue"> loop</font>
       Z[l1, l2] := Vr[l2, l1]/sigmaB[l2];
     <font color="blue">end for</font>;
   <font color="blue">end for</font>;
   U0 := Ur[:, 1:rankB];

 <font color="blue">if </font>nx&gt;<font color="red">size</font>(B,2)<font color="blue"> then</font>

   U1T :=<font color="red"> Complex</font>(1)*<font color="red">transpose</font>(Ur[:, rankB + 1:nx]);
   U1Tr :=<font color="red"> transpose</font>(Ur[:, rankB + 1:nx]);
   condX2 := eps + 1;

  S :=<font color="red"> fill</font>(<font color="red">Complex</font>(0), nx,<font color="red"> size</font>(B, 2)*(nx - numberOfComplexPairs));

   <font color="blue">if </font>numberOfComplexPairs &gt; 0<font color="blue"> and </font>2*rankB - nx &gt; 0<font color="blue"> then</font>
     Srr :=<font color="red"> Matrices.nullspace</font>([U1Tr; U1Tr*A]);
   <font color="blue">else</font>
     Srr :=<font color="red"> fill</font>(0, nx, 0);
   <font color="blue">end if</font>;
   Sr :=<font color="red"> Complex</font>(1)*Srr;

   <font color="darkgreen">//Computation of the nullspaces, i.e. the bases of the eigenvectors</font>
   AC :=<font color="red"> Complex</font>(-1)*A;
   <font color="blue">for </font>l1<font color="blue"> in </font>1:nx - numberOfComplexPairs<font color="blue"> loop</font>
     <font color="blue">for </font>l2<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
       AC[l2, l2] :=<font color="red"> Complex</font>(-A[l2, l2]) + gammaSorted[l1];
     <font color="blue">end for</font>;

     C :=<font color="red"> matMul</font>(U1T, AC);

     S2 := <font color="blue">if </font>l1 &gt; numberOfRealEigenvalues<font color="blue"> and </font>2*rankB - nx &gt; 0<font color="blue"> then </font>[<font color="red">Modelica_LinearSystems2.WorkInProgress.Math.Matrices.C_nullspace</font>(
                                                                                           [C;<font color="red"> C_transpose</font>(Sr)]),Sr]<font color="blue"> else </font><font color="red">Modelica_LinearSystems2.WorkInProgress.Math.Matrices.C_nullspace</font>(
                                                                                                    C);
     <font color="blue">for </font>l2<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
       <font color="blue">for </font>l3<font color="blue"> in </font>1:rankB<font color="blue"> loop</font>
         S[l2, rankB*(l1 - 1) + l3] := S2[l2, l3];
       <font color="blue">end for</font>;
     <font color="blue">end for</font>;
   <font color="blue">end for</font>;
 <font color="darkgreen">// ############  Calculation of S (bases of X)  end</font>
<font color="darkgreen">// (U0, Z, S, rankB) := Modelica_LinearSystems2.StateSpace.Internal.xBase(A, B, gammaSorted, numberOfComplexPairs);</font>

  <font color="blue">if </font><font color="blue">not </font>IniX<font color="blue"> and </font>rankB&gt;1<font color="blue"> then</font>
<font color="darkgreen">// // initialization of X according to Byers</font>
<font color="darkgreen">//   for l1 in 1:nx - numberOfComplexPairs loop</font>
<font color="darkgreen">//     y := fill(Complex(0), nx);</font>
<font color="darkgreen">//     for l2 in 1:rankB loop</font>
<font color="darkgreen">// //      y := X[:, l1] + X[:, l1] + subS[l1].S[:, l2];</font>
<font color="darkgreen">//       y := X[:, l1] + X[:, l1] + S[:, rankB*(l1-1)+l2];</font>
<font color="darkgreen">//     end for;</font>
<font color="darkgreen">//     y := y/Complex.Vectors.norm(y);</font>
<font color="darkgreen">//     for l2 in 1:nx loop</font>
<font color="darkgreen">//       X[l2, l1] := y[l2];</font>
<font color="darkgreen">//     end for;</font>
<font color="darkgreen">//   end for;</font>
<font color="darkgreen">//   for l1 in 1:numberOfComplexPairs loop</font>
<font color="darkgreen">//     for l2 in 1:nx loop</font>
<font color="darkgreen">//       X[l2, numberOfRealEigenvalues + numberOfComplexPairs + l1] :=</font>
<font color="darkgreen">//         Complex.conj(X[l2, numberOfRealEigenvalues + l1]);</font>
<font color="darkgreen">//     end for;</font>
<font color="darkgreen">//   end for;</font>

 <font color="darkgreen">// initialization of X according to place.m</font>
    <font color="blue">for </font>l1<font color="blue"> in </font>1:nx - numberOfComplexPairs<font color="blue"> loop</font>
      <font color="blue">for </font>l2<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
        X[l2, l1] := S[l2, rankB*(l1 - 1) + 1];
      <font color="blue">end for</font>;
    <font color="blue">end for</font>;
    <font color="blue">for </font>l1<font color="blue"> in </font>1:numberOfComplexPairs<font color="blue"> loop</font>
      <font color="blue">for </font>l2<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
        X[l2, numberOfRealEigenvalues + numberOfComplexPairs + l1] :=
          <font color="red">Complex.conj</font>(X[l2, numberOfRealEigenvalues + l1]);
      <font color="blue">end for</font>;
    <font color="blue">end for</font>;
  <font color="blue">end if</font>;

  <font color="blue">if </font>rankB==1<font color="blue"> then</font><font color="darkgreen"> //X=S</font>
    <font color="blue">for </font>l1<font color="blue"> in </font>1:nx - numberOfComplexPairs<font color="blue"> loop</font>
      <font color="blue">for </font>l2<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
        X[l2, l1] := S[l2, rankB*(l1 - 1) + 1];
      <font color="blue">end for</font>;
    <font color="blue">end for</font>;
    <font color="blue">for </font>l1<font color="blue"> in </font>1:numberOfComplexPairs<font color="blue"> loop</font>
      <font color="blue">for </font>l2<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
        X[l2, numberOfRealEigenvalues + numberOfComplexPairs + l1] :=
          <font color="red">Complex.conj</font>(X[l2, numberOfRealEigenvalues + l1]);
      <font color="blue">end for</font>;
    <font color="blue">end for</font>;
  <font color="blue">end if</font>;

<font color="darkgreen">// eigenvector modification</font>
<font color="darkgreen">//  X := Modelica_LinearSystems2.StateSpace.Internal.modifyX( X,S,rankB,numberOfComplexPairs,maxSteps,IniX);</font>

  <font color="blue">if </font>rankB&gt;1<font color="blue"> then</font>
   k := 0;
   <font color="blue">while </font>(k &lt; maxSteps)<font color="blue"> loop</font>
     k := k + 1;

     <font color="blue">for </font>l1<font color="blue"> in </font>1:nx - numberOfComplexPairs<font color="blue"> loop</font>
       <font color="blue">if </font>l1 == 1<font color="blue"> then</font>
         <font color="blue">for </font>l2<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
           <font color="blue">for </font>l3<font color="blue"> in </font>1:nx - 1<font color="blue"> loop</font>
             Xjj[l2, l3] := X[l2, l3 + 1];
           <font color="blue">end for</font>;
         <font color="blue">end for</font>;
       <font color="blue">else</font>
         <font color="blue">for </font>l2<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
           <font color="blue">for </font>l3<font color="blue"> in </font>1:l1 - 1<font color="blue"> loop</font>
             Xjj[l2, l3] := X[l2, l3];
           <font color="blue">end for</font>;
           <font color="blue">for </font>l3<font color="blue"> in </font>l1:nx - 1<font color="blue"> loop</font>
             Xjj[l2, l3] := X[l2, l3 + 1];
           <font color="blue">end for</font>;
         <font color="blue">end for</font>;
       <font color="blue">end if</font>;

       QX :=<font color="red"> Modelica_LinearSystems2.WorkInProgress.Math.Matrices.C_QR</font>(
                                                        Xjj);

       ST :=<font color="red"> C_transpose</font>(S[:, rankB*(l1 - 1) + 1:rankB*l1]);
       y :=<font color="red"> matVecMul</font>(ST, QX[:, nx]);

       norm_y :=<font color="red"> Complex.Vectors.norm</font>(y);
       y :=<font color="red"> matVecMul</font>(S[:, rankB*(l1 - 1) + 1:rankB*l1], y)/norm_y;

       <font color="blue">if </font>l1 &gt; numberOfRealEigenvalues<font color="blue"> and </font><font color="red">Complex.&#39;abs&#39;</font>(
           <font color="red">Complex.Vectors.multiply</font>(y,<font color="red"> Complex.conj</font>(y))) &gt; 0.9<font color="blue"> then</font>
         idx := 1 +<font color="red"> rem</font>(k, rankB -<font color="red"> size</font>(Sr, 2));
         y := (y + S[:, (l1 - 1)*rankB + idx])/<font color="red">sqrt</font>(2);
       <font color="blue">end if</font>;

       <font color="blue">for </font>l2<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
         X[l2, l1] := y[l2];
       <font color="blue">end for</font>;

       <font color="blue">if </font>l1 &gt; numberOfRealEigenvalues<font color="blue"> then</font>
         <font color="blue">for </font>l2<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
           X[l2, l1 + numberOfComplexPairs] :=<font color="red"> Complex.conj</font>(y[l2]);
         <font color="blue">end for</font>;
       <font color="blue">end if</font>;
     <font color="blue">end for</font>;
     condX2 :=<font color="red"> Modelica_LinearSystems2.WorkInProgress.Math.Complex.Matrices.conditionNumber</font>(
                                                X);
   <font color="blue">end while</font>;
   <font color="blue">end if</font>;<font color="darkgreen">//rankB&gt;1</font>

<font color="darkgreen">// Computation of the feedback matrix K</font>
   XC :=<font color="red"> C_transpose</font>(X);
   XC2 :=<font color="red"> C_transpose</font>(<font color="red">matMul</font>(X, Lambda));
   MM :=<font color="red"> Modelica_LinearSystems2.WorkInProgress.Math.Matrices.C_solve2</font>(
                                                        XC, XC2);
   M :=<font color="red"> Re</font>(MM);
   M :=<font color="red"> transpose</font>(M);

   <font color="blue">for </font>l2<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
     <font color="blue">for </font>l3<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
       M[l2, l3] := M[l2, l3] - A[l2, l3];
     <font color="blue">end for</font>;
     <font color="blue">end for</font>;

   <font color="blue">else</font>
 gammaSorted2 :=<font color="red">  Modelica_LinearSystems2.Internal.reorderZeros</font>(gamma);
    <font color="blue">for </font>i<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
    Lambda[i, i] := gammaSorted2[i];
  <font color="blue">end for</font>;
  X:=<font color="red">fill</font>(<font color="red">Complex</font>(0),nx,nx);

   <font color="blue">for </font>i<font color="blue"> in </font>1:numberOfRealEigenvalues<font color="blue"> loop</font>
     M[i,i]:=<font color="red">Re</font>(gammaSorted[i]);
     X[i,i] :=<font color="red"> Complex</font>(1);
   <font color="blue">end for</font>;
   <font color="blue">for </font>i<font color="blue"> in </font>1:numberOfComplexPairs<font color="blue"> loop</font>
         M[numberOfRealEigenvalues+2*i-1,numberOfRealEigenvalues+2*i] := -<font color="red">Im</font>(gammaSorted[numberOfRealEigenvalues + 2*i - 1]);
         M[numberOfRealEigenvalues+2*i,numberOfRealEigenvalues+2*i-1] :=<font color="red"> Im</font>(gammaSorted[numberOfRealEigenvalues + 2*i - 1]);
         M[numberOfRealEigenvalues+2*i-1,numberOfRealEigenvalues+2*i-1] :=<font color="red"> Re</font>(gammaSorted[numberOfRealEigenvalues + 2*i - 1]);
         M[numberOfRealEigenvalues+2*i,numberOfRealEigenvalues+2*i] :=<font color="red"> Re</font>(gammaSorted[numberOfRealEigenvalues + 2*i - 1]);
         X[numberOfRealEigenvalues+2*i-1,numberOfRealEigenvalues+2*i-1] :=<font color="red"> Complex</font>(0.5);
         X[numberOfRealEigenvalues+2*i,numberOfRealEigenvalues+2*i] :=<font color="red"> Complex</font>(0,0.5);
         X[numberOfRealEigenvalues+2*i-1,numberOfRealEigenvalues+2*i] :=<font color="red"> Complex</font>(0,-0.5);
         X[numberOfRealEigenvalues+2*i,numberOfRealEigenvalues+2*i-1] :=<font color="red"> Complex</font>(0.5);
   <font color="blue">end for</font>;
    <font color="red">     Modelica_LinearSystems2.Math.Complex.Matrices.print</font>(X,6,&quot;X&quot;);
    <font color="red">     Modelica_LinearSystems2.Math.Matrices.printMatrix</font>(M,6,&quot;M&quot;);
         MM :=<font color="red"> Complex</font>(1)*M;
         XX :=<font color="red"> matMul</font>(MM,X);
         XX :=<font color="red"> Modelica_LinearSystems2.WorkInProgress.Math.Matrices.C_solve2</font>(
                                                              X, XX);
    <font color="red">     Modelica_LinearSystems2.Math.Complex.Matrices.print</font>(XX,6,&quot;XX&quot;);
         M:=M-A;
    <font color="red">     Modelica_LinearSystems2.Math.Matrices.printMatrix</font>(M,6,&quot;M-A&quot;);

   <font color="blue">end if</font>;

   K := -Z*<font color="red">transpose</font>(U0)*M;
<font color="darkgreen">//  evX := X;</font>
<font color="darkgreen">//K:=Modelica_LinearSystems2.StateSpace.Internal.calcK(A,U0,Z,gammaSorted,X);</font>

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>assignPolesMI_rob2;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE assignPolesSI_rq<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.assignPolesMI_robI.png" ALT="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.assignPolesSI_rq" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.assignPolesSI_rq"></A><A HREF="Modelica_LinearSystems2_WorkInProgress_StateSpace_Internal.html#Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal"
>Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal</A>.assignPolesSI_rq</H2>
<B>RQ implementation of a recursiv single-input pole assignment problem</B><p>
<P><H3>Information</H3></P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A></TD><TD>ss</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>gamma[size(ss.A, 1)]</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>K[1, size(ss.A, 1)]</TD><TD>feedback matrix</TD></TR>
<TR><TD>Real</TD><TD>S[size(ss.A, 1), size(ss.A, 1)]</TD><TD>Closed loop System matrix</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>po[size(ss.A, 1)]</TD><TD>poles of the closed loop system</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> assignPolesSI_rq <font color="darkgreen">
  &quot;RQ implementation of a recursiv single-input pole assignment problem&quot;</font>
  <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;

  <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>Modelica_LinearSystems2.StateSpace</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
  <font color="blue">import </font>matMul = <A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Complex.Matrices.matMatMul"
>Modelica_LinearSystems2.Math.Complex.Matrices.matMatMul</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Complex.Matrices.matVecMul"
>Modelica_LinearSystems2.Math.Complex.Matrices.matVecMul</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math_Internal.html#Modelica_LinearSystems2.Math.Complex.Internal.C_transpose"
>Modelica_LinearSystems2.Math.Complex.Internal.C_transpose</A>;
  <font color="blue">import </font>Re = <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex.real"
>Modelica_LinearSystems2.Math.Complex.real</A>;
  <font color="blue">import </font>Im = <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex.imag"
>Modelica_LinearSystems2.Math.Complex.imag</A>;
  <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Utilities_Streams.html#Modelica.Utilities.Streams.print"
>Modelica.Utilities.Streams.print</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2.StateSpace"
>StateSpace</A> ss;
  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> gamma[<font color="red">size</font>(ss.A, 1)];

  <font color="blue">output </font>Real K[1,<font color="red">size</font>(ss.A, 1)] <font color="darkgreen">&quot;feedback matrix&quot;</font>;
  <font color="blue">output </font>Real S[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 1)] <font color="darkgreen">&quot;Closed loop System matrix&quot;</font>;
  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> po[<font color="red">size</font>(ss.A, 1)] <font color="darkgreen">&quot;poles of the closed loop system&quot;</font>;
<font color="blue">protected </font>
  Boolean isCntrbl <font color="darkgreen">&quot;is set to true if the system is controllable&quot;</font>;
  <A HREF="Modelica_LinearSystems2_Internal.html#Modelica_LinearSystems2.Internal.StateSpaceR"
>Modelica_LinearSystems2.Internal.StateSpaceR</A> ssr <font color="darkgreen">&quot;system in Hessenberg form&quot;</font>;

  Integer nx=<font color="red">size</font>(ss.A, 1);
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> H[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 1)];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> Q[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 1)];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> R[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 1)];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> Qi[:,:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> Ri[:,:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> Hi[:,:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> Hlr[:,:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> Qn[<font color="red">size</font>(ss.A, 1),<font color="red">size</font>(ss.A, 1)];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> rho;

  Real alpha=1.0;
  Real beta;
  Integer i;
  Integer ni;

  Real P[:,:];

  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> ev[:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> RQ[:,:];
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> tau[:];

<font color="blue">algorithm </font>
  <font color="darkgreen">//reduction to controller-Hessenberg form</font>
  (isCntrbl,ssr,P) :=<font color="red"> StateSpace.Internal.staircaseSVD</font>(ss);

  <font color="red">assert</font>(isCntrbl, &quot;Poles cannot be placed since system is not controllable&quot;);

  H :=<font color="red"> Complex</font>(1)*ssr.A;

  <font color="blue">if </font>nx == 1<font color="blue"> then</font>
    K[1, 1] := (ss.A[1, 1] -<font color="red"> Re</font>(gamma[1]))/ss.B[1,1];
  <font color="blue">else</font>
    beta := ssr.B[1,1];
    <font color="blue">for </font>i<font color="blue"> in </font>2:nx<font color="blue"> loop</font>
      alpha := alpha*<font color="red">Re</font>(H[i, i - 1]);
    <font color="blue">end for</font>;

    <font color="blue">for </font>i<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
      H[i, i] := H[i, i] - gamma[1];
    <font color="blue">end for</font>;

    (R,Q) :=<font color="red"> Modelica_LinearSystems2.WorkInProgress.Math.Matrices.C_RQ</font>(
                           H);
    H :=<font color="red"> matMul</font>(Q, R);

    <font color="blue">for </font>i<font color="blue"> in </font>1:nx<font color="blue"> loop</font>
      H[i, i] := H[i, i] + gamma[1];
    <font color="blue">end for</font>;

    rho := R[nx, nx];
    Hi := H;

    <font color="blue">for </font>i<font color="blue"> in </font>2:nx<font color="blue"> loop</font>
      ni :=<font color="red"> size</font>(Hi, 1);
      <font color="blue">for </font>ii<font color="blue"> in </font>1:ni<font color="blue"> loop</font>
        Hi[ii, ii] := Hi[ii, ii] - gamma[i];
      <font color="blue">end for</font>;

<font color="darkgreen">//       (Ri,Qi) :=  Matrices.C_RQ(Hi);</font>
<font color="darkgreen">//       Hlr := Qi*Ri;</font>
<font color="darkgreen">// replaced by :########</font>
      (RQ,tau) :=<font color="red"> Modelica_LinearSystems2.WorkInProgress.Math.LAPACK.zgerq2</font>(
                                         Hi);
      Ri :=<font color="red"> fill</font>(<font color="red">Complex</font>(0),ni,ni);
      <font color="blue">for </font>ii<font color="blue"> in </font>1:ni<font color="blue"> loop</font>
        <font color="blue">for </font>iii<font color="blue"> in </font>ii:ni<font color="blue"> loop</font>
          Ri[ii,iii] := RQ[ii,iii];
        <font color="blue">end for</font>;
      <font color="blue">end for</font>;
      Qi :=<font color="red"> Modelica_LinearSystems2.WorkInProgress.Math.LAPACK.zungrq</font>(
                                   RQ,tau);
      Hlr :=<font color="red"> Modelica_LinearSystems2.WorkInProgress.Math.LAPACK.zunmrq</font>(
                                    Ri,RQ,tau,true);
<font color="darkgreen">// ##########</font>

      <font color="blue">for </font>ii<font color="blue"> in </font>1:ni<font color="blue"> loop</font>
        Hlr[ii, ii] := Hlr[ii, ii] + gamma[i];
      <font color="blue">end for</font>;
      Hi := Hlr[2:ni, 2:ni];

      <font color="blue">if </font>i &gt; 2<font color="blue"> then</font>
        Qn :=<font color="red"> fill</font>(<font color="red">Complex</font>(0), nx, nx);
        <font color="blue">for </font>ii<font color="blue"> in </font>1:i - 2<font color="blue"> loop</font>
          Qn[ii, ii] :=<font color="red"> Complex</font>(1);
        <font color="blue">end for</font>;
        <font color="blue">for </font>ii<font color="blue"> in </font>1:nx-i+2<font color="blue"> loop</font>
          <font color="blue">for </font>iii<font color="blue"> in </font>1:nx-i+2<font color="blue"> loop</font>
            Qn[ii+i-2, iii+i-2] := Qi[ii, iii];
          <font color="blue">end for</font>;
        <font color="blue">end for</font>;
        Q :=<font color="red"> matMul</font>(Qn,Q);
      <font color="blue">else</font>
        Q :=<font color="red"> matMul</font>(Qi,Q);
      <font color="blue">end if</font>;

      rho := rho*Ri[nx + 2 - i, nx + 2 - i];
    <font color="blue">end for</font>;

    K[1, :] := Q[nx, :].re;
    K := (rho.re/alpha/beta)*K*P;
    <font color="blue">end if</font>;
    S := ss.A-ss.B*K;
    po :=<font color="red">  Complex.eigenValues</font>(S);
  <font color="red">  Complex.Vectors.print</font>(&quot;ev&quot;,ev);
<font color="blue">end </font>assignPolesSI_rq;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE xBase<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.xBase"></A><A HREF="Modelica_LinearSystems2_WorkInProgress_StateSpace_Internal.html#Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal"
>Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal</A>.xBase</H2>
<B>Compute the eigenvector bases according to Kautsky algorithm</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>Real square system matrix</TD></TR>
<TR><TD>Real</TD><TD>B[size(A, 1), :]</TD><TD>&nbsp;</TD><TD>Real input matrix</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>gamma[size(A, 1)]</TD><TD>&nbsp;</TD><TD>Assigned complex eigenvalues</TD></TR>
<TR><TD>Integer</TD><TD>ncp</TD><TD>&nbsp;</TD><TD>Number of complex pairs of eigenvalues</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>U0[size(A, 1), size(B, 2)]</TD><TD>U0 and Z are the decompositions of B</TD></TR>
<TR><TD>Real</TD><TD>Z[size(B, 2), size(B, 2)]</TD><TD>Z and U0 are the decompositions of B</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>S[size(A, 1), (size(A, 1) - ncp)*size(B, 2)]</TD><TD>Eigenvector bases</TD></TR>
<TR><TD>Integer</TD><TD>rankB</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> xBase <font color="darkgreen">
  &quot;Compute the eigenvector bases according to Kautsky algorithm&quot;</font>
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
  <font color="blue">import </font>Re = <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex.real"
>Modelica_LinearSystems2.Math.Complex.real</A>;
  <font color="blue">import </font>Im = <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex.imag"
>Modelica_LinearSystems2.Math.Complex.imag</A>;

  <font color="blue">input </font>Real A[:,<font color="red">size</font>(A,1)] <font color="darkgreen">&quot;Real square system matrix&quot;</font>;
  <font color="blue">input </font>Real B[<font color="red">size</font>(A,1),:] <font color="darkgreen">&quot;Real input matrix&quot;</font>;
  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> gamma[<font color="red">size</font>(A,1)] <font color="darkgreen">&quot;Assigned complex eigenvalues&quot;</font>;
  <font color="blue">input </font>Integer ncp <font color="darkgreen">&quot;Number of complex pairs of eigenvalues&quot;</font>;

  <font color="blue">output </font>Real U0[<font color="red">size</font>(A, 1),<font color="red">size</font>(B, 2)] <font color="darkgreen">&quot;U0 and Z are the decompositions of B&quot;</font>;
  <font color="blue">output </font>Real Z[<font color="red">size</font>(B,2),<font color="red">size</font>(B,2)] <font color="darkgreen">&quot;Z and U0 are the decompositions of B&quot;</font>;
  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> S[<font color="red">size</font>(A,1),(<font color="red">size</font>(A,1)-ncp)*<font color="red">size</font>(B,2)] <font color="darkgreen">&quot;Eigenvector bases&quot;</font>;
  <font color="blue">output </font>Integer rankB;

<font color="blue">protected </font>
   <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> j=<font color="red">Modelica_LinearSystems2.Math.Complex.j</font>();
   Integer n=<font color="red">size</font>(A,1);
   Integer m=<font color="red">size</font>(B,2);

   Real gamma_real[n]=<font color="red">Re</font>(gamma) <font color="darkgreen">&quot;Eigenvalue vector, real part&quot;</font>;
   Real gamma_imag[n]=<font color="red">Im</font>(gamma) <font color="darkgreen">&quot;Eigenvalue vector, imaginary part&quot;</font>;
   Real S_real[n,m*(n-ncp)] <font color="darkgreen">&quot;Eigenvector bases, real part&quot;</font>;
   Real S_imag[n,m*(n-ncp)] <font color="darkgreen">&quot;Eigenvector bases, imaginary part&quot;</font>;
  Integer i;
  Integer ii;

<font color="blue">algorithm </font>
  (U0, Z, S_real, S_imag, rankB) :=<font color="red">Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.wrapper_xBase</font>(
                                                                                             A, B, gamma_real, gamma_imag, ncp);
  <font color="red">assert</font>(m==rankB,&quot;Input matrix B must have full column rank&quot;);
  <font color="blue">for </font>i<font color="blue"> in </font>1:n<font color="blue"> loop</font>
    <font color="blue">for </font>ii<font color="blue"> in </font>1:(n-ncp)*m<font color="blue"> loop</font>
      S[i,ii] :=<font color="red"> Complex</font>(S_real[i,ii],S_imag[i,ii]);
    <font color="blue">end for</font>;
  <font color="blue">end for</font>;
<font color="blue">end </font>xBase;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE calcK<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.calcK"></A><A HREF="Modelica_LinearSystems2_WorkInProgress_StateSpace_Internal.html#Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal"
>Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal</A>.calcK</H2>
<B>Computes the feedback matrix from the assigned eigenvalues, closed loop eigenvectors and the B matrix factorization</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>Real square system matrix</TD></TR>
<TR><TD>Real</TD><TD>U0[size(A, 1), :]</TD><TD>&nbsp;</TD><TD>U0 and Z are the decompositions of B</TD></TR>
<TR><TD>Real</TD><TD>Z[size(U0, 2), size(U0, 2)]</TD><TD>&nbsp;</TD><TD>Z and U0 are the decompositions of B</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>gamma[size(A, 1)]</TD><TD>&nbsp;</TD><TD>Assigned complex eigenvalues</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>X[size(A, 1), size(A, 1)]</TD><TD>&nbsp;</TD><TD>Closed loop eigenvectors</TD></TR>
<TR><TD>Integer</TD><TD>nre</TD><TD>&nbsp;</TD><TD>number of real eigenvalues</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>K[size(U0, 2), size(A, 1)]</TD><TD>Feedback matrix</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> calcK <font color="darkgreen">
  &quot;Computes the feedback matrix from the assigned eigenvalues, closed loop eigenvectors and the B matrix factorization&quot;</font>
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
  <font color="blue">import </font>Re = <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex.real"
>Modelica_LinearSystems2.Math.Complex.real</A>;
  <font color="blue">import </font>Im = <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex.imag"
>Modelica_LinearSystems2.Math.Complex.imag</A>;

  <font color="blue">input </font>Real A[:,<font color="red">size</font>(A, 1)] <font color="darkgreen">&quot;Real square system matrix&quot;</font>;
  <font color="blue">input </font>Real U0[<font color="red">size</font>(A, 1),:] <font color="darkgreen">&quot;U0 and Z are the decompositions of B&quot;</font>;
  <font color="blue">input </font>Real Z[<font color="red">size</font>(U0, 2),<font color="red">size</font>(U0, 2)] <font color="darkgreen">&quot;Z and U0 are the decompositions of B&quot;</font>;
  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> gamma[<font color="red">size</font>(A, 1)] <font color="darkgreen">&quot;Assigned complex eigenvalues&quot;</font>;
  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> X[<font color="red">size</font>(A, 1),<font color="red">size</font>(A, 1)] <font color="darkgreen">&quot;Closed loop eigenvectors&quot;</font>;
  <font color="blue">input </font>Integer nre <font color="darkgreen">&quot;number of real eigenvalues&quot;</font>;

  <font color="blue">output </font>Real K[<font color="red">size</font>(U0, 2),<font color="red">size</font>(A, 1)] <font color="darkgreen">&quot;Feedback matrix&quot;</font>;

<font color="blue">protected </font>
  Integer n=<font color="red">size</font>(A, 1);
  Integer m=<font color="red">size</font>(U0, 2);

  Real gamma_real[n]=<font color="red">Re</font>(gamma) <font color="darkgreen">&quot;Eigenvalue vector, real part&quot;</font>;
  Real gamma_imag[n]=<font color="red">Im</font>(gamma) <font color="darkgreen">&quot;Eigenvalue vector, imaginary part&quot;</font>;
  Real X_real[n,n]=<font color="red">Re</font>(X) <font color="darkgreen">&quot;Eigenvectors, real part&quot;</font>;
  Real X_imag[n,n]=<font color="red">Im</font>(X) <font color="darkgreen">&quot;Eigenvectors, imaginary part&quot;</font>;

<font color="blue">algorithm </font>
  K :=<font color="red"> Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.wrapper_calcK</font>(
                                                                 A, U0, Z, gamma_real, gamma_imag, X_real,X_imag, nre);
<font color="blue">end </font>calcK;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE modifyX<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.modifyX"></A><A HREF="Modelica_LinearSystems2_WorkInProgress_StateSpace_Internal.html#Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal"
>Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal</A>.modifyX</H2>
<B>Contains a C sub routine of robust pole assignment to modify the eigenvector matrix X according to Kautsky algorithm</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>X[:, size(X, 1)]</TD><TD>&nbsp;</TD><TD>Complex eigenvector matrix</TD></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>S[size(X, 1), :]</TD><TD>&nbsp;</TD><TD>Complex eigenvector matrix</TD></TR>
<TR><TD>Integer</TD><TD>m</TD><TD>&nbsp;</TD><TD>Rank of the system input matrix B; S_real and S_imag must have n*m columns</TD></TR>
<TR><TD>Integer</TD><TD>ncp</TD><TD>&nbsp;</TD><TD>number of complex pairs</TD></TR>
<TR><TD>Integer</TD><TD>steps</TD><TD>&nbsp;</TD><TD>Number of iterations</TD></TR>
<TR><TD>Boolean</TD><TD>IniX</TD><TD>false</TD><TD>Initial values of X are provided</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A></TD><TD>Xm[size(X, 1), size(X, 2)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> modifyX <font color="darkgreen">
  &quot;Contains a C sub routine of robust pole assignment to modify the eigenvector matrix X according to Kautsky algorithm&quot;</font>

  <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A>;
  <font color="blue">import </font>Re = <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex.real"
>Modelica_LinearSystems2.Math.Complex.real</A>;
  <font color="blue">import </font>Im = <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex.imag"
>Modelica_LinearSystems2.Math.Complex.imag</A>;

  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> X[:,<font color="red">size</font>(X,1)] <font color="darkgreen">&quot;Complex eigenvector matrix&quot;</font>;
  <font color="blue">input </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> S[<font color="red">size</font>(X,1),:] <font color="darkgreen">&quot;Complex eigenvector matrix&quot;</font>;
  <font color="blue">input </font>Integer m <font color="darkgreen">
    &quot;Rank of the system input matrix B; S_real and S_imag must have n*m columns&quot;</font>;
  <font color="blue">input </font>Integer ncp <font color="darkgreen">&quot;number of complex pairs&quot;</font>;
  <font color="blue">input </font>Integer steps <font color="darkgreen">&quot;Number of iterations&quot;</font>;
  <font color="blue">input </font>Boolean IniX=false <font color="darkgreen">&quot;Initial values of X are provided&quot;</font>;

  <font color="blue">output </font><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> Xm[<font color="red">size</font>(X, 1),<font color="red">size</font>(X, 2)];

<font color="blue">protected </font>
   <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Complex</A> j=<font color="red">Modelica_LinearSystems2.Math.Complex.j</font>();
   Integer n=<font color="red">size</font>(X,1);
   Real X_real[n,n]=<font color="red">Re</font>(X) <font color="darkgreen">&quot;Eigenvector matrix, real part&quot;</font>;
   Real X_imag[n,n]=<font color="red">Im</font>(X) <font color="darkgreen">&quot;Eigenvector matrix, imaginary part&quot;</font>;
   Real S_real[n,m*(n-ncp)]=<font color="red">Re</font>(S) <font color="darkgreen">&quot;Eigenvector bases, real part&quot;</font>;
   Real S_imag[n,m*(n-ncp)]=<font color="red">Im</font>(S) <font color="darkgreen">&quot;Eigenvector bases, imaginary part&quot;</font>;

   Real Xm_real[n,n];
   Real Xm_imag[n,n];

  Integer i;
  Integer ii;

<font color="blue">algorithm </font>
  (Xm_real, Xm_imag) :=<font color="red">Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.wrapper_modifyX</font>(
                                                                                    X_real, X_imag, n, S_real, S_imag, m, ncp, steps, IniX);
  <font color="blue">for </font>i<font color="blue"> in </font>1:n<font color="blue"> loop</font>
    <font color="blue">for </font>ii<font color="blue"> in </font>1:n<font color="blue"> loop</font>
      Xm[i,ii] :=<font color="red"> Complex</font>(Xm_real[i,ii],Xm_imag[i,ii]);
    <font color="blue">end for</font>;
  <font color="blue">end for</font>;
<font color="blue">end </font>modifyX;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE wrapper_calcK<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.wrapper_calcK"></A><A HREF="Modelica_LinearSystems2_WorkInProgress_StateSpace_Internal.html#Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal"
>Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal</A>.wrapper_calcK</H2>
<B>Computes the feedback matrix from the assigned eigenvalues, closed loop eigenvectors and the B matrix factorization</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>Real square system matrix</TD></TR>
<TR><TD>Real</TD><TD>U0[size(A, 1), :]</TD><TD>&nbsp;</TD><TD>U0 and Z are the decompositions of B</TD></TR>
<TR><TD>Real</TD><TD>Z[size(U0, 2), size(U0, 2)]</TD><TD>&nbsp;</TD><TD>Z and U0 are the decompositions of B</TD></TR>
<TR><TD>Real</TD><TD>gamma_real[size(A, 1)]</TD><TD>&nbsp;</TD><TD>Eigenvalue vector, real part</TD></TR>
<TR><TD>Real</TD><TD>gamma_imag[size(A, 1)]</TD><TD>&nbsp;</TD><TD>Eigenvalue vector, imaginary part</TD></TR>
<TR><TD>Real</TD><TD>X_real[n, n]</TD><TD>&nbsp;</TD><TD>Eigenvectors, real part</TD></TR>
<TR><TD>Real</TD><TD>X_imag[n, n]</TD><TD>&nbsp;</TD><TD>Eigenvectors, imaginary part</TD></TR>
<TR><TD>Integer</TD><TD>nre</TD><TD>&nbsp;</TD><TD>Number of real eigenvalues</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>K[size(U0, 2), size(A, 1)]</TD><TD>Feedback matrix</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> wrapper_calcK <font color="darkgreen">
  &quot;Computes the feedback matrix from the assigned eigenvalues, closed loop eigenvectors and the B matrix factorization&quot;</font>

  <font color="blue">input </font>Real A[:,<font color="red">size</font>(A, 1)] <font color="darkgreen">&quot;Real square system matrix&quot;</font>;
  <font color="blue">input </font>Real U0[<font color="red">size</font>(A, 1),:] <font color="darkgreen">&quot;U0 and Z are the decompositions of B&quot;</font>;
  <font color="blue">input </font>Real Z[<font color="red">size</font>(U0, 2),<font color="red">size</font>(U0, 2)] <font color="darkgreen">&quot;Z and U0 are the decompositions of B&quot;</font>;
  <font color="blue">input </font>Real gamma_real[<font color="red">size</font>(A,1)] <font color="darkgreen">&quot;Eigenvalue vector, real part&quot;</font>;
  <font color="blue">input </font>Real gamma_imag[<font color="red">size</font>(A,1)] <font color="darkgreen">&quot;Eigenvalue vector, imaginary part&quot;</font>;
  <font color="blue">input </font>Real X_real[n,n] <font color="darkgreen">&quot;Eigenvectors, real part&quot;</font>;
  <font color="blue">input </font>Real X_imag[n,n] <font color="darkgreen">&quot;Eigenvectors, imaginary part&quot;</font>;
  <font color="blue">input </font>Integer nre <font color="darkgreen">&quot;Number of real eigenvalues&quot;</font>;

  <font color="blue">output </font>Real K[<font color="red">size</font>(U0,2),<font color="red"> size</font>(A,1)] <font color="darkgreen">&quot;Feedback matrix&quot;</font>;

<font color="blue">protected </font>
  Integer n=<font color="red">size</font>(A,1);
  Integer m=<font color="red">size</font>(U0,2);

<font color="blue">external</font>&quot;FORTRAN 77&quot; <font color="red">c_inter_calcK</font>(n, m, A, U0, Z, gamma_real, gamma_imag, X_real, X_imag, nre, K);

<textblock type="annotcomp" expanded="false">
<font color="blue">end </font>wrapper_calcK;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE wrapper_modifyX<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.wrapper_modifyX"></A><A HREF="Modelica_LinearSystems2_WorkInProgress_StateSpace_Internal.html#Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal"
>Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal</A>.wrapper_modifyX</H2>
<B>Contains a C sub routine of robust pole assignment to modify the eigenvector matrix X according to Kautsky algorithm</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>X_real[:, size(X_real, 1)]</TD><TD>&nbsp;</TD><TD>Eigenvector matrix, real part</TD></TR>
<TR><TD>Real</TD><TD>X_imag[size(X_real, 1), size(X_real, 2)]</TD><TD>&nbsp;</TD><TD>Eigenvector matrix, imaginary part</TD></TR>
<TR><TD>Integer</TD><TD>n</TD><TD>&nbsp;</TD><TD>Order of X</TD></TR>
<TR><TD>Real</TD><TD>S_real[size(X_real, 1), :]</TD><TD>&nbsp;</TD><TD>Eigenvector bases, real part</TD></TR>
<TR><TD>Real</TD><TD>S_imag[size(S_real, 1), size(S_real, 2)]</TD><TD>&nbsp;</TD><TD>Eigenvector bases, imaginary part</TD></TR>
<TR><TD>Integer</TD><TD>m</TD><TD>&nbsp;</TD><TD>Rank of the system input matrix B; S_real and S_imag must have n*m columns</TD></TR>
<TR><TD>Integer</TD><TD>ncp</TD><TD>&nbsp;</TD><TD>number of complex pairs</TD></TR>
<TR><TD>Integer</TD><TD>steps</TD><TD>&nbsp;</TD><TD>Number of iterations</TD></TR>
<TR><TD>Boolean</TD><TD>IniX</TD><TD>false</TD><TD>Initial values of X are provided</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>Xm_real[size(X_real, 1), size(X_real, 2)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>Real</TD><TD>Xm_imag[size(X_imag, 1), size(X_imag, 2)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> wrapper_modifyX <font color="darkgreen">
  &quot;Contains a C sub routine of robust pole assignment to modify the eigenvector matrix X according to Kautsky algorithm&quot;</font>
  <font color="blue">input </font>Real X_real[:,<font color="red">size</font>(X_real, 1)] <font color="darkgreen">&quot;Eigenvector matrix, real part&quot;</font>;
  <font color="blue">input </font>Real X_imag[<font color="red">size</font>(X_real, 1),<font color="red">size</font>(X_real, 2)] <font color="darkgreen">
    &quot;Eigenvector matrix, imaginary part&quot;</font>;
  <font color="blue">input </font>Integer n <font color="darkgreen">&quot;Order of X&quot;</font>;
  <font color="blue">input </font>Real S_real[<font color="red">size</font>(X_real, 1),:] <font color="darkgreen">&quot;Eigenvector bases, real part&quot;</font>;
  <font color="blue">input </font>Real S_imag[<font color="red">size</font>(S_real, 1),<font color="red">size</font>(S_real, 2)] <font color="darkgreen">
    &quot;Eigenvector bases, imaginary part&quot;</font>;
  <font color="blue">input </font>Integer m <font color="darkgreen">
    &quot;Rank of the system input matrix B; S_real and S_imag must have n*m columns&quot;</font>;
  <font color="blue">input </font>Integer ncp <font color="darkgreen">&quot;number of complex pairs&quot;</font>;
  <font color="blue">input </font>Integer steps <font color="darkgreen">&quot;Number of iterations&quot;</font>;
  <font color="blue">input </font>Boolean IniX=false <font color="darkgreen">&quot;Initial values of X are provided&quot;</font>;

  <font color="blue">output </font>Real Xm_real[<font color="red">size</font>(X_real, 1),<font color="red">size</font>(X_real, 2)]=X_real;
  <font color="blue">output </font>Real Xm_imag[<font color="red">size</font>(X_imag, 1),<font color="red">size</font>(X_imag, 2)]=X_imag;

<font color="blue">protected </font>
  Integer inix=<font color="blue">if </font>IniX<font color="blue"> then </font>1<font color="blue"> else </font>0;

<font color="blue">external</font>&quot;FORTRAN 77&quot; <font color="red">c_inter_modifyX2</font>(
    Xm_real,
    Xm_imag,
    n,
    S_real,
    S_imag,
    m,
    ncp,
    steps,
    inix);

<textblock type="annotcomp" expanded="false">
<font color="blue">end </font>wrapper_modifyX;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE wrapper_xBase<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.wrapper_xBase"></A><A HREF="Modelica_LinearSystems2_WorkInProgress_StateSpace_Internal.html#Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal"
>Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal</A>.wrapper_xBase</H2>
<B>Compute the eigenvector bases according to Kautsky algorithm</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD><TD>Real square system matrix</TD></TR>
<TR><TD>Real</TD><TD>B[size(A, 1), :]</TD><TD>&nbsp;</TD><TD>Real input matrix</TD></TR>
<TR><TD>Real</TD><TD>gamma_real[size(A, 1)]</TD><TD>&nbsp;</TD><TD>Eigenvalue vector, real part</TD></TR>
<TR><TD>Real</TD><TD>gamma_imag[size(A, 1)]</TD><TD>&nbsp;</TD><TD>Eigenvalue vector, imaginary part</TD></TR>
<TR><TD>Integer</TD><TD>ncp</TD><TD>&nbsp;</TD><TD>Number of complex pairs of eigenvalues</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>U0[size(A, 1), size(B, 2)]</TD><TD>U0</TD></TR>
<TR><TD>Real</TD><TD>Z[size(B, 2), size(B, 2)]</TD><TD>Z</TD></TR>
<TR><TD>Real</TD><TD>S_real[size(A, 1), size(B, 2)*(size(A, 1) - ncp)]</TD><TD>Eigenvector bases, real part</TD></TR>
<TR><TD>Real</TD><TD>S_imag[size(A, 1), size(B, 2)*(size(A, 1) - ncp)]</TD><TD>Eigenvector bases, imaginary part</TD></TR>
<TR><TD>Integer</TD><TD>rankB</TD><TD>Rank of matrix B</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> wrapper_xBase <font color="darkgreen">
  &quot;Compute the eigenvector bases according to Kautsky algorithm&quot;</font>

  <font color="blue">input </font>Real A[:,<font color="red">size</font>(A, 1)] <font color="darkgreen">&quot;Real square system matrix&quot;</font>;
  <font color="blue">input </font>Real B[<font color="red">size</font>(A,1),:] <font color="darkgreen">&quot;Real input matrix&quot;</font>;
  <font color="blue">input </font>Real gamma_real[<font color="red">size</font>(A,1)] <font color="darkgreen">&quot;Eigenvalue vector, real part&quot;</font>;
  <font color="blue">input </font>Real gamma_imag[<font color="red">size</font>(A,1)] <font color="darkgreen">&quot;Eigenvalue vector, imaginary part&quot;</font>;
  <font color="blue">input </font>Integer ncp <font color="darkgreen">&quot;Number of complex pairs of eigenvalues&quot;</font>;

  <font color="blue">output </font>Real U0[<font color="red">size</font>(A,1),<font color="red">size</font>(B,2)] <font color="darkgreen">&quot;U0&quot;</font>;
  <font color="blue">output </font>Real Z[<font color="red">size</font>(B,2),<font color="red">size</font>(B,2)] <font color="darkgreen">&quot;Z&quot;</font>;
  <font color="blue">output </font>Real S_real[<font color="red">size</font>(A,1),<font color="red">size</font>(B,2)*(<font color="red">size</font>(A,1)-ncp)] <font color="darkgreen">
    &quot;Eigenvector bases, real part&quot;</font>;
  <font color="blue">output </font>Real S_imag[<font color="red">size</font>(A,1),<font color="red">size</font>(B,2)*(<font color="red">size</font>(A,1)-ncp)] <font color="darkgreen">
    &quot;Eigenvector bases, imaginary part&quot;</font>;
  <font color="blue">output </font>Integer rankB <font color="darkgreen">&quot;Rank of matrix B&quot;</font>;

<font color="blue">protected </font>
  Integer n=<font color="red">size</font>(A,1);
  Integer m=<font color="red">size</font>(B,2);

<font color="blue">external</font>&quot;FORTRAN 77&quot; <font color="red">c_inter_xBase</font>(A, B, n, m, gamma_real, gamma_imag, ncp, U0, Z, S_real, S_imag, rankB);

<textblock type="annotcomp" expanded="false">
<font color="blue">end </font>wrapper_xBase;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE subSpace<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.assignPolesMI_rob_old.subSpaceI.png" ALT="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.assignPolesMI_rob_old.subSpace" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.assignPolesMI_rob_old.subSpace"></A><A HREF="Modelica_LinearSystems2_WorkInProgress_StateSpace_Internal.html#Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.assignPolesMI_rob_old"
>Modelica_LinearSystems2.WorkInProgress.StateSpace.Internal.assignPolesMI_rob_old</A>.subSpace</H2>
<P><H3>Information</H3></P>
Extends from <A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Record"
>Modelica.Icons.Record</A> (Icon for a record).
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">encapsulated </font><font color="blue">record</font> subSpace
  <font color="blue">import </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica.html#Modelica"
>Modelica</A>;
  <font color="blue">import </font><A HREF="Modelica_LinearSystems2.html#Modelica_LinearSystems2"
>Modelica_LinearSystems2</A>;
  <font color="blue">extends </font><A HREF="file:///C:/Programme/Dymola 7.4 Alpha/Modelica/Library/Modelica 3.1/help/Modelica_Icons.html#Modelica.Icons.Record"
>Modelica.Icons.Record</A>;
  <A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math.Complex"
>Modelica_LinearSystems2.Math.Complex</A> S[:,:];
<font color="blue">end </font>subSpace;
</PRE>
<HR>
<address>HTML-documentation generated by <a href="http://www.Dymola.com/">Dymola</a> Fri Jan 15 12:29:02 2010.
</address></BODY>
</HTML>
